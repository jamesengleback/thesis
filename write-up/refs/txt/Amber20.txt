Amber 2020

Reference Manual

(Covers Amber20 and AmberTools20)

Principal contributors to the current codes:

David A. Case (Rutgers)

Ross C. Walker (UCSD, GSK)
Thomas E. Cheatham III (Utah)
Carlos Simmerling (Stony Brook)

Adrian Roitberg (Florida)

Kenneth M. Merz (Michigan State)

Pengfei Li (Yale)

Ray Luo (UC Irvine)

Tom Darden (OpenEye)
Celeste Sagui (NCSU)

Feng Pan (FSU)

Junmei Wang (Pitt)
Daniel R. Roe (NIH)

Scott LeGrand (NVIDIA)

Jason Swails (Lutron)

Andreas W. Götz (UCSD)

Jamie Smith (USC)

David Cerutti (Rutgers)
Taisung Lee (Rutgers)
Darrin York (Rutgers)

Tyler Luchko (CSU Northridge)

Leighton Wilson (Michigan)
Robert Krasny (Michigan)

Viet Man (Pitt)

Vinícius Wilian D. Cruzeiro (UCSD)

Gérald Monard (U. Lorraine)

Yinglong Miao (Kansas)

Jinan Wang (Kansas)

G. Andrés Cisneros (UNT)

Robert E. Duke (UNT)

Nikolai R. Skrynnikov (Purdue, SPbU)

Oleg Mikhailovskii (Purdue, SPbU)

Yi Xue (Tsinghua)

Sergei A. Izmailov (SPbU)

Koushik Kasavajhala (Stony Brook)

Kellon Belfon (Stony Brook)

Jana Shen (Maryland)

Robert Harris (Maryland)

Charles Lin (Silicon Therapeutics)
Alexey Onufriev (Virginia Tech)

Saeed Izadi (Virginia Tech, Genentech)

Yeyue Xiong (Virginia Tech)

Romain M. Wolf (Bangkok, Thailand)

Xiongwu Wu (NIH)

Holger Gohlke (Düsseldorf)

Stephan Schott-Verdugo (Düsseldorf)

Ruxi Qi (UC Irvine)

George Giambasu (Rutgers)

Jian Liu (Peking Univ.)
Hai Nguyen (Rutgers)

Scott R. Brozell (Rutgers)
Andriy Kovalenko (NINT)

Mike Gilson (UCSD)

Ido Ben-Shalom (UCSD)
Tom Kurtzman (CUNY)

Sergio Pantano (Inst. Pasteur, Uruguay)
Peter A. Kollman (UC San Francisco)

For more information, please visit http://ambermd.org/contributors.html

3

• When citing Amber 2020 (comprised of AmberTools20 and Amber20) in the literature, the following citation

should be used:
D.A. Case, K. Belfon, I.Y. Ben-Shalom, S.R. Brozell, D.S. Cerutti, T.E. Cheatham, III, V.W.D. Cruzeiro,
T.A. Darden, R.E. Duke, G. Giambasu, M.K. Gilson, H. Gohlke, A.W. Goetz,R Harris, S. Izadi, S.A. Iz-
mailov, K. Kasavajhala, A. Kovalenko, R. Krasny, T. Kurtzman, T.S. Lee, S. LeGrand, P. Li, C. Lin, J. Liu,
T. Luchko, R. Luo, V. Man, K.M. Merz, Y. Miao, O. Mikhailovskii, G. Monard, H. Nguyen, A. Onufriev, F.
Pan, S. Pantano, R. Qi, D.R. Roe, A. Roitberg, C. Sagui, S. Schott-Verdugo, J. Shen, C.L. Simmerling, N.R.
Skrynnikov, J. Smith, J. Swails, R.C. Walker, J. Wang, L. Wilson, R.M. Wolf, X. Wu, Y. Xiong, Y. Xue,
D.M. York and P.A. Kollman (2020), AMBER 2020, University of California, San Francisco.

• Peter Kollman died unexpectedly in May, 2001. We dedicate Amber to his memory.

• Cover illustration: representation of cytochrome c3 being studied using simulations at constant pH and
constant redox potential in Amber, using methodology developed by Adrian Roitberg’s group. Multiple
examples are given in J. Am. Chem. Soc. 142, 3823-3835 (2020). Figure by Vinícius Wilian D. Cruzeiro.

4

Contents

Contents

I.

1.

2.

Introduction and Installation

Introduction
1.1.
1.2. List of programs .

Information ﬂow in Amber .
.

.

.

.

.

.

.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

.

.

.

Installation
2.1. Basic installation guide .
2.2. The cmake build system in Amber
2.3. Python in Amber
.
2.4. Applying Updates .
2.5.
2.6. Contacting the developers .

.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Installation using the old (legacy) build system . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

.
.

.
.

.
.

.

.

II. Amber force ﬁelds

.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

3. Molecular mechanics force ﬁelds
.
.
.
.
.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
3.1. Proteins .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2. Nucleic acids
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3. Carbohydrates .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
3.4. Lipids .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
3.5. Solvents .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
3.6.
.
.
3.7. Modiﬁed amino acids and nucleotides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.8. Force ﬁelds related to semi-empirical QM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.9. The GAL17 force ﬁeld for water over platinum . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.10. Fluorescent dyes: AMBER-DYES in AMBER force ﬁeld ﬁles
. . . . . . . . . . . . . . . . . . .
3.11. Coarse-grained and multiscale simulations using the SIRAH force ﬁeld . . . . . . . . . . . . . .
3.12. Obsolete force ﬁeld ﬁles
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Ions .

.
.
.

.
.
.

.

.

.

.

4. The Generalized Born/Surface Area Model

4.1. GB/SA input parameters
4.2. ALPB (Analytical Linearized Poisson-Boltzmann)

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
. . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

5. GBNSR6

5.1. GB equations available in gbnsr6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2. Numerical implementation of the R6 integral
5.3. Usage .
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

.

.

.

.

.

.

.

.

.

6. PBSA

Introduction .

6.1.
.
6.2. Usage and keywords

.

.

.

.
.

.
.

.
.

.
.

.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5

11

13
13
16

21
21
23
28
28
31
32

33

35
36
41
43
50
52
54
56
57
57
58
60
62

67
69
72

75
75
75
76

79
79
82

5

CONTENTS

6.3. Example inputs and demonstrations of functionalities . . . . . . . . . . . . . . . . . . . . . . . .
6.4. Visualization functions in pbsa .
. . . . . . . . . . . . . . . . . . . . . .
6.5. pbsa in sander and NAB .
.
6.6. GPU accelerated pbsa .
.
.

90
93
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
. . .
. . . . . . . . . . . . . . . . . . . . . . . . . 102

. . .
. . . .
.

. . .
. . . . .

. . . . . . .

. . .

.
.

.
.

.

.

.

.

.

.

.

Introduction .

7. Reference Interaction Site Model
.
.
.
.
.
.
.
.

7.1.
.
7.2. Practical Considerations
.
.
7.3. Work Flow .
.
.
7.4.
.
.
.
.
.
7.5. 3D-RISM in NAB .
.
7.6. rism3d.snglpnt .
.
.
7.7. 3D-RISM in sander .
7.8. RISM File Formats .
.

rism1d .

.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.

.
.

.

.

8. Empirical Valence Bond
.

Introduction .

8.1.
.
8.2. General usage description .
.
8.3. Biased sampling .

.

.

.

.

.

.

.

.

.

.
.
.

105
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
. . . . . . . . . . . . . . . . . . . . . . . . . 119
. .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . 121
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135

. . . . .
. . . . .

. . .
. . .

.

141
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

.
.
.
.
.
.
.
.

.
.
.

.
.
.
.
.
.
.
.

.
.
.

9. sqm: Semi-empirical quantum chemistry
.

147
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
9.1. Available Hamiltonians .
9.2. Dispersion and hydrogen bond correction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
9.3. Usage .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

10. QM/MM calculations

156
10.1. Built-in semiempirical NDDO methods and SCC-DFTB . . . . . . . . . . . . . . . . . . . . . . 156
10.2. Interface for ab initio and DFT methods . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 165
10.3. Adaptive solvent QM/MM simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
10.4. Adaptive buffered force-mixing QM/MM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
10.5. SEBOMD: SemiEmpirical Born-Oppenheimer Molecular Dynamics . . . . . . . . . . . . . . . . 194

. . .

11. Using energies and forces from an external library

199
11.1. Installation instructions .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
11.2. Simulation setup and input parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199

.

.

.

.

III. System preparation

201

12. Preparing PDB Files

203
12.1. Cleaning up Protein PDB Files for AMBER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
12.2. Residue naming conventions .
12.3. Chains, Residue Numbering, Missing Residues
. . . . . . . . . . . . . . . . . . . . . . . . . . . 205
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
12.4. pdb4amber
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
12.5. reduce .
.
.
12.6. packmol-memgen .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
12.7. Building bilayer systems with AMBAT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.

.
.

.
.

.

.

.

.

13. LEaP

.
13.1. Introduction .
13.2. Concepts
.
.
13.3. Running LEaP .
13.4. Basic instructions for using LEaP to build molecules
13.5. Error Handling and Reporting .

213
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
. . . . . . . . . . . . . . . . . . . . . . . . 222
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.

.

.

6

. 223
13.6. Commands
13.7. Building oligosaccharides, lipids and glycoproteins . . . . . . . . . . . . . . . . . . . . . . . . . 240

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

.

.

.

.

.

.

.

.

CONTENTS

14. Reading and modifying Amber parameter ﬁles

14.1. Understanding Amber parameter ﬁles
14.2. ParmEd .

.

.

.

.

.

.

.

.

.

.

.

249
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257

286
15. Antechamber and GAFF
15.1. Principal programs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
15.2. A simple example for antechamber . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
15.3. Programs called by antechamber . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
15.4. Miscellaneous programs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297

.

.

.

.

.

.

.

.

.

.

.
.

.
.

.
.

.
.

.
.

16. Molecular Mechanics Parameter Fitting in mdgx

.
16.1. Input and Output
16.2. Installation .
.
.
16.3. Partial Charge Development
16.4. Implicitly Polarized Charge Development
16.5. Customizable Virtual Site Support
16.6. Bonded Term Fitting in mdgx .
16.7. Conﬁguration Sampling .
.
16.8. Parallel Generalized Born Problems on the GPU . . . . . . . . . . . . . . . . . . . . . . . . . .

301
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
. 304
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
. 315

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.

.

.

17. Python Metal Site Modeling Toolbox (pyMSMT)

17.1. Introduction .
17.2. Usage .
.

.

.

.
.

.
.

.
.

.
.

.
.

.
.

18. Setting up crystal simulations
.
.
.
.

18.1. UnitCell .
.
18.2. PropPDB .
18.3. AddToBox .
.
18.4. ChBox .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.

.
.

.
.
.
.

.
.

.
.
.
.

.
.

.
.
.
.

317
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318

331
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333

IV. Running simulations

334

19. sander

.
.

.
.

.
.

.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

336
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
.
19.1. Introduction .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
19.2. File usage .
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
19.3. Example input ﬁles .
.
19.4. Namelist Input Syntax .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
19.5. Overview of the information in the input ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
19.6. General minimization and dynamics parameters . . . . . . . . . . . . . . . . . . . . . . . . . .
. 340
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
19.7. Potential function parameters .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
.
19.8. Varying conditions
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
19.9. File redirection commands .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
19.10.Getting debugging information .
19.11.multisander (and multipmemd) .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374
19.12.APBS as an alternate PB solver in Sander
. 375
19.13.Programmer’s Corner: The sander API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.

.

.

.

20. pmemd

20.1. Introduction .
.
20.2. Functionality .

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

398
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398

7

CONTENTS

20.3. PMEMD-speciﬁc namelist variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
20.4. Slightly changed functionality .
20.5. Parallel performance tuning and hints
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
20.6. GPU Accelerated PMEMD .

.

.

21. Atom and Residue Selections
.

410
21.1. Amber Masks .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
21.2. "Atom Expressions" in NAB Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
21.3. GROUP Speciﬁcation .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

22. Sampling conﬁguration space

418
22.1. Self-Guided Langevin dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
22.2. Accelerated Molecular Dynamics .
22.3. Gaussian Accelerated Molecular Dynamics
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
22.4. Targeted MD .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
.
22.5. Multiply-Targeted MD (MTMD) .
.
22.6. Nudged elastic band calculations .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
22.7. Low-MODe (LMOD) methods .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436

.

.

.

.

.

.

.

.

.

.

23. Free energies

441
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
23.1. Thermodynamic integration .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455
23.2. Linear Interaction Energies .
23.3. Replica Exchange Molecular Dynamics (REMD)
. . . . . . . . . . . . . . . . . . . . . . . . . . 455
23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method . . . . . 480
23.5. Steered Molecular Dynamics (SMD) and the Jarzynski Relationship . . . . . . . . . . . . . . . . 496
23.6. Absolute Free Energies using EMIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498

.
.

.
.

.

.

.

.

.

.

.

.

.

24. Constant pH calculations
.
.

510
24.1. Background .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
24.2. Preparing a system for constant pH simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
24.3. Running at constant pH .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
24.4. Analyzing constant pH simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
24.5. Extending constant pH to additional titratable groups . . . . . . . . . . . . . . . . . . . . . . . . 516
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
24.6. pH Replica Exchange MD .
24.7. cphstats .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521

.
.

.
.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

25. Constant Redox Potential calculations

530
25.1. Preparing a system for constant Redox Potential simulation . . . . . . . . . . . . . . . . . . . . . 530
25.2. Running at constant Redox Potential . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 532
25.3. Analyzing constant Redox Potential simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
25.4. Extending constant Redox Potential to additional titratable groups
. . . . . . . . . . . . . . . . . 533
25.5. Redox Potential Replica Exchange MD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
25.6. cestats .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534

.

.

.

.

.

.

.

.

.

.

.

.

.

26. Continuous constant pH molecular dynamics

537
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
26.1. Implementation notes .
26.2. Usage description .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
.
26.3. Continuous constant pH MD with pH replica exchange . . . . . . . . . . . . . . . . . . . . . . . 542
26.4. Obtaining parameters for a novel titratable group . . . . . . . . . . . . . . . . . . . . . . . . . . 544

.
.

.
.

.
.

.
.

.
.

.
.

.

27. NMR reﬁnement

545
27.1. Distance, angle and torsional restraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551
27.2. NOESY volume restraints
27.3. Chemical shift restraints
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552

.
.

.
.

.
.

.

8

CONTENTS

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
27.4. Pseudocontact shift restraints .
27.5. Direct dipolar coupling restraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
27.6. Residual CSA or pseudo-CSA restraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
27.7. Preparing restraint ﬁles for Sander
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
27.8. Getting summaries of NMR violations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564
27.9. Time-averaged restraints
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565
27.10.Multiple copies reﬁnement using LES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566
27.11.Some sample input ﬁles .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566

.

.

.

.

.

.

28. Xray and cryoEM reﬁnement

571
28.1. EMAP restraints for rigid and ﬂexible ﬁtting into EM maps . . . . . . . . . . . . . . . . . . . . . 571
28.2. FRETrest: Förster Resonance Energy Transfer restraints
. . . . . . . . . . . . . . . . . . . . . . 572
28.3. X-ray functionality and diffraction-based restraints for pmemd . . . . . . . . . . . . . . . . . . . 574

29. Locally-enchanced sampling

577
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
29.1. Preparing to use LES with Amber
29.2. Using the ADDLES program .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 578
29.3. More information on the ADDLES commands and options . . . . . . . . . . . . . . . . . . . . . 580
29.4. Using the new topology/coordinate ﬁles with SANDER . . . . . . . . . . . . . . . . . . . . . . . 581
. 582
29.5. Using LES with the Generalized Born solvation model
. . . . . . . . . . . . . . . . . . . . . .
29.6. Case studies: Examples of application of LES . . . . . . . . . . . . . . . . . . . . . . . . . . .
. 582

30. gem.pmemd

30.1. Introduction .
.
30.2. Input variables .

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

586
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586

V. Analysis of simulations

590

31. mdout_analyzer.py and ambpdb
.

31.1. ambpdb .

.

.

.

.

.

.

.

.

592
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592

.

.

32. cpptraj

.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

594
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 594
.
32.1. Introduction .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
.
32.2. Running Cpptraj .
32.3. General Concepts .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 599
32.4. Variables and Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
32.5. Data Sets and Data Files
32.6. Data File Options .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
32.7. Coordinates (COORDS) Data Set Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . 612
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 616
.
32.8. General Commands .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626
32.9. Topology File Commands .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635
32.10.Trajectory File Commands .
32.11.Action Commands
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 643
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 712
.
32.12.Analysis Commands
32.13.Analysis Examples .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 750

.
.
.
.
.
.

.
.
.

.
.
.

.
.
.

.
.

.
.

.
.

.

.

.

.

.

33. pytraj

.
33.1. Introduction .
33.2. Development
.
33.3. Documentation and examples .

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

752
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 752
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 752
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 752

34. MMPBSA.py

34.1. Introduction .

.

.

.

.

.

.

.

.

.

756
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 756

9

CONTENTS

34.2. Preparing for an MM/PB(GB)SA calculation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 756
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 759
34.3. Running MMPBSA.py .
34.4. Python API
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771

.
.

.
.

.
.

.
.

.

.

.

.

.

.

35. FEW

.

.

.

.

.

.

.

.

.

777
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 777
35.1. Installation .
. . . . . . . . . . . . . . . . . . . . . . . . . . . 779
35.2. Overview of workﬂow steps and minimal input
. . . . . . . . . . . . . . . . . . . . . . . . . 779
35.3. Common setup of molecular dynamics simulations
35.4. Workﬂow for automated MM-PBSA & MM-GBSA calculations (WAMM)
. . . . . . . . . . . . 786
35.5. Linear interaction energy workﬂow (LIEW) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 794
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 797
35.6. Thermodynamic integration workﬂow (TIW)

.

36. SAXS

36.1. Introduction and theory .
.
36.2. Usage .

.

.

.

.

.

.

.

.

.
.

.
.

37. MoFT: analysis of volumetric data
.
.

.
37.1. Usage .
37.2. Examples .

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.

806
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 806
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 807

810
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 810
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 812
.

.
.

.
.

.
.

.
.

VI. NAB/sff

814

38. NAB and sff

.

.

816
38.1. A little history .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 816
38.2. A C interface to libsff
.
. . . . . . . . . . . . . . . . . . . . . . . . . 816
38.3. NAB overview .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
38.4. Fiber Diffraction Duplexes in NAB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 818
38.5. Symmetry Functions
.
38.6. Symmetry server programs .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 820

. . . . .

. . .

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.

.
.

.

.

.

.

.

39. libsff: Molecular mechanics and dynamics

824
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 824
39.1. Basic molecular mechanics routines
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835
39.2. NetCDF read/write routines .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 838
39.3. Second derivatives and normal modes
39.4. Low-MODe (LMOD) optimization methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 839
39.5. The Generalized Born with Hierarchical Charge Partitioning (GB-HCP)
. . . . . . . . . . . . . . 852

.

.

854

907

Bibliography

Index

10

Part I.

Introduction and Installation

11

1. Introduction

Amber is the collective name for a suite of programs that allow users to carry out molecular dynamics simu-
lations, particularly on biomolecules. None of the individual programs carries this name, but the various parts
work reasonably well together, and provide a powerful framework for many common calculations.[1, 2] The term
Amber is also used to refer to the empirical force ﬁelds that are implemented here.[3, 4] It should be recognized,
however, that the code and force ﬁeld are separate: several other computer packages have implemented the Amber
force ﬁelds, and other force ﬁelds can be implemented with the Amber programs. Further, the force ﬁelds are in
the public domain, whereas the codes are distributed under a license agreement.

The Amber software suite is divided into two parts: AmberTools20, a collection of freely available programs
mostly under the GPL license, and Amber20, which is centered around the pmemd simulation program, and which
continues to be licensed as before, under a more restrictive license. Amber20 represents a signiﬁcant change from
the most recent previous version, Amber18. (We have moved to numbering Amber releases by the last two digits
of the calendar year, so there are no odd-numbered versions.) Please see http://ambermd.org for an overview
of the most important changes.

AmberTools is a set of programs for biomolecular simulation and analysis. They are designed to work well
with each other, and with the “regular” Amber suite of programs. You can perform many simulation tasks with
AmberTools, and you can do more extensive simulations with the combination of AmberTools and Amber itself.
Most components of AmberTools are released under the GNU General Public License (GPL). A few components
are in the public domain or have other open-source licenses. See the README ﬁle for more information.

Everyone should read (or at least skim) this chapter. Even if you are an experienced Amber user, there may be
things you have missed, or new features, that will help. There are also tips and examples on the Amber Web pages
at http://ambermd.org. Although Amber may appear dauntingly complex at ﬁrst, it has become easier to use over
the past few years, and overall is reasonably straightforward once you understand the basic architecture and option
choices. In particular, we have worked hard on the tutorials to make them accessible to new users. Thousands of
people have learned to use Amber; don’t be easily discouraged.

If you want to learn more about basic biochemical simulation techniques, there are a variety of good books to
consult, ranging from introductory descriptions,[5–7] to standard works on liquid state simulation methods,[8–10]
to multi-author compilations that cover many important aspects of biomolecular modelling.[11–15] Looking for
"paradigm" papers that report simulations similar to ones you may want to undertake is also generally a good idea.
If you are new to this ﬁeld, Chapter 14 provides a basic introduction to force ﬁelds, along with details of how the
parameters are encoded in Amber ﬁles.

1.1. Information ﬂow in Amber

Understanding where to begin in AmberTools is primarily a problem of managing the ﬂow of information in
this package — see Fig. 1.1. You ﬁrst need to understand what information is needed by the simulation programs
(sander, pmemd, mdgx or nab). You need to know where it comes from, and how it gets into the form that these
programs require. This section is meant to orient the new user and is not a substitute for the individual program
documentation.

Information that all the simulation programs need (see the circles in Fig. 1.1):

1. Cartesian coordinates for each atom in the system. These usually come from X-ray crystallography, NMR
spectroscopy, or model-building. They should generally be in Protein Data Bank (PDB) format. The program
LEaP provides a platform for carrying out many of these modeling tasks, but users may wish to consider
other programs as well. Generally, editing of these ﬁles is needed, and the pdb4amber script can do some of
this.

13

1. Introduction

Figure 1.1.: Basic information ﬂow in Amber

2. Topology: Connectivity, atom names, atom types, residue names, and charges. This information comes from
the database, which is found in the $AMBERHOME/dat/leap/lib directory, and is described in Chapter 3. It
contains topology for the standard amino acids as well as N- and C-terminal charged amino acids, DNA,
RNA, and common sugars and lipids. Topology information for other molecules (not found in the standard
database) is kept in user-generated “residue ﬁles”, which are generally created using antechamber.

3. Force ﬁeld: Parameters for all of the bonds, angles, dihedrals, and atom types in the system. The standard
parameters for several force ﬁelds are found in the $AMBERHOME/dat/leap/parm directory; see Chapter 3
for more information. These ﬁles may be used “as is” for proteins and nucleic acids, or users may prepare
their own ﬁles that contain modiﬁcations to the standard force ﬁelds.

4. Once the topology and coordinate ﬁles (often called prmtop and prmcrd, but any legal ﬁle names can be
used) are created, the parmed script can be used to examine and verify these, and to make modiﬁcations. In
particular, the checkValidity action will ﬂag many potential problems.

5. Commands: The user speciﬁes the procedural options and state parameters desired. These are speciﬁed in

input ﬁles (named mdin by default) or in “driver” programs written in the NAB language.

14

pdbpdb4amberantechamber,pyMSMT,mdgx,LEaPforceﬁeldinfoprmtopprmcrdpar medsander,mdgx,pmemdNMR orXRAYinfomdininfomdout_analyzer,cpptrajMMPBSA.py,FEW1.1. Information ﬂow in Amber

1.1.1. Preparatory programs

LEaP is the primary program to create a new system in Amber, or to modify existing systems. It is available as
the command-line program tleap or the GUI xleap. It combines the functionality of prep, link, edit and parm
from much earlier versions of Amber.

pdb4amber generally helps in preparing pdb-format ﬁles coming from other places (such as rcsb.org) to be com-

patible with LEaP.

parmed provides a simple way to extract information about the parameters deﬁned in a parameter-topology ﬁle. It
can also be used to check that the parameter-topology ﬁle is valid for complex systems (see the checkValidity
command), and it can also make simple modiﬁcations to this ﬁle.

antechamber is the main program to develop force ﬁelds for small organic molecules (e.g., drugs, modiﬁed amino
acids) using a version of the general Amber force ﬁeld (GAFF). These can be used directly in LEaP, or can
serve as a starting point for further parameter development.

MCPB.py provides a means to build, prototype, and validate MM models of metalloproteins and organometallic
compounds. It uses the bonded plus electrostatics model to expand existing pairwise additive force ﬁelds.
It is a reimplementation of MCPB in Python, with a more efﬁcient workﬂow and many modeling processes
from previous versions incorporated automatically.

IPMach.py provides a tool to facilitate the parameterization of nonbonded models (12-6 LJ model and 12-6-4

LJ-type model) for ions.

mdgx allows the generation of bonded force ﬁeld parameters for any molecule by ﬁtting to quantum data.

packmol-memgen provides a simple way to generate membrane systems, with or without protein, by orient-
ing input proteins with Memembed and using Packmol as the packing engine.
It can handle complex
lipid mixtures, as well as multi-bilayer systems. The output is compatible with Amber through charmm-
lipid2amber.py.

1.1.2. Simulation programs

sander (part of AmberTools) is the basic energy minimizer and molecular dynamics program. This program
relaxes the structure by iteratively moving the atoms down the energy gradient until a sufﬁciently low average
gradient is obtained. The molecular dynamics portion generates conﬁgurations of the system by integrating
Newtonian equations of motion. MD will sample more conﬁgurational space than minimization, and will
allow the structure to cross over small potential energy barriers. Conﬁgurations may be saved at regular
intervals during the simulation for later analysis, and basic free energy calculations using thermodynamic
integration may be performed. More elaborate conformational searching and modeling MD studies can also
be carried out using the sander module. This allows a variety of constraints to be added to the basic force
ﬁeld, and has been designed especially for the types of calculations involved in NMR, Xray or cryo-EM
structure reﬁnement.

pmemd (part of Amber) is a version of sander that is optimized for speed and for parallel scaling; the pmemd.cuda
variant runs on GPUs. The name stands for “Particle Mesh Ewald Molecular Dynamics,” but this code can
now also carry out generalized Born simulations. The input and output have only a few changes from sander.

gem.pmemd (part of AmberTools) is a (CPU-only) variant of the pmemd program that is designed for calculations

using “advanced” force ﬁelds, such as AMOEBA[16] and GEM.[17]

1.1.3. Analysis programs

mdout_analyzer.py is a simple-to-run Python script that will provide summaries of information that is in the

output ﬁles from sander or pmemd.

15

1. Introduction

cpptraj is the main trajectory analysis utility (written in C++) for carrying out superpositions, extractions of
coordinates, calculation of bond/angle/dihedral values, atomic positional ﬂuctuations, correlation functions,
analysis of hydrogen bonds, etc. See Chap. 32 for more information.

pytraj is a Python wrapper for cpptraj. It introduces additional ﬂexibility into data analysis by combining with

Python’s rich ecosystems (such as numpy, scipy, and ipython-notebook).

pbsa is an analysis program for solvent-mediated energetics of biomolecules. The pbsa.cuda variant runs on
GPUs. It can be used to perform both electrostatic and non-electrostatic continuum solvation calculations
with input coordinate ﬁles from molecular dynamics simulations and other sources (in the pqr format). It
also supports visualization of solvent-mediated electrostatic potentials in various visualization programs.
See Chap. 6 for more information.

MMPBSA.py is a python script that automates energy analysis of snapshots from a molecular dynamics simulation
using ideas generated from continuum solvent models. (There is also an older perl script, called mm_pbsa.pl,
that has similar functionality.)

FEW (Free energy workﬂow) automates free energy calculations of protein-ligand binding using TI, MM/PBSA-

type, or LIE calculations.

1.2. List of programs

Amber is comprised of a large number of programs designed to aid you in your computational studies of chemical
systems, and the number of released tools grows regularly. This section provides a list of the main programs
included with AmberTools. Each program included in the suite is listed here with a very brief description of its
main function along with a reference to its documentation. For most programs executing it without arguments
prints the usage statement.

AddToBox A program for adding solvent molecules to a crystal cell. See Subsection 18.3.

amb2chm_par.py A program for converting AMBER dat and/or frcmod ﬁle(s) into CHARMM PAR ﬁle. SeeSub-

section 14.2.4.

amb2chm_psf_crd.py A program for converting AMBER prmtop and inpcrd ﬁles into CHARMM PSF and CRD

ﬁles. SeeSubsection 14.2.4.

amb2gro_top_gro.py A program for converting AMBER prmtop and inpcrd ﬁles into GROMACS top and gro

ﬁles. SeeSubsection 14.2.4.

CartHess2FC.py A program to derive the force constants based on Cartesian Hessian matrix using Seminario

method. See Subsection 17.2.5.

car_to_ﬁles.py A program program to generate the mol2 and PDB ﬁles based on the car ﬁle. SeeSubsection

17.2.8.

ChBox A program for changing the box dimensions of an Amber restart ﬁle. See Subsection 18.4.

IPMach.py A python program for facilitating the parameterization of the nonbonded models of ions. See Subsec-

tion 17.2.2.

MCPB.py A python version of MCPB with optimized workﬂow. See Subsection 17.2.1.

MMPBSA.py A program to post-process trajectories to calculate binding free energies according to the MM/PBSA

approximation. See Chapter 34.

mol2rtf.py A program for converting mol2 ﬁle into CHARMM RTF ﬁle. SeeSubsection 17.2.9.

OptC4.py optimizes the C4 terms in the metal-site-complex of a protein system. See Subsection 17.2.4.

16

1.2. List of programs

PdbSearcher.py a python version of Pdbsearcher, a program in MTK++. See Subsection 17.2.3.

PropPDB A program for propagating a PDB structure. See Subsection 18.2

ProScrs.py A program for cutting and capping the protein segment into clusters. SeeSubsection 17.2.7.

UnitCell A program for recreating a crystallographic unit cell from a PDB structure. See Subsection 18.1

am1bcc A program called by antechamber to calculate AM1-BCC charges during ligand parametrization.

It
can be used as a standalone program, with the options printed when you enter the program name with no
arguments. See Section 15.3

ambpdb A program to convert an Amber system (prmtop and inpcrd/restart) into a PDB, MOL2, or PQR ﬁle. See

Section 31.1

ante-MMPBSA.py A program to create the necessary, self-consistent prmtop ﬁles for MMPBSA with a single

starting topology ﬁle. See Subsection 34.2.2

antechamber A program for parametrizing ligands and other small molecules. See Chapter 15

atomtype A program called by antechamber to judge the atom types in an input structure. It can be used as a

standalone program. See Section 15.3

bondtype A program called by antechamber to judge what types of bonds exist in a given input structure. It can

be used as a standalone program. See Section 15.3

ceinutil.py A program to create a constant Redox Potential input (cein) ﬁle. See Section 25.1

cestats A program that computes redox state statistics from constant Redox Potential simulations. See Section

25.6

charmmlipid2amber.py A script that converts a PDB created with the CHARMM-GUI lipid builder into one

recognized by Amber and AmberTools programs.

cpinutil.py A program to create a constant pH input (cpin) ﬁle. See Section 24.2

cpeinutil.py A program to create a constant pH and Redox Potential input (cpein) ﬁle.

cpptraj A versatile program for trajectory post-processing and data analysis. See Chapter 32

cphstats A program that computes protonation state statistics from constant pH simulations. See Section 24.7

elsize A program that estimates the effective electrostatic size of a given input structure. See Section 4.2.1

espgen A program called by antechamber to generate ESP ﬁles during ligand or small molecule parametrization.

espgen.py A python version of espgen. See Subsection 17.2.6.

ﬁnddgref.py A program that automatically ﬁnds the value of Delta G reference necessary for constant pH and

constant Redox Potential simulations. See Subsection 24.5.1

ﬁxremdcouts.py A program that sorts CPout and/or CEout ﬁles from any Replica Exchange simulation, including

MultiD-REMD. See Subsection 23.3.9.4

ﬁtpkaeo.py A program that automatically ﬁts the pKa or standard Redox Potential value of all titratable residues

starting from the output of cphstats or cestats for multiple CPout or CEout ﬁles.

ffgbsa A program that calculates MM/GBSA energies as part of the amberlite package.

FEW.pl A program to automate the workﬂow for free energy calculations. See Chapter 35

gbnsr6 A program to compute a surface-area-based Generalized Born solvation free energy. See Section 5

17

1. Introduction

genremdinputs.py A program that generates the input ﬁles (mdins, grouﬁle and remd-ﬁle) for any Replica Ex-

change simulation, including MultiD-REMD. See Subsection 23.3.3

hcp_getpdb A program that adds necessary sections to a topology (prmtop) ﬁle so it can be used for the HCP GB

approximation. See Section 39.5

makeANG_RST A program to create angle restraints for use with sander’s nmropt=1 facility.

makeCHIR_RST A program to create chiral restraint ﬁle for use with sander’s nmropt=1 facility

makeDIP_RST.cyana A program to make restraints based on dipole information from CYANA for use with

sander’s nmropt=1 facility

makeDIST_RST A program to make distance restraints for use with sander’s nmropt=1 facility

mdgx An explicit solvent, PME molecular dynamics engine. See Chapter 16

mdout_analyzer.py A script that allows you to rapidly analyze and graph data from sander/pmemd output ﬁles.

See Section 31

metalpdb2mol2.py A script that converts PDB ﬁles of metal ions to mol2 ﬁles, speciﬁcally used for MCPB.py

modeling. See Subsection 17.2.10

mm_pbsa.pl Older perl script for performing MM/PBSA calculations. New users are encouraged to use MMPBSA.py

instead.

mm_pbsa_statistics.pl Complementary script to mm_pbsa.pl to compute MM/PBSA statistics from a completed

mm_pbsa calculation.

mm_pbsa_nabnmode Program for performing minimizations and normal mode analyses on biomolecules through

mm_pbsa.pl.

mmpbsa_py_energy A NAB program written to calculate energies for MMPBSA using either GB or PB solvent
models. It can be used as a standalone program that mimics the imin=5 functionality of sander, but it is
called automatically inside MMPBSA. See MMPBSA mdin ﬁles as example input ﬁles for this program.
Providing the –help or -h ﬂags prints the usage message.

mmpbsa_py_nabnmode A NAB program written to calculate normal mode entropic contributions for MMPBSA.

This can really only be used by MMPBSA.

molsurf A program that calculates a molecular surface area based on input PQR ﬁles and a probe radius.

nab Stands for Nucleic Acid Builder. NAB is really a compiler that provides a convenient molecular programming

language loosely based on C. See Chapter 38 and other related chapters.

nfe-umbrella-slice A program to process the biasing potential generated in NFE modules. See Subsection 23.4.8

nmode An outdated program to compute normal modes for biomolecules. You are encouraged to use NAB in-

stead. See Section 39.1

packmol-memgen A workﬂow for generating membrane simulation systems. See 12.6

mdgx Improves force ﬁeld parameters by ﬁtting to quantum data. See Chapter 16

parmchk2 A program that analyzes an input force ﬁeld library ﬁle (mol2 or amber prep), and extracts relevant

parameters into an frcmod ﬁle. See Subsection 15.1.2

parmed A program for querying and manipulating prmtop ﬁles. See Section 14.2

pbsa A program for computing electrostatic and non-electrostatic continuum solvation free energies. See Chapter

6

18

1.2. List of programs

pbsa.cuda A GPU-accelerated version of pbsa. See Chapter 6

pdb4amber A program to prepares PDB ﬁles for use in LEaP. See Section 12.4

pmemd A performance- and parallel-optimized dynamics engine implementing a subset of sander’s functionality

pmemd.cuda A GPU-accelerated version of pmemd

prepgen A program used as part of antechamber that generates an Amber prep ﬁle. See Section 15.3

pytraj A Python program binding to cpptraj. See Section 33

reduce A program for adding or removing hydrogen atoms to a PDB. See Section 12.5

residuegen A program to automate the generation of an Amber residue template (i.e. Amber prep ﬁle). See

Subsection 15.4.3

respgen A program called by antechamber to generate RESP input ﬁles. See Section 15.3

rism1d A 1D-RISM solver. See Section 7.4

rism3d.snglpnt A 3D-RISM solver for single point calculations. See Section 7.6

sander The main engine used for running molecular simulations with Amber. Originally an acronym standing for

Simulated Annealing with Nmr-Derived Energy Restraints.

saxs_rism A program to compute small (wide) angle X-ray scattering curve from 3D-RISM output

saxs_md A program to compute small (wide) angle X-ray scattering curve from MD trajectories

sqm Semiempirical (or Stand-alone) Quantum Mechanics solver. See Chapter 9

tleap A script that calls teLeap with speciﬁc setup command-line arguments. See Chapter 13

xleap A script that calls xaLeap with speciﬁc setup command-line arguments. See Chapter 13

xparmed A graphical front-end to ParmEd functionality (i.e., parameter ﬁle editing and querying). See Section

14.2

19

2. Installation

2.1. Basic installation guide

This chapter gives an overview of how to install and test your distribution. Note that the procedure is different
from earlier versions of Amber, relying on CMake rather than make. Once you have downloaded the distribution
ﬁles, do the following:

1. First, extract the ﬁles in some location (we use /home/xxxx as an example here, but you can install anywhere

that you have write permissions):

cd /home/xxxx
tar xvfj AmberTools20.tar.bz2

# (Note: extracts in an
#

“amber20_src” directory)

tar xvfj Amber20.tar.bz2

# (only if you have licensed Amber 20!)

2. Next, you may need to install some compilers and other libraries. Details depend on what OS you have,
and what is already installed. Package managers can greatly simplify this task. For lists of requirements for
Mac OSX and for many variants of Linux, please visit ambermd.org/Installation.php. In particular, you will
need to have cmake in your PATH. A restriction is that you cannot use the cmake you obtain from a conda
distribution you may have; you will need to use a package manager, or download it from https://cmake.org/.
If you have an existing miniconda distribution, please remove it from your PATH while building Amber.

3. Building with cmake: The Amber development team has recently moved our build system to cmake, with

the conversion being spearheaded by Jamie Smith.
The basic rationale for the move, and instructions on using cmake to build Amber, are at

• ambermd.org/pmwiki/index.php/Main/CMake-Quick-Start
• ambermd.org/pmwiki/pmwiki.php/Main/CMake-Common-Options
• Section 2.2, below.

For most users, the options chosen in the sample script (below) should be OK. Note that with cmake, the
“source” directory (where you extracted the ﬁles,) must be different from the installation directory. Thus,
make sure that -DCMAKE_INSTALL_PREFIX is not set to amber20_src in the run_cmake script.

cd amber20_src/build
# optional: edit the run_cmake script to make any needed changes;
#
./run_cmake

most users should not need to do this.

Next, build and install the code:

make install

4. The installation step will create a resource ﬁle amber.sh at your installation directory. This script will set up

your shell environment correctly for Amber:

source /home/xxxx/amber20/amber.sh # for bash, zsh, ksh, etc.

Adding these commands to your login resource ﬁle (e.g., ~/.bashrc, ~/.zshrc, etc.) will set up your environ-
ment every time you start a new shell. In particular, it sets the AMBERHOME environment variable, which
is needed for a number of workﬂows involving Amber. [There is a similar script, amber.csh, for those (few)
who use a C-shell as their interactive script.]

21

2. Installation

5. This can be followed by a testing phase. If you have -DINSTALL_TESTS=TRUE in your cmake invocation,

then you can do the following:

cd $AMBERHOME
make test.serial

# (this was set in step 4, above)

which will run tests and will report successes or failures.
Where "possible FAILURE" messages are found, go to the indicated directory under $AMBERHOME/AmberTools/test
or $AMBERHOME/test, and look at the "*.dif" ﬁles. Differences should involve round-off in the ﬁnal digit
printed, or occasional messages that differ from machine to machine (see below for details). As with compi-
lation, if you have trouble with individual tests, you may wish to comment out certain lines in the Makeﬁles
(i.e., $AMBERHOME/AmberTools/test/Makefile or $AMBERHOME/test/Makefile), and/or go directly to
the test subdirectories to examine the inputs and outputs in detail. For convenience, all of the failure mes-
sages and differences are collected in the $AMBERHOME/logs directory; you can quickly see from these if
there is anything more than round-off errors.
The nature of molecular dynamics is such that the course of the calculation is very dependent on the order
of arithmetical operations and the machine arithmetic implementation, i.e., the method used for round-off.
Because each step of the calculation depends on the results of the previous step, the slightest difference
will eventually lead to a divergence in trajectories. As an initially identical dynamics run progresses on
two different machines, the trajectories will eventually become completely uncorrelated. Neither of them
are "wrong;" they are just exploring different regions of phase space. Hence, states at the end of long
simulations are not very useful for verifying correctness. Averages are meaningful, provided that normal
statistical ﬂuctuations are taken into account. "Different machines" in this context means any difference in
ﬂoating point hardware, word size, or rounding modes, as well as any differences in compilers or libraries.
Differences in the order of arithmetic operations will affect round-off behavior; (a + b) + c is not necessarily
the same as a + (b + c). Different optimization levels will affect operation order, and may therefore affect
the course of the calculations.
All initial values reported as integers should be identical. The energies and temperatures on the ﬁrst cycle
should be identical. The RMS and MAX gradients reported in sander are often more precision sensitive
than the energies, and may vary by 1 in the last ﬁgure on some machines. In minimization and dynamics
calculations, it is not unusual to see small divergences in behavior after as little as 100-200 cycles.
Note: If you have untarred the Amber20.tar.bz2 ﬁle, then steps 1-6 will install and test both AmberTools
and Amber; otherwise it will just install and test AmberTools. If you license Amber later, just come back and
repeat steps 1-6 again.

6. If you are new to Amber, you should look at the tutorials (available at https://ambermd.org/tutorials)

and this manual in order to become familiar with the Amber features and functionalities.

7. Installation instructions for the GPU-accelerated versions of pmemd, cpptraj and pbsa are available in Sec-

tion 20.6.5.

8. In order to compile the parallel (MPI) version of Amber, follow these steps (after successfully installing the

serial version).

a) You must ﬁrst ensure that you have installed MPI and that mpicc and mpif90 are in your PATH. Some

MPI installations are tuned to particular hardware (such as InﬁniBand), and you should use those
versions if you have such hardware. Most people can use standard versions of either mpich or
openmpi obtained from a package manager, but these must correspond to the compilers you are using.
For many users, especially for Mac OSX, the easiest approach is the following:

cd $AMBERHOME/AmberTools/src
./configure_mpich <compiler>

This will build the mpich MPI stack with what is needed for Amber, and install it in $AMBERHOME.
If you wish, you can replace conﬁgure_mpich with conﬁgure_openmpi above. (For MacOSX, use clang
as the compiler, unless you are using GNU compilers you intalled yourself).

22

2.2. The cmake build system in Amber

b) Then do the following:

cd /home/xxxx/amber20_src/build
# edit the run_cmake script to set -DMPI=TRUE
./run_cmake
make install
# To run tests: Note the value below may depend on your MPI implementation
export DO_PARALLEL="mpirun -np 2"
cd $AMBERHOME
source amber.sh
make test.parallel
# Note, some tests, like the replica exchange tests, require more
# than 2 threads, so we suggest that you test with either 4 or 8
# threads as well
export DO_PARALLEL="mpirun -np 4"
make test.parallel

Some notes about the parallel programs in AmberTools:

a) The MPI version of nab is called mpinab, by analogy with mpicc or mpif90: mpinab is a compiler
that will produce an MPI-enabled executable from source code written in the NAB language. Before
compiling mpinab, be sure that you are familiar with the serial version of nab and that you really need a
parallel version. If you have shared-memory nodes, the OpenMP version might be a better alternative.
(Note that mpinab is primarily designed to write driver routines that call MPI versions of the energy
functions; it is not set up to write your own, novel, parallel codes.)

b) The MPI version of MMPBSA.py is called MMPBSA.py.MPI, and requires the package mpi4py to run.
If it is not present in your Python standard library already, it will be built along with MMPBSA.py.MPI
and placed in the $AMBERHOME preﬁx. If you have problems with MMPBSA.py.MPI, see if you get
the same problems with the serial version, MMPBSA.py, to see if it is an issue with the parallel
version or MMPBSA.py in general. Because we do not make or maintain the mpi4py source code,
MMPBSA.py.MPI will not be available on platforms on which mpi4py cannot be built.

2.2. The cmake build system in Amber

This section will walk you through performing certain common tasks with the CMake build system. Note: this

is fairly advanced information; for a more gentle introduction, please visit these pages:

• CMake Quick Start Guide

• CMake Common Options

2.2.1. Using MPI and OpenMP

MPI and OpenMP provide different methods of parallelizing Amber -- MPI at the process level, and OpenMP at
the thread level. MPI takes the form of one or more libraries that Amber needs to link with, while OpenMP requires
compiler support and is activated by a speciﬁc compiler ﬂag. If you are working in a high-performance computing
environment, then there will usually be a speciﬁc system MPI installation compatible with your hardware that you
are supposed to use. Make sure to ﬁnd out what that is and where it’s installed before going any further.

You can enable MPI in the CMake build system by passing the -DMPI=TRUE ﬂag. This will enable use of
MPI in all programs that support it. For each of these programs, the standard (serial) version will still be built,
and an additional version with MPI support, usually identiﬁed by the ".MPI" sufﬁx appended to the name, will be
compiled.

Traditionally, MPI is integrated into programs’ build systems by telling them to use special "compiler wrappers"
that automatically apply the needed ﬂags and libraries for MPI before calling the real compiler. However, Amber

23

2. Installation

Instead,
does not use these, since it would make it impossible to compile executables without MPI support.
Amber makes use of CMake’s FindMPI module, which extracts the compiler ﬂags from the MPI wrappers and
lets CMake use them only where needed. By default, FindMPI will search for MPI compiler wrappers (e.g.
mpicc, mpicxx, or mpif95) on your PATH and use the settings from the ﬁrst one it ﬁnds. If you want to select a
different MPI implementation, you can deﬁne (-D) the variables MPI_C_COMPILER, MPI_CXX_COMPILER,
and MPI_Fortran_COMPILER to point to the MPI wrappers for their respective languages. Or, with CMake >=
3.9 installed, you can deﬁne MPIEXEC_EXECUTABLE to point to the location of a mpiexec executable, and
CMake will attempt to ﬁnd the MPI that is installed in the same directory as it. For even more information, Refer
to Cmake’s FindMPI docs.

OpenMP can be enabled using the -DOPENMP=TRUE, and thankfully the process for conﬁguring it is not as
convoluted. CMake is aware of the needed OpenMP ﬂags for all supported compilers and will automatically ﬁnd
one that works. If none is available, an error will be printed. Similarly to MPI, once OpenMP is enabled an
alternate version of all supported programs will be made that has a ".OMP" sufﬁx.

2.2.2. Using CUDA

CUDA is NVidia’s software development kit for creating custom applications that run on NVidia GPUs. Amber
primarily uses CUDA in pmemd.cuda, but it’s also used to accelerate several other applications in AmberTools,
such as pbsa and cpptraj. You can enable CUDA in the CMake build system using -DCUDA=TRUE. This will
build CUDA versions of all applications that support it. MPI CUDA versions will also be built if MPI is enabled.
Currently Amber supports CUDA versions from 7.5 to 10.2 inclusive. However, older versions are less well
tested and more likely to cause issues, and you may also run into trouble with the CUDA SDK being incompatible
with newer compilers on your machine. So, it’s better to use one of the newer CUDA versions if possible. Note
that the compilation of complex CUDA code such as Amber’s is extremely CPU and memory intensive, so CUDA
builds are much slower than those of other languages. It is not abnormal for the compilation of a single source ﬁle
to take several minutes, and for the compilation of all of pmemd.cuda to take close to an hour.

By default, CMake will search for the CUDA compiler executable (nvcc) on your PATH and use the CUDA
installation associated with it. To specify a certain install location, deﬁne the CUDA_TOOLKIT_ROOT_DIR
variable, e.g.
-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-8.0. The Amber build system uses CMake’s
legacy FindCUDA module and will continue to for the forseeable future. So, information related to CUDA that is
for newer versions of CMake may not be accurate. Instead, refer to the FindCUDA docs for infornation.

Starting with Amber 20, Amber supports use of the NVidia NCCL library for communications between mul-
tiple GPUs, which an provide a performance improvement over plain MPI. If the library is enabled (using -
DNCCL=TRUE), then it will be activated when pmemd.MPI.cuda is run on 3 or more GPUs.

2.2.3. Controlling External Libraries

Amber can use, for one purpose or another, a great variety of third-party libraries. Some, such as NetCDF,
FFTW, and boost, are core components of many programs and as such must be enabled for the build to succeed.
Others are only optional and Amber can work just ﬁne without them. The complete description of what these
libraries do and how to use them is too complex for here and is left to the relevant sections of the manual. Instead,
this section will instead focus on the build system’s tools for managing them.

After the conﬁguration ﬁnishes, the build system will print a build report showing all libraries used. Here’s an



example from my system:



3rd Party Libraries

--
-- ---building bundled: -----------------------------------------------------
-- ucpp - used as a preprocessor for the NAB compiler
-- netcdf-fortran - for creating trajectory data files from Fortran
-- pnetcdf - used by cpptraj for parallel trajectory output
-- readline - used for the console functionality of cpptraj
-- xblas - used for high-precision linear algebra calculations
-- mpi4py - MPI support library for MMPBSA.py
-- ---using installed: ------------------------------------------------------

24

2.2. The cmake build system in Amber

-- arpack - for fundamental linear algebra calculations
-- netcdf - for creating trajectory data files
-- fftw - used to do Fourier transforms very quickly
-- apbs - used by Sander as an alternate Poisson-Boltzmann equation solver
-- zlib - for various compression and decompression tasks
-- libbz2 - for bzip2 compression in cpptraj
-- plumed - used as an alternate MD backend for Sander
-- libm - for fundamental math routines if they are not contained in the C library
-- mkl - alternate implementation of lapack and blas that is tuned for speed
-- perlmol - chemistry library used by FEW
-- boost - C++ support library
-- nccl - NVIDIA parallel GPU communication library
-- mbx - computes energies and forces for pmemd with the MB-pol model
-- ---disabled: ------------------------------------------------
-- blas - for fundamental linear algebra calculations
-- lapack - for fundamental linear algebra calculations
-- c9x-complex - used as a support library on systems that do not have C99 complex.h support
-- lio - used by Sander to run certain QM routines on the GPU
-- pupil - used by Sander as an alternate user interface





There are a lot of important details in this report. The "canonical" name of each library is listed, along with
its description. You’ll also notice that each library is listed as either "bundled", "installed", or "disabled". This
indicates where the build system found each library.

With some exceptions, Amber will automatically ﬁnd and use libraries it ﬁnds on the system, marking them as
installed. You’ll see output from these detections earlier in the build, with a message explaining why it couldn’t
ﬁnd each library that is missing and what info it needs to locate it. If you don’t need the library active you can
ignore these messages, but otherwise you can use that information to determine what variables to deﬁne. For
example, if you saw this output:

-- Could NOT find PnetCDF_C (missing: PnetCDF_C_LIBRARY PnetCDF_C_INCLUDE_DIR)

you could help CMake ﬁnd the library with the following command:

cmake <path to source> -DPnetCDF_C_LIBRARY=<path to libpnetcdf.so> \

-DPnetCDF_C_INCLUDE_DIR=<path to folder containing pnetcdf.h>

To ﬁnd libraries when the paths aren’t speciﬁed directly, CMake uses a speciﬁc search path which generally con-
tains all the system directories. But what if you have certain libraries installed to a nonstandard directory? The
easiest way to help CMake ﬁnd those libraries is by deﬁning the variable CMAKE_PREFIX_PATH. This can be
set to one path or a semicolon-separated list, and each of these paths will be searched like a standard Unix preﬁx:
<path>/bin for programs, <path>/lib for libraries, and <path>/include for headers. If you’ve used Autoconf build
systems before this is similar to the --preﬁx option, though it does not control the install directory.

Unlike many other CMake build systems, Amber is smart enough to automatically ﬁnd and use new libraries
that have been installed on the system after the initial conﬁguration has been run. So, you should be able to pick
up new libraries just by running cmake on a previously conﬁgured build directory. However, there are still some
situations that will require you to delete and recreate the build directly completely, such as if the build or source
directory is moved or if an external library is deleted or moved to a new location.

For many libraries which are required and are not commonly found on people’s systems, Amber provides bun-
dled versions to make users’ lives easier. These bundled versions are automatically compiled and installed along
with Amber, and should work seamlessly. They also are guaranteed to get built with the same environment and
settings as Amber, removing a common source of problems. However, they do increase the binary size and can
cause conﬂicts with libraries already installed on the system, so especially if you are packaging Amber, you may
wish to use the external versions.

In the past, the Amber developers have had trouble with user issues related to broken installations of cer-
tain libraries on certain common OSs. To combat this, the decision was made to prevent Amber from linking

25

2. Installation

to certain libraries by default unless speciﬁcally told to. As of Amber 20, these libraries are netcdf, netcdf-
fortran, boost, mkl, and arpack. To disable this behavior and use all found libraries, you can use the option
-DTRUST_SYSTEM_LIBS=TRUE.

Sometimes, even more ﬁne-grained control over 3rd party libraries is needed, such as if a speciﬁc 3rd party
library is found but fails to link and you want to disable it. For this purpose, three override options are pro-
vided: FORCE_DISABLE_LIBS, FORCE_INTERNAL_LIBS, and FORCE_EXTERNAL_LIBS. These accept
semicolon-separated lists of library names. FORCE_DISABLE_LIBS will force Amber to build without a given
library, and will print an error if that library is required. FORCE_INTERNAL_LIBS will tell Amber to prefer the
internal version of a bundled library. Finally, FORCE_EXTERNAL_LIBS will tell Amber to prefer the version of
a library that is installed on the system.

One last thing: keep in mind that these variables are lists and the entire list is set at once. Suppose you
had previously disabled MKL because of a link error, using -DFORCE_DISABLE_LIBS=mkl. Then, a build
error occurs with mpi4py and you want to disable that too.
It’s ﬁne to run CMake again without passing the
FORCE_DISABLE_LIBS option, but when you change it you need to pass the full new value so the mkl entry
isn’t erased. So, the argument to use would be -DFORCE_DISABLE_LIBS=mkl;mpi4py.

2.2.4. Selecting BLAS and MKL

Almost all Amber programs require access to the BLAS (Basic Linear Algebra Subprograms) and LAPACK
(Linear Algebra PACKage) libraries for computing various matrix operations. By default, Amber uses the vener-
able Netlib implementations of these libraries, which are widely compatible, but are not the best optimized. Over
time, several optimized versions of BLAS and LAPACK have been produced, which can offer performance in-
creases of 50%-1000% on large matrix operations. If you are building Amber for a high performance computing
environment, it is highly recommended to make use of an optimized BLAS implementation. Popular options in-
clude OpenBLAS, which is free and supports a wide variety of platforms, and MKL, which is more extensive and
may provide better performance on Intel chips.

Non-MKL BLAS implementations are handled using CMake’s FindBLAS and FindLAPACK modules. These
know about and search for a variety of BLAS and LAPACK implementations, including Netlib, OpenBLAS, and
Macs’ Accelerate framework. To force them to search for these speciﬁc versions of BLAS and LAPACK, you can
set the BLA_VENDOR variable to "Generic", "OpenBLAS", or "Apple" respectively. The full list is documented
here. If your BLAS is installed to a nonstandard location, you may need to add it to the CMake search path using
the methods in the previous section.

MKL, however, is a special case. It is a very complicated library that is difﬁcult to link properly on all systems, so
it is not found by default to reduce the chance of errors. To enable it, either pass -DTRUST_SYSTEM_LIBS=TRUE
or -DFORCE_EXTERNAL_LIBS=mkl (see above). Amber will then search for MKL in its default install location,
such as /opt/intel/mkl on Linux. The environment variables MKL_HOME and MKLROOT will also be checked
if they are deﬁned. If MKL is installed to a different location, or if you need to select a speciﬁc version, deﬁne
the MKL_HOME CMake variable to point to MKL’s install directory. MKL can be used in two modes: threaded
or serial. Threaded mode provides the option for MKL to split calculations across multiple threads internally (ex-
actly how it does this is conﬁgured using environment variables). By default Amber will attempt to link MKL
in threaded mode, but if this causes problems (it requires that your compiler have an OpenMP implementation
supported by MKL) then you can use -DMKL_MULTI_THREADED=FALSE to turn this off. Also, if you want
Amber to use the MKL static libraries, you can pass the -DMKL_STATIC=TRUE option. Unfortunately, due to
how CMake ﬁnd modules work, this option only takes effect the ﬁrst time CMake is run.

2.2.5. Conﬁguring Python

A substantial amount of Amber programs either are written in or provide interfaces to Python. Unfortunately,
Python installations tend to vary wildly across different systems, and Python programs are very prone to issues
with dependencies on native libraries as well as other Python libraries. So, Amber supports three different Python
conﬁgurations for different systems and setups.

1. The ﬁrst option, and the one that is used by default, is to let Amber control the Python distribution en-
tirely. This is best if your system python environment is broken, unpredictable, or uncontrolled. Amber

26

2.2. The cmake build system in Amber

will download a self-contained Continuum Miniconda python interpreter when CMake is run for the ﬁrst
time and will manage it entirely itself.
In Amber 20, Python 3 is used by default, but you can use -
DMINICONDA_USE_PY3=FALSE to download Python 2 instead. Once Amber is installed, you can access
Amber’s miniconda via the amber.python symlink in the install directory. Using miniconda will eliminate
the chance of a conﬂict between Amber’s binaries and dependencies and your system Python interpreter.
However, there are some downsides: it takes up a fair amount of space, on the order of a gigabyte, and
since it’s a separate interpreter, packages that you have installed to other interpreters won’t be able to easily
interoperate with Amber. Finally, when using miniconda, you can’t move the Amber install folder from
its original location. However, it’s still a reliable option for new users and those with problematic Python
environments.

2. Another popular option for Amber python is to use Anaconda.

If you haven’t heard of it, Anaconda is
a scientiﬁc python distribution, but it’s also practically a miniature Linux distro, containing a huge array
of binary libraries that are installed along with the Python packages that need them. This can be very
helpful because it already includes a lot of the libraries needed by Amber, such as MKL and openblas.
And unlike using internal Miniconda, using your system Anaconda means Amber can interoperate with
other packages and programs installed to that interpreter. However, Anaconda has its own caveat: since
it includes its own versions of system libraries, the Anaconda interpreter sometimes won’t be able to load
Amber libraries that link to the system versions of those same libraries. Also, there are situations where
Anaconda’s internal libraries can conﬂict with system libraries and cause programs to fail to build or run.
Phew, have I confused you yet? Yeah, shared library dependencies are the pits. To use Anaconda as a python
interpreter only, all that is needed is to disable Miniconda (-DDOWNLOAD_MINICONDA=FALSE) and
activate your conda env before you build Amber. Just make sure to keep the conda env active whenever
you use Amber, and everything should work ﬁne. To also link libraries from Anaconda by default, use -
DUSE_CONDA_LIBS=TRUE (this must be passed the ﬁrst time you run CMake). The build system will
search for the conda executable in your PATH, ﬁnd your Anaconda installation, and add it to the front of the
library search path.

3. Your ﬁnal option is to just use your existing system Python interpreter. Set DOWNLOAD_MINICONDA to
FALSE, and let CMake ﬁnd your Python interpreter on the PATH. By default it will prefer the latest versioned
python available, so python3.6 would be found before python2.7. To select a different interpreter, set the
PYTHON_EXECUTABLE variable to point to it. Amber requires certain Python packages be installed:
currently numpy, scipy, matplotlib, cython, setuptools, and tkinter. You can install these through your distro’s
package manager or through pip. If you don’t have root access, the pip install --user command is your friend
since it will install to your home directory instead of the system dirs. Compared to the legacy build system,
Amber’s CMake build system now has much-improved support for working with your system Python, and
it should work ﬁne on most system. However, there can still be issues, so we recommend switching to
Anaconda or Miniconda if the system installation is not working for you.

2.2.6. Conﬁguring Amber Settings

There are a few other commonly used Amber build options that it’s worth being aware of. Ever had an Amber
tool that you didn’t care about fail to build, and you just wish you could make it disappear? Well now you can,
with DISABLE_TOOLS! Just pass it a semicolon-separated list of tools (folder names under AmberTools/src/ or
src/) to this option, and it will prevent them from building. A note will be added at the bottom of the build report
saying which tools you’ve disabled. It also tracks dependencies between tools, so disabling something that other
things depend on will properly disable the dependers instead of causing build errors.

Another useful option is the STATIC ﬂag. This will cause all Amber executables and libraries to be linked
statically. This means that they don’t depend on any other libraries from Amber and can be moved anywhere or
to any other machine (as long as the same system libraries are present). It also may provide a performance boost
to some programs by removing the overhead of resolving symbols in shared libraries, though this has not been
measured.

Finally, Amber has two different ways of running tests, controlled by the INSTALL_TESTS option. With
INSTALL_TESTS enabled, all Amber and AmberTools tests are installed to the install preﬁx, and can be run with

27

2. Installation

the standard commands using the Makeﬁle there. This makes the installation totally independent of the source dir,
which is convenient for packaging or distributing Amber. However, there are some downsides: the tests are quite
large, taking up a gigabyte or more of space. Copying them from the source folder will eat up even more of your
disk and make the install process take quite a bit longer. If you’re planning on keeping the source directory around
then it might make more sense to leave INSTALL_TESTS disabled. In this conﬁguration, the tests will not be
installed and you must run them out of the source directory after sourcing amber.sh.

Several other common tasks are covered with more in-depth guides:

• Cross-compiling Amber

• Creating packages (includes Linux deb/rpm packages, OS X DMG packages, and Windows installers)

2.2.7. Debugging the Build

Last but not least, there are several options that are very useful when things go haywire in the build.
You’ll notice pretty quickly when building that CMake chooses to omit the full compiler command in favor of
a pretty-looking ﬁlename and progress percentage only. This is nice most of the time, but can be a problem if a
compile command is failing and you aren’t sure why. Luckily, CMake has a handy option for these situations:
CMAKE_VERBOSE_MAKEFILE. Setting it to TRUE will cause it to print out the full compiler command for
each ﬁle. As a shortcut, if you are using Makeﬁles, then you can run make VERBOSE=1 to trigger the same
behavior without rerunning CMake.

But what if you’re sure that Amber is being compiled correctly, but it’s having trouble linking to an external
library? This is where -DPRINT_PACKAGING_REPORT=TRUE can help. This will cause Amber to print a
detailed list of all the libraries that it is linking to on your system and where they are located. It’s mainly meant
to help analyze dependencies for packaging, but it’s also convenient as a general purpose debugging tool in case
Amber is linking to something it shouldn’t be.

2.3. Python in Amber

The Python programming language is the language of several key components of Amber. In addition to stan-
dalone programs like MMPBSA.py, MCPB.py, and ParmEd, a growing number of components also expose a
substantial fraction of Amber functionality through Python APIs, like pysander, ParmEd, and pytraj.

If you point cmake to a python interpreter (by setting -DPYTHON_EXECUTABLE=/path/to/python), that will
be used if has the necessary components installed. Otherwise, you will be notiﬁed and asked if you want to install
Miniconda. If so, cmake will download and install this version, which can either be miniconda2 or miniconda3.
Making use of this download facility is recommended for most users; if you choose to use some other python
installation, you should know what you are doing, and how to install the needed components, which include numpy,
scipy, cython, ipython, notebook, matplotlib. Users can access this Python via $AMBERHOME/bin/amber.python.
By default, AmberTools attempts to install Python packages to $AMBERHOME/lib/pythonX.Y, where X.Y is the
version of Python that was found (or assigned) by cmake. The amber.sh resource script then adds this path to your
PYTHONPATH environment variable to ensure that the Python runtime can ﬁnd these packages.

Users are encouraged to use Python versions 2.7 and 3.4 (or greater) since those versions have been veriﬁed
to work with all Python components of Amber (assuming other prerequisites, like numpy and/or scipy are met).
Different components of AmberTools support different versions of Python. Some codes (like pytraj, ParmEd and
pdb4amber) work unchanged in both Python 2.7 and Python 3.x, while others need to be converted using 2to3
upon installation. If users plan to combine AmberTools (such as pysander, ParmEd) with third party packages then
they they need to be careful. For example, circa 2017 Phenix and PyRosetta did not support Python 3.x, so users
would need to use Python 2.7.

2.4. Applying Updates

For most users, simply running cmake and responding ‘yes’ to the update request will automatically download
and apply all patches. This section describes the main updating script responsible for managing updates. We

28

2.4. Applying Updates

suggest that you at least skim the ﬁrst section on the basic usage—particularly the note about the --version ﬂag
for if/when you ask for help on the mailing list.

2.4.1. Basic Usage

Updates to AmberTools and Amber are downloaded, applied, and managed automatically using the Python

script update_amber. This script works on every version of Python from Python 2.4 through the latest Python 3
release. To use this command manually, you must refer to the “source” directory, i.e. the folder headed by
“amber20_src” where you downloaded the codes. Here, we are going to assume that you have set your
AMBERSOURCE environment variable to this directory, say by typing the command:

export AMBERSOURCE=/path/to/amber20_src

Please substitute /path/to amber20_src with the appropriate path for your machine: this will be the folder where
you un-tarred the distribution. Now there are three basic update-related commands:

• $AMBERSOURCE/update_amber --check-updates : This option will query the Amber website for any
updates that have been posted that have not been applied to your installation. If you think you have found a
bug, this is helpful to try ﬁrst before emailing with problems since your bug may have already been ﬁxed.

• $AMBERSOURCE/update_amber --version : This option will return which patches have been applied to
the current tree so far. When emailing the Amber list with problems, it is important to have the output of this
command, since that lets us know exactly which updates have been applied.

• $AMBERSOURCE/update_amber --update : This option will go to the Amber website, download all updates
that have not been applied to your installation, and apply them to the source code. Note that you will
have to recompile any affected code for the changes to take effect! To do this, go to your
build directory and re-rerun the cmake command you used in Step 3 of Section 2.1.

2.4.2. Advanced options

update_amber has additional functionality as well that allows more intimate control over the patching process.

For a full list of options, use the --full-help command-line option. These are considered advanced options.

• $AMBERSOURCE/update_amber --download-patches : Only download patches, do not apply them

• $AMBERSOURCE/update_amber --apply-patch=<PATCH> : This will apply a third-party patch

• $AMBERSOURCE/update_amber --reverse-patch=<PATCH> : Reverses a third-party patch ﬁle that was

applied via the --apply-patch option (see above).

• $AMBERSOURCE/update_amber --show-applied-patches : Shows details about each patch that has been

applied (including third-party patches)

• $AMBERSOURCE/update_amber --show-unapplied-patches : Shows details about each patch that has

been downloaded but not yet applied.

• $AMBERSOURCE/update_amber --remove-unapplied : Deletes all patches that have been downloaded but

not applied. This will force update_amber to download a fresh copy of that patch.

• $AMBERSOURCE/update_amber --update-to AmberTools/#,Amber/# : This command will apply all
patches necessary to bring AmberTools up to a speciﬁc version and Amber up to a speciﬁc version. Note,
no updates will ever be reversed using this command. You may specify only an AmberTools version or an
Amber version (or both, comma-delimited). No patches are applied to an omitted branch.

• $AMBERSOURCE/update_amber --revert-to AmberTools/#,Amber/# : This command does the same

as --update-to described above, except it will only reverse patches, never apply them.

29

2. Installation

update_amber will also provide varying amounts of information about each patch based on the verbosity setting.
The verbose level can be set with the --verbose ﬂag and can be any integer between 0 and 4, inclusive. The
default verbosity level changes based on how many updates must be described. If only a small number of updates
need be described, all details are printed out. The more updates that must be described, the less information is
printed. If you manually set a value on the command-line, it will override the default. These values are described
below (each level prints all information from the levels before plus additional information):

• 0: Print out only the name of the update ﬁle (no other information)

• 1: Also prints out the name of the program(s) that are affected

• 2: Also prints out the description of the update written by the author of that update.

• 3: Also prints the name of the person that authored the patch and the date it was created.

• 4: Also prints out the name of every ﬁle that is modiﬁed by the patch.

2.4.3. Internet Connection Settings

If update_amber ever needs to connect to the internet, it will check to see if http://ambermd.org can be contacted
within 10 seconds. If not, it will report an error and quit. If your connection speed is particularly slow, you can
lengthen this timeout via the --timeout command-line ﬂag (where the time is given in seconds).

Proxies By default, update_amber will attempt to contact the internet through the same mechanism as
programs like wget and curl. For users that connect to the internet through a proxy server, you can either set the
http_proxy environment variable yourself (in which case you can ignore the rest of the advice about proxies
here), or you can conﬁgure update_amber to connect to the internet through a proxy. To set up update_amber to
connect to the internet through a proxy, use the following command:

$AMBERSOURCE/update_amber --proxy=<PROXY_ADDRESS>

You can often ﬁnd your proxy address from your IT department or the preferences in your favorite (conﬁgured)
web browser that you use to surf the web. If your proxy is authenticated, you will also need to set up a user:

$AMBERSOURCE/update_amber --proxy-user=<USERNAME>

If you have set up a user name to connect to your proxy, then you will be asked for your proxy password the ﬁrst
time update_amber attempts to utilize an online resource. (For security, your password is never stored, and will
need to be retyped every time update_amber runs).

You can clear all proxy information using the --delete-proxy command-line ﬂag—this is really only necessary
if you no longer need to connect through any proxy, since each time you conﬁgure a particular proxy user or server
it overwrites whatever was set before.

Mirrors If you would like to download Amber patches from another website or even a folder on a local ﬁlesystem,
you can use the --amber-updates and --ambertools-updates command-line ﬂags to specify a particular web
address (must start with http://) or a local folder (use an absolute path). You can use the --reset-remotes
command-line ﬂag to erase these settings and return to the default Amber locations on http://ambermd.org.

If you set up online mirrors and never plan on connecting directly to http://ambermd.org, you can change
the web address that update_amber attempts to connect to when it veriﬁes an internet connection using the
--internet-check command-line option.

30

2.5. Installation using the old (legacy) build system

2.5. Installation using the old (legacy) build system

The transition of our build system to cmake (described above) offers many advantages. This system has been
tested on many variants of Linux and MacOSX, but we recognize that there may well be a period of adjustment,
since the setup of compilers and installed libraries can vary a lot from machine to machine. This section gives an
overview of how to install and test your distribution using the older (aka “legacy”) build system. You may ﬁnd it
useful if cmake doesn’t work for you. Once you have downloaded the distribution ﬁles, do the following:

1. First, extract the ﬁles in some location (we use /home/myname as an example here):

cd /home/myname
tar xvfj AmberTools20.tar.bz2 #
#

(Note: extracts in an

“amber20_src” directory)

tar xvfj Amber20.tar.bz2

# (only if you have licensed Amber 20!)

2. Next, set your AMBERHOME environment variable:

export AMBERHOME=/home/myname/amber20_src
setenv AMBERHOME /home/myname/amber20_src

# (for bash, zsh, ksh, etc.)
# (for csh, tcsh)

Be sure to change the “/home/myname” above to whatever directory is appropriate for your machine, and
be sure that you have write permissions in the directory tree you choose. (In general, you should not install
application software, e.g., Amber, as root.)

3. Next, you may need to install some compilers and other libraries. Details depend on what OS you have, and

what is already installed. Package managers can greatly simplify this task. See http://ambermd.org/amber_install.html
for more information, and for requirements for other variants of Linux, and for Macintosh OSX.

4. Now, in the AMBERHOME directory, run the conﬁgure script:

cd $AMBERHOME
./configure --help

will show you the options. Choose the compiler and ﬂags you want; for most systems, the following should
work:

./configure gnu

This step will also check to see if there are any updates and bug ﬁxes that have not been applied to your
installation, and will apply them (unless you ask it not to). If the conﬁgure step ﬁnds missing libraries, go
back to Step 3. This step will also ask if you want to install a compatible Python executable for the Python
programs in Amber (including MMPBSA.py, MCPB.py, ParmEd, pysander, pytraj, pdb4amber, and the rest
of amberlite). Since Amber now requires Python 2.7 or later, along with numpy, scipy, and matplotlib to
enable all of its functionality, conﬁgure now provides an option to download a compatible Python from
Continuum IO (via miniconda) and install it in the Amber directory for use with Amber programs. See
Section 2.3 for more details. If your default Python has the required prerequisites installed, conﬁgure will
simply select that Python for use with Amber.
Do not choose any parallel options at this step! You will need to install the serial version ﬁrst; options for
parallel builds are described below at Step 8.

5. The conﬁgure step will create two resource ﬁles in the AMBERHOME directory: amber.sh and amber.csh.

These sourceable scripts will set up your shell environment correctly for Amber:

source /home/myname/amber20_src/amber.sh
source /home/myname/amber20_src/amber.csh # for csh, tcsh

# for bash, zsh, ksh, etc.

Of course, /home/myname/amber18 should be adjusted for your AMBERHOME. Adding these commands
to your login resource ﬁle (e.g., ~/.bashrc, ~/.cshrc, ~/.zshrc, etc.) will set up your environment every time
you start a new shell. Note, this step is absolutely necessary to run any of the Python modules included with
Amber.

31

2. Installation

6. Then,

make install

will compile the codes. If this step fails, read the error messages carefully to try to identify the problem.

7. This can be followed by

make test

which will run tests and will report successes or failures. See the discussion above about how to interpret
test results.

8. If you are new to Amber, you should look at the tutorials and this manual and become familiar with how

things work. If and when you wish to compile parallel (MPI) versions of Amber, do this:

cd $AMBERHOME
./configure -mpi <....other options....> <compiler-choice>
make install
# Note the value below may depend on your MPI implementation
export DO_PARALLEL="mpirun -np 2"
make test
# Note, some tests, like the replica exchange tests, require more
# than 2 threads, so we suggest that you test with either 4 or 8
# threads as well
export DO_PARALLEL="mpirun -np 8"
make test

This assumes that you have installed MPI and that mpicc and mpif90 are in your PATH. Some MPI
installations are tuned to particular hardware (such as InﬁniBand), and you should use those versions if you
have such hardware. Most people can use standard versions of either mpich or openmpi. To install one of
these, use one of the simple scripts that we have prepared:

cd $AMBERHOME/AmberTools/src
./configure_mpich <compiler-choice>
./configure_openmpi <compiler-choice>

OR

Follow the instructions of these scripts, then return to the beginning of step 7.

9. See Section 20.6.5 for information about installing the GPU-accelerated versions of pmemd.

10. See Section 6.6.4 for information about installing the GPU-accelerated version of pbsa.

2.6. Contacting the developers

Please send suggestions and questions to amber@ambermd.org. You need to be subscribed to post there; to
subscribe, go to http://lists.ambermd.org/mailman/listinfo/amber. You can unsubscribe from this mailing list on
the same site.

32

Part II.

Amber force ﬁelds

33

3. Molecular mechanics force ﬁelds

Amber is designed to work with several simple types of force ﬁelds, although it is most commonly used with
parametrizations developed by Peter Kollman and his co-workers and “descendents”. The traditional parametriza-
tion uses ﬁxed partial charges, centered on atoms. Less commonly used modiﬁcations add polarizable dipoles to
atoms, so that the charge description depends upon the environment; such potentials are called “polarizable” or
“non-additive”. An alternative is to use force ﬁelds originally developed for the CHARMM or Tinker (AMOEBA)
codes; these require a different setup procedure, which is described in Sections 14.2.2.8 (for CHARMM) and
Chapter 30 (for AMOEBA). Chapter 14 provides a basic introduction to force ﬁelds, along with details of how the
parameters are encoded in Amber ﬁles.

In previous versions of AmberTools, we included “combined” leaprc ﬁles (such as leaprc.ff14SB) that loaded,
protein, nucleic acid and water models that worked well together. This was convenient for most users, but tended
to obfuscate the important issue of deciding which force ﬁelds to use. Since various choices make good sense, as of
Amber 16 we have implemented a new scheme for users to specify the force ﬁelds they wish to use. Depending
on what components are in your system, you may need to specify:

'

• a protein force ﬁeld (recommended choice is ff14SB)

$

• a DNA force ﬁeld (recommended choice is OL15)

• an RNA force ﬁeld (recommended choice is OL3)

• a carbohydrate force ﬁeld (recommended choice is GLYCAM_06j)

• a lipid force ﬁeld (recommended choice is lipid17)

• a water model with associated atomic ions (more variable, but the most common choice is still tip3p); other

popular choices are spc/e, tip4pew, and OPC. Not needed if you are using an implicit solvent model.

&

• a general force ﬁeld, for organic molecules like ligands (recommended choice is gaff2)

• other components (such as modiﬁed amino acids or nucleotides, other ions), as needed

%

Notes:

1. You have to be careful if you try to adopt a “mix and match” strategy for different components. The recom-
mended choices are designed to work well together, and have been fairly extensively tested. Use of other
combinations requires a deeper knowledge of the nature and origin of force ﬁelds; see below and consult the
original papers for more information. If you wish to combine proteins with nucleic acids, only the recom-
mended combination above (or one where leaprc.DNA.OL15 is replaced with leaprc.DNA.bsc1) is allowed.

2. In general, your input ﬁle to LEaP will begin with several commands to source the relevant leaprc ﬁles. For
example the following preamble would allow you to include proteins, DNA, lipids, general components,
water, and atomic ions like Na+ or Cl-, using the current recommended force ﬁelds:



source leaprc.protein.ff14SB
source leaprc.DNA.OL15
source leaprc.lipid17
source leaprc.water.tip3p
source leaprc.gaff2







35





leaprc.protein.ff19SB
leaprc.protein.ff14SB

leaprc.protein.ff14SBonly
frcmod.ff99SB14

3. Molecular mechanics force ﬁelds

Note that explicit solvent simulations now require you to load a leaprc.water.xxxx ﬁle; this is a change
from AmberTools15 and earlier versions, where the TIP3P water model was loaded by default. The change
reﬂects the growing awareness[18] within the modeling community that TIP3P should no longer be assumed
as appropriate for every type of biomolecular simulation, and that the use of more modern water models
instead can offer clear accuracy improvements in a rapidly increasing number of situations, see below.

3. There are some leaprc ﬁles for older force ﬁelds in the $AMBERHOME/dat/leap/cmd/oldff directory. We no
longer recommend these combinations, but we recognize that there may be reasons to use them, especially
for comparisons to older simulations. See Section 3.12 for more information.

4. In particular, the leaprc.ff14SB ﬁle, in the oldff/ directory, is identical to the ﬁle of the same name in Amber-
Tools15. In spite of its name, it is a “combined” ﬁle, with protein, DNA, RNA and water elements. This ﬁle
might be of particular interest if you want to make sure that systems created the “new” way (with the leaprc
ﬁles outlined above) are consistent with those using the older, “combined” method.

3.1. Proteins

In addition to the recommended ﬁle, leaprc.protein.ff14SB, there are a variety of alternatives for proteins; these

are described in the following sections.

3.1.1. The SB family of protein forceﬁelds (ff19SB, ff14SB, and ff99SB)

This is the same as leaprc.protein.ff14SB, but will additionally load:

ff99SB backbone parameters with ff14SB atom types

ff19SB

ff19SB [19] is the latest model of the SB protein forceﬁelds, developed in the Simmerling Lab at Stony Brook
University. The new ff19SB forceﬁeld has shown to improve amino acid-dependent properties such as helical
propensities and reproduces the differences in amino-acid-speciﬁc PDB Ramachandran map. Users are encouraged
to read the ff19SB article [19] to learn more about the motivation behind ff19SB, as well as details of the ﬁtting and
testing protocols and improved performance relative to ff14SB. Our older SB protein forceﬁeld models utilized
uncoupled phi/psi dihedral parameters for the protein backbone, and every amino acid except for glycine used
the backbone dihedral parameters ﬁt using alanine. In ff19SB, we improved the backbone dihedrals parameters
for every standard amino acids. We ﬁt coupled φ/ψ parameters using 2D φ/ψ conformational scans for multiple
amino acids, using 2D QM energy surfaces in solution as reference data. These new dihedral parameters include
amino-acid speciﬁc CMAPs that are based on residue name. We also zeroed the amplitudes of the old backbone
phi/psi dihedral parameters (in atom name, C-N-CA-C, N-CA-C-N, C-N-CA-CB, CB-CA-C-N, HA-CA-C-O)
from ff14SB that are based on the atom types. It is important that ff19SB be combined only with a parameter set
that has no cosine terms for these dihedrals.

Our results [19]showed that ff19SB pairs best with the more accurate water model OPC [20] , and that the older
TIP3P model has serious limitations when used with the QM-based ff19SB. As a result, we strongly recommend
using ff19SB with OPC, and we recommend against use with TIP3P.

In order to separate the new ff19SB parameters from the original ff14SB parameters, a new atom type XC was
created for C-alpha for all non-terminal residues. All the bonds, angles, non-bonded parameters (except S, see
below), and dihedral parameters not involving C-alpha were retained from ff14SB. The old backbone dihedral
parameters for C-alpha were modiﬁed to use atom type XC for C-alpha (instead of the old CX), and the amplitudes
were set to zero since it will use CMAP instead.

How to use ff19SB:

36





3.1. Proteins

To use ff19SB users can execute the following command in tleap:

source leaprc.protein.ff19SB

This will load the following ﬁles:

1. parm19.dat is similar to parm10.dat. It has the new atom type XC parameters, which are identical to CX

parameters, except for the dihedral H1-CX-C-O parameters.

2. frcmod.ff19SB contains the parameters from frcmod.ff14SB, where the CX atom type was replaced with
the XC atom types. The dihedral H1-CX-C-O was copied over from parm10.dat. CX is also replaced
with XC for this dihedral. The magnitude of the backbone dihedrals with XC is zeroed. This is done
since the residue-based CMAP is used instead to calculate the backbone dihedral energies. The Lennard-
Jones parameters for S, SH were both obtained from atom type “s” (sulfur with one connected atom) from
gaff2.dat, while Lennard-Jones parameters for HS were obtained from atom type “hs” (hydrogen-bonded to
sulphur) in gaff2.dat. The CMAP parameters were updated for all non-terminal versions of the 20 standard
amino acids, as well as alternate protonation states for these residues.

3. amino19.lib All parameters from amino12.lib were copied over. Then, CX (alpha carbon atom type in
ff14SB) was replaced with XC for the entire ﬁle. None of the amino acids here should use atom type CX for
the alpha carbon.

4. aminont12.lib and aminoct12.lib is the same ﬁle as used for ff14SB, and is not changed in ff19SB. ff19SB
CMAP parameters are not applied to terminal amino acids since they do not have both phi and psi. Instead,
ff14SB is applied using parameters contained in aminont12.lib for N-terminal amino acids and aminoct12.lib
for the C-terminal amino acids.

Instructions for implementing ff19SB for a new amino acid (residue)
The situation often arises when a user may want to modify parameters for a standard amino acid or may want
to create a new parameters set for a modiﬁed amino acid. If the user wants to implement ff19SB on their new
amino acid, they should be cautious about the C-alpha atom type. In ff14SB, CX is used for the C-alpha atom
type, and hence all the ff14SB backbone parameters specify the CX atom type. In ff19SB, CX is replaced by
XC, and hence all the ff19SB backbone parameters specify the XC atom type. Additionally, the ff19SB backbone
dihedral parameters are zeroed, since CMAPS are used to deﬁne the energy of phi and psi. Importantly, if the
CX atom type is used, then ff14SB backbone dihedral parameters will be applied to all residues that use the CX
atom type, and if the XC atom type is used, then all backbone dihedral parameters will be zeroed. Care must be
taken not to mix these two protocols. When implementing ff19SB for a new amino acid, the user has the option to
build their topology ﬁle via tleap using pure ff19SB including a generic CMAP for the new residue, or a mixture
of ff14SB/ff19SB using ff19SB for everything except the new residue. Therefore we urge the user to follow the
procedure described in one of the scenarios below.

Scenario 1: In order to apply ff14SB parameters to a non-standard amino acid or a speciﬁc standard amino acid

and apply ff19SB to every other amino acid in the protein, please follow these steps:

source leaprc.protein.ff19SB
loadoff user-defined-file.lib
loadamberparams user-defined-file.frcmod

The user-deﬁned library and frcmod ﬁles for the new residue must use the CX atom type for C-alpha. Since the
ff19SB CMAP is applied based on residue name, it is important that new residue using CX for C-alpha does not
match the existing residue names for the standard amino acids, or else the CMAP will be applied in addition to the
ff14SB backbone parameters, giving incorrect results.

Scenario 2: In order to apply ff19SB parameters to a non-standard amino acid or a speciﬁc standard amino acid

and also apply ff19SB to every other amino acid in the protein, please follow these steps:

37

3. Molecular mechanics force ﬁelds

source leaprc.protein.ff19SB
loadoff user-defined-file.lib
loadamberparams user-defined-file.frcmod
loadamberparams frcmod.ff19SB_XXX

The user-deﬁned library ﬁle and frcmod ﬁles for the new residue must use the XC atom type for C-alpha. Ensure
the amplitudes of the phi/psi dihedrals are zeroed since you will be applying a CMAP for phi/psi. To apply a
CMAP for the phi/psi dihedral of the modiﬁed amino acid, the user must modify the provided ﬁle
frcmod.ff19SB_XXX by replacing XXX in the CMAP_TITLE and CMAP_RESLIST shown below, with the new
residue name matching that deﬁned in the user-deﬁned library ﬁle. frcmod.ff19SB_XXX can be found in
$AMBERHOME/dat/leap/parm/ directory.

%FLAG CMAP_TITLE
XXX CMAP
%FLAG CMAP_RESLIST 1
XXX

frcmod.ff19SB_XXX will apply the LEU CMAP backbone parameters which we recommend as a generic model
for modiﬁed amino acids. Next, the user can load the new frcmod.ff19SB_XXX.

ff14SB

ff14SB [21] was a continuing evolution of the earlier ff99SB force ﬁeld.[22] Several groups had noticed that the
older ff94 and ff99 parameter sets did not provide a good energy balance between helical and extended regions of
peptide and protein backbones. Another problem is that many of the ff94 variants had incorrect treatment of glycine
ff99SB improved this behavior, presenting a careful reparametrization of the backbone
backbone parameters.
torsion terms in ff99 and achieves much better balance of four basic secondary structure elements (PP II, β , αL,
and αR). Brieﬂy, dihedral term parameters were obtained through ﬁtting the energies of multiple conformations
of glycine and alanine tetrapeptides to high-level ab initio QM calculations. We have shown that this force ﬁeld
provides much improved proportions of helical versus extended structures. In addition, it corrected the glycine
sampling and should also perform well for β -turn structures, two things which were especially problematic with
most previous Amber force ﬁeld variants. The changes mainly involve torsional parameters for the backbone and
side chains. For backbones, experimental scalar coupling data for small solvated peptides became available [23]
against which ff99SB was compared.[24] As ff99SB backbone dihedrals were ﬁt based on gas-phase quantum data,
we felt that slight empirical adjustments were worth pursuing. This was done to improve agreement with scalar
coupling data, and we observed that this also improved stabilities of helical peptides.

ff14SBonlysc

ff14SBonlysc, where sc stands for side chains, includes ff99SB backbone parameters with updated side chain
parameters that were derived from ab initio quantum mechanics calculations (as were the ff99SB backbone cor-
rections). This model is slightly different from ff14SB, which includes the ff14SBonlysc parameters as well as a
small empirical correction to backbone parameters that was designed to improve agreement between NMR data
and simulations in TIP3P water for short peptides. We are currently exploring whether this empirical correction
also improves simulations in other water models, such as the GBneck2 (igb=8) model. [25] Currently, it appears
that igb=8 may work best with the fully quantum mechanics-based dihedral parameters included in ff14SBonlysc.
Simulations performed in explicit water most likely beneﬁt from the empirical corrections included in ff14SB or
ff19SB..



3.1.2. The ff15ipq protein force ﬁeld

leaprc.protein.ff15ipq
parm15ipq_10.3.dat
amino15ipq_10.0.lib

This will load the files listed below

force field parameters
topologies and charges for amino acids



38



aminont15_ipq10.0.lib
aminoct15ipq_10.0.lib

same, for N-terminal amino acids
same, for C-terminal amino acids

3.1. Proteins



ff15ipq [26] continues the development begun with the ff14ipq force ﬁeld [27, 28], but offers new, we hope
better, parameter choices, data ﬁtting, and validation. The physical assumptions behind the model are the same,
but problems with ff14ipq, most generally the "stickiness" of polar groups in simulations, led to sweeping pa-
rameter changes. The pair-speciﬁc Lennard-Jones terms in ff14ipq were the problem, introducing an imbalance
of protein:water and protein:protein interactions. They have been replaced by modiﬁed polar hydrogen radii and
a consistent Lorentz-Berthlot combining rule as found in other Amber force ﬁelds. As a consequence, the entire
charge set has changed, albeit slightly, and the the torsion parameters have been expanded and rederived. To further
improve the internal potential energy surface, reﬁtted angle parameters are included for the protein backbone. The
new version comprises nearly 1,200 unique parameters, and ff14ipq is archived (use oldff/leaprc.ff14ipq) for
backwards compatibility and comparisons.

The extended IPolQ charge derivation anticipates a workﬂow in which the ﬁnal model must have charges roughly
consistent with the polarization molecules experience in water, but also new torsion parameters which are often
derived with quantum calculations of the system in vacuum. In the extended methodology, two sets of charges
are ﬁtted: one for the systems in vacuum and the other for systems in the condensed phase. The original IPolQ
method [27] derives the appropriate condensed phase charges by ﬁtting to the average electrostatic potential of
polarized and unpolarized molecules: a process that harkens to linear response theory and implicitly accounts for
the energetic cost of polarizing the system away from its gas phase equilibrium. The extended scheme draws on
the vacuum phase electrostatic data a second time to make an alternative set of charges appropriate to describe the
vacuum potential energy surface–the IPolQ charges themselves are, in fact, re-expressed as a perturbation of this
gas phase charge set. Both sets of charges are derived in the same linear least squares ﬁtting problem, with restraint
equations weakly coupling the corresponding charges together. This creates charge sets for each phase related by
a minimal perturbation, which can be assumed to be the effective, average polarization of the molecules when
they enter solution. The charge set appropriate to the vacuum phase is then used when ﬁtting torsion potentials
to vacuum phase quantum mechanical energies, and the torsion potentials are transferred directly for use with the
condensed-phase charge set in actual simulations, following the earlier assumption that the effective polarization
of the molecules, and thereby any energetic consequences of entering the condensed phase, are captured in the
charge perturbation.

All parameter optimization in ff15ipq, like its predecessor ff14ipq, is iterative: a generational learning scheme
whereby the results of previous simulations and force ﬁeld manipulations are submitted to quantum single point
energy calculations and then added to the training data. As with ff14ipq, charges and gas-phase conformational
energies are all taken at the MP2/cc-pVTZ level; ff15ipq takes the ff14ipq conformational energies as its starting
point and expands the space nearly four-fold. We ﬁnd that this crude form of machine learning is a good substitute
for human intervention. As with ff14ipq, the iterative process led to an evolution in simulation performance over
a variety of systems. We utilized these benchmarks to determine when the parameter set was ready for general
release.

The new ff15ipq model [26] was derived with the SPC/E-b water model of Takemura and Kitao [29]. Returning
to three-point water models improves performance of most Amber protein simulations on GPUs by about 30% due
to the reduction in the overall number of particles; a smaller improvement can be seen on CPUs. While SPC/E-b
is the recommended water model, the solvent reaction ﬁeld potential observed in our IPolQ studies is consistent
across three- and even some four-point waters: combinations of ff15ipq with TIP3P, the original SPC/E, and other
water models are reasonable to try. One issue that may arise in some circumstances is the compatibility of the water
model with ion parameters: we have set ff15ipq to reference ion parameters appropriate for the nearest water model
available, SPC/E. However, for highly charged or dense ionic solutions this combination may be sub-optimal. With
respect to compatibility with other macromolecular force ﬁelds such as sugars, lipids, or nucleic acids, we note
that while the charge set is novel, the MP2/cc-pVTZ solution-phase IPolQ charges [27] are in fact quite similar to
the Cornell charges derived at the HF/6-31G* level [30]. This result may support the long lifespan of that charge
set, and makes it likely that ff15ipq will be compatible with other force ﬁelds designed at the common HF/6-31G*
level.

ff15ipq has been validated on a larger number of test systems than its predecessor, and for much longer timescales.
Multiple alpha-helical and beta-sheet peptides have been tested at a variety of temperatures, and numerous small

39

3. Molecular mechanics force ﬁelds

proteins (the largest including lysozyme and the p53/MDM2 complex) have been simulated for timescales ranging
from 4 to 10 microseconds, displaying excellent stability and also instability in cases where loops of the proteins
or isolated peptides are known to be disordered. Various teething problems in the ff14ipq force ﬁeld were solved
by improvements to the data set or the ﬁtting protocol itself, so we are increasingly conﬁdent that ff15ipq and
future products of the IPolQ workﬂow will be reliable straight out of the automated parameter development phase.
The entire data set and mdgx input ﬁle for deriving the torsion and angle parameters of ff15ipq will be released as
supporting information in the upcoming publication on the force ﬁeld. In the future we hope to build on the lineage
of ff-ipq protein models to include other important areas of biological chemistry.



3.1.3. The fb15 (“force balance”) protein force ﬁeld

leaprc.protein.fb15
frcmod.fb15
frcmod.tip3pfb
all_aminofb15.lib
all_aminontfb15.lib
all_aminoctfb15.lib



This will load the files listed below

force field parameters
parameters for the force balance 3-point model
topologies and charges for amino acids

same, for N-terminal amino acids
same, for C-terminal amino acids

The ﬁles can be used for protein-water simulations using the “force-balance” approach described in Ref. [31, 32].
There is also a 4-point water model available, as described in section 3.5. For alkali and halide ions, the Joung-
Cheatham parameters for TIP3P (or TIP4PEW) are recommended; see Section 3.6.



3.1.4. The Duan et al. (2003) force ﬁeld

leaprc.protein.ff03.r1
frcmod.ff03

all_amino03.in
all_aminont03.in
all_aminoct03.in



loads the following files:

For proteins: changes to parm99.dat, primarily in the
phi and psi torsions.
Charges and atom types for proteins
For N-terminal amino acids
For C-terminal amino acids

The ff03 force ﬁeld [33, 34] is a modiﬁed version of ff99 (described below). The main changes are that charges
are now derived from quantum calculations that use a continuum dielectric to mimic solvent polarization, and that
the φ and ψ backbone torsions for proteins are modiﬁed, with the effect of decreasing the preference for helical
conﬁgurations. The changes are just for proteins; nucleic acid parameters are the same as in ff99.

The original model used the old (ff94) charge scheme for N- and C-terminal amino acids. This was what was
distributed with Amber 9, and can still be activated by using oldff/leaprc.ff03. More recently, new libraries for the
terminal amino acids have been constructed, using the same charge scheme as for the rest of the force ﬁeld. This
newer version (which is recommended for all new simulations) is accessed by using leaprc.protein.ff03.r1.



3.1.5. The Yang et al. (2003) united-atom force ﬁeld

frcmod.ff03ua

uni_amino03.in
uni_aminont03.in
uni_aminoct03.in



For proteins: changes to parm99.dat, primarily in the
introduction of new united-atom carbon types and new
side chain torsions.
Amino acid input for building database
NH3+ amino acid input for building database.
COO- amino acid input for building database.

The ff03ua force ﬁeld [35] is the united-atom counterpart of ff03. This force ﬁeld uses the same charging scheme
as ff03. In this force ﬁeld, the aliphatic hydrogen atoms on all amino acid side-chains are united to their corre-
sponding carbon atoms. The aliphatic hydrogen atoms on all alpha carbon atoms are still represented explicitly to
minimize the impact of the united-atom approximation on protein backbone conformations. In addition, aromatic

40













3.2. Nucleic acids

hydrogens are also explicitly represented. Van der Waals parameters of the united carbon atoms are reﬁtted based
on solvation free energy calculations. Due to the use of an all-atom protein backbone, the φ and ψ backbone
torsions from ff03 are left unchanged. The sidechain torsions involving united carbon atoms are all reﬁtted. In this
parameter set, nucleic acid parameters are still in all atom and kept the same as in ff99.

3.1.6. Options for intrinsically disordered proteins.

Intrinsically disordered proteins (IDPs) and intrinsically disordered regions (IDRs) are proteins or parts (regions)
of protein that lack stable secondary and tertiary structures under speciﬁc physiological conditions[36]. Compared
to globular proteins in their native states, atomistic modeling of IDPs and IDRs is inherently more demanding:
these structures are represented by multiple inter-converting conformations, often within kBT of each other. Thus,
while a simulation that focuses on the unique native state of a globular protein may be robust to errors in the force-
ﬁeld that over-stabilize the native state, the same errors of just 1 or 2kBT may lead to a completely wrong relative
abundance of conformations representing the IDP. Long time-scale simulations have demonstrated[37] that several
popular water models, in combination with any of several widely accepted force-ﬁelds, lead to overly compact
IDP conformations. Efforts to improve force ﬁelds and water models for IDPs are on-going[37–41]; recently, OPC
water model in combination with the ff99SB was found to improve, signiﬁcantly, accuracy of atomistic simulations
of IDPs[42].

3.2. Nucleic acids

As with proteins, many features of the current force ﬁelds, including partial atomic charges, Lennard-Jones
parameters, and most bond and angle terms, date back to force ﬁelds developed in the 1990’s, and overviews
of this work are available.[43, 44] The next breakthroughs in the Amber nucleic acid force ﬁeld development
came from observations on relatively longer simulations, 50-100 ns time scale, in the early 2000’s.[45, 46] These
simulations found systematic over-population of γ = trans backbone geometries in nucleic acids. High level QM
calculations were performed on models of sugars and phosphates, speciﬁcally a sugar-phosphate model[47] and
a sugar-phosphate-sugar model,[48] which ultimately led to the ff99-bsc0 parameterization.[47] For simulation
of canonical DNA and RNA structures, the ff99-bsc0 parameterization has proven rather successful. For non-
canonical structures, particularly those with loops or bulges, or χ ﬂips, some anomalies have been noted.

3.2.1. RNA

Desired Behavior

Source these ﬁles

Notes

RNA

ff99OL3

ff99OL3 + backbone phosphate

ff99χ + bsc0

ff99bsc0

leaprc.RNA.OL3
leaprc.RNA.LJbb
leaprc.RNA.YIL

parmbsc0 α/γ [47] + χOL3 [49] to ff99

ff99OL3 + backbone phosphate modiﬁcations[50]
parmbsc0 α/γ [47]+ Yildirim [51]χ mods to ff99.

oldff/leaprc.ff99bsc0

Contains parmbsc0 α/γ mods[47] to ff99.

“Rochester” torsions

“DE Shaw” modiﬁcations

Modiﬁed nucleotides

leaprc.RNA.ROC
leaprc.RNA.Shaw
leaprc.modrna08

[52]
[53]

parameters for modiﬁed nucleosides [54]

Table 3.1.: How to specify RNA force ﬁelds in LEaP; recommended variants are in italics.

With RNA, incorrect loop geometries, backbone sub-state populations and sugar pucker populations were ob-
served in longer simulations. In addition to not being able to always maintain south puckers where found in RNA
structures, multiple groups noticed a tendency for the RNA backbone to shift, putting χ into the high-anti region
which leads to an opening of the duplex structure into a ladder-like conﬁguration. Again, QM methods at various
levels were employed to improve the χ distribution using relevant model systems. The most tested χ modiﬁcations
are the “OL” modiﬁcations used in ff14SB.[49, 55] On top of the OL modiﬁcations, Bergonzo & Cheatham found

41

3. Molecular mechanics force ﬁelds

that with modiﬁed phosphate parameters from Steinbrecher et al.[50] and an improved water model (OPC), better
agreement with NMR data for RNA tetranucleotide populations was observed.[56] In this parameter set, a new
atom type for O4’ was created named OR (previously type OS). This allowed modiﬁcation of O2 and OS atom
types to LJ=1.7493, 0.2100 and 1.7718, 0.1700; previous values = 1.6612, 0.2100 and 1.6837, 0.1700.

An alternative available with Amber is the Yildirim χ modiﬁcations (and also related modiﬁcations called TOR
which alter ε/ζ as well)[51, 57, 58], and a systematic assessment and validation of these newer χ modiﬁcations
is underway on a large series of RNA tetraloop structures. Note that small changes to a particular dihedral may
lead to alteration in properties of related dihedrals, and may have unintended consequences. For example, the
ff99-bsc0 modiﬁcations tend to lock RNA sugar puckers mainly in the north, even with nucleotides in particular
sequence contexts that prefer southern conformations. Moreover, the χ modiﬁcations tend to further destabilize γ
= trans. This suggests that to reliably improve the nucleic acid dihedrals, a more systematic approach across many
dihedrals with simultaneous ﬁtting may be more appropriate. Moreover, we no longer fully support the idea that
parameters are transferable between DNA and RNA, or between purines and pyrimidines. For example, the ff99-
OL modiﬁcations (with or without ff99-bsc0) improve the modeling of RNA, but lead to issues with DNA, most
notably with quadruplex structures. Therefore recent work has focused on separate χ modiﬁcations for DNA.[59]
An alternative set of torsions for RNA, ﬁt to quantum calculations has recently been reported by the Rochester
group,[52] and can be loaded with the leaprc.RNA.ROC ﬁle. More extensive modiﬁcations are contained in the
“DE Shaw” force ﬁeld,[53], which can be loaded with leaprc.RNA.Shaw.

3.2.2. DNA

Name
ff94
ff98
ff99
bsc0

ε/ζ OL1
χ OL4
β OL1
OL15
bsc1

Modiﬁcation

Original force ﬁeld ﬁle

Modiﬁed charge set
Updated charge set

Barcelona α/γ backbone modiﬁcation

ε/ζ modiﬁcation for DNA

χ modiﬁcation tuned for DNA

(ε/ζ OL1+χOL4+β OL1)

Major update to bsc0

Notes

Obsolete
Obsolete

Foundation for all current ff’s

[47]

improvement for DNA, no effects for RNA [60]

[59]

[62]
[63]

β dihedral modiﬁcation tuned for DNA improvement for DNA, no effects for RNA[61]

Table 3.2.: Force ﬁeld name and modiﬁcations for simulating nucleic DNA. Recommended variants are listed in

italics.

As noted in Table 3.2, most current DNA force ﬁelds are based on parameters and charges that go back to
Amber’s ff99. A new set of parameters for the ε/ζ dihedral[60] and for the β dihedral[61] torsion for DNA have
been developed using QM methods that include the solvation effects implicitly. This set of parameters have been
tested with several double-stranded DNA systems including the Dickerson-Drew dodecamer, A-tracs, CG-rich
duplexes, Z-DNA and G-quadruplexes. These modiﬁcations increase the population of BII substate by stabilizing
the ε/ζ = g-/t state and renders higher values for the helical twist in the tested systems. In combination with the χ
modiﬁcation for DNA (χOL4, [59]), the force ﬁeld generates structures that suggest a better agreement with NMR
data. The reader should pay careful attention to the use of the χ modiﬁcations, since the naming convention of the
authors is the same for RNA and DNA.

The combination of the three dihedral updates (ε/ζ OL1+χOL4+β OL1) are now termed OL15 [62], which are
available sourcing the ﬁle leaprc.nucleic.OL15. More details about the OL15 force ﬁeld development and test
cases is available in http://fch.upol.cz/ff_ol/.

In a parallel effort, the group at the Barcelona Supercomputing Center have updated the well-known bsc0 mod-
iﬁcation, now termed bsc1.[63] This updated version of the bsc0 modiﬁcation has also been developed using
implicit solvation model and rigorous QM methodology. As with the OL15 variant, the updated bsc1 force ﬁeld
increases the helical twist and yields double stranded DNA structures that are in better agreement with experimen-
tal structures. Testing of the bsc1 force ﬁeld has been performed using more than 130 systems, including single

42

3.3. Carbohydrates

and double stranded DNA, hairpin structures, DNA-protein complexes, G-quadruplexes and more. This can be
accessed by sourcing leaprc.nuclic.bsc1; additional information about the bsc1 force ﬁeld development and test
cases is available in http://mmb.irbbarcelona.org/ParmBSC1/.

Details of the different modiﬁcations available for DNA are presented in Table 3.2. Regarding the performance
of OL15 and bsc1 for DNA, preliminary testing comparing both force ﬁelds strongly suggest that both variations
perform in a similar way and are improvements over the previous commonly bsc0 modiﬁcation.[62] We refer the
reader to the original articles of each force ﬁeld to better understand the details and performance between each
variant.

3.2.3. Some nonstandard situations

Nucleic acid residues use the new (version 3) PDB nomenclature: “DC” is used for deoxy-cytosine, and “C”
for cytosine in RNA, etc. Earlier force ﬁelds (which are not recommended!) use “RC” for the RNA version. If
you want a single, nucleoside, use “CN”, etc. For a single nucleotide, use the following command in LEaP:

cnuc = sequence { OHE C3 }

and analogs for other bases. Note that this will construct a protonated 5’ phosphate group, which may not be what
you want.

Some RNA molecules may have a 5’ residue with an attached phosphate group. This requires a bit-of

hand-editing of your PDB ﬁle. Suppose your 5’ end looks like this (taken from PDB code 2DXI):

ATOM
ATOM
ATOM
ATOM
ATOM
ATOM

1 OP3
2 P
3 OP1
4 OP2
5 O5’
6 C5’

G C 501
G C 501
G C 501
G C 501
G C 501
G C 501

19.050 87.190
18.499 87.676
16.984 87.888
18.979 86.828
19.153 89.150
18.729 90.260

73.029
71.706
71.715
70.515
71.502
72.301

1.00 73.49
1.00 75.79
1.00 73.44
1.00 77.51
1.00 63.81
1.00 48.63

You need to edit the ﬁrst atom, changing its residue name to OHE:

ATOM
ATOM
ATOM
ATOM
ATOM
ATOM

1 OP3 OHE C 500
2 P
G C 501
G C 501
3 OP1
G C 501
4 OP2
G C 501
5 O5’
6 C5’
G C 501

19.050 87.190
18.499 87.676
16.984 87.888
18.979 86.828
19.153 89.150
18.729 90.260

73.029
71.706
71.715
70.515
71.502
72.301

1.00 73.49
1.00 75.79
1.00 73.44
1.00 77.51
1.00 63.81
1.00 48.63

O
P
O
O
O
C

O
P
O
O
O
C

Note that this is not necessarily optimal: the 5’ terminal phosphate will have the same charges as the phosphate in
a phosphodiester linkage between residues along the chain. If the properties of the 5’ terminal group are especially
important to you, you may need to construct a special residue here. Also note (as noted above), this constructs a
protonated terminal phosphate (net charge of -1); again you will need to construct special residues it you wish to
have a deprotonated phosphate at the 5’ position.

3.3. Carbohydrates

GLYCAM06 is a consistent and transferable parameter set for modeling carbohydrates,[64] and glycoconjugates.[65,

66] The core philosophy of the force ﬁeld development process is that parameters should be: (1) be transferable
to all carbohydrate ring formations and sizes, (2) be self-contained and therefore readily transferable to many
quadratic force ﬁelds, (3) not require speciﬁc atom types for α- and β -anomers, (4) be readily extendible to carbo-
hydrate derivatives and other biomolecules, (5) be applicable to monosaccharides and complex oligosaccharides,
and (6) be rigorously assessed in terms of the relative accuracy of its component terms.

When combining GLYCAM06 with AMBER parameters for other biomolecules, parameter orthogonality is
ensured by assigning unique atom types for GLYCAM. In order to facilitate combining GLYCAM06 with other
AMBER parameter sets for other biomolecules, a variation on the GLYCAM atom types has been introduced in

43

3. Molecular mechanics force ﬁelds

which the new name consists of an uppercase letter followed by second character, either a number or lowercase
letter. For example the GLYCAM "CG" atom type has been changed to "Cg"; "HO" is now represented as "Ho",
and so forth.

As soon as new parameters are generated, or alterations are made to existing parameters, a new version of
GLYCAM is released. Updated versions that introduce new functionality are denoted using a letter sufﬁx (i.e.
GLYCAM06a, 06b, etc.). Each release is accompanied with an associated text ﬁle that summarizes the new
functionality or alteration. For example, a particularly important update, released in GLYCAM06e, altered the
endo-anomeric torsion term (Cg-Os-Cg-Os) in order to more accurately reproduce the populations arising from
ring ﬂips (4C1 to 1C4 etc.). This particular case suggested the need to be able to independently characterize the
exo- and endo-anomeric effect, which was achieved by assigning different atom types (Oa and Oe) to represent the
endo-anomeric and exo-anomeric oxygen atoms, respectively.

In another important update (GLYCAM06g), a small van der Waals term was applied to all hydroxyl hydrogen
atoms (Ho) to address a rare, but catastrophic, situation that can arise during MD simulations. In certain carbohy-
drate (and potentially other) conﬁgurations, a hydroxyl proton may be structurally constrained to being very close
to a carboxylate moiety. During an MD simulation of such a system, an oscillatory motion can begin between the
hydroxyl proton and the negative charge site, leading ultimately to failure of the simulation as the proton collapses
onto the negatively charged moiety. The small van der Waals term (Ho, R* = 0.2000 Å, ε = 0.0300 kcal/mol)
is just large enough to add sufﬁcient repulsion to prevent this behavior, while not being large enough to perturb
properties such as hydrogen bond lengths.

The GLYCAM force ﬁeld family, especially, GLYCAM06, has been extensively employed in simulations of

biomolecules by the larger scientiﬁc community.[67–70] The updated GLYCAM parameters and documentation
are available for download at the GLYCAM-Web site (www.glycam.org). Also available on the website are tools
for simplifying the generation of structure and topology ﬁles for performing simulations of oligosaccharides,
glycoconjugates and glycoproteins. GLYCAM-Web has been integrated into several glycomics databases, such as
the Consortium for Functional Glycomics (www.functionalglycomics.org).







Always check glycam.org/params for more recent versions and new functionalities.

LEaP configuration file for use of GLYCAM06
with carbohydrates alone or in combination
with the ff14SB force field.
Parameters for oligosaccharides

Structures and charges for glycosyl residues
Structures and charges for some lipid residues

Glycoprotein libraries compatible with ff14SB.

GLYCAM06 force ﬁeld

leaprc.GLYCAM_06j-1

GLYCAM_06j.dat
GLYCAM_06j-1.prep
GLYCAM_lipids_06h.prep
GLYCAM_amino_06j_12SB.lib
GLYCAM_aminoct_06j_12SB.lib
GLYCAM_aminont_06j_12SB.lib







GLYCAM06EP force ﬁeld using lone pairs (extra points)

GLYCAM_06EPb.dat
GLYCAM_06EPb.prep
leaprc.GLYCAM_06EPb

Parameters for oligosaccharides
Structures and charges for glycosyl residues
LEaP configuration file for GLYCAM-06EP

GLYCAM Force Field Parameters Download Page

http://www.glycam.org/params

GLYCAM_06j-1.prep contains prep entries for all carbohydrate residues and GLYCAM_lipids_06h.prep contains
prep entries for some lipid residues (although for lipid membrane simulations we recommend you use the Amber
Lipid 17 force ﬁeld). GLYCAM_06EPb.prep contains prep entries for all carbohydrate residues available for
modeling with extra points.

For linking glycans to proteins, libraries containing modiﬁed amino acid residues (Ser, Thr, Hyp, and Asn) must

be loaded. To build a glycoprotein using ff14SB, GLYCAM_amino_06j_12SB.lib GLYCAM_aminont_06j_12SB.lib

44

Version

Release Date

Contributors

15 Feb., 2014

27 Aug., 2013

BLF

AKN

20 Oct., 2010

MBT, BLF

20 Oct., 2010

3 Feb., 2009

28 May, 2008

MBT

MBT

MBT

3.3. Carbohydrates

Change Summary
Modiﬁed all parameters to be compatible with ff14SB.
These ﬁles may not be compatible with older protein and
nucleic acid force ﬁelds.
Added two new monosaccharides to the prep ﬁle.
*Changed atom type naming to be orthogonal to other
force ﬁelds. Added HO van der Waals parameters. Set
protein-related parameter values to their parm99
counterparts. Updated N-sulfation parameters.
* 1,4-scaling terms added to parameter ﬁle. Angle and
torsion updates for pyranose rings, N-sulfate, phosphate
and sialic acid.
* Corrected a typo in O-Acetyl term
* Updated glycosidic linkage terms to optimize ring
puckering in pyranoses

12 May, 2008

SPK, MBT, ABY Terms for thiol glycosidic linkages

21 Feb., 2008

MBT, ABY

10 Jan., 2008

MBT, ABY

24 Apr., 2005

ABY

* Additional (published) terms for some lipid
simulations[71]
Alkanes, alkenes, amide and amino groups for some
lipid simulations[71]
Sulfates & phosphates for carbohydrates

j

i

h

g

f

e

d

c

b

a

Table 3.3.: Version change summary for the GLYCAM-06 force ﬁeld. *Previously released parameters were
changed. See full release notes at glycam.org/params. SPK: Sameer P. Kawatkar. MBT: Matthew
B. Tessier. ABY: Austin B. Yongye. BLF: B. Lachele Foley. AKN: Anita K. Nivedha

and GLYCAM_aminoct_06j_12SB.lib must be loaded and the desired protein force ﬁeld must also be loaded.
Amino acid libraries designed for linking carbohydrates modeled with extra points are not currently available.

3.3.1. File versioning

Beginning on 15 September, 2011, a new versioning system was implemented for Glycam parameters. Files
produced before that date will not necessarily conform to the new system. In the new system, all ﬁles containing
parameters are versioned. Users should check their contents and replace them with recent versions as appropriate.
The new versioning system employs letters and numbers. If a parameter set contains new functionality (e.g.,
the addition of new parameters) or fundamental changes (e.g., atom type name reassignments), a letter will be
appended to its name. If the new version contains corrections (e.g., for typographical errors), its name will be
appended with a number. See glycam.org/params for more documentation and examples.

Researchers are also encouraged to read the version change documentation available on the GLYCAM Parame-
ters download page under "Documents." In this document, the changes speciﬁc to each version release are detailed.
The changes are also summarized here in Table 3.3.

3.3.2. Atom type name changes

Beginning with versions g, Glycam atom type names will adopt a standard designed to keep them from over-
lapping with other force ﬁelds. In most cases, Glycam’s type names will consist of two characters, one upper-case
followed by one lower-case. Because of this, leaprc ﬁles, lib ﬁles and prep ﬁles from versions prior to g will be
incompatible with current versions.

Note that some type names will not reﬂect the new Glycam type standard, despite being present in the Glycam
force ﬁeld ﬁles, for example in the ﬁles for linking glycans to amino acid residues. In these cases, Glycam will use
the type name appropriate to the external force ﬁeld. Parameters will be introduced only to the extent necessary

45

3. Molecular mechanics force ﬁelds

to provide a link between the force ﬁelds. Since the associated parameters will also include Glycam types, they
should only affect the intersections between the two force ﬁelds.

Beginning with versions j, atom type names for linking to amino acids are compatible with ff14SB. Older

versions of protein and nucleic acid force ﬁelds might not be compatible.

3.3.3. General information regarding parameter development

In GLYCAM-06,[64] the torsion terms have now been entirely developed by ﬁtting to quantum mechanical
data (B3LYP/6-31++G(2d,2p)//HF/6-31G(d)) for small-molecules. This has converted GLYCAM-06 into an addi-
tive force ﬁeld that is extensible to diverse molecular classes including, for example, lipids and glycolipids. The
parameters are self-contained, such that it is not necessary to load any AMBER parameter ﬁles when modeling
carbohydrates or lipids. To maintain orthogonality with AMBER parameters for proteins, notably those involving
the CT atom type, tetrahedral carbon atoms in GLYCAM are called Cg (C-GLYCAM, CG in previous releases).
Thus, GLYCAM and AMBER may be combined for modeling carbohydrate-protein complexes and glycoproteins.
More information on atom type names is available in 3.3.2 . Because the GLYCAM-06 torsion terms were de-
rived by ﬁtting to data for small, often highly symmetric molecules, asymmetric phase shifts were not required
in the parameters. This has the signiﬁcant advantage that it allows one set of torsion terms to be used for both
α- and β -carbohydrate anomers regardless of monosaccharide ring size or conformation. A molecular develop-
ment suite of more than 75 molecules was employed, with a test suite that included carbohydrates and numerous
smaller molecular fragments. The GLYCAM-06 force ﬁeld has been validated against quantum mechanical and
experimental properties, including: gas-phase conformational energies, hydrogen bond energies, and vibrational
frequencies; solution-phase rotamer populations (from NMR data); and solid-phase vibrational frequencies and
crystallographic unit cell dimensions.

3.3.4. Development of partial atomic charges

As in previous versions of GLYCAM, the atomic partial charges were determined using the RESP formalism,
with a weighting factor of 0.01,[64, 72] from a wavefunction computed at the HF/6-31G(d) level. To reduce
artifactual ﬂuctuations in the charges on aliphatic hydrogen atoms, and on the adjacent saturated carbon atoms,
charges on aliphatic hydrogens (types HC, H1, H2, and H3) were set to zero while the partial charges were ﬁt
to the remaining atoms.[73] It should be noted that aliphatic hydrogen atoms typically carry partial charges that
ﬂuctuate around zero when they are included in the RESP ﬁtting, particularly when averaged over conformational
ensembles.[64, 74] In order to account for the effects of charge variation associated with exocyclic bond rotation,
particularly associated with hydroxyl and hydroxylmethyl groups, partial atomic charges for each sugar were
determined by averaging RESP charges obtained from 100 conformations selected evenly from 10-50 ns solvated
MD simulations of the methyl glycoside of each monosaccharide, thus yielding an ensemble averaged charge
set.[64, 74]

3.3.5. Carbohydrate parameters for use with the TIP5P water model

In order to extend GLYCAM to simulations employing the TIP-5P water model, an additional set of carbohydrate
parameters, GLYCAM-06EP, has been derived in which lone pairs (or extra points, EPs) have been incorporated
on the oxygen atoms.[75] The optimal O-EP distance was located by obtaining the best ﬁt to the HF/6-31g(d)
electrostatic potential. In general, the best ﬁt to the quantum potential coincided with a negligible charge on the
oxygen nuclear position. The optimal O-EP distance for an sp3 oxygen atom was found to be 0.70 Å; for an sp2
oxygen atom a shorter length of 0.3 Åwas optimal. When applied to water, this approach to locating the lone pair
positions and assigning the partial charges yielded a model that was essentially indistinguishable from TIP-5P.
Therefore, we believe this model is well suited for use with TIP-5P.[75] The new ﬁles are named 06EP (originally
04EP), as they have been corrected for numerous typographical errors and updated to match current naming and
residue structure conventions.

46

3.3. Carbohydrates

Carbohydrate

Pyranose
α/β , D/L

Furanose
α/β , D/L

Arabinose

Lyxose
Ribose
Xylose
Allose
Altrose
Galactose
Glucose
Gulose
Idose

Mannose
Talose
Fructose
Psicose
Sorbose
Tagatose
Fucose

Quinovose
Rhamnose

Galacturonic Acid
Glucuronic Acid
Iduronic Acid

N-Acetylgalactosamine
N-Acetylglucosamine
N-Acetylmannosamine

Neu5Ac
KDN
KDO

yes
yes
yes
yes
yes
yes
yes
yes
yes
a
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes, b
a,b
a,b

yes
yes
yes
yes

a
a

yes
yes
yes
yes

yes,b
a,b
a,b

Table 3.4.: Current Status of Monosaccharide Availability in GLYCAM. (a) Currently under development. (b) Only

one enantiomer and ring form known.

47

3. Molecular mechanics force ﬁelds

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Carbohydratea
D-Arabinose

D-Lyxose
D-Ribose
D-Xylose
D-Allose
D-Altrose
D-Galactose
D-Glucose
D-Gulose
D-Idose

D-Mannose
D-Talose
D-Fructose
D-Psicose
D-Sorbose
D-Tagatose

D-Fucose (6-deoxy D-galactose)
D-Quinovose (6-deoxy D-glucose)
D-Rhamnose (6-deoxy D-mannose)

D-Galacturonic Acid
D-Glucuronic Acid
D-Iduronic Acid

D-N-Acetylgalactosamine
D-N-Acetylglucosamine
D-N-Acetylmannosamine
N-Acetyl-neuraminic Acid

KDN
KDO

N-Glycolyl-neuraminic Acid

One letter codeb Common Abbreviation

A
D
R
X
N
E
L
G
K
I
M
T
C
P
Bd
J
F
Q
H
Od
Zd
Ud
Vd
Yd
Wd
Sd

KNc,d
KOc,d
SGc,d

Ara
Lyx
Rib
Xyl
All
Alt
Gal
Glc
Gul
Ido
Man
Tal
Fru
Psi
Sor
Tag
Fuc
Qui
Rha
GalA
GlcA
IdoA
GalNac
GlcNAc
ManNAc

NeuNAc, Neu5Ac

KDN
KDO

NeuNGc, Neu5Gc

Table 3.5.: The one-letter codes that form the core of the GLYCAM residue names for monosaccharides aUsers
requiring prep ﬁles for residues not currently available may contact the Woods group (www.glycam.org)
to request generation of structures and ensemble averaged charges. bLowercase letters indicate L-
sugars, thus L-Fucose would be “f”, see Table 3.8 . cLess common residues that cannot be assigned
a single letter code are accommodated at the expense of some information content. dNomenclature
involving these residues will likely change in future releases.[76] Please visit www.glycam.org for the
most updated information.

48

3.3. Carbohydrates

β−D-Xylp
Linkage Position Residue Name Residue Name Residue Name Residue Name

α−D-Arap

α−D-Glcp

β−D-Galp

Terminalb

1-c
2-
3-
4-
6-
2,3-
2,4-
2,6-
3,4-
3,6-
4,6-
2,3,4-
2,3,6-
2,4,6-
3,4,6-
2,3,4,6-

0GAb
1GAc
2GA
3GA
4GA
6GA
ZGAd
YGA
XGA
WGA
VGA
UGA
TGA
SGA
RGA
QGA
PGA

0AA
1AA
2AA
3AA
4AA

ZAA
YAA

WAA

TAA

0XB
1XB
2XB
3XB
4XB

ZXB
YXB

WXB

TXB

0LB
1LB
2LB
3LB
4LB
6LB
ZLB
YLB
XLB
WLB
VLB
ULB
TLB
SLB
RLB
QLB
PLB

Table 3.6.: Speciﬁcation of linkage position and anomeric conﬁguration in D-hexo- and D-pentopyranoses in three-
letter codes based on the GLYCAM one-letter code aIn pyranoses A signiﬁes α-conﬁguration; B = β .
bPreviously called GA, the zero preﬁx indicates that there are no oxygen atoms available for bond
formation, i.e., that the residue is for chain termination. cIntroduced to facilitate the formation of a
1–1´ linkage as in α-D-Glc-1-1´-α-D-Glc {1GA 0GA}. dFor linkages involving more than one position,
it is necessary to avoid employing preﬁx letters that would lead to a three-letter code that was already
employed for amino acids, such as ALA.

Linkage position Residue name Residue name Residue name Residue name

α-D-Glc f

β -D-Man f

α-D-Ara f

β -D-Xyl f

Terminal

1-
2-
3-
···
etc.

0GD
1GD
2GD
3GD
···
etc.

0MU
1MU
2MU
3MU
···
etc.

0AD
1AD
2AD
3AD
···
etc.

0XU
1XU
2XU
3XU
···
etc.

Table 3.7.: Speciﬁcation of linkage position and anomeric conﬁguration in D-hexo- and Dpentofuranoses in three-

letter codes based on the GLYCAM one-letter code. In furanoses D (down) signiﬁes α; U (up) = β .

Linkage position Residue name Residue name Residue name Residue name

α-L-Glcp

β -L-Manp

α-L-Arap

β -L-Xylp

Terminal

1-
2-
3-
···
etc.

0gA
1gA
2gA
3gA
···
etc.

0mB
1mB
2mB
3mB
···
etc.

0aA
1aA
2aA
3aA
···
etc.

0xB
1xB
2xB
3xB
···
etc.

Table 3.8.: Speciﬁcation of linkage position and anomeric conﬁguration in L-hexo- and Lpentofuranoses in three-

letter codes.

49

3. Molecular mechanics force ﬁelds

3.3.6. Carbohydrate Naming Convention in GLYCAM

In order to incorporate carbohydrates in a standardized way into modeling programs, as well as to provide a stan-
dard for X-ray and NMR protein database ﬁles (pdb), we have developed a three-letter code nomenclature. The
restriction to three letters is based on standards imposed on protein data bank (PDB) ﬁles by the RCSB PDB Ad-
visory Committee (www.rcsb.org/pdb/pdbac.html), and for the practical reason that all modeling and experimental
software has been developed to read three-letter codes, primarily for use with protein and nucleic acids.

As a basis for a three-letter PDB code for monosaccharides, we have introduced a one-letter code for monosac-
charides (Table 3.5).[76] Where possible, the letter is taken from the ﬁrst letter of the monosaccharide name.
Given the endless variety in monosaccharide derivatives, the limitation of 26 letters ensures that no one-letter
(or three-letter) code can be all encompassing. We have therefore allocated single letters ﬁrstly to all 5- and 6-
carbon, non-derivatized monosaccharides. Subsequently, letters have been assigned on the order of frequency of
occurrence or biological signiﬁcance.

Using three letters (Tables 3.6 to 3.8), the present GLYCAM residue names encode the following content:
carbohydrate residue name (Glc, Gal, etc.), ring form (pyranosyl or furanosyl), anomeric conﬁguration (α or β ,
enantiomeric form (D or L) and occupied linkage positions (2-, 2,3-, 2,4,6-, etc.). Incorporation of linkage position
is a particularly useful addition, since, unlike amino acids, the linkage cannot otherwise be inferred from the
monosaccharide name. Further, the three-letter codes were chosen to be orthogonal to those currently employed
for amino acids.

3.4. Lipids

Biological processes in the human body are dependent on highly speciﬁc molecular interactions. The vast
majority of the interactions take place in compartments within the cell, and an understanding of the behavior of
the membranes that compartmentalize and enclose the cell is therefore critical for rationalizing these processes.
Biological membranes are complex structures formed mostly by lipids and proteins. For this reason lipid bilay-
ers have received a lot of attention both computationally and experimentally for many years.[77, 78] The vital
role of cell membranes is underlined by the estimation that over half of all proteins interact with membranes, ei-
ther transiently or permanently.[79] Further, G protein-coupled receptors embedded in the membrane account for
50−60% of present day drug targets, and membrane proteins as a whole make up around 70%.[80] Even so, only
685 resolved unique structures of membrane embedded proteins, out of a total of 65 500 searchable entries (after
removing redundant structures), exist in the Protein Data Bank (April 2017) reﬂecting the difﬁculties in studying
membrane-associated proteins experimentally, making them prime targets for simulation.

Prior to 2012, the only force ﬁeld parameters for lipids distributed with AmberTools were part of the Gly-
cam force ﬁeld and were limited in scope.[71] Traditionally, lipid simulations with Amber have either employed
the Charmm parameters, via support for the Charmm force ﬁelds through the Chamber package[81] or through
attempts to adapt the General Amber Force Field (GAFF) with limited success.

In 2012, Amber greatly expanded support for simulation of lipids. This includes the development of a modular
framework for lipid simulations and initial parameterization within the LIPID11 force ﬁeld[82] as well as a careful
reﬁnement of the non-bonded parameters and associated torsion terms within the GAFF force ﬁeld for speciﬁc
application to lipids.[83] The latter, GAFFLipid, was the ﬁrst lipid parameter set based on the Amber force ﬁeld
equation to support simulation of lipid bilayers in the tensionless NPT ensemble while the former, LIPID11, pro-
vided the ﬁrst modular framework for constructing lipid simulations analogous to the Amber amino and nucleic
acid force ﬁelds. Together these developments have made simulation of phospholipids with AMBER substantially
easier. LIPID14 was released in 2014 [84] and represented a major advancement over the previous Amber compat-
ible lipid force ﬁelds for lipid bilayer simulations in the NPT ensemble without the need for an artiﬁcial constant
surface tension term. Validation of the LIPID14 parameters were provided through extensive self-assembly simu-
lations [85, 86]. Inclusion and validation of parameters for cholesterol [87] represented an important addition to
the lipid parameter set, allowing even more complex lipid containing systems to be simulated. LIPID17 is the most
recent release of Amber lipid parameters. It builds upon the modularity of LIPID14 and provides an extension of
modular phospholipid residues to include anionic head groups and polyunsaturated tails. In the process the bonded
alkane parameters have been revised and updated by ﬁtting to quantum energies. Furthermore, new partial charges

50

3.4. Lipids

LIPID17 Residue Name

Description
Lauroyl (12:0)
Myristoyl (14:0)
Palmitoyl (16:0)
Oleoyl (18:1 n-9)
Stearoyl (18:0)

Arachidonoyl (20:4)

Docosahexaenoyl (22:6)

Phosphatidylcholine

Phosphatidylethanolamine

Phosphatidylserine
Phosphatidylglycerol

Phosphaditic acid

Acyl chain

Head group

Other

Cholesterol

Table 3.9.: LIPID17 residue names.

LAL
MY
PA
OL
ST
AR
DHA
PC
PE
PS
PGR
PH-
CHL

have been generated for all the head group residues in order to accommodate the anionic head groups whilst main-
taining consistency in the charge derivation approach. Details regarding the parameterization are given in Skjevik
et al. (####). The modular nature of the force ﬁeld allows for many combinations of lipid head and tail groups as
well as rapid and standardized parameterization of additional lipids. LIPID17 was validated through bilayer sim-
ulations of eighteen different phospholipid types, for a total of 0.6 microseconds each without applying a surface
tension or constant area term. The lipid bilayer structural features compare favorably with experimental measures
such as area per lipid, bilayer thickness, NMR order parameters, scattering data, and lipid lateral diffusion.

In Amber18, packmol-memgen was included into the list of available software, allowing the user to generate

membrane systems in a simple and automated way (12.6).




3.4.1. LIPID17: The Amber lipid force ﬁeld

leaprc.lipid17
lipid17.lib
lipid17.dat

defines atom types and loads the files below
atoms, charges, and topologies for LIPID17 residues
LIPID17 force field parameters




The LIPID17 force ﬁeld represented the logical next step in the development of an Amber lipid force ﬁeld that
build on the modular nature of LIPID11[82] and LIPID 14 [84] to allow for tensionless lipid bilayer simulations in
Amber. LIPID17 (####) has been designed to be fully compatible with the other pairwise-additive protein, nucleic
acid, carbohydrate, and small molecule Amber force ﬁelds.

LIPID17 is a modular force ﬁeld for the simulation of phospholipids and cholesterol. To achieve this modularity

phospholipids are divided into interchangeable head group and tail group "residues."

Currently, there are seven tail group residues and ﬁve head group residues supported, as well as cholesterol, and
LEaP supports any combination of these lipid residues. The supported LIPID17 residues and their residue names
are listed in Table 3.9. LIPID17 can be used alone or in conjunction with other Amber force ﬁelds. The order
with which the various AMBER force ﬁelds are loaded along with LIPID17 should not matter. For example, to
load ff14SB and LIPID17 in LEaP use:

source leaprc.protein.ff14SB
source leaprc.lipid17

LIPID17 PDB format

LIPID17 atom names and types are deﬁned in Skjevik, et al[82], Dickson, et al[84], Madej et al[87] and Skjevik

et al (####).

A properly formatted lipid PDB can be loaded into LEaP. Each phospholipid molecule in LIPID17 is made up
of three residues. Atoms from each residue must be in contiguous blocks and ordered as described below in each

51

3. Molecular mechanics force ﬁelds

Lipid 1

Lipid 2

...

sn-1 tail residue

head group residue

sn-2 tail residue

TER card

sn-1 tail residue

head group residue

sn-2 tail residue

TER card

...

Table 3.10.: LIPID17 PDB format for LEaP

molecule. A TER card must be appended after all the atoms for each molecule. Table 3.10 speciﬁes the residue
format for the PDB ﬁle loaded by LEaP in order to correctly deﬁne linker atoms.

The connectivity (CONECT records) section of the PDB is redundant and should be removed prior to loading
into LEaP. The head group and tail residues are linked together by the LEaP program after loading the lipid PDB
ﬁle.

PDB formatted structure ﬁles with alternative residue and atom names (such as Charmm C36) may be

converted to the LIPID17 naming convention by way of the script called charmmlipid2amber.py which is supplied
with AmberTools to convert Charmm C36 residue and atom names to LIPID17 nomenclature.

charmmlipid2amber.py -i charmm_c36.pdb -o output lipid17.pdb

Additionally, membrane systems can be prepared by means of the packmol-memgen included software (12.6).

3.5. Solvents



leaprc.water.<type> loads solvents.lib and the appropriate frcmod file
library for water, methanol, chloroform, NMA, urea
solvents.lib
frcmod.tip4p
Parameter changes for TIP4P.
Parameter changes for TIP4PEW.
frcmod.tip4pew
Parameter changes for TIP5P.
frcmod.tip5p
Parameter changes for SPC/E.
frcmod.spce
Parameter changes for SPC/Eb.
frcmod.spceb
frcmod.opc
Parameter changes for OPC.
Parameter changes for OPC3.
frcmod.opc3
Parameter changes for POL3.
frcmod.pol3
Parameter changes for the force-balance TIP3P model
frcmod.tip3pfb
frcmod.tip4pfb
Parameter changes for the force-balance TIP4P model

frcmod.meoh
frcmod.chcl3
frcmod.nma
frcmod.urea



Parameters for methanol.
Parameters for chloroform.
Parameters for N-methyacetamide.
Parameters for urea (or urea-water mixtures).





Amber provides direct support for several water models.
There is no default, but TIP3P[88] will be used for residues with names HOH or WAT, following a long tradition.
Despite the fact that many properties of this old water model deviate signiﬁcantly from those of real water, the
model has an impressive track record and is still a popular choice in biomolecular simulations. There is more
than one good reason behind this tenacity other than simple inertia[18]. In particular, many older force ﬁelds
were parametrized in simulations that used TIP3P as the solvent: errors in the solvent part of the total energy are
compensated, to an extent, by ﬁtted parameters of the gas phase (solute) part. As a result, many existing force ﬁelds
are inherently biased towards TIP3P to various degrees. Replacing TIP3P with another water model without re-
parametrizing the underlying gas-phase force ﬁeld may not necessarily lead to better accuracy of the biomolecular

52

3.5. Solvents

simulation that might be expected to beneﬁt from the more accurate water model. Fortunately, AMBER force ﬁelds
are not very strongly biased towards any speciﬁc water model, which makes the task of testing new models easier.
In recent years several new models appeared that describe the state of liquid water much more accurately than
TIP3P, these models showed signiﬁcant improvements in outcomes of many types of biomolecular simulations,
even with older force ﬁelds. A recent addition to AMBER family of protein force ﬁelds, ff99SB[19], was developed
without an inherent bias towards a water model; OPC is recommended for use with this force ﬁeld[19].

If you want to use water models other than TIP3P, execute the following LEaP commands after loading your

leaprc ﬁle:

WAT = PL3 (residues named WAT in pdb file will be POL3)
source leaprc.water.pol3

(The above is obviously for the POL3 model.) The solvents.lib ﬁle contains TIP3P,[88] TIP3P/F,[89] TIP4P,[88,
90] TIP4P/Ew,[91, 92] TIP5P,[93] OPC,[20] OPC3,[94], POL3[95], SPC/E[96], SPC/Eb[29], TIP3PFB[31] and
TIP4PFB[31] models for water; these are called TP3, TPF, TP4, T4E, TP5, OPC, OP3, PL3, SPC, SPC, FB3 and
FB4, respectively. (The SPC/E and SPC/Eb models are both called SPC: you just have to be sure to load the
appropriate frcmod ﬁle.) By default, the residue name in the prmtop ﬁle will be WAT, regardless of which water
model is used.

The “standard” leaprc ﬁles for tip3p, spce, tip4pew and opc also load the Joung/Cheatham monovalent ion
parameters (see below). If you wish to use other parameters, or to deal with divalent or other ions, you will need
to load the appropriate frcmod ﬁles.

Amber has two ﬂexible water models, one for classical dynamics, SPC/Fw[97] (called “SPF”) and one for

path-integral MD, qSPC/Fw[98] (called “SPG”). You would use these in the following manner:

WAT = SPG
loadAmberParams frcmod.qspcfw
set default FlexibleWater on

Then, when you load a PDB ﬁle with residues called WAT, they will get the parameters for qSPC/Fw. (Obviously,
you need to run some version of quantum dynamics if you are using qSPC/Fw water.)

The solvents.lib ﬁle, which is automatically loaded with many leaprc ﬁles, also contains pre-equilibrated boxes
for many of these water models. These are called POL3BOX, QSPCFWBOX, SPCBOX, SPCFWBOX, TIP3PBOX,
TIP3PFBOX, TIP4PBOX, TIP4PEWBOX, OPCBOX, OPC3BOX, and TIP5PBOX. These can be used as argu-
ments to the solvateBox or solvateOct commands in LEaP.

In addition, non-polarizable models for the organic solvents methanol, chloroform and N-methylacetamide are
provided,[99] along with a box for an 8M urea-water mixture. The input ﬁles for a single molecule are in $AMBER-
HOME/dat/leap/prep, and the corresponding frcmod ﬁles are in $AMBERHOME/dat/leap/parm. Pre-equilibrated
boxes are in $AMBERHOME/dat/leap/lib. For example, to solvate a simple peptide in methanol, you could do the
following:



source leaprc.protein.ff14SB (get a standard force field)
loadAmberParams frcmod.meoh (get methanol parameters)
peptide = sequence { ACE VAL NME } (construct a simple peptide)
solvateBox peptide MEOHBOX 12.0 0.8 (solvate the peptide with meoh)
saveAmberParm peptide prmtop prmcrd

quit

Similar commands will work for other solvent models.

3.5.1. The OPC family of water models

OPC is a new non-polarizable, 4-point, 3-charge rigid water model.[20] Geometrically, it resembles TIP4P-like
models, although the values of OPC point charges and charge-charge distances are quite different. The model has
a single VDW center on the oxygen nucleus. The model is constructed based on the concept of optimal point
charge approximation; [100] the central idea of OPC is to distribute the point charges to best reproduce the 3
lowest order multipole moments of water molecule in liquid phase. The optimal values for the dipole µ and the

53





3. Molecular mechanics force ﬁelds

square quadrupole moment QT [101] are determined as best ﬁt values that reproduce key experimental properties
of water in liquid phase. The low dimensionality of the parameter space µ-QT permits a virtually exhaustive
search. The linear quadrupole and the octupole moments[102] are ﬁxed to values obtained from high quality QM
calculations.[101]

A full description of OPC and its properties can be found in Ref.[20]. For 11 key liquid state properties against
which water models are most often benchmarked, OPC is on average within 0.76% of the experiment (relative
error). This accuracy is dramatically better compared to the commonly used rigid models. For example, the
dielectric constant of TIP3P and TIP4PEw is 94 and 63.9 respectively, while OPC predicts it to be 78.4±0.6 (the
experimental value is 78.4). The reported OPC properties were computed using Amber 12 on GPUs with a time-
step of 2 fs, periodic boundary conditions, an 8 angstrom cut-off for nonbonded interactions, and PME for long
range electrostatics. SHAKE was used to constrain hydrogens. The rest of parameters are set to current Amber
defaults; note that these include accounting for the van der Waals interactions beyond the cut-off via a continuum
model (vdwmeth=1).

OPC in biomolecular simulations: Because of the improved accuracy in bulk properties, OPC delivers no-
ticeable accuracy improvement in practical biomolecular simulations, even with existing force-ﬁelds. Speciﬁcally,
OPC was found to yield quantitative agreement with NMR experiment for conformational populations of small
RNA fragments,[56, 103, 104] and therefore is a commonly used water model for RNA simulations. [105–107]
OPC has been shown to improve structural description of DNA dublex,[62] DNA G-quadruplex, [108] thermody-
namics of ligand binding,[109] small molecule hydration,[20] rotational dynamics of proteins, [110] simulations
of lipid monolayer, [111] and intrinsically disordered proteins.[42, 112]

Ion parameters for OPC: Two sets of 12-6 LJ parameters for OPC water model (the 12-6 IOD set and the
12-6 HFE set) for 3 monovalent ions (Na+, K+, Cl-) have been developed by Li, Merz and co-workers; see
Section 3.6 for the deﬁnition and important usage suggestions. Our tests show that the deviation of the Ion-Oxygen
Distances (IODs) predicted using the 12-6 HFE set from the reference IOD values is within ±0.2Å. Comparing
these deviations to those reported for other ion parameter sets available, it seems that the magnitude of the deviation
is borderline acceptable, which means that the HFE set might also work in situations where IOD is formally
recommended. For Na+ the transferability is not an issue as Hydration Free Energy (HFE) and IOD parameters are
essentially the same. In situations where agreement of HFEs with one of the common experimental references is
critical, the use of OPC-speciﬁc parameters (the 12-6 HFE set) for K+, Na+, and Cl- may be advisable. The IOD
parameter set are recommended to be used in the structural reﬁnement. Additional OPC-speciﬁc ion parameters
have been reported recently.[113]

Based on our limited experience, it appears that the Joung/Cheatham ion parameters for TIP4P-EW (jc_tip4pew)[114]

may also be acceptable for OPC water model, especially when accurate reproduction of IODs is critical. One ad-
vantage of using the jc_tip4pew set is that it provides a consistent set of parameters for most biologically relevant
ions, not just K+, Na+, and Cl-. Another advantage at the moment is that the set has already been tested in practice
with OPC model.[56, 109]

OPC3 water model: OPC3 – a 3-point rigid non-polarizable water model – is the latest addition to the fam-
ily, constructed using the same philosophy as OPC. Further details are available in Ref.[94]. Brieﬂy, OPC3 is
signiﬁcantly more accurate than the commonly used water models of same class (TIP3P, SPC/E) in reproducing a
comprehensive set of liquid bulk properties, over a wide range of temperatures. Relative to the 4-point OPC, OPC3
is somewhat less accurate comapred to experiment. Until model-speciﬁc ion parametrs have been developed, we
cautiosly recommend the Joung/Cheatham ion parameters previously developed for TIP3P to be used with OPC3.

3.6. Ions





frcmod.ionsjc_tip3p
frcmod.ionsjc_spce
frcmod.ionsjc_tip4pew

Joung/Cheatham ion parameters for TIP3P water
same, but for SPC/E water
same, but for TIP4P/EW water

frcmod.ions1lm_126_tip3p
frcmod.ions1lm_126_spce
frcmod.ions1lm_126_tip4pew same, but in TIP4P/EW water

Li/Merz ion parameters for +1 and -1 ions in TIP3P water (12-6 normal usage set)
same, but in SPC/E water

54

3.6. Ions

frcmod.ions1lm_iod

Li/Merz ion parameters for +1 and -1 ions (12-6 IOD set)

frcmod.ions234lm_126_tip3p
frcmod.ions234lm_126_spce
frcmod.ions234lm_126_tip4pew
frcmod.ions234lm_hfe_tip3p
frcmod.ions234lm_hfe_spce
frcmod.ions234lm_hfe_tip4pew
frcmod.ions234lm_iod_tip3p
frcmod.ions234lm_iod_spce
frcmod.ions234lm_iod_tip4pew

Li/Merz ion parameters for +2 to +4 ions in TIP3P water (12-6 normal usage set)
same, but in SPC/E water
same, but in TIP4P/EW water
Li/Merz ion parameters for +2 to +4 ions in TIP3P water (12-6 HFE set)
same, but in SPC/E water
same, but in TIP4PEW water
Li/Merz ion parameters for +2 to +4 ions in TIP3P water (12-6 IOD set)
same, but in SPC/E water
same, but in TIP4P/EW water

frcmod.ions1lm_1264_tip3p
frcmod.ions1lm_1264_spce
frcmod.ions1lm_1264_tip4pew same, but in TIP4PEW water

Li/Merz ion parameters for -1 and +1 ions in TIP3P water (12-6-4 set)
same, but in SPC/E water

frcmod.ions234lm_1264_tip3p
frcmod.ions234lm_1264_spce
frcmod.ions234lm_1264_tip4pew same, but in TIP4PEW water

Li/Merz ion parameters for +2 to +4 ions in TIP3P water (12-6-4 set)
same, but in SPC/E water

frcmod.ions1lm_126_hfe_opc
frcmod.ions1lm_126_iod_opc

Li/Merz ion parameters for +1 and -1 ions in OPC water (12-6 HFE set)
Li/Merz ion parameters for +1 and -1 ions in OPC water (12-6 IOD set)



atomic_ions.lib
ions94.lib

topologies for monoatomic ions (new naming scheme)
topologies for ions with the old naming scheme



In 2008, Joung and Cheatham created a consistent set of parameters for alkali halide ions, ﬁtting solvation
free energies, radial distribution functions, ion-water interaction energies and crystal lattice energies and lattice
constants for non-polarizable spherical ions.[114, 115] These have been separately parametrized for each of three
popular water models, as indicated above.

Li, Merz and co-workers subsequently developed ion parameters for the monovalent, divalent, trivalent and

tetravalent ions for the 12-6 LJ nonbonded model and the 12-6-4 LJ-type nonbonded model for PME simulations.[116–
119] The experimental values they tried to reproduce are the experimental Hydration Free Energy (HFE) values,
Ion-Oxygen Distance (IOD) values and Coordination Number (CN) values of the ﬁrst solvation shell. It was found
that it is hard to reproduce the three experimental values simultaneously by using the 12-6 LJ nonbonded model.
Since the charge-induced dipole interaction is proportional to r−4 , a new term with format (C/r)4 was added
to the 12-6 LJ potential, yielding a 12-6-4 LJ-type potential. The new potential with designed parameters could
reproduce the experimental HFE, IOD and CN values at the same time without signiﬁcant compromise. Especially
for the highly charged metal ions, the 12-6-4 LJ-type nonbonded model performs much better than the 12-6 one
overall. Similar to Joung and Cheatam’s work, three water models were treated separately for the parameter design,
as indicated in the name of frcmod ﬁles. Users can check the notes in the frcmod ﬁles to see the reference of each
parameter.

For the 12-6 LJ nonbonded model, three different parameter sets are available for each water model to meet

different requirements:

1. 12-6 normal usage set. This contains the HFE set of the monovalent ions (which could reproduce the ex-
perimental HFE),[119] the Compromise (CM) set of divalent ions (which could reproduce the experimental
relative HFE and CN values),[117] and the IOD set (which could reproduce the experimental IOD) for the
trivalent and tetravalent ions.[118] These parameters are recommended to be used in the normal MD
simulations. This is because for the monovalent ions the error of the 12-6 LJ nonbonded model is pretty
small (a CM set may not be needed since the HFE or IOD sets are pretty close to each other) while for the
trivalent and tetravalent metal ions the 12-6 LJ nonboned model has relatively big errors (a CM set could
have big errors for both HFE and IOD at this moment).

2. 12-6 HFE set to reproduce experimental HFE.[116, 118, 119] The HFE parameter set has limited error for
monovalent ions, while could have remarkable error for highly charged ions. Since we use the HFE set for

55

3. Molecular mechanics force ﬁelds

monovalent ions in the 12-6 normal usage set, we don’t have a speciﬁc HFE set parameter ﬁle for monovalent
ions.

3. 12-6 IOD set to reproduce experimental IOD.[116, 118, 119] Since the ion with certain parameter could re-
produce similar IOD values in the three water models, so the IOD set parameters of three water models were
designed identical (for the monovalent and divalent metal ions, while for the trivalent and tetravalent ions,
the IOD set are estimated for each water model separately). The IOD parameter set are recommended to
be used in the structural reﬁnement or for structural property orientated investigation.

For the 12-6-4 LJ-type nobonded model, only one parameter set (12-6-4 set) designed for each of the three water
models. The 12-6-4 model has also been tested in mixed systems (such as nucleic acids, proteins and ionic solu-
tions) and have shown excellent transferability.[117–119] In the recent work of Panteva et al., the 12-6-4 model was
shown to give greaty improved structural, thermodynamic, kinetic and mass transport properties for Mg2+in water
relative to the 12-6 model..[120] The 12-6-4 model with the SPC/E water model performed exceptionally well for
simulating all properties in these benchmark calculations.[120] The parameters which are speciﬁcally designed for
the divalent metal ions with 12-6-4 LJ-type nonbonded model are shown as the 12-6-4 set above. These frcmod ﬁles
can be used to generate an original prmtop ﬁle. After obtaining the original prmtop ﬁle, you can use the add12_6_4
command in parmed to generate a prmtop with the additionalC4 terms with the ﬂag LENNARD_JONES_CCOEF. Please
see the add12_6_4 command14.2.2.6 in Subsection14.2.2 in the manual for detailed information. After obtaining
the prmtop with the additional C4 term, you can use sander or pmemd to run the simulation. Recently Penteva et
al. ﬁne-tuned the C4 terms between several divalent metal ions (Mg2+, Mn2+, Zn2+, and Cd2+ ) and nucleic acid
systems[121] while keep theC4 terms between metal ions and water desgined by Li and Merz.[117] The new pa-
rameter set could better balance the interaction types in the nucleic acid systems, and been shown to be predictive in
identifying metal ion binding sites in nucleic acids[122], and are recommended to use in related modeling. An re-
lated tutorial is shown in the following webpage: "http://ambermd.org/tutorials/advanced/tutorial20/12_6_4.htm".

3.7. Modiﬁed amino acids and nucleotides

Parameters for phosphorylated amino acids [50, 123] to be used for ff99SB and older forceﬁelds can be

obtained with the following command in LEaP:

source leaprc.phosaa10

Updated parameters have been developed for newer versions of the Stony Brook (SB) family of forceﬁelds, with
new forceﬁeld parameters for the side chains of phosphorylated amino acids [124], in addition to modiﬁed amino
acids [125] that are commonly used in experimental studies such as FRET and EPR. These side-chain parameters
are optimized for use with ff14SB and ff19SB by ﬁtting against relative QM energies at the MP2/6-311+G**
level using our inhouse torsion ﬁtting protocol[126]. Currently, side-chain parameters for phosphorylated serine,
histidine (deprotonated, protonated), tyrosine, and threonine are provided. For ff14SB, parameters for
phosphorylated amino acids [124] can be obtained with the following command in LEaP:

source leaprc.phosaa14SB

For ff19SB, parameters for phosphorylated amino acids [124] can be obtained with the following command in
LEaP:

source leaprc.phosaa19SB

The modiﬁed amino acids selenomethionine, cyano-phenylalanine, and azido-phenylalanine are used as FRET
quenchers. We also added parameters for the nitroxide spin-label methanesulfonothioate (MTSL), which is often
used in EPR experiments to probe distances. We also added parameters for acetylated lysine. For
selenomethionine, we ﬁt new LJ parameters for selenium, as well as bond, angle, and dihedral parameters for the
C-Se bond. To use these parameters for ff14SB, the user can run the following command in LEaP:

source leaprc.protein.ff14SB_modAA

56

To use these parameters for ff19SB, the user can run the following command in LEaP:

source leaprc.protein.ff19SB_modAA

3.8. Force ﬁelds related to semi-empirical QM

The ff19SB_modAA leaprc will load lib and frcmod ﬁles that have the CX to XC atom type conversion, the
backbone phi/psi dihedrals will be zeroed, and the LEU CMAP will be applied to all ﬁve residues.

The residue names for these modiﬁed amino acids are MSE (selenomethionine), AZF (azido-phenylalanine),
CYF (cyano-phenylalanine), CNX (MTSL) and ALY (acetylated-lysine). These residue names should match those
in the loaded ﬁle with the coordinates (e.g. PDB ﬁle). The residue names can also be used with the sequence
command in LEaP to create XYZ coordinates. Since the modiﬁcations for the phosphorylated and modiﬁed amino
acids are on the side chains and not the backbone, users can use these modiﬁcations with ff19SB.

Many post-translational modiﬁcations are also available at http://selene.princeton.edu/FFPTM/. Parameters for
common modiﬁcations for RNA nucleotides [54]can by loaded with “source leaprc.modrna08”. Pointers to
other sets of Amber-compatible force ﬁelds may be found at the Amber web site, http://ambermd.org/.

Additional parameters for six common ﬂuorescent protein chromophores–eGFP, eBFP, eYFP, eCFP, DsRed, and
mCherry–are available[127] by sourcing leaprc.xFPchromophores after sourcing the main force ﬁeld leaprc ﬁle
(e.g. leaprc.protein.ff14SB). This will allow seamless loading of PDB ﬁles containing ﬂuorescent proteins provided
they follow standard naming of the chromophore: eGFP=CRO, eBFP=IIC, eYFP=CR2, eCFP=CRF, DsRed=
CRQ, and mCherry=CH6. The chromophore parameters are based on parm10 with the ff14SB modiﬁcations,
but also borrow heavily from GAFF. Both uppercase and lowercase atom types are utilized, so users should take
caution if mixing ff14SB with GAFF. See original reference[127] for details of implementation.

3.8. Force ﬁelds related to semi-empirical QM

ParmAM1 and parmPM3 are classical force ﬁeld parameter sets that reproduce the geometry of proteins mini-
mized at the semi-empirical AM1 or PM3 level, respectively.[128] These new force ﬁelds provide an inexpensive,
yet reliable, method to arrive at geometries that are more consistent with a semi-empirical treatment of protein
structure. These force ﬁelds are meant only to reproduce AM1 and PM3 geometries (warts and all) and were
not tested for use in other instances (e.g., in classical MD simulations, etc.) Since the minimization of a pro-
tein structure at the semi-empirical level can become cost-prohibitive, a “preminimization” with an appropriately
parametrized classical treatment will facilitate future analysis using AM1 or PM3 Hamiltonians.

3.9. The GAL17 force ﬁeld for water over platinum

leaprc.music
music.lib
music.dat

Adds atom types and loads music.lib and music.dat
Library for metal surface atoms, virtual sites, and Drude rod particles.
Parameters for metal surface, Drude rod particles and LJ terms with water.

The GAL17 force ﬁeld[129] was developed as part of the MuSiC project (Multiscale Simulations in Catalysis)
to describe the interaction of water and a Pt(111) surface. The GAL17 force ﬁeld is implemented in the sander
It provides a signiﬁcant improvement over previously
program and can be combined with any water model.
existing force ﬁelds for Pt(111)/water interactions.
Its well-balanced performance suggests that it is an ideal
candidate to generate relevant geometries for the metal/water interface, paving a way to a representative sampling
of the equilibrium distribution at the interface and to predict solvation free energies at the solid/liquid interface. At
present only parameters for water over Pt(111) are available, however, the force ﬁeld is extensible to other metal
surface and solutes such as alcohols or sugar molecules that are typical substrates in catalytic upgrading of biomass
extracts. The GAL17 force ﬁeld consists of

• A Lennard-Jones term between Pt atoms and water oxygen atoms that describes physisorption of water at

the surface.

• A polarized Gaussian term between Pt surface atoms and water oxygen atoms that describes chemisorption

at Pt top sites.

57







3. Molecular mechanics force ﬁelds

• Two terms that describe the angular dependence of the water/Pt surface interaction energy.

The GAL17 force ﬁeld thus does not include explicit terms to describe image charge interactions, that is electro-
static interactions between charged particles and a metallic conductor, explicitly. Instead these effects are included
implicitly. In addition, it has been shown that image charge interactions account for less than 10% of the interac-
tion energy for water adsorbed at a Pt(111) surface[130]. Although not employed in GAL17, the music force ﬁeld
library does contain parameters for a symmetric Drude rod model[130] that can be employed to investigate image
charge effects.

In GAL17 the platinum surface atoms have atom name Pt and residue name MET. The platinum surface must
be perpendicular to one of the Cartesian coordinate axes. Water molecules must be above the surface (coordinate
values larger than the metal atoms). Given a properly formatted pdb ﬁle that contains a platinum metal surface
and water molecules, one would use the GAL17 force ﬁeld with TIP3P water in the following manner:

source leaprc.music
source leaprc.water.tip3p
ptwat = loadpdb ptwat.pdb
saveAmberParm ptwat prmtop inpcrd

This will load the correct LJ parameters between platinum and water oxygen atoms. In addition, one needs to
activate the Gaussian and angle adsorption correction terms via the &music namelist. This namelist also provides
an option to deﬁne the orientation of the surface plane. All force ﬁeld parameters can be controlled via this
namelist, advanced users may want to look into the source code ﬁle music_module.F90 for all available options.
At present there are no good parameters for platinum metal and simulations must therefore constrain the position
of the platinum atoms. This can be conveniently achieved with belly dynamics. A typical input would thus
contain

&cntrl

...
ibelly = 1,
bellymask = ’@O,H1,H2’

/
&music

! constrain atom positions
! let water molecules move

pt_plane = ’yz’

! default is ’xy’, i.e. surface in xy plane

/

When running simulations with sander in parallel, it may be advisable to orient the metal surface in the yz plane to
achieve better load balancing with the algorithm that is used by sander to distribute work across MPI tasks. Tests
that may serve as examples how to build input ﬁles and run simulations with GAL17 are contained in directory
$AMBERHOME/test/sander_music/.




3.10. Fluorescent dyes: AMBER-DYES in AMBER force ﬁeld ﬁles

leaprc.amberdyes
amberdyes.lib
amberdyes.dat

defines atom types and loads the files below
atoms, charges, and topologies for dye and linker residues
AMBER-DYES in AMBER force field parameters

The AMBER-DYES force ﬁeld parameters[131] were modiﬁed and implemented into the AMBER Software
Suite[132]. The modiﬁcations were performed for all Cystein-ending linkers to ﬁx an issue [133] existing in the
original dye parameters[131]. The chirality of the Cystein-ending linkers is in R-conﬁguration, but can be easily
changed via the “ﬂip” command in cpptraj. Fluorescence ligands, so-called dyes, are widely used to investigate
protein structures and dynamics, such as conformational changes, folding, association and dissociation of com-
plexes, and enzymatic cycles. Dyes are usable with multi-protein and single-protein systems. MD simulations
with explicit dyes can improve the interpretation of experimental results. Especially in Forster Resonance En-
ergy Transfer (FRET) experiments, it is of utmost importance to obtain precise information about the position and
orientation of the dyes.

58




3.10. Fluorescent dyes: AMBER-DYES in AMBER force ﬁeld ﬁles

At the moment AMBER-DYES in AMBER covers 22 commonly used dyes and 6 linkers (see table below):

Dye

Residue name Linker residue

Dye

Residue name Linker residue

Alexa Fluor 350
Alexa Fluor 488
Alexa Fluor 532
Alexa Fluor 568
Alexa Fluor 594
Alexa Fluor 647
Lumiprope Cy3

Lumiprope Sulfo-Cy3

Lumiprope Cy5

Lumiprope Sulfo-Cy5

Lumiprope Cy5.5
Lumiprope Cy7
Lumiprope Cy7.5

A35
A48
A53
A56
A59
A64
C3N
C3W
C5N
C5W
C55
C7N
C75

C1R, L1R

B1R, C1R, L1R

C1R, L1R
C1R, L1R
C1R, L1R

B1R, C2R, L1R

C2R, L1R

C2R, L1R

C2R, L1R

L1R

L1R

L1R
L1R

ATTO 390
ATTO 425
ATTO 465
ATTO 488
ATTO 495
ATTO 514
ATTO 520
ATTO 610

ATTO Thio12

T39
T42
T46
T48
T49
T51
T52
T61
Tth

C2R, L1R
C2R, L1R
C2R, L1R
C3R, L2R
C2R, L1R
C3R, L2R
C2R, L1R
C2R, L1R
C3R. L2R

Table 3.11.: AMBER-DYES in AMBER residue names.

To attach a linker / dye combination to your structure, hand-edit your PDB ﬁle, similarly to 3.2.3, and choose

an attachment point (e.g. residue 3):

ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM

16 ND2 ASN E 2
17 N
ILE E 3
18 CA ILE E 3
ILE E 3
19 C
20 O
ILE E 3
21 CB ILE E 3
22 CG1 ILE E 3
23 CG2 ILE E 3
24 CD1 ILE E 3
PHE E 4
25 N

3.872
5.739
4.144
5.305
5.662
4.933
5.138
3.449
6.522
4.507

30.857
34.298
36.258
36.089
37.000
36.389
37.899
36.064
38.291
35.854

39.020
36.056
39.575
40.541
41.282
35.001
35.089
35.230
34.603
38.224

1.00 13.86
1.00 14.08
7.14
1.00
1.00
9.18
1.00 12.86
1.00 13.23
1.00 11.53
1.00 12.95
1.00 11.29
1.00 11.91

N
N
C
C
O
C
C
C
C
N

Change the residue name (ILE) of the CA atom to the linker residue name (e.g. C1R) and delete the rest of the
residue:

ATOM
ATOM
ATOM

16 ND2 ASN E 2
18 CA C1R E 3
25 N
PHE E 4

3.872
4.144
4.507

30.857
36.258
35.854

39.020
39.575
38.224

1.00 13.86
1.00
7.14
1.00 11.91

Append your PDF ﬁle with the C99 atom of your dye (e.g. Alexa Fluor 488) after the TER card:

ATOM
TER
ATOM

ASN E 163
1317 N
1318
ASN E 163
1319 C99 A48 E 164

19.398 31.025

41.679

1.00 38.17

N
C
N

N

Use LEaP to load the AMBER-DYES in AMBER force ﬁeld (at best by sourcinv leaprc.amberdyes, load your
updated PDB ﬁle, set a bond between the dye (always atom C99) and linker (always atom N99), and relax the
structure:

source leaprc.amberdyes
pdb = loadpdb 148l.pdb
bond pdb.A48.C99 pdb.C1R.N99
select pdb.A48
select pdb.C1R
relax pdb
saveAmberParm pdb prmtop inpcrd

59

3. Molecular mechanics force ﬁelds

Additional settings are subject to personal preference. LEaP will produce a structure with a bonded dye usable for
MD simulations. Do, however, check the generated structure for sanity before using it.

3.11. Coarse-grained and multiscale simulations using the SIRAH force

ﬁeld

In the following section, we brieﬂy introduce the Coarse-Grained (CG) force ﬁeld named SIRAH, which has
been completely ported to Amber and is compatible with multiscale simulations. SIRAH is a residue-based top-
down force ﬁeld developed to reproduce structural properties of biomolecules, granting a speed up of above 2
orders of magnitude in comparison to all-atom simulations, with a reasonable compromise on accuracy.[134] Cur-
rently, it includes parameters for DNA,[135] phospholipids,[136] and proteins (including the most frequent post-
translational modiﬁcations.[137] Most recently, metal ions to be used as cofactors have been incorporated.[138]
Notably, SIRAH uses its own water model for explicit solvent called WatFour (WT4 for shortness), which also
includes monovalent electrolytes (Na+, K+, and Cl-).[139] Four interconnected beads mimicking an elementary
water cluster constitute the WT4 water model. Since each bead carries a partial charge, WT4 creates its dielectric
permittivity, while the use of explicit electrolytes allows setting the ionic strength in the solution.

SIRAH uses the standard two-body classical Hamiltonian implemented in most common MD packages, and in
particular in Amber. Hence, common concepts as partial charges, atom types, and equilibrium distances/angles can
be straightforwardly transferred from atomistic to CG simulations. In this way, simulations performed with SIRAH
can fully proﬁt from GPU acceleration and analysis programs included in common MD packages. Mapping from
fully atomistic structures uses the position of real atoms to place interacting beads. Therefore, equilibrium values
in the bonded terms of the Hamiltonian are directly extracted from experimental or canonical structures, reducing
free parameters and facilitating the backmapping from CG to all-atoms.[140] Because of this, conformational
preferences (i.e., helical, extended beta or coil conformations in proteins, and the B-form in DNA) are introduced
in the bonded part of the Hamiltonian, obviating topological biases or the need to impose elastic network models
to ﬁx secondary structures.

Since CG beads carry a partial charge, electrostatic interactions are calculated at long range via the Particle

Mesh Ewald method.

Perhaps the main difference with a fully atomistic force ﬁeld regards the use of parameters for the calculation of
the Lennard-Jones potential. Although most of the interactions are calculated in the standard way, some of them
are not calculated using normal combination rules but set to speciﬁc values between pairs of beads. This provides
a ﬂexible and convenient option to ﬁx interactions that only apply to certain pairs of beads without modifying the
entire force ﬁeld. In particular, this feature is used in SIRAH to ﬁne-tune the balance between electrostatic and
Lennard-Jones interactions.

3.11.1. Available simulation schemes

Currently, the following CG and multiscale simulation schemes are available in SIRAH:

1. Explicit solvent CG simulations: they may include complex systems (Protein, DNA, Membranes, water, and

ions)[134, 136, 139]

2. Implicit solvent CG simulations: Currently available only for DNA using generalized Born model with

igb=1.[135, 141]

3. Multiscale simulations: These can be performed in three fashions:

a) - Multiscale solvation: ﬁne grain (FG, or fully atomistic) solute solvated with atomistic water + CG
water + supra CG water. This scheme is particularly well suited for highly solvated systems as virus
capsids[142] and is transferable to different force ﬁelds. Indeed, the WT4 water model has been tested
to work in combination with TIP3P, SPC and SPC/e water models.[143]

b) - Dual scale DNA simulations: this scheme can deal with single or double-stranded DNA in which
a certain number of nucleotides are deﬁned at the atomistic level, while the rest is treated at the CG

60

3.11. Coarse-grained and multiscale simulations using the SIRAH force ﬁeld

level. Simulations can be performed in explicit or implicit solvent (see point 2). SIRAH parameters
have been developed to work with the bsc0 FG force ﬁeld,[144, 145] and successfully checked for
compatibility with the newer bsc1 version.

c) - QM/(FG/CG) simulations: this scheme proﬁts from the possibility to run QM/MM simulations in
AMBER. The current implementation has been only tested in a Russian-doll fashion with a quantum
region surrounded by FG nucleotides nested in a CG double helix.[146]

3.11.2. Preparing your system for a CG simulation

In a nutshell, SIRAH is provided simply as another force ﬁeld, plus a set of tools. In principle, all you need to
get started is previous knowledge on how to run an MD simulation with AMBER and a fully protonated structure.
Schematically, you can set up a CG simulation in three very simple steps.

1. Create a symbolic link in your working directory to ensure you will ﬁnd the required ﬁles:

ln -s $AMBERHOME/dat/SIRAH/ .

2. Map the FG structure to CG. In its simplest form just type

./SIRAH/tools/CGCONV/cgconv.pl -i your_protonated_FG_file.pdb -o your_CG_file.pdb

This will return a CG PDB ﬁle with standard mapping options. All options are shown typing:

./SIRAH/tools/CGCONV/cgconv.pl -h

3. In your Leap ﬁle you will have to:

AddPath SIRAH
source leaprc.sirah



For instance, a typical Leap ﬁle for the protein 1CRN would look like:

# Load SIRAH force field

addPath ./sirah.amber
source leaprc.sirah

# Load model

protein = loadpdb 1CRN_cg.pdb

# Info on system charge

charge protein

# Set S-S bridges

bond protein.3.BSG protein.40.BSG
bond protein.4.BSG protein.32.BSG
bond protein.16.BSG protein.26.BSG

# Add solvent, counterions and 0.15M NaCl
# Tuned solute-solvent closeness for best hydration

solvateOct
protein WT4BOX 20 0.7
addIonsRand protein NaW 22 ClW 22

# Save Parms

# EXIT quit



saveAmberParmNetcdf protein 1CRN_cg.prmtop 1CRN_cg.ncrst





Notice that three disulﬁde bonds are created. For this to work, the Cysteine names in your PDB ﬁle must be
edited from their thiol name (see comment on residue naming below).

Thereafter it is just normal Amber stuff!

Step-by-step tutorials on different cases of interest can be found in $AMBERHOME/dat/SIRAH/tutorial/. In
particular, using input ﬁles and initialization protocols contained therein is strongly suggested. Note that the version
included in this release corresponds to the version SIRAH 2.1. We recommend users to check and download the
latest updates from www.sirahff.com.

61

3. Molecular mechanics force ﬁelds

3.11.3. Tips and tricks.

Answers to frequently asked questions can be found at $AMBERHOME/dat/SIRAH/tutorial/SIRAH_FAQs.pdf.

1. The FG to CG mapping in SIRAH is intended to preserve physicochemically important interaction points
(for example, Watson-Crick interactions in DNA). Therefore, the positions of Hydrogen atoms are needed
in some residues, for instance, in Serine. Because of this, the starting point for CG simulation is a properly
protonated PDB ﬁle. Amber naming is fully supported.

2. An important point to keep in mind is that the use of a 12-6 term for the Lennard-Jones interaction in
a generally ﬂatten CG surface may be potentially troublesome. Large steric repulsions in the absence of
topological restraints could produce spurious structural distortions particularly sensitive to steric clashes.
Hence, it is always a good idea (although not strictly necessary) to start with a well-relaxed set of starting
coordinates.

3. Although appealing, the coarse-graining philosophy based on keeping important interaction points has the
negative feature that a simple recipe for arbitrary molecular moieties does not exist, and new functional
groups must be tested case by case.

4. Solvation may be a potential source of problems. SIRAH uses Leap tools solvateBox or solvateOct to solvate
CG solutes. However, the relatively large size of a CG water molecule may create vacuum holes nearby the
solute that can lead to strong (unscreened) electrostatic interactions in the solute’s surface. Similarly, when
adding electrolytes, the use of addIons or addIonsRand, which substitute one water molecule by one ion,
might be problematic if the ionic positions lie very close to the solute’s surface. Most likely, these problems
will be ﬁxed during the initialization protocol described in the tutorials. However, as in any simulation, the
user should carefully check the initial set up.

5. In proteins, residues are named with lower "s" and the one-letter-code for amino acids (i.e., Alanine is sA). A
third letter may indicate a residue modiﬁcation. For instance, sE or sD stands for a Glutamate or Aspartate,
respectively, while sEh or sDh correspond to protonated versions of those amino acids. Besides standard
amino acids, the following modiﬁcations are available.

a) sX: Cysteine in S-S bond
b) sCp: Palmitoylated cysteine.
c) sEh, sDh: protonated acidic residues
d) sHe, sHd: Histidine protonated in epsilon and delta positions
e) sSp, sTp, sYp: phosphorylated aminoacids.
f) sKa, sKm: Acetylated and methylated Lysine, respectively.

6. Zwitterionic and non-zwitterionic terminals are available. However, unlike the protein force ﬁelds included
in AMBER, ACE and NME residues do not exist in SIRAH. Zwitterionic terminals are the default option
but neutral terminals can be set by renaming the corresponding residues from s[one-letter-code] to a[one-
letter-code] (Nt-acetylated) or m[one-letter-code] (Ct-amidated) after mapping. For example, to set a neutral
N-terminal Histidine protonated at Nε rename it from “sHe” to “aHe”.

7. Analysis: The Tcl script sirah_vmdtk.tcl provided in $AMBERHOME/dat/SIRAH/tools/ contains a series
of analysis and visualization tools to be used in VMD including backmapping, calculation of secondary
structures. Additionally, it provides visualization macros to obtain the right connectivity, sizes, etc.[140]

3.12. Obsolete force ﬁeld ﬁles

The following ﬁles are included for historical interest. We do not recommend that these be used any more for
molecular simulations. The leaprc ﬁles that load these ﬁles have been moved to $AMBERHOME/dat/leap/cmd/oldff.

62









3.12. Obsolete force ﬁeld ﬁles



3.12.1. The Weiner et al. (1984,1986) force ﬁelds

all.in
allct.in
allnt.in
uni.in
unict.in
unint.in
parm91X.dat



All atom database input.
All atom database input, COO- Amino acids.
All atom database input, NH3+ Amino acids.
United atom database input.
United atom database input, COO- Amino acids.
United atom database input, NH3+ Amino acids.
Parameters for 1984, 1986 force fields.

The ff86 parameters are described in early papers from the Kollman and Case groups.[147, 148] [The “parm91”
designation is somewhat unfortunate: this ﬁle is really only a corrected version of the parameters described in
the 1984 and 1986 papers listed above.] These parameters are not generally recommended any more, but may
still be useful for vacuum simulations of nucleic acids and proteins using a distance-dependent dielectric, or for
comparisons to earlier work. The material in parm91X.dat is the parameter set distributed with Amber 4.0. The
STUB nonbonded set has been copied from parmuni.dat; these sets of parameters are appropriate for united atom
calculations using the “larger” carbon radii referred to in the “note added in proof” of the 1984 JACS paper. If
these values are used for a united atom calculation, the parameter scnb must be deﬁned in the prmtop ﬁle and
should be set to 8.0; for all-atom calculations it should be 2.0. The scee parameter should be deﬁned in the prmtop
ﬁle and set to 2.0 for both united atom and all-atom variants. Note that the default value for scee is now 1.2 (the
value for 1994 and later force ﬁelds); this must be explicitly deﬁned in the prmtop ﬁle when using the earlier force
ﬁelds.

parm91X.dat is not recommended. However, for historical completeness a number of terms in the non-bonded
list of parm91X.dat should be noted. The non-bonded terms for I (iodine), CU (copper) and MG (magnesium) have
not been carefully calibrated, but are given as approximate values. In the STUB set of non-bonded parameters, we
have included parameters for a large hydrated monovalent cation (IP) that represent work by Singh et al.[149] on
large hydrated counterions for DNA. Similar values are included for a hydrated anion (IM).

The non-bonded potentials for hydrogen-bond pairs in ff86 use a Lennard-Jones 10-12 potential. If you want to

run sander with ff86 then you will need to recompile, adding -DHAS_10_12 to the Fortran preprocessor ﬂags.



3.12.2. The Cornell et al. (1994) force ﬁeld

all_nuc94.in
all_amino94.in
all_aminoct94.in
all_aminont94.in
nacl.in
parm94.dat
parm96.dat
parm98.dat



Nucleic acid input for building database.
Amino acid input for building database.
COO- amino acid input for database.
NH3+ amino acid input for database.
Ion file.
1994 force field file.
Modified version of 1994 force field, for proteins.
Modified version of 1994 force field, for nucleic acids.

Contained in ff94 are parameters from the so-called “second generation” force ﬁeld developed in the Kollman
group in the early 1990s.[30] These parameters are especially derived for solvated systems, and when used with an
appropriate 1-4 electrostatic scale factor, have been shown to perform well at modeling many organic molecules.
The parameters in parm94.dat omit the hydrogen bonding terms of earlier force ﬁelds. This is an all-atom force
ﬁeld; no united-atom counterpart is provided. 1-4 electrostatic interactions are scaled by 1.2 instead of the value
of 2.0 that had been used in earlier force ﬁelds.

Charges were derived using Hartree-Fock theory with the 6-31G* basis set, because this exaggerates the dipole
moment of most residues by 10-20%. It thus “builds in” the amount of polarization which would be expected in
aqueous solution. This is necessary for carrying out condensed phase simulations with an effective two-body force
ﬁeld which does not include explicit polarization. The charge-ﬁtting procedure is described in Ref [30].

The ff96 force ﬁeld [150] differs from parm94.dat in that the torsions for φ and ψ have been modiﬁed in
response to ab initio calculations [151] which showed that the energy difference between conformations were
quite different than calculated by Cornell et al. (using parm94.dat). To create parm96.dat, common V1 and V2

63

3. Molecular mechanics force ﬁelds

parameters were used for φ and ψ, which were empirically adjusted to reproduce the energy difference between
extended and constrained alpha helical energies for the alanine tetrapeptide. This led to a signiﬁcant improvement
between molecular mechanical and quantum mechanical relative energies for the remaining members of the set of
tetrapeptides studied by Beachy et al. Users should be aware that parm96.dat has not been as extensively used
as parm94.dat, and that it almost certainly has its own biases and idiosyncrasies, including strong bias favoring
extended β conformations.[22, 152, 153]

The ff98 force ﬁeld [154] differs from parm94.dat in torsion angle parameters involving the glycosidic torsion

in nucleic acids. These serve to improve the predicted helical repeat and sugar pucker proﬁles.

3.12.3. The Wang et al. (1999) force ﬁeld

Basic force field parameters
topologies and charges for amino acids

parm99.dat
all_amino94.in
all_amino94nt.in
all_amino94ct.in
topologies and charges for nucleic acids
all_nuc94.in
Force field for general organic molecules
gaff.dat
topologies for modified nucleosides
all_modrna08.lib
all_modrna08.frcmod parameters for modified nucleosides

same, for N-terminal amino acids
same, for C-terminal amino acids



The ff99 force ﬁeld [155] points toward a common force ﬁeld for proteins for “general” organic and bio-organic
systems. The atom types are mostly those of Cornell et al. (see below), but changes have been made in many
torsional parameters. The topology and coordinate ﬁles for the small molecule test cases used in the development
of this force ﬁeld are in the parm99_lib subdirectory. The ff99 force ﬁeld uses these parameters, along with the
topologies and charges from the Cornell et al. force ﬁeld, to create an all-atom nonpolarizable force ﬁeld for
proteins and nucleic acids.

There are more than 99 naturally occurring modiﬁcations in RNA. Amber force ﬁeld parameters for all these
modiﬁcations have been developed to be consistent with ff94 and ff99.[54] The modular nature of RNA was taken
into consideration in computing the atom-centered partial charges for these modiﬁed nucleosides, based on the
charging model for the “normal” nucleotides.[156] All the ab initio calculations were done at the Hartree-Fock
level of theory with 6-31G(d) basis sets, using the GAUSSIAN suite of programs. The computed electrostatic
potential (ESP) was ﬁt using RESP charge ﬁtting in antechamber. Three-letter codes for all of the ﬁtted nucleosides
were developed to standardize the naming of the modiﬁed nucleosides in PDB ﬁles. For a detailed description of
charge ﬁtting for these nucleosides and an outline for the three letter codes, please refer to Ref. [54].

The AMBER force ﬁeld parameters for 99 modiﬁed nucleosides are distributed in the form of library ﬁles. The
all_modrna08.lib ﬁle contains coordinates, connectivity, and charges, and all_modrna08.frcmod contains infor-
mation about bond lengths, angles, dihedrals and others. The AMBER force ﬁeld parameters for the 99 modiﬁed
nucleosides in RNA are also maintained at the modiﬁed RNA database at http://ozone3.chem.wayne.edu.





3.12.4. The 2002 polarizable force ﬁelds

frcmod.ff02pol.r1
parm99.dat

parm99EP.dat

frcmod.ff02pol.r1
all_nuc02.in

all_amino02.in
all_aminoct02.in
all_aminont02.in
all_nuc02EP.in

Recommended initialization file
Force field, for amino acids and some organic molecules;
can be used with either additive or
non-additive treatment of electrostatics.
Like parm99.dat, but with "extra-points": off-center
atomic charges, somewhat like lone-pairs.
Updated torsion parameters for ff02.
Nucleic acid input for building database, for a non-
additive (polarizable) force field without extra points.
Amino acid input ...
COO- amino acid input ...
NH3+ amino acid input ....
Nucleic acid input for building database, for a non-

64







all_amino02EP.in
all_aminoct02EP.in
all_aminont02EP.in



additive (polarizable) force field with extra points.
Amino acid input ...
COO- amino acid input ...
NH3+ amino acid input ....



3.12. Obsolete force ﬁeld ﬁles

The ff02 force ﬁeld is a polarizable variant of ff99. (See Ref. [157] for a recent overview of polarizable force
ﬁelds.) Here, the charges were determined at the B3LYP/cc-pVTZ//HF/6-31G* level, and hence are more like “gas-
phase” charges. During charge ﬁtting the correction for intramolecular self polarization has been included.[99]
Bond polarization arising from interactions with a condensed phase environment are achieved through polarizable
dipoles attached to the atoms. These are determined from isotropic atomic polarizabilities assigned to each atom,
taken from experimental work of Applequist. The dipoles can either be determined at each step through an iterative
scheme, or can be treated as additional dynamical variables, and propagated through dynamics along with the
atomic positions, in a manner analogous to Car-Parinello dynamics. Derivation of the polarizable force ﬁeld
required only minor changes in dihedral terms and a few modiﬁcation of the van der Waals parameters.

Subsequently, a set up updated torsion parameters has been developed for the ff02 polarizable force ﬁeld.[158]

These are available in the frcmod.ff02pol.r1 ﬁle.

The user also has a choice to use the polarizable force ﬁeld with extra points on which additional point charges
are located; this is called ff02EP. The additional points are located on electron donating atoms (e.g. O,N,S), which
mimic the presence of electron lone pairs.[159] For nucleic acids we chose to use extra interacting points only on
nucleic acid bases and not on sugars or phosphate groups.

There is not (yet) a full published description of this, but a good deal of preliminary work on small molecules
is available.[99, 160] Beyond small molecules, our initial tests have focused on small proteins and double helical
oligonucleotides, in additive TIP3P water solution. Such a simulation model, (using a polarizable solute in a non-
polarizable solvent) gains some of the advantages of polarization at only a small extra cost, compared to a standard
force ﬁeld model. In particular, the polarizable force ﬁeld appears better suited to reproduce intermolecular inter-
actions and directionality of H-bonding in biological systems than the additive force ﬁeld. Initial tests show ff02EP
behaves slightly better than ff02, but it is not yet clear how signiﬁcant or widespread these differences will be.

3.12.5. Older ion parameters

In the past, for alkali ions with TIP3P waters, Amber has provided the values of Aqvist,[161] adjusted for
Amber’s nonbonded atom pair combining rules to give the same ion-OW potentials as in the original (which were
designed for SPC water); these values reproduce the ﬁrst peak of the radial distribution for ion-OW and the relative
free energies of solvation in water of the various ions. Note that these values would have to be changed if a
water model other than TIP3P were to be used. Rather arbitrarily, Amber also included chloride parameters from
Dang.[162] These are now known not to work all that well with the Aqvist cation parameters, particularly for the
K/Cl pair. Speciﬁcally, at concentrations above 200 mM, KCl will spontaneously crystallize; this is also seen with
NaCl at concentrations above 1 M.[163] These “older” parameters are now collected in frcmod.ionsff99_tip3p, but
are not recommended except to reproduce older simulations.

65

4. The Generalized Born/Surface Area Model

Implicit solvent methods can speed up atomistic simulations by approximating the discrete solvent as a contin-
uum, thus drastically reducing the number of particles in the system. An additional effective speedup often comes
from much faster sampling of the conformational space afforded by these methods.[164–168] The generalized
Born (GB) solvation model is the most commonly used implicit solvent model for atomistic MD simulation; it has
been most widely tested on ff99SB and ff14SBonlysc, but in principle could be used with other non-polarizable
force ﬁelds, such as ff03. A recent (2019) review gives a good overview.[169] To estimate the total solvation
free energy of a molecule, ∆Gsolv, one typically assumes that it can be decomposed into the "electrostatic" and
"non-electrostatic" parts:

∆Gsolv = ∆Gel + ∆Gnonel

(4.1)
where ∆Gnonel is the free energy of solvating a molecule from which all charges have been removed (i.e. partial
charges of every atom are set to zero), and ∆Gel is the free energy of ﬁrst removing all charges in the vacuum,
and then adding them back in the presence of a continuum solvent environment. Generally speaking, ∆Gnonel
comes from the combined effect of two types of interaction: the favorable van der Waals attraction between the
solute and solvent molecules, and the unfavorable cost of breaking the structure of the solvent (water) around the
solute. In the current Amber codes, this is taken to be proportional to the total solvent accessible surface area (SA)
of the molecule, with a proportionality constant derived from experimental solvation energies of small non-polar
molecules, and uses a fast LCPO algorithm [170] to compute an analytical approximation to the solvent accessible
area of the molecule.

The Poisson-Boltzmann approach described in the next section has traditionally been used in calculating ∆Gel.
However, in molecular dynamics applications, the associated computational costs are often very high, as the
Poisson-Boltzmann equation needs to be solved every time the conformation of the molecule changes. Amber
developers have pursued an alternative approach, the analytic generalized Born (GB) method, to obtain a rea-
sonable, computationally efﬁcient estimate to be used in molecular dynamics simulations. The methodology has
become popular,[171–178] especially in molecular dynamics applications,[179–182] due to its relative simplicity
and computational efﬁciency, compared to the more standard numerical solution of the Poisson-Boltzmann equa-
tion. Within Amber GB models, each atom in a molecule is represented as a sphere of radius Ri with a charge qi
at its center; the interior of the atom is assumed to be ﬁlled uniformly with a material of dielectric constant 1. The
molecule is surrounded by a solvent of a high dielectric ε (80 for water at 300 K). The GB model approximates
∆Gel by an analytical formula,[171, 183]

∆Gel ≈ −1

2 ∑

i j

qiq j

fGB(ri j,Ri,R j)

(cid:18)
1− exp[−κ fGB]

(cid:19)

ε

where ri j is the distance between atoms i and j, the Ri are the so-called effective Born radii, and fGB() is a certain
smooth function of its arguments. The electrostatic screening effects of (monovalent) salt are incorporated [183]
via the Debye-Huckel screening parameter κ.

A common choice [171] of fGB is

fGB =(cid:2)r2

i j/4RiR j)(cid:3)1/2

(4.3)
although other expressions have been tried.[174, 184] The effective Born radius of an atom reﬂects the degree of its
burial inside the molecule: for an isolated ion, it is equal to its van der Waals (VDW) radius ρi. Then one obtains
the particularly simple form:

i j + RiR j exp(−r2

(4.2)

67

4. The Generalized Born/Surface Area Model

∆Gel = − q2
i
2ρi

(cid:19)

(cid:18)
1− 1
ε

(4.4)

where we assumed κ = 0 (pure water). This is the famous expression due to Born for the solvation energy of
a single ion. The function fGB() is designed to interpolate, in a clever manner, between the limit ri j → 0, when
atomic spheres merge into one, and the opposite extreme ri j → ∞, when the ions can be treated as point charges
obeying the Coulomb’s law.[177] For deeply buried atoms, the effective radii are large, Ri (cid:29) ρi, and for such atoms
one can use a rough estimate Ri ≈ Li, where Li is the distance from the atom to the molecular surface. Closer to
the surface, the effective radii become smaller, and for a completely solvent exposed side-chain one can expect Ri
to approach ρi.

The effective radii depend on the molecule’s conformation, and so have to be re-computed every time the confor-
mation changes. This makes the computational efﬁciency a critical issue, and various approximations are normally
made that facilitate an effective estimate of Ri. With the exception of GBNSR6 (see Section 5.1), the so-called
Coulomb ﬁeld approximation, or CFA, is used for Amber GB models, which replaces the true electric displacement
around the atom by the Coulomb ﬁeld. Within this assumption, the following expression can be derived:[177]

(cid:90)

R−1
i = ρ−1

i − 1
4π

θ (|r|− ρi)r−4d3r

(4.5)

where the integral is over the solute volume surrounding atom i. For a realistic molecule, the solute boundary
(molecular surface) is anything but trivial, and so further approximations are made to obtain a closed-form ana-
lytical expression for the above equation, e.g. the so-called pairwise de-screening approach of Hawkins, Cramer
and Truhlar,[185] which leads to a GB model implemented in Amber with igb=1. The 3D integral used in the
estimation of the effective radii is performed over the van der Waals (VDW) spheres of solute atoms, which im-
plies a deﬁnition of the solute volume in terms of a set of spheres, rather than the complex molecular surface,[186]
commonly used in the PB calculations. For macromolecules, this approach tends to underestimate the effective
radii for buried atoms,[177] arguably because the standard integration procedure treats the small vacuum–ﬁlled
crevices between the van der Waals (VDW) spheres of protein atoms as being ﬁlled with water, even for struc-
tures with large interior.[184] This error is expected to be greatest for deeply buried atoms characterized by large
effective radii, while for the surface atoms it is largely canceled by the opposing error arising from the Coulomb
approximation, which tends [172, 176, 187] to overestimate Ri.

The deﬁciency of the model described above can, to some extent, be corrected by noticing that even the opti-
mal packing of hard spheres, which is a reasonable assumption for biomolecules, still occupies only about three
quarters of the space, and so "scaling-up" of the integral by a factor of four thirds should effectively increase the
underestimated radii by about the right amount, without any loss of computational efﬁciency. This idea was devel-
oped and applied in the context of pH titration,[177] where it was shown to improve the performance of the GB
approximation in calculating pKa values of protein sidechains. However, the one-parameter correction introduced
in Ref. [177] was not optimal in keeping the model’s established performance on small molecules. It was therefore
proposed [182] to re-scale the effective radii with the re-scaling parameters being proportional to the degree of the
atom’s burial, as quantiﬁed by the value Ii of the 3D integral. The latter is large for the deeply buried atoms and
small for exposed ones. Consequently, one seeks a well-behaved re-scaling function, such that Ri ≈ (ρ−1
i − Ii)−1
for small Ii, and Ri > (ρ−1
i −Ii)−1 when Ii becomes large. The following simple, inﬁnitely differentiable re-scaling
function was chosen to replace the model’s original expression for the effective radii:

R−1
i = ˜ρ−1

i − ρ−1

i

tanh(αΨ− βΨ2 + γΨ3)

(4.6)
where Ψ = Ii ˜ρi, and α, β , γ are treated as adjustable dimensionless parameters which were optimized using the
guidelines mentioned earlier (primarily agreement with the PB). Currently, Amber supports two GB models (
termed OBC ) based on this idea. These differ by the values of α, β , γ, and are invoked by setting igb to either
igb=2 or igb=5. The details of the optimization procedure and the performance of the OBC model relative to the
PB treatment and in MD simulations on proteins is described in Ref. [182]; an independent comparison to the PB
in calculating the electrostatic part of solvation free energy on a large data set of proteins can be found in Ref.
[188].

Our experience with generalized Born simulations is mainly with ff99SB, ff14SBonlysc or ff03; the current GB

68

1

2

5

7

8

mbondi mbondi2 mbondi2

bondi mbondi3

4.1. GB/SA input parameters

Table 4.1.: Recommended radii sets for various GB models. For values of igb given in the top row, the string in the

second row should be entered in LEaP as “set default PBRadii xxx”.

models are not compatible with polarizable force ﬁelds. Replacing explicit water with a GB model is equivalent to
specifying a different force ﬁeld, and users should be aware that none of the GB options (in Amber or elsewhere)
is as mature as simulations with explicit solvent; user discretion is advised. For example, it was shown that
salt bridges are too strong in some of these models [189, 190] and some of them provide secondary structure
distributions that differ signiﬁcantly from those obtained using the same protein parameters in explicit solvent,
with GB having too much α-helix present.[191, 192] The combination of the ff14SBonlysc force ﬁeld with igb=8
gives the best results for proteins [25][193], nucleic acids and protein-nucleic acid complexes. [194]

Despite these limitations, implicit treatment of solvent is widely used in molecular simulations for two main
reasons: algorithmic/computational speed and conformational sampling. [168, 195] Implicit solvent methods can
be algorithmically/computationally faster, as measured by simulation time steps per processor (CPU) time, because
the vast number of individual interactions between the atoms of individual solvent molecules do not need to be
explicitly computed. Implicit-solvent simulations can also sample conformational space faster in the low viscosity
regime afforded by the implicit solvent model.[164–168] To some extent, the interest in implicit-solvent-based
simulations is motivated by the need to sample very large conformational spaces for problems such as protein
folding, binding-afﬁnity calculations, or large-scale ﬂuctuations of nucleosomal DNA fragments. The speedup of
conformational change can vary considerably, depending on the details of the transition, and can range from no
speedup at all to almost a 100-fold speedup. [168] In general, the larger the conformational change, the higher the
speedup one may expect, but this tendency is not universal or uniform. These speedup values are also expected to
vary by the speciﬁc ﬂavour of GB model used, a detailed analysis for igb5 can be found in Ref. [168].

The generalized Born models used here are based on the "pairwise" model introduced by Hawkins, Cramer and
Truhlar,[185, 196] which in turn is based on earlier ideas by Still and others.[171, 176, 187, 197] The so-called
overlap parameters for most models are taken from the Tinker molecular modeling package (http://tinker.wustl.edu).
The effects of added monovalent salt are included at a level that approximates the solutions of the linearized
Poisson-Boltzmann equation.[183] The original implementation was by David Case, who thanks Charlie Brooks
for inspiration. Details of our implementation of generalized Born models can be found in Refs. [198, 199].

4.1. GB/SA input parameters

As outlined above, there are several "ﬂavors" of GB available, depending upon the value of igb. The version
that has been most extensively tested corresponds to igb=1; the "OBC" models (igb=2 and 5) are newer, but ap-
pear to give signiﬁcant improvements and are recommended for most projects (certainly for peptides or proteins).
The newest, most advanced, and least extensively tested model, GBn (igb=7), yields results in considerably better
agreement with molecular surface Poisson-Boltzmann and explicit solvent results than the "OBC" models under
many circumstances.[192] The GBn model was parameterized for peptide and protein systems and is not rec-
ommended for use with nucleic acids. A modiﬁcation on the GBn model (igb=8) further improves agreement
between Poisson-Boltzmann and explicit solvent data compared to the original formulation (igb=7).[25] Users
should understand that all (current) GB models have limitations and should proceed with caution. Generalized
Born simulations can only be run for non-periodic systems, i.e. where ntb=0. Unlike its use in explicit solvent
PME simulations, short nonbonded cutoff values have much stronger impact on accuracy of the GB calculations.
Essentially, any cutoff values other than cut > structure size can lead to artifacts. Current GPU implementation of
the GB can not use cutoffs. An alternative that retains most of the speed of the GB with a cutoff, but without most
of its artifacts, is GB-HCP described in Section 39.5. If the nonbonded cutoff is used in GB calculations, it should
be greater than that for PME calculations, perhaps cut=16. The slowly-varying forces generally do not have to be
evaluated at every step for GB, either nrespa=2 or 4, although that option may lead to some artifacts as well.

igb

= 0 No generalized Born term is used. (Default)

69

4. The Generalized Born/Surface Area Model

= 1 The Hawkins, Cramer, Truhlar[185, 196] pairwise generalized Born model is used, with param-
eters described by Tsui and Case.[198] This model uses the default radii set up by LEaP. It is
slightly different from the GB model that was included in Amber6. If you want to compare to
Amber 6, or need to continue an ongoing simulation, you should use the command "set default
PBradii amber6" in LEaP, and set igb=1 in sander. For reference, the Amber6 values are those
used by an earlier Tsui and Case paper.[180] Note that most nucleic acid simulations have used
this model, so you take care when using other values. Also note that Tsui and Case used an
offset (see below) of 0.13 Å, which is different from its default value.

= 2 Use a modiﬁed GB model developed by A. Onufriev, D. Bashford and D.A. Case; the main
idea was published earlier,[177] but the actual implementation here[182] is an elaboration of
this initial idea. Within this model, the effective Born radii are re-scaled to account for the
interstitial spaces between atom spheres missed by the GBHCT approximation. In that sense,
GBOBC is intended to be a closer approximation to true molecular volume, albeit in an average
sense. With igb=2, the inverse of the effective Born radius is given
by:cedure
i = ρ−1
R−1
where ρi = ρi − o f f set, and Ψ = Iρi, with I given in our earlier paper. The parameters α,
β , and γ were determined by empirical ﬁts, and have the values 0.8, 0.0, and 2.909125. This
corresponds to model I in Ref [182]. With this option, you should use the LEaP command "set
default PBradii mbondi2" to prepare the prmtop ﬁle.

i − tanh(cid:0)αΨ− βΨ2 + γΨ3(cid:1) /ρi

= 3 or 4 These values are unused; they were used in Amber 7 for parameter sets that are no longer

supported.

= 5 Same as igb=2, except that now α,β ,γ are 1.0, 0.8, and 4.85. This corresponds to model II
in Ref [182]. With this option, you should use the command "set default PBradii mbondi2"
in setting up the prmtop ﬁle, although "set default PBradii bondi" is also OK. When tested in
MD simulations of several proteins,[182] both of the above parameterizations of the "OBC"
model showed equal performance, although further tests [188] on an extensive set of protein
structures revealed that the igb=5 variant agrees better with the Poisson-Boltzmann treatment
in calculating the electrostatic part of the solvation free energy.

= 6 With this option, there is no continuum solvent model used at all; this corresponds to a non-
periodic, "vacuum", model where the non-bonded interactions are just Lennard-Jones and
Coulomb interactions.

= 7 The GBn model described by Mongan, Simmerling, McCammon, Case and Onufriev[200] is
employed. This model uses a pairwise correction term to GBHCT to approximate a molecular
surface dielectric boundary; that is to eliminate interstitial regions of high dielectric smaller
than a solvent molecule. This correction affects all atoms and is geometry-speciﬁc, going be-
yond the geometry-free, "average" re-scaling approach of GBOBC, which mostly affects buried
atoms. With this method, you should use the bondi radii set. The overlap or screening pa-
rameters in the prmtop ﬁle are ignored, and the model-speciﬁc GBn optimized values are sub-
stituted. The model carries little additional computational overhead relative to the other GB
models described above.[200] This method is not recommended fcedureor systems involving
nucleic acids.

= 8 Same GB functional form as the GBn model (igb=7), but with different parameters. The offset,
overlap screening parameters, and gbneckscale are changed. In addition, individual α , β , and
γ parameters can be speciﬁed for each of the elements H, C, N, O, S, P. Parameters for other
elements have not been optimized, and the default values used are the ones from igb=5, which
were not element-dependent. Default values were optimized for H, C, N, O and S atoms in
protein systems.[25] Although the parameters for P in proteins can be speciﬁed, the default
values were not optimized and are the igb=5 values. Nucleic acids have separate parameters

70

from those used for proteins, and default values were optimized for H, C, N, O and P atoms in
nucleic acid systems.[194]
The following are the default parameters sander uses with igb=8:

4.1. GB/SA input parameters

Sh=1.425952, Sc=1.058554, Sn=0.733599,
So=1.061039, Ss=-0.703469, Sp=0.5,
offset=0.195141, gbneckscale=0.826836,
gbalphaH=0.788440, gbbetaH=0.798699, gbgammaH=0.437334,
gbalphaC=0.733756, gbbetaC=0.506378, gbgammaC=0.205844,
gbalphaN=0.503364, gbbetaN=0.316828, gbgammaN=0.192915,
gbalphaOS=0.867814, gbbetaOS=0.876635, gbgammaOS=0.387882,
gbalphaP=1.0, gbbetaP=0.8, gbgammaP=4.85
screen_hnu=1.69654, screen_cnu=1.26890,
screen_nnu=1.425974, screen_onu=0.18401, screen_pnu=1.54506,
gb_alpha_hnu=0.53705, gb_beta_hnu=0.36286, gb_gamma_hnu=0.11670,
gb_alpha_cnu=0.33167, gb_beta_cnu=0.19684, gb_gamma_cnu=0.09342,
gb_alpha_nnu=0.68631, gb_beta_nnu=0.46319, gb_gamma_nnu=0.13872,
gb_alpha_onu=0.60634, gb_beta_onu=0.46301, gb_gamma_onu=0.14226,
gb_alpha_pnu=0.41836, gb_beta_pnu=0.29005, gb_gamma_pnu=0.10642

Parameters for proteins and for nucleic acids were optimized separately and can be indepen-
dently speciﬁed. Protein parameters: Sh, Sc, Sn, So, Ss and Sp are scaling parameters, gbal-
phaX, gbbetaX, gbgammaX are the α , β , γ set for element X. gbalphaOS, gbbetaOS, gbgam-
maOS is the α , β , γ set applied to both O and S. The phosphorus parameters (in proteins)
were not optimized and are simply taken as the parameters used in the OBC-2 model (igb=5).
Nucleic acid parameters (end with "nu"): screen_Xnu (X=h, c, n, o, p) are scaling parameters,
gb_alpha_Xnu (X=h, c, n, o, p) are the α , β , γ set for element X.
Since parameters are assigned for each atom based on its residue name (hard-coded in "sander/egb.F90"
(subroutine isnucat)), users need to update the residue table in the sander source code if nucleic
acids with different names are simulated using this GB model.
The default values for offset=0.195141, gbneckscale=0.826836 are recommended for both pro-
teins and nucleic acids.
mbondi3 radii are recommended with igb=8 and can be employed with the LEaP command
"set default PBradii mbondi3". The mbondi3 radii were adjusted based on protein simulations,
and optimization of these radii for nucleic acids is currently underway.

=10 Calculate the reaction ﬁeld and nonbonded interactions using a numerical Poisson-Boltzmann
solver. This option is described in the Chapter 6. Note that this is not a generalized Born
simulation, in spite of its use of igb; it is rather an alternative continuum solvent model.

intdiel

Sets the interior dielectric constant of the molecule of interest. Default is 1.0. Other values have not
been extensively tested.

extdiel

Sets the exterior or solvent dielectric constant. Default is 78.5.

saltcon

rgbmax

Sets the concentration (M) of 1-1 mobile counterions in solution, using a modiﬁed generalized Born
theory based on the Debye-Hückel limiting law for ion screening of interactions.[183] Default is 0.0
M (i.e. no Debye-Hückel screening.) Setting saltcon to a nonzero value does result in some increase
in computation time.

This parameter controls the maximum distance between atom pairs that will be considered in car-
rying out the pairwise summation involved in calculating the effective Born radii. Atoms whose
associated spheres are farther way than rgbmax from given atom will not contribute to that atom’s
effective Born radius. This is implemented in a "smooth" fashion (thanks mainly to W.A. Svrcek-
Seiler), so that when part of an atom’s atomic sphere lies inside rgbmax cutoff, that part contributes

71

4. The Generalized Born/Surface Area Model

to the low-dielectric region that determines the effective Born radius. The default is 25 Å, which is
usually plenty for single-domain proteins of a few hundred residues. Even smaller values (of 10-15
Å) are reasonable, changing the functional form of the generalized Born theory a little bit, in ex-
change for a considerable speed-up in efﬁciency, and without introducing the usual cut-off artifacts
such as drifts in the total energy.
The rgbmax parameter affects only the effective Born radii (and the derivatives of these values with
respect to atomic coordinates). The cut parameter, on the other hand, determines the maximum
distance for the electrostatic, van der Waals and "off-diagonal" terms of the generalized Born inter-
action. The value of rgbmax might be either greater or smaller than that of cut: these two parameters
are independent of each other. However, values of cut that are too small are more likely to lead to
artifacts than are small values of rgbmax; therefore one typically sets rgbmax <= cut.

rbornstat If rbornstat = 1, the statistics of the effective Born radii for each atom of the molecule throughout

the molecular dynamics simulation are reported in the output ﬁle. Default is 0.

offset

gbsa

surften

rdt

The dielectric radii for generalized Born calculations are decreased by a uniform value "offset" to
give the "intrinsic radii" used to obtain effective Born radii. Default is 0.09 Å.

Option to carry out GB/SA (generalized Born/surface area) simulations. For the default value of 0,
surface area will not be computed and will not be included in the solvation term. If gbsa = 1, surface
area will be computed using the LCPO model.[170] If gbsa = 2, surface area will be computed by
recursively approximating a sphere around an atom, starting from an icosahedra. Note that no forces
are generated in this case, hence, gbsa = 2 only works for a single point energy calculation and is
mainly intended for energy decomposition in the realm of MM-GBSA. If gbsa = 3, surface area will
be computed using a fast pairwise approximation [201] suitable for GPU computing in pmemd.cuda
program; the acceleration in pmemd.cuda compared with gbsa = 2 is ~30 times faster [201]. Note
that gbsa = 3 is currently not supported in sander, MM-GBSA, QM/MM or libsff. Although gbsa =
3 is supported in pmemd, the general usage is not recommended as the speed gain is trivial, given that
the algorithm was particularly designed for fast approximation of surface area in GPU-accelerated
GB simulations. Therefore, we recommend users to use gbsa=3 with pmemd.cuda.

Surface tension used to calculate the nonpolar contribution to the free energy of solvation (when
gbsa = 1), as Enp = surften*SA. The default is 0.005 kcal/mol/A2.[202] For gbsa = 3, suften works
comparably with gbsa = 1 given the same value. [201]

This parameter is only used for GB simulations with LES (Locally Enhanced Sampling). In GB+LES
simulations, non-LES atoms require multiple effective Born radii due to alternate descreening effects
of different LES copies. When the multiple radii for a non-LES atom differ by less than RDT, only
a single radius will be used for that atom. See Chapter 29 for more details. Default is 0.0 Å.

4.2. ALPB (Analytical Linearized Poisson-Boltzmann)

Like the GB model, the ALPB approximation [203, 204] can be used to replace the need for explicit solvent,
with similar beneﬁts (such as enhanced conformational sampling) and caveats. The basic ALPB equation that
approximates the electrostatic part of the solvation free energy is

∆Gel ≈ ∆Gal pb = −1
2

− 1
εex

εin

(cid:18) 1

(cid:19) 1
1 + αβ ∑

i j

(cid:18) 1

qiq j

+

αβ
A

fGB

(cid:19)

(4.7)

where β = εin/εex is the ratio of the internal and external dielectrics, α=0.571412, and A is the so-called effective
electrostatic size of the molecule, see the deﬁnition of Arad below. Here fGB is the same smooth function as in the
GB model. The GB approximation is then just the special case of the ALPB when the solvent dielectric is inﬁnite;
however, for ﬁnite values of solvent dielectric the ALPB tends to be more accurate. For aqueous solvation, the
accuracy advantage offered by the ALPB is still noticeable, and becomes more pronounced for less polar solvents.

72

4.2. ALPB (Analytical Linearized Poisson-Boltzmann)

Statistically signiﬁcant tests on macromolecular structures [204] have shown that ALPB is more likely to be a
better approximation to PB than the GB. At the same time, the ALPB has virtually no additional computational
overhead relative to GB. However, users should realize that at this point the new model has not yet been tested
nearly as extensively as the canonocal GB model. The ALPB can potentially replace the GB in the energy analysis
of snapshots via the MM-GB/SA scheme. The electrostatic screening effects of monovalent salt are currently
introduced into the ALPB in the same manner as in the GB, and are determined by the parameter saltcon .

alpb

arad

Flag for using ALPB to handle electrostatic interactions within the implicit solvent model.
= 0 No ALPB (default).
= 1 ALPB is turned on. Requires that one of the analytical GB models is also used to compute the
effective Born radii, that is one must set igb=1,2,5, or 7. The ALPB uses the same sets of radii
as required by the particular GB model.

Effective electrostatic size (radius) of the molecule. Characterizes its over-all dimensions and global
shape, and is not to be confused with the effective Born radius of an atom. An appropriate value
of Arad must be set if alpb=1:
this can be conveniently estimated for your input structure with
the utility elsize that comes with the main distribution. The default is 15 Å. While Arad may change
during the course of a simulation, these changes are usually not very large; the accuracy of the ALPB
is found to be rather insensitive to these variations. In the current version of Amber Arad is treated
as constant throughout the simulation, the validity of this assumption is discussed in Ref. [204].
Currently, the effective electrostatic size is only deﬁned for "single-connected" molecules. However,
the ALPB model can still be used to treat the important case of complex formation. In the docked
state, the compound is considered as one, with its electrostatic size well deﬁned. When the ligand
and receptor become inﬁnitely separated, each can be assigned its own value of Arad.

4.2.1. elsize

NAME

elsize - Given the structure, estimates its effective electrostatic size

(parameter Arad ) need by the ALPB model.

SYNOPSIS

Usage: elsize input-pqr-file [-options]
-det an estimate based on structural invariants. DEFAULT.
-ell an estimate via elliptic integral (numerical).
-elf same as above, but via elementary functions.
-abc prints semi-axes of the effective ellipsoid.
-tab prints all of the above into a table without header.
-hea prints same table as -tab but with a header.
-deb prints same as -tab with some debugging information.
-xyz uses a file containing only XYZ coordinates.

DESCRIPTION

elsize is a program originally written by G. Sigalov to estimate the effective electrostatic size of a structure via a
quick, analytical method. The algorithm is presented in detail in Ref. .[204] You will need your structure in a pqr
format as input, which can be easily obtained from the prmtop and inpcrd ﬁles using ambpdb utility described
above:

ambpdb -p prmtop -pqr -c inpcrd > input-file-pqr

After that you can simply do: elsize input-ﬁle-pqr , the value of electrostatic size in Angstroms will be output on
stdout. The source code is in the src/etc/ directory, its comments contain more extensive description of the options
and give an outline of the algorithm. A somewhat less accurate estimate uses just the XYZ coordinates of the
molecule and assumes the default radius size of for all atoms:

73

4. The Generalized Born/Surface Area Model

elsize input-file-xyz

This option is not recommended for very small compounds. The code should not be used on structures made up
of two or more completely disjoint" compounds – while the code will still produce a ﬁnite value of Arad , it is not
very meaningful. Instead, one should obtain estimates for each compound separately.

74

5. GBNSR6

GBNSR6 is an implementation of the Generalized Born (GB) model in which the effective Born radii are com-

puted numerically, via the so-called “R6” integration[205, 206] over molecular surface of the solute:

(cid:18)

(cid:73)

R−1
i =

− 1
4π

r− ri
|r−ri|6 · dS

∂V

(cid:19)1/3

(5.1)

For most structures, GB solvation based on the numerical R6 radii are virtually as accurate[200] as the GB energies
based on the “gold standard” perfect effective radii, which can in principle be obtained from numerical solution
of the PB equation[184]. As a result, the numerical R6 formulation is generally more accurate than the fast
analytical approaches described above. In contrast to most GB practical models, GBNSR6 model is parameter-
free in the same sense as the numerical PB framework is. Thus, accuracy of GBNSR6 relative to the PB standard
is virtually unaffected by the choice of input atomic radii. However, unlike the analytical GB models in AMBER,
GBNSR6 can not yet be used in dynamics. Recent benchmarks show that electrostatic binding energies computed
by GBNSR6 are in good agreement with the numerical PB reference[207, 208].

Within GBNSR6, any of the following three versions of the pairwise GB equation can be used for computation of
the solvation energies: (1) the canonical (Still 1990) GB[171], (2) the canonical GB with the ALPB correction[203,
204], and (3) the charge hydration asymmetric generalized Born (CHAGB) model[209]. The models are listed
below; the ﬁrst two are described in more detail in the GB section of the main manual, a brief introduction into
CHAGB is below. For more information about these models please refer to the original references.

5.1. GB equations available in gbnsr6

• Canonical GB: the original equation due to Still et al, Eqs.4.2, 4.3.

• ALPB: an inexpensive correction, Eq. 4.7, to Still’s equation that restores correct dependence on dielectric
constants. The correction is recommended in all cases except small molecules with decidedly non-spherical
topology (e.g., rings) or structures that are topologically not singly-connected, e.g., two molecules not in
contact with each other. The electrostatic size is computed automatically, no need to specify it in GBNSR6.

• CHAGB: The effect of charge hydration asymmetry (CHA)[102] – non-invariance of solvation free energy
upon solute charge inversion – is incorporated into the Generalized Born framework[209]. The CHA is
added to the GB equation (with or without the ALPB correction) to emulate asymmetric response to solvated
charge of the speciﬁed explicit water model, e.g. TIP3P; the asymmetric response, which can be very
strong, is ultimately determined by the charge distribution within the water model. Note that in contrast to
standard GB or PB, CHAGB employs a novel deﬁnition of the dielectric boundary that does not subsume
the CHA effects into the intrinsic atomic radii, therefore a special input radii set is used with this model.
This model has so far been tested on a diverse set of neutral small molecules, charged and uncharged amino
acid analogs and small proteins. Noticeable accuracy improvement over the uncorrected GB was reported
for individual solvation energies. The optimum radii set for CHAGB available in this implementation shows
better transferability between different classes of molecules. However, the model has not been tested in the
context of protein-ligand binding, which may require a different radii set for optimum performance.

5.2. Numerical implementation of the R6 integral

• The R6 integral for computing the effective Born radius, Eq. 5.1, is performed for each atom over grid-based
molecular surface of the solute. The molecular surface is based on the ﬁeld-view method[210] also used in

75

5. GBNSR6

the PBSA tool. A uniform Cartesian grid is utilized to discretize a rectangular box containing the molecular
structure. By exploiting the conservation of “electric ﬂux” through the surface, the resulting ﬁnite difference
grid surface elements traverse the same solid angle as the spherical surface elements obtained from the Lee
and Richards molecular surface. More details of this implementation can be found in Ref.[210].

5.3. Usage

Just like other GB models available in AMBER, GBNSR6 can be used for efﬁcient estimates of solvation free
energy in situation where numerical PB estimates are too expensive. In addition to the value of the total solvation
free energy, ∆G,its pairwise decomposition ∆Gi j can be obtained without signiﬁcant additional computational
expense typically associated with such estimates within the PB formalism. Options to output components of the
non-polar solvation energy are available as well.

5.3.1. Input ﬁles

gbnsr6 has a similar usage as amber/sander:
gbnsr6 -i mdin -o mdout -p prmtop -c inpcrd

mdin input control data for the computations.

mdout output of the program in a user readable state info and diagnostics. “-o stdout” will send the output to the

terminal.

prmtop input molecular topology ﬁle.

inpcrd input initial coordinate ﬁle.

5.3.2. Basic input options

The input ﬁle is very similar to the Amber/sander format. There are two namelist &cntrl and &gb . The only
ﬂag available in &cntrl is inp, the rest of the ﬂags are in the namelist &gb. The following is a description of the
available ﬂags:

B

alpb

epsin

epsout

istrng

Rs

Speciﬁes the value of uniform offset [200] to the (inverse) effective radii, the default value is 0.028
Å−1 which gives better agreement with the PB model, regardless of the structure size. For best
agreement with the explicit solvent (TIP3P) solvation energies, optimal value of B depends on the
structure size: for small molecules (number of atoms less than 50), we recommend B=0. With -chagb
option, B is calculated automatically based on the solute size.

Speciﬁes if ALBP correction is to be used.
= 0 Canonical GB is used.
= 1 ALPB is used (default)

Sets the dielectric constant of the solute region, default is 1.0. The solute region is deﬁned to be the
solvent excluded volume.

Sets the implicit solvent dielectric constant for the solvent, the default value is 78.5.

Sets the ionic strength (in mM) for the GB equation. Default is 0 mM. Physiological monovalent
salt would correspond to 145 mM. Note the unit is different from that (in M) used by the other
generalized Born methods implemented in Amber.

Sets the value of the dielectric boundary shift compared to the molecular surface, default value is
0.52Å (only relevant for the -chagb option).

dprob

Sets the radius of the solvent robe, default is 1.4 Å.

76

5.3. Usage

space

Sets the grid spacing that determines the resolution of the solute molecular surface, default is 0.5 Å.
Note that memory footprint of this grid-based implementation of GBNSR6 may become large for
large structures, e.g. the nucleosome (about 25,000 atoms) will take close to 2 GB of RAM when
the default grid spacing is used. For very large structures, one may consider increasing the value of
space, which will reduce the memory footprint and execution time; however, the accuracy will also
decrease.

arcres

Sets the arc resolution used for numerical integration over molecular surface, the default value is 0.2
Å.

rbornstat = 0 values of the inverse effective Born radii are not printed (default).

= 1 print the inverse effective Born radii to the outﬁle.

dgij

This ﬂag is used for printing pairwise electrostatic energies. The values will be found in the output
ﬁle, starting with the label “DGij”. The second and third columns of these lines especify the atom
indexes of the respective atomic pair. Energy units are kcal/mol.

= 0 does not print pairwise terms (default).
= 1 prints polar component only of the solvation energy between all pairs of atoms.

radiopt

Speciﬁes the set of intrinsic atomic radii to be used with the chagb option.

= 0 uses hardcoded intrisic radii optimized for small drug like molecules, and single amino acid

dipeptides[209] (default)

= 1 intrinsic radii are read from the topology ﬁle. Note that the dielectric surface deﬁned using
these radii is then shifted outwards by Rs relative to the molecular surface. The option is not
recommended unless you are planning to re-optimize the input radii set for your problem.

chagb

ROH

tau

inp

= 0 Do not use CHAGB (default).
= 1 Use CHAGB.
Sets the value of Rz
OH for CHA GB model, the default is 0.586Å. This parameter deﬁnes which
explicit water model is being mimicked with respect to its propensity to cause CHA, the default
corresponds to TIP3P and SPC/E. For OPC, Rz
OH = 0.734Å, and 0.183Å
for TIP5P/E. A perfectly tetrahedral water , which can not cause charge hydration asymmetry, would
have Rz

OH = 0.699Å, for TIP4P Rz

OH = 0.

Sets the value of τ in the CHAGB model, the default is 1.47. This dimensionless parameter controls
the effective range of the neighboring charges (j) affecting the CHA of atom (i), see Ref.[209] for
details.

= 0 do not compute nonpolar solvation energy.
= 1 compute nonpolar solvation energies.

cavity_surften Sets the surface tension parameter for nonpolar solvation calculation, the default value is 0.005

(kcal/mol/A2). This will be read only if the inp=1.

More options are available in a stand-alone version of GBNSR6 code not based on Cartesian grid [205].

5.3.3. Examples of input ﬁles

Compute electrostatic energy using default parameters.

&cntrl
inp=0

/

77

5. GBNSR6

Compute electrostatic energies including nonpolar solvation energies and print the inverse effective Born radii

&cntrl

np=1

/
&gb

epsin=1.0, epsout=78.5, istrng=0, dprob=1.4, space=0.5,
arcres=0.2, B=0.028, alpb=1, rbornstat=1, cavity_surften=0.005

/

Use chagb to compute solvation energy, include ALPB correction.

&cntrl
inp=1

/
&gb

alpb=1, chagb=1

/

78

6. PBSA

Several efﬁcient ﬁnite-difference numerical solvers, both linear [211, 212] and nonlinear,[213] are implemented
in pbsa for various applications of the Poisson-Boltzmann method. The GPU support of those solvers is also
implemented in pbsa.cuda.[214, 215] In the following, a brief introduction is given to the method, numerical
solvers, and numerical energy and force calculations. This is followed by a detailed description of the usage
and keywords. Example input ﬁles are explained for typical pbsa applications. The GPU-enabled pbsa.cuda is
illustrated in section 6.6. For more information on the background and how to use the method, please consult the
cited references and online Amber tutorial pages.

6.1. Introduction

Solvation interactions, especially solvent-mediated dielectric screening and Debye-Hückel screening, are es-
sential determinants of the structure and function of proteins and nucleic acids.[216] Ideally, one would like to
provide a detailed description of solvation through explicit simulation of a large number of solvent molecules and
ions. This approach is frequently used in molecular dynamics simulations of solution systems. In many appli-
cations, however, the solute is the focus of interest, and the detailed properties of the solvent are not of central
importance. In such cases, a simpliﬁed representation of solvation, based on an approximation of the mean-force
potential for the solvation interactions, can be employed to accelerate the computation.

The mean-force potential averages out the degrees of freedom of the solvent molecules, so that they are often
called implicit or continuum solvents. The formalism with which implicit solvents can be applied in molecular
mechanics simulations is based on a rigorous foundation in statistical mechanics, at least for additive molecular
mechanics force ﬁelds. Within the formalism, it is straightforward to understand how to decompose the total mean-
ﬁeld solvation interaction into electrostatic and non-electrostatic components that scale quite differently and must
be modeled separately (see for example [217]).

The Poisson-Boltzmann (PB) solvents are a class of widely used implicit solvents to model solvent-mediated
electrostatic interactions.[216] They have been demonstrated to be reliable in reproducing the energetics and con-
formations as compared with explicit solvent simulations and experimental measurements for a wide range of
systems.[216] In these models, a solute is represented by an atomic-detail model as in a molecular mechanics force
ﬁeld, while the solvent molecules and any dissolved electrolyte are treated as a structure-less continuum. The
continuum treatment represents the solute as a dielectric body whose shape is deﬁned by atomic coordinates and
atomic cavity radii.[218] The solute contains a set of point charges at atomic centers that produce an electrostatic
ﬁeld in the solute region and the solvent region. The electrostatic ﬁeld in such a system, including the solvent
reaction ﬁeld and the Coulombic ﬁeld, may be computed by solving the PB equation:[219, 220]

∇(cid:5) [ε(r)∇φ (r)] = −4πρ(r)− 4πλ (r)∑

i

zici exp(−ziφ (r)/kBT )

(6.1)

where ε(r) is the dielectric constant, φ (r) is the electrostatic potential, ρ(r) is the solute charge, λ (r) is the Stern
layer masking function, zi is the charge of ion type i, ci is the bulk number density of ion type i far from the solute,
kB is the Boltzmann constant, and T is the temperature; the summation is over all different ion types. The salt
term in the PB equation can be linearized when the Boltzmann factor is close to zero. However, the approximation
apparently does not hold in highly charged systems. Thus, it is recommended that the full nonlinear PB equation
solvers be used in such systems.

The non-electrostatic or non-polar (NP) solvation interactions are typically modeled with a term proportional
to the solvent accessible surface area (SASA).[202] An alternative and more accurate method to model the non-
polar solvation interactions is also implemented in pbsa.[221] The new method separates the non-polar solvation
interactions into two terms: the attractive (dispersion) and repulsive (cavity) interactions. Doing so signiﬁcantly

79

6. PBSA

improves the correlation between the cavity free energies and solvent accessible surface areas or molecular vol-
umes enclosed by SASA for branched and cyclic organic molecules.[222] This is in contrast to the commonly used
strategy that correlates total non-polar solvation energies with solvent accessible surface areas, which only corre-
lates well for linear aliphatic molecules.[202] In the alternative method, the attractive free energy is computed by
a numerical integration over the solvent accessible surface area that accounts for solvation attractive interactions
with no cutoff.[223]

6.1.1. Numerical solutions of the PB equation

In pbsa both the linear form and the full nonlinear form of the PB equation are supported. Many strategies
may be used to discretize the PB equation, but only the ﬁnite-difference (FD) method, or more rigorously, the
ﬁnite-volume method [224–226] is fully supported in pbsa for both the linear and nonlinear PB equations. A FD
method involves the following steps: mapping atomic charges to the FD grid points (termed grid charges below);
assigning non-periodic/periodic boundary conditions, i.e., electrostatic potentials on the boundary surfaces of the
FD grid; and applying a dielectric model to deﬁne the high-dielectric (i.e., water) and low-dielectric (i.e., solute
interior) regions and mapping it to the FD grid edges.

These steps allow the partial differential equation to be converted into a linear or nonlinear system with the
electrostatic potential on grid points as unknowns, the charge distribution on the grid points as the source, and
the dielectric constant on the grid edges (and the salt-related term for the linear case) wrapped into the coefﬁcient
matrix, which is a seven-banded symmetric matrix. In pbsa, four common linear FD solvers are implemented:
modiﬁed ICCG, geometric multigrid, conjugate gradient, and successive over-relaxation (SOR).[212] In addition,
we have also implemented six nonlinear FD solvers: Inexact Newton(NT)/modiﬁed ICCG, NT/geometric multi-
grid, conjugate gradient, and SOR and its improved versions - adaptive SOR and damped SOR.[213]

In addition to the FD method, a new discretization strategy is also introduced to solve the linear PB equation.[227]
The Immersed Interface method (IIM) is a second-order accurate numerical method developed for systems with
interface, i.e. solute/solvent boundary in this case. In the IIM discretization scheme, the linear equations on regular
grid points, i.e. grid points away from the interface, are the same as the standard ﬁnite-difference method, but the
linear equations on irregular grid points, i.e. grid points nearby the interface, are constructed by minimizing the
magnitude of the local truncation error in the discretization of the PB equation.[228] It can be proven that the
errors of calculated potentials are at the order of O(h2) on the regular grid points and O(h) on the irregular grid
points.[228]

6.1.2. Numerical interpretation of energy and forces

PB solvents approximate the solvent-induced electrostatic mean-force potential by computing the reversible
work in the process of charging the atomic charges in a solute molecule or complex. The charging free energy is a
function of the electrostatic potential φ, which can be computed by solving the linear or nonlinear system.

coul,short) from the total FD electrostatic energy (GFD

It has been shown (see for example [217]) that the total electrostatic energy of a solute molecule can be approx-
imated through the FD approach by subtracting the self FD Coulombic energy (GFD
coul,shel f ) and the short-range FD
Coulombic energy (GFD
coul,total), and adding back the analytical
short-range Coulombic energy (Gana
coul,short). The self FD Coulombic energy is due to interactions of grid charges
within one single atom. The self energy exists even when the atomic charge is exactly positioned on one grid point.
It also exists in the absence of solvent and any other charges. It apparently is a pure artifact of the FD approach
and must be removed. The short-range FD Coulombic energy is due to interactions between grid charges in two
different atoms that are separated by a short distance, usually less than 14 grid units. The short-range Coulombic
energy is inaccurate because the atomic charges are mapped onto their eight nearest FD grids, thus causing devia-
tion from the analytical Coulomb energy. The correction of GFD
coul,shortis made possible by the work
of Luty and McCammon’s analytical approach to compute FD Coulombic interactions.[229]

coul,shel f and GFD

Therefore, the PB electrostatic interactions include both Coulombic interactions and reaction ﬁeld interactions
for all atoms of the solute. The total electrostatic energy is given in the energy component EEL in the output ﬁle.
The term that is reserved for the reaction ﬁeld energy, EPB, is zero if this method is used. If you want to know how
much of EEL is the reaction ﬁeld energy, you can set the BCOPT keyword (to be explained below) to compute the
reaction ﬁeld energy only by using a Coulombic ﬁeld (or singularity) free formulation.[230]

80

6.1. Introduction

When the full nonlinear Poisson-Boltzmann equation is used, an additional energy term, the ionic energy, should
also be included. This energy term disappears in the symmetrical linear system because the effects due to opposite
ions cancel out. It is currently approximated by calculation up to the space boundary of the FD grid. It should
be noted that the NBUFFER keyword may need increasing to obtain good precision in the ionic energy for small
molecules with a large FILLRATIO.

An alternative method of computing the electrostatic interactions is also implemented in pbsa. In this method,
the reaction ﬁeld energy is computed directly after the induced surface charges are ﬁrst computed at the dielectric
boundary (i.e., the surface that separates solute and solvent). These surface charges are then used to compute the
reaction ﬁeld energy,[216] and is given as the EPB term. It has been shown that doing so improves the convergence
of reaction ﬁeld energy with respect to the FD grid spacing. However, a limitation of this method is that the
Coulombic energy has to be recomputed analytically with a pairwise summation procedure. When this method
is used, the EEL term only gives the Coulombic energy with a cutoff distance provided in the input ﬁle. The
two ways of computing electrostatic interactions are controlled by the keywords ENEOPT and FRCOPT to be
described below.

The non-polar solvation free energy is returned by the ECAVITY term, which is either the total non-polar
solvation free energy or the cavity solvation free energy in the two different models described above. The EDISPER
term returns the dispersion solvation free energy. Of course it is zero if the total non-polar solvation free energy
has been returned by ECAVITY. The word INP can be used to choose one of the two treatments of non-polar
solvation interactions.[221] Speciﬁcally, you can use SASA to correlate total non-polar solvation free energy, i.e.,
Gnp = NP_T ENSION × SASA + NP_OFFSET as in PARSE.[202] You can also use SASA to correlate the cavity
term only and use a surface-integration approach to compute the dispersion term.[221] i.e., Gnp= Gdisp+ Gcavity,
with Gcavity = CAV ITY _T ENSION×SASA +CAV ITY _OFFSET . See the discussion of keywords in 8.2.8. These
options are described in detail in Ref. [221].

Finally, in this release, the PB forces are now correctly interpreted for the widely used SES molecular surface
deﬁnition, i.e., the partition of dielectric boundary pressure/force can now reproduce the virtual work principle.
This is achieved by proper decomposition of the dielectric boundary force on the reentrant portion of the molecular
surface. Speciﬁcally, the molecular surface is computed more accurately by considering the cases when the solvent
probe touches three atoms simultaneously. Next the reentrant force is also distributed onto the three atoms forming
the reentrant surface following the virtual work principle.[231]

6.1.3. Numerical accuracy and related issues

Note that the accuracy of any numerical PB procedure is determined by the discretization resolution speciﬁed
in the input, i.e., the grid spacing. The convergence criterion for the iteration procedures also plays some role for
the numerical PB solvers. Finally the accuracy is highly dependent upon the methods used for computing total
electrostatic interactions. In Lu and Luo,[217] the accuracy of the ﬁrst method for total electrostatic interactions is
discussed in detail. In Ref.[231] the accuracy of the second method is discussed.

It is recommended that the second method for total electrostatic interactions be used for most calculations.
Apparently the cutoff distance for charge-charge interactions strongly inﬂuences the accuracy of electrostatic in-
teractions. The default setting is inﬁnity, i.e., no cutoff is used. In this method, the convergence of the reaction
ﬁeld energy with respect to the grid spacing is much better than that of the ﬁrst method. Our experience shows
that the reaction ﬁeld energies converge to within ~2% for tested proteins at the grid spacing of 0.5 Å when the
weighted harmonic average of dielectric constants is used at the solute/solvent interface (when SMOOTHOPT =
1, see below).[232]

The reaction ﬁeld energies computed with the second method (when SMOOTHOPT = 2) are also in excellent
agreement (differences in the order of 0.1%) with those computed with the Delphi program which uses the same
method for energy calculation. For example, see the computational set up documented in test case pbsa_delphi in
this release.[233]

The accuracy of non-polar solvation energy depends on the quality of SASA which is computed numerically by
representing each atomic surface by spherically distributed dots. Thus a higher dot density gives more accurate
atomic surface and molecular surface. However, it is found that the default setting for the dot density is quite
sufﬁcient for typical applications.[221] Should you encounter any memory allocation error for surface calculation,
you are advised to use a coarser surface dot resolution if the physical memory of your computer is limited.

81

6. PBSA

Numerical solvation calculations are memory intensive for macromolecules due to the ﬁne grid resolution re-
quired for sufﬁcient accuracy. Thus, the efﬁciency of pbsa depends on how much memory is allocated for it and
the performance of the memory subsystem. The option that is directly related to its memory allocation is the FD
grid spacing for the PB equation and the surface dot resolution for molecular surface. Apparently the geometric
dimension and the number of atoms are also important for predicting the memory usage. In general for a typical
computer conﬁguration with 8GB memory, the geometric dimension can be as large as 180× 180× 180 Å3 at the
default grid spacing of 0.5 Å before the computer responds too slowly.

6.2. Usage and keywords

6.2.1. File usage

pbsa has a very similar user interface as the Amber/sander program, though much simpler.

pbsa [-O] -i mdin -o mdout [-p prmtop -c inpcrd]/[-pqr pqr]

Starting from the 2014 release, pbsa supports the free format pqr ﬁle. Once the pqr reading is enabled, the default
Amber ﬁle reading and processing would be bypassed. Here is a brief description of the ﬁles mentioned above.

mdin input control data for the run.

mdout output user readable state info and diagnostics “-o stdout” will send output to stdout (to the terminal)

instead of to a ﬁle.

prmtop input molecular topology, force ﬁeld, atom and residue names, and (optionally) periodic box type.

inpcrd input initial coordinates and (optionally) velocities and periodic box size.

pqr input initial coordinates, atomic charges and radii in the free format pqr.

Here are a few comments on the “free-formatted” pqr ﬁle used by pbsa. First all ﬁelds are delimited by spaces only.
Second there is no strict format requirement as in a standard pdb ﬁle. This more liberal style is to accommodate
pqr ﬁles of different origins. pbsa reads data on a per-line basis using the following format:

Tag AtomNumber AtomName ResidueName ChainID ResidueNumber XYZ Charge Radius

Tag A string specifying either ATOM or HETATM. Lines with other strings are ignored.

AtomNumber The sequence no of the atom, which is reset to start from 1.

AtomName The atom name.

ResidueName The residue name.

ChainID The chain ID of the atom, optional, which is ignored.

ResidueNumber The sequence no. of the residue, which is ignored.

XYZ The ﬂoating numbers representing the atomic coordinates (in Angstrom).

Charge A ﬂoat number providing the atomic charge (in electron).

Radius A ﬂoat number providing the atomic radius (in Angstrom).

Finally it is worth to point out that it is apparently very hard to know whether the charge and radius ﬁelds are
swapped as in the Delphi generated pqr ﬁle. Here we have assumed that the data are in the plain P.Q.R. order.
Please make sure you are following the same convention in generating the pqr ﬁles.

82

6.2. Usage and keywords

6.2.2. Basic input options

The layout of the input ﬁle is in the same way as that of Amber/sander for backward compatibility with previous
releases in Amber. The keywords are put in the the namelist of &cntrl for basic controls and &pb for more detailed
manipulation of the numerical procedures. This subsection discusses the basic keywords, either retained from
sander or newly created to invoke different energetic analyses. To reduce confusion most keywords from sander
have been removed from the namelist so they can no longer be read since the current implementation in pbsa only
performs single-structure calculations with the coordinates from inpcrd and exits. However, the current release is
compatible with the mdin ﬁle generated with the mmpbsa script in previous releases in Amber. Users interested in
energy minimization and molecular dynamics with the PB implementation are referred to sander in the release of
Amber. Nevertheless, for purposes of validation and development, the atomic forces can be dumped out in a ﬁle
when requested as described below.

The numerical electrostatic procedures can be turned on by setting IPB to either 1, 2 or 4. The ﬂag IGB = 10 is
phased out in this release. The numerical non-polar procedures can be turned on by setting INP to either 1 or 2.
The backward compatible ﬂag NPOPT is also phased out in this release.

imin

ntx

ipb

Flag to run minimization. Both options give the same output energies though the output formats are
slightly different. This option is retained from previous releases in the Amber package for backward
compatibility. The current release of pbsa only supports single point energy calculation.
= 0 No minimization. Dynamics is available with sander and NAB.
= 1 Single point energy calculation. Default. Multiple-step PB minimization is also available with

sander and NAB.

Option to read the coordinates from the “inpcrd” ﬁle. Only options 1 and 2 are supported in this
releases. Other options will cause pbsa to issue a warning though it does not affect the energy
calculation.
= 1 X is read formatted with no initial velocity information. Default.
= 2 X is read unformatted with no initial velocity information.

Option to set up a dielectric model for all numerical PB procedures.
IPB = 1 corresponds to a
classical geometric method, while a level-set based algebraic method is used when IPB (cid:62) 2. The
default IPB is 2.
= 0 No electrostatic solvation free energy is computed.
= 1 The dielectric interface between solvent and solute is built with a geometric approach.
= 2 The dielectric interface is implemented with the level set function. Use of a level set function
simpliﬁes the calculation of the intersection points of the molecular surface and grid edges and
leads to more stable numerical calculations. Default.

= 4 The dielectric interface is also implemented with the level set function. However, the linear
equations on the grid points nearby the dielectric boundary are constructed using the IIM.
In this option, The dielectric constant do not need to be smoothed, that is, SMOOTHOPT is
useless. Only the linear PB equation is supported, that is, NPBOPT = 0. Starting in the Amber
2018 release, SOLVOPT is no longer relevant as only one stable solver is supported.

= 6 The dielectric interface is implemented analytically with the revised density function approach
(SASOPT=2). The linear equations on the irregular points are constructed using the IIM and
fully utilizing the analytical surface. Otherwise, it is exactly the same as IPB=4.

= 7 The dielectric interface is implemented analytically with the revised density function approach
(SASOPT=2). The linear equations on the irregular points are constructed using the Χ-factor
harmonic average method.

= 8 The dielectric interface is implemented analytically with the revised density function approach
(SASOPT=2). The linear equations on the irregular points are constructed using the second-
order harmonic average method.

83

6. PBSA

inp

Option to select different methods to compute non-polar solvation free energy.

= 0 No non-polar solvation free energy is computed.
= 1 The total non-polar solvation free energy is modeled as a single term linearly proportional to the
solvent accessible surface area, as in the PARSE parameter set, that is, if INP = 1, USE_SAV
must be equal to 0. See Introduction.

= 2 The total non-polar solvation free energy is modeled as two terms:

the cavity term and the
dispersion term. The dispersion term is computed with a surface-based integration method
[221] closely related to the PCM solvent for quantum chemical programs.[223] Under this
framework, the cavity term is still computed as a term linearly proportional to the molecular
solvent-accessible-surface area (SASA) or the molecular volume enclosed by SASA. Default.

Once the above basic options are speciﬁed, pbsa can proceed with the default options to compute the solvation free
energies with the input coordinates. Of course, this means that you only want to use default options for default
applications. More PB options described below can be deﬁned in the &pb namelist, which is read immediately
after the &cntrl namelist. We have tried hard to make the defaults for these parameters appropriate for calcula-
tions of solvated molecular systems. Please use caution when changing any default options. Also note that the
default options may have changed over time. For a detailed discussion of all related options on the quality of the
calculations, please refer to our recent publication [234].

6.2.3. Options to deﬁne the physical constants

epsin

epsout

epsmem

Sets the dielectric constant of the solute region, default to 1.0. The solute region is deﬁned to be the
solvent excluded volume.

Sets the implicit solvent dielectric constant, default to 80. The solvent region is deﬁned to be the
space not occupied the solute region.
i.e., only two dielectric regions are allowed in the current
release.

Sets the membrane dielectric constant. Only used if membraneopt > 0, does nothing otherwise. Value
used should be between epsin and epsout or there may be errors. Previously spelled as epsmemb,
which is being phased out. Defaults to 1.0.

smoothopt Instructs PB how to set up dielectric values for ﬁnite-difference grid edges that are located across the

solute/solvent dielectric boundary.

= 0 The dielectric constants of the boundary grid edges are always set to the equal-weight harmonic

average of EPSIN and EPSOUT.

= 1 A weighted harmonic average of EPSIN and EPSOUT is used for boundary grid edges. The
weights for EPSIN and EPSOUT are fractions of the boundary grid edges that are inside or
outside the solute surface.[235] Default.

= 2 The dielectric constants of the boundary grid edges are set to either EPSIN or EPSOUT depend-

ing on whether the midpoints of the grid edges are inside or outside the solute surface.

istrng

Sets the ionic strength (in mM) for the PB equation. Default is 0 mM. Note the unit is different
from that (in M) in the generalized Born methods implemented in Amber. Note also that we are only
dealing with symmetrical solution, so the ionic strength should be equal to the square of the valence
of the symmetrical ions times the ion concentration (in mM).

pbtemp

Temperature (in K) used for the PB equation, needed to compute the Boltzmann factor for salt effects;
default is 300 K.

radiopt

Option to set up atomic radii.

= 0 Use radii from the prmtop ﬁle for both the PB calculation and for the NP calculation (see INP).

84

6.2. Usage and keywords

= 1 Use atom-type/charge-based radii by Tan and Luo [236] for the PB calculation. Note that the
radii are optimized for Amber atom types as in standard residues from the Amber database. If
a residue is built by antechamber, i.e., if GAFF atom types are used, radii from the prmtop ﬁle
will be used. Please see [236] on how these radii are optimized. The procedure in [236] can
also be used to optimize radii for nonstandard residues. These optimized radii can be read in
if they are incorporated into the radii section of the prmtop ﬁle (of course via RADIOPT = 0).
Default.

Solvent probe radius for molecular surface used to deﬁne the dielectric boundary between solute and
solvent. DPROB = 1.4 by default.

Mobile ion probe radius for ion accessible surface used to deﬁne the Stern layer. Default to 2.0 Å.

Option to determine which kind of molecular surfaces to be used in the Poisson-Boltzmann implicit
solvent model. Default is 0.

= 0 Use the solvent excluded surface as implemented by[233]
= 1 Use the solvent accessible surface. Apparently, this reduces to the van der Waals surface when

the dprobe is set to zero.

= 2 Use the smooth surface deﬁned by a revised density function.[237] This must be combined with

IPB (cid:62) 2.

dprob

iprob

sasopt

saopt

Option to compute the surface area of a molecule. Default is 0. Once the computation is enabled,
the surface area will be reported in the output ﬁle with the subtitle “Total molecular surface”. Note
that only the surface areas for the solvent excluded surface and the solvent accessible surface are
supported in this release.

= 0 Do not compute any surface area.
= 1 Use the ﬁeld-view method to compute the surface area.[210]

triopt

Option to add trimer arc dots for a more accurate and lower memory mapping method of the analyt-
ical solvent excluded surface. See [233]

= 0 Trimer arc dots are not used.
= 1 Trimer arc dots are used. Default.

arcres

pbsa uses a numerical method to compute solvent accessible arcs. See [233]. The ARCRES keyword
gives the resolution (in the unit of Å) of dots used to represent these arcs, default to 0.25 Å. These
dots are ﬁrst checked against nearby atoms to see whether any of the dots are buried. The exposed
dots represent the solvent accessible portion of the arcs and are used to deﬁne the dielectric constants
on the grid edges. It should be pointed out that ARCRES should be reduced to (0.125 Å) when the
TRIOPT option is turned off to achieve a similar accuracy in the reaction ﬁeld energies. More
generally, ARCRES should be set to max(0.125 Å, 0.5h) when the TRIOPT option is turned on, or
max(0.0625 Å, 0.25h) when the TRIOPT option is turned off (h is the grid spacing).

6.2.4. Options for Implicit Membranes
membraneopt Option to turn the implicit membrane on and off. The membrane is implemented as a slab like

region with a uniform or heterogeneous dielectric constant depth proﬁle.

= 0 No implicit membrane used (default).
= 1 Use a uniform membrane dielectric constant in a slab-like implicit membrane.
= 2 Use a heterogeneous membrane dielectric constant in a slab-like implicit membrane. The dielec-
tric constant varies with depth from a value of 1 in the membrane center to 80 at the membrane
periphery. The dielectric constant depth proﬁle was implemented using the PCHIP ﬁtting.

85

6. PBSA

mprob

mthick

mctrdz

= 3 Use a heterogeneous membrane dielectric constant in a slab-like implicit membrane. The dielec-
tric constant varies with depth from a value of 1 in the membrane center to 80 at the membrane
periphery. The dielectric constant depth proﬁle was implemented using the Spline ﬁtting.

Membrane probe radius in Å, default to 2.70. This is used to specify the highly different lipid
molecule accessibility versus that of the water.

Membrane thickness in Å, default to 40.0. This is different from the previous default of 20 Å.

Membrane center in Å in the z direction. Default is 0 - membrane centered at the center of the
protein.

poretype

Turn on and off the automatic depth-ﬁrst search method to identify the pore.

= 0 Do not turn on the pore searching algorithm.
= 1 Turn on the pore searching algorithm.

poreradius Controls the radius, in Å, of the cylindrical exclusion region. This is no longer needed given the

automatic pore searching algorithm.

6.2.5. Options to select numerical procedures

npbopt

Option to select the linear or the full nonlinear PB equation.

= 0 Linear PB equation is solved. Default.
= 1 Nonlinear PB equation is solved.

solvopt

Option to select iterative solvers.

= 1 Modiﬁed ICCG or Periodic (PICCG) if bcopt = 10 is. Default.
= 2 Geometric multigrid. A four-level v-cycle implementation is applied by default.
= 3 Conjugate gradient (Periodic version available under bcopt = 10). This option requires a large

MAXITN to converge.

= 4 SOR. This option requires a large MAXITN to converge.
= 5 Adaptive SOR. This is only compatible with NPBOPT = 1. This option requires a large MAX-

ITN converge.

= 6 Damped SOR. This is only compatible with NPBOPT = 1. This option requires a large MAXITN

to converge.

accept

maxitn

Sets the iteration convergence criterion (relative to the initial residue). Default to 0.001.

Sets the maximum number of iterations for the ﬁnite difference solvers, default to 100. Note that
MAXITN has to be set to a much larger value, e.g. 10,000, for the less efﬁcient solvers, such as
conjugate gradient and SOR, to converge.

fillratio The ratio between the longest dimension of the rectangular ﬁnite-difference grid and that of the
solute. Default is 2.0.
It is suggested that a larger FILLRATIO, for example 4.0, be used for a
small solute, such as a ligand molecule. Otherwise, part of the small solute may lie outside of the
ﬁnite-difference grid, causing the ﬁnite-difference solvers to fail.

space

Sets the grid spacing for the ﬁnite difference solver; default is 0.5 Å.

nbuffer

Sets how far away (in grid units) the boundary of the ﬁnite difference grid is away from the solute
surface; default is 0 grids, i.e., automatically set to be at least a solvent probe or ion probe (diameter)
away from the solute surface.

86

6.2. Usage and keywords

nfocus

fscale

npbgrid

Set how many successive FD calculations will be used to perform an electrostatic focussing calcu-
lation on a molecule. Default to 2, the maximum. When NFOCUS = 1, no focusing is used. It is
recommended that NFOCUS = 1 when the multigrid solver is used.

Set the ratio between the coarse and ﬁne grid spacings in an electrostatic focussing calculation.
Default to 8.

Sets how often the ﬁnite-difference grid is regenerated; default is 1 step. For molecular dynamics
simulations, it is recommended to be set to at least 100. Note that the PB solver effectively takes
advantage of the fact that the electrostatic potential distribution varies very slowly during dynamics
simulations. This requires that the ﬁnite-difference grid be ﬁxed in space for the code to be efﬁcient.
However, molecules do move freely in simulations. Thus, it is necessary to regenerate the ﬁnite-
difference grid occasionally to make sure a molecule is well within the grid.

6.2.6. Options to compute energy and forces

ENEOPT is the option to set a method to compute electrostatic energy and forces, and DBFOPT is phased out

in this release.

bcopt

Boundary condition options.

= 1 Boundary grid potentials are set as zero, i.e. conductor. Total electrostatic potentials and energy

are computed.

= 5 Computation of boundary grid potentials using all grid charges. Total electrostatic potentials

and energy are computed. Default.

= 6 Computation of boundary grid potentials using all grid charges. Reaction ﬁeld potentials and

energy are computed with the charge singularity free formalism.[230]

= 10 Periodic boundary condition is used. Total electrostatic potentials and energy are computed.
Can be used with SOLVOPT = 1, 2, 3, or 4 and IPB = 1 or 2. It should only be used on charge-
neutral systems. If the system net charge is detected to be nonzero, it will be neutralized by
applying a small neutralizing charge on each grid (i.e. a uniform plasma) before solving.

eneopt

Option to compute total electrostatic energy and forces.

= 1 Compute total electrostatic energy and forces with the particle-particle particle-mesh (P3M)
procedure outlined in Lu and Luo.[217] In doing so, energy term EPB in the output ﬁle is set
to zero, while EEL includes both the reaction ﬁeld energy and the Coulombic energy. The van
der Waals energy is computed along with the particle-particle portion of the Coulombic energy.
The electrostatic forces and dielectric boundary forces can also be computed.[217] This option
requires a nonzero CUTNB and BCOPT = 5.

= 2 Use dielectric boundary surface charges to compute the reaction ﬁeld energy. Default. Both
the Coulombic energy and the van der Waals energy are computed via summation of pairwise
atomic interactions. Energy term EPB in the output ﬁle is the reaction ﬁeld energy. EEL is the
Coulombic energy.

= 3 Similar to the ﬁrst option above, a P3M procedure is applied for both solvation and Coulombic

energy and forces for larger systems.

= 4 Similar to the third option above, a P3M procedure for the full nonlinear PB equation is applied
for both solvation and Coulombic energy and forces for larger systems. A more robust and
clean set of routines were used for the P3M and dielectric surface force calculations.

frcopt

Option to compute and output electrostatic forces to a ﬁle named force.dat in the working directory.

= 0 Do not compute or output atomic and total electrostatic forces. This is default.

87

6. PBSA

= 1 Reaction ﬁeld forces are computed by trilinear interpolation. Dielectric boundary forces are
computed using the electric ﬁeld on dielectric boundary. The forces are output in the unit of
kcal/mol·Å.

= 2 Use dielectric boundary surface polarized charges to compute the reaction ﬁeld forces and di-

electric boundary forces [231] The forces are output in the unit of kcal/mol·Å.

= 3 Reaction ﬁeld forces are computed using dielectric boundary polarized charge. Dielectric bound-
ary forces are computed using the electric ﬁeld on dielectric boundary. [238] The forces are
output in the unit of kcal/mol·Å.

scalec

Option to compute reaction ﬁeld energy and forces.

cutfd

cutnb

= 0 Do not scale dielectric boundary surface charges before computing reaction ﬁeld energy and

forces. Default.

= 1 Scale dielectric boundary surface charges using Gauss’s law before computing reaction ﬁeld

energy and forces.

Atom-based cutoff distance to remove short-range ﬁnite-difference interactions, and to add pairwise
charge-based interactions, default is 5 Å. This is used for both energy and force calculations. See
Eqn (20) in Lu and Luo.[217]

Atom-based cutoff distance for van der Waals interactions, and pairwise Coulombic interactions
when ENEOPT = 2. Default to 0. When CUTNB is set to the default value of 0, no cutoff will be
used for van der Waals and Coulombic interactions, i.e., all pairwise interactions will be included.
When ENEOPT = 1, this is the cutoff distance used for van der Waals interactions only. The particle-
particle portion of the Coulombic interactions is computed with the cutoff of CUTFD.

nsnba

Sets how often atom-based pairlist is generated; default is 1 step. For molecular dynamics simula-
tions, a value of 5 is recommended.

6.2.7. Options for visualization and output

phiout

phiform

pbsa can be used to output spatial distribution of electrostatic potential for visualization.
= 0 No potential ﬁle is printed out. Default.
= 1 Electrostatic potential is printed out in a ﬁle named pbsa.phi in the working directory. Please
refer to examples in the next section on how to display electrostatic potential on molecular
surface.

Controls the format of the electrostatic potential ﬁle.
= 0 The electrostatic potential (kT/mol·e) is printed in the Delphi binary format. Default.
= 1 The electrostatic potential (kcal/mol·e) is printed in the Amber ASCII format.
= 2 The electrostatic potential (kcal/mol·e) is printed in the DX volumetric data format for use with

VMD.

outlvlset pbsa can be set to write the total level set, used in locating interfaces between regions of differing
dielectric constant, to a DX format volumetric data ﬁle. This option will control printing of the total
level set (i.e. both solute-solvent and membrane level sets combined if membrane present)

= false No level set ﬁle printed out. Default.
= true Level set printed out in a ﬁle named pbsa_lvlset.dx

outmlvlset pbsa can be set to write the membrane level set, used in locating interfaces between regions of
differing dielectric constant, to a DX format volumetric data ﬁle. This option controls printing a
separate ﬁle for the membrane level set. Does nothing if membraneopt is not turned on.

88

6.2. Usage and keywords

= false No level set ﬁle printed out. Default.
= true Level set printed out in a ﬁle named pbsa_lvlset.dx

npbverb

When set to 1, turns on verbose mode in pbsa; default is 0.

6.2.8. Options to select a non-polar solvation treatment
decompopt Option to select different decomposition schemes when INP = 2. See [221] for a detailed discussion
of the different schemes. The default is 2, the σ decomposition scheme, which is the best of the
three schemes studied.[221] As discussed in Ref. [221], DECOMPOPT = 1 is not a very accurate
approach even if it is more straightforward to understand the decomposition.
= 1 The 6/12 decomposition scheme.
= 2 The σ decomposition scheme. Default
= 3 The WCA decomposition scheme.

use_rmin

sprob

The option to set up van der Waals radii. The default is to use rmin to improve the agreement with
TIP3P [221].
= 0 Use atomic van der Waals σ values.
= 1 Use atomic van der Waals rmin values. Default.

Solvent probe radius for solvent accessible surface area (SASA) used to compute the dispersion term,
default to 0.557 Å in the σ decomposition scheme as optimized in Ref. [221] with respect to the
TIP3P solvent and the PME treatment. Recommended values for other decomposition schemes can
be found in Table 4 of [221]. If USE_SAV = 0 (see below), SPROB can be used to compute SASA
for the cavity term as well. Unfortunately, the recommended value is different from that used in the
dispersion term calculation as documented in Ref. [221] Thus two separate pbsa calculations are
needed when USE_SAV = 0, one for the dispersion term and one for the cavity term. Therefore,
please carefully read Ref. [221] before proceeding with the option of USE_SAV = 0. Note that
SPROB was used for ALL three terms of solvation free energies, i.e., electrostatic, attractive, and
repulsive terms in previous releases in Amber. However, it was found in the more recent study [221]
that it was impossible to use the same probe radii for all three terms after each term was calibrated
and validated with respect to the TIP3P solvent. [221, 236]

vprob

Solvent probe radius for molecular volume (the volume enclosed by SASA) used to compute non-
polar cavity solvation free energy, default to 1.300 Å, the value optimized in Ref. [221] with respect
to the TIP3P solvent. Recommended values for other decomposition schemes can be found in Tables
1-3 of Ref. [221].

rhow_effect Effective water density used in the non-polar dispersion term calculation, default to 1.129 for DE-
COMPOPT = 2, the σ scheme. This was optimized in Ref. [221] with respect to the TIP3P solvent
in PME. Optimized values for other decomposition schemes can be found in Table 4 of Ref. [221].

use_sav

The option to use molecular volume (the volume enclosed by SASA) or to use molecular sur-
face (SASA) for cavity term calculation. The default is to use the molecular volume enclosed by
SASA. Recent study shows that the molecular volume approach transfers better from small training
molecules to biomacromolecules.
= 0 Use SASA to estimate cavity free energy.
= 1 Use the molecular volume enclosed by SASA. Default.

cavity_surften The regression coefﬁcient for the linear relation between the total non-polar solvation free en-
ergy (INP = 1) or the cavity free energy (INP = 2) and SASA/volume enclosed by SASA. The default
value is for INP = 2 and set to the best of three tested schemes as reported in Ref. [221], i.e. DE-
COMPOPT = 2, USE_RMIN = 1, and USE_SAV = 1. See recommended values in Tables 1-3 for
other schemes.

89

6. PBSA

cavity_offset The regression offset for the linear relation between the total non-polar solvation free energy (INP
= 1) or the cavity free energy (INP = 2) and SASA/volume enclosed by SASA. The default value is
for INP = 2 and set to the best of three tested schemes as reported in Ref. [221], i.e. DECOMPOPT
= 2, USE_RMIN = 1, and USE_SAV = 1. See recommended values in Tables 1-3 for other schemes.

maxsph

pbsa uses a numerical method to compute solvent accessible surface area.[221] MAXSPH variable
gives the approximate number of dots to represent the maximum atomic solvent accessible surface,
default to 400. These dots are ﬁrst checked against covalently bonded atoms to see whether any
of the dots are buried. The exposed dots from the ﬁrst step are then checked against a non-bonded
pair list with a cutoff distance of 9 Å to see whether any of the exposed dots from the ﬁrst step are
buried. The exposed dots of each atom after the second step then represent the solvent accessible
portion of the atom and are used to compute the SASA of the atom. The molecular SASA is simply a
summation of the atomic SASA’s. A molecular SASA is used for both PB dielectric map assignment
and for NP calculations.

6.2.9. Options to enable active site focusing

Active site focusing is an extension to the electrostatic focusing method. Electrostatic focusing can be regarded
as a multi-level FDPB calculation (two levels currently implemented) in which a coarse-grid solution is conducted
to set up the boundary condition for the requested ﬁne-grid solution. In the original implementation of electrostatic
focusing, the ﬁne grid always covers all the solute atoms. However in the enhanced implementation, the ﬁne grid
is allowed to cover only a local region of interest, such as an enzyme active site or ligand docking site. In such
applications, most or all of the protein atoms are held frozen during a calculation while only the active site side
chain and the substrate ligand are allowed to move. In principle, energies computed with the local electrostatic fo-
cusing method should correlate with those computed with the original electrostatic focusing method if the movable
substrate/ligand atoms are well within the local region of interest. The “active site” or the local region is speciﬁed
as a rectangular box by the following six variables:

xmax

xmin

ymax

ymin

zmax

zmin

The upper boundary of the box in x direction.

The lower boundary of the box in x direction, XMAX has to be greater than XMIN.

The upper boundary of the box in y direction.

The lower boundary of the box in y direction, YMAX has to be greater than YMIN.

The upper boundary of the box in z direction.

The lower boundary of the box in z direction, ZMAX has to be greater than ZMIN.

Of course, these keywords are zero by default, i.e. the original electrostatic focusing would be invoked if these
keywords remain to be the default value of zero.

6.2.10. Options to enable multiblock focusing

This option is no longer supported starting in the Amber 2018 release.

6.3. Example inputs and demonstrations of functionalities

6.3.1. Single-point calculation of solvation free energies

Normally the default pbsa options are capable of dealing with most situations. Users should be fully aware of

the meaning of an option before they change its default value. In all the following example inputs, only the
options that are different from their default values will be shown, and the explanations on the changes will be
given in detail. Here is a sample input ﬁle that might be used to perform single structure calculations.

90

6.3. Example inputs and demonstrations of functionalities

Sample single point PB calculation
&cntrl
/
&pb
npbverb=1, istrng=150, fillratio=1.5, saopt=1,
/

Note that NPBVERB = 1 above. This generates much detailed information in the output ﬁle for the PB and NP
calculations. A useful printout is atomic SASA data for both PB and NP calculations which may or may not
use the same atomic radius deﬁnition. Since the FD solver for PB is called twice to perform electrostatic focus
calculations, two PB printouts are shown for each single point calculation. For the PB calculation, a common error
message can be generated when FILLRATIO is set to the default value of 2.0 for small molecules. This may cause
a solute to lie outside of the focusing ﬁnite-difference grid.

In this example INP is not set and equal to the default value of 2, which calls for non-polar solvation calculation
with the new method that separates cavity and dispersion interactions. The EDISPER term gives the dispersion
solvation free energy, and the ECAVITY term gives the cavity solvation free energy. The default options for the
NP calculation are set to the recommended values for the σ decomposition scheme and to use molecular volume
to correlate with cavity free energy. You can ﬁnd recommended values for other decomposition schemes and other
options in Tables 1-4 of Ref. [221]. If INP is set to 1, the ECAVITY term would give the total non-polar solvation
free energy.

Finally, a few words on the RADIOPT option, set to the default value of 1 instructing PB to use the optimized
values instead of reading the radii from the prmtop ﬁle. Starting this release, the RADIOPT option only controls
the radius deﬁnition for the PB calculation. The INP=2 calculation automatically uses the default values, such as
atomic radii and solvent probes as optimized in Ref. [221]. On the other hand, the INP=1 calculation is allowed to
use whatever radii that a user decides to use.

The ion strength option ISTRNG is set to 150 in unit mM, a typical value for a physiological environment. The
FILLRATIO option is set to 1.5 because the biomolecule is relatively large. We set saopt to 1 because we need the
information of the molecular surface area (the molecular surface is deﬁned as the solvent excluded surface since
SASOPT is set to its default value 0).

6.3.2. Implicit membrane model

pbsa now supports inclusion of an implicit membrane region in implicit solvation calculations. This feature
is enabled by setting MEMBRANEOPT to 1 (default value is 0, for off). The membrane will extend the solute
dielectric region to include a slab-like planar region running parallel to the xy plane. The thickness is controlled by
the MTHICK option. The default is 40 Å. The membrane region will be centered on the protein center by default,
and can be set to a user-provided value using the MCTRDZ option (default is 0). Neither option will have any
effect unless MEMBRANEOPT is set to 1. The dielectric constant can be controlled using epsmem. We set the
membrane interior dielectric constant to a value of 4.0 in this example. This is four times that of the solute which
defaults to 1 (same as vacuum). The value of epsmem should always be set to a value greater than or equal to
EPSIN (solute dielectric constant) and less than EPSOUT (solvent dielectric constant). These default to 1.0 and
80.0 respectively.

When using the implicit membrane model, we recommend SASOPT=0, i.e. the classical solvent excluded

surface, due to its better numerical behavior. When running with the default options, the program will compute
solvent excluded surfaces both with the water probe (DPROB=1.40 by default) and the membrane probe
(MPROB=2.70 by default). This setting was found to be consistent with the explicit solvent MD simulations. It is
also suggested that periodic boundary conditions be used to avoid unphysical edge effects. This is supported in all
linear solvers. In the following we choose Periodic Incomplete Cholesky Conjugate Gradient (PICCG). So we set
IPB = 1, BCOPT = 10, and SOLVOPT = 1 (default). In addition, ENEOPT needs to be set to 1 because the
charge-view method (ENEOPT = 2) is not supported for this application.

Sample single point PB calculation with membrane region
&cntrl
ipb=1, inp=0

91

6. PBSA

/
&pb
radiopt=0, nfocus=1, maxitn=200,
bcopt=10, eneopt=1, solvopt=1,
sasopt=0, membraneopt=1, epsmem = 4.0
outlvlset=true, outmlvlset=true
/

The MAXITN option is set to a bigger value, 200, than the default one, 100, because the linear solvers, when
applied to periodic boundary conditions, seem to require slightly more iterations than non-periodic solvers to
converge.

To aid in visualization of the dielectric model, the level set function, which is used to locate the interfacial
surfaces between regions of differing dielectric constant, can be written to output ﬁles. Output of the total level
set function, including both the solute-solvent and membrane contributions, can be written to a DX formatted
volumetric data ﬁle by setting the OUTLVLSET option to “true”. The membrane contribution can be written to a
separate ﬁle by setting the OUTMLVLSET option to “true”. This may take a good deal of extra time, so be sure to
leave it off if you don’t want / need to visualize the levelset surface. Accordingly, NFOCUS is set to 1 because of
the use of periodic boundary condition.

Finally, if calculations need to be performed on a protein with a solvent-ﬁlled channel region, this region would

be identiﬁed automatically by setting PORETYPE=1.

6.3.3. Single point calculation of forces

Since pbsa is released for single point calculations in AmberTools, no energy minimization or molecular

dynamics is supported. However, the PB procedure can be invoked to print out the numerical electrostatic forces
for developmental purposes. Here is a sample input:

Sample PB force computation
&cntrl
inp=0
/
&pb
npbverb=1, radiopt=0, frcopt=2
/

Note that INP is set to 0 to turn off non-polar solvation interactions. RADIOPT = 0 means the atomic radii from the
topology ﬁles will be used. FRCOPT is set to 2, i.e., induced surface charges are used to compute the electrostatic
energy and forces. Since CUTNB is equal to the default value of zero, an inﬁnite cutoff distance is used for both
Coulombic and van der Waals interactions.

6.3.4. Comparing with Delphi results

Under identical condition, pbsa is highly consistent with Delphi in term of computed reaction ﬁeld energies. In
this subsection, we brieﬂy go over the details on how you can obtain comparable energies from both programs.
Apparently, you need coordinates, atomic charges, and atomic radii that have exactly the same numerical values in
both the Amber format and the Delphi format, i.e., the pqr format.
For a Delphi computation with the following input parameters:

salt=0.150
ionrad=2.0
exdi=80.0
indi=1.0
scale=2.0
prbrad=1.5

92

6.4. Visualization functions in pbsa

perfil=50
bndcon=4
linit=1000

A comparable computation in pbsa can be obtained by using the following input ﬁle:

Sample PB for delphi comparison
&cntrl
ipb=1, inp=0
/
&pb
istrng=150, ivalence=1, iprob=2.0, dprob=1.5,
radiopt=0, bcopt=5, smoothopt=2, nfocus=1,
/

IPB is set to 1 to make sure pbsa uses exactly the same surface deﬁnition as Delphi. Note that the values of exdi,
indi, prbrad, and ionrad in Delphi should be consistent with the values of EPSOUT, EPSIN, DPROB, and IPROB
in pbsa, respectively. In Delphi salt=0.150 is set in the unit of M, while in pbsa ISTRNG = 150 is in the unit of
mM. In Delphi the grid spacing is set as the number of grids per Å, i.e., scale=2.0, while in pbsa the grid spacing
is set straight in Å as SPACE = 0.5. In Delphi the grid dimension is set as percentage of the solute dimension over
the grid dimension, i.e., perﬁl=50, which is equivalent to the ratio of solute dimension over grid dimension set as
FILLRATIO = 2 in pbsa. Finally, Delphi sets the boundary condition by bndcon=4 and pbsa sets the boundary
condition as BCOPT = 5; both programs mean to use the Debye-Huckel limiting behavior for each atomic charged
sphere. There are additional options in pbsa that do not have corresponding counterparts in Delphi. For example,
SMOOTHOPT is used to instruct the program to use a speciﬁc dielectric boundary smoothing option, which is
equivalent to that used in Delphi when set to 2. (see Section 6.2.3).

6.4. Visualization functions in pbsa

pbsa can produce volumetric data ﬁles to allow visualization of electrostatic potential and level set maps. There

are two points to note before continuing.

1. The data ﬁles generated can become quite large if small grid spacings are used since they will scale as the

cube of the inverse of grid spacing

2. Unless singularity removal methods are used, the potential at grid nodes corresponding to atom centers may
be quite large when compared to the potential at the molecular / atomic surface. This will often result in poor
contrast during visualization of the potential map, particularly when it is used as a color map for a molecular
surface.

These two points should be kept in mind when determining grid spacing. For visualization purposes, a grid spacing
of about one angstrom should provide good results. If ﬁner spacing is needed, singularity removal (BCOPT = 6)
can be used to prevent poor contrast that could result from the presence of singularities. Lastly, when using grid
spacings of 0.5 Å or lower, the output ﬁles may become quite large (tens, or even hundreds of megabytes each)
and may take a signiﬁcant amount of time (up to several seconds each) to generate.

6.4.1. Visualization of electrostatic potential using PyMol

pbsa can produce an electrostatic potential map for visualization in PyMol when setting PHIOUT = 1. By

default, pbsa outputs a ﬁle pbsa.phi in the Delphi binary format. The sample input ﬁle is listed below:

Sample PB visualization input
&cntrl
inp=0
/

93

6. PBSA

&pb
npbverb=1, space=1.,
phiout=1, phiform=0
/

To be consistent with the surface routine of PyMol, the option PHIOUT = 1 instructs pbsa to use the radii as deﬁned
in PyMol. The ﬁnite-difference grid is also set to be cubic as in Delphi. The default DPROB value is equal to that
used in PyMol, 1.4 Å. A large grid spacing, e.g. 1 Å or higher, is recommended for visualization purposes, as
commented above.

Here is an example of loading the potential map in PyMol. First load the molecule in the form of prmtop and

inpcrd. In our case we need to rename our prmtop ﬁle to molecule.top and inpcrd ﬁle to molecule.rst and load the
molecule with commands

PyMol> load molecule.top
PyMol> load molecule.rst

The molecule will appear as an object “molecule”. Next display the surface of the molecule in the PyMol menu
by clicking “S” and then select surface. Now import the potential map generated by pbsa with the command in
PyMol

PyMol> load pbsa.phi

to create a value map object called “pbsa”. After this, create a value ramp called e_lvl from the potential map with
the command

PyMol> ramp_new e_lvl, pbsa, [-7, 0, 7]

You can assign surface_color to the e_lvl ramp with the command

PyMol> set surface_color, e_lvl, molecule

This will display the surface with the color scale according to the potential. You can adjust the value scale, such as
[-5, 0, 5], to change the color scale and use “rebuild” command to redraw the surface.

6.4.2. Writing electrostatic potential to DX format volumetric data ﬁle

To visualize the pbsa potential using VMD, you will need to set the output to DX format by changing

PHIFORM = 0 to PHIFORM = 2.

Sample PB visualization input
&cntrl
inp=0
/
&pb
npbverb=1, space=1., sasopt=2,
phiout=1, phiform=2
/

The program will now generate a ﬁle called pbsa_phi.dx. This format should be automatically recognized by
VMD. It can be either loaded directly into your molecule or as a separate ﬁle.

6.4.3. Loading DX format electrostatic potential data in VMD

1. go to the “File” menu in the VMD Main window.

2. Select “New Molecule...”.

• This will bring up the “Molecule File Browser” window

94

6.4. Visualization functions in pbsa

3. Click on the “Browse...” button in the “Molecule File Browser” window

4. Select the ﬁle “pbsa_phi.dx” that was generated by pbsa using the ﬁle selection dialogue that pops up.

• The “Determine ﬁle type:” drop down menu should now read “DX”.

5. Click the “Load” button.

VMD will, by default, display the data with an isosurface representation.

6.4.4. Changing the representation model

1. Select “Representations...” from the “Graphics” menu in the “VMD Main” window

• The “Graphical Representations” window should pop up

2. Select the object corresponding to the volumetric data you loaded from the “Selected Molecule” pull down

menu

3. Click on the representation you wish to change

• There should be one present for the isosurface being displayed

4. Click on the “Draw style” tab if it is not already selected

5. Select “Volume” from the “Coloring Method” pull down menu if it is not already chosen

• Another pull down menu will appear next to it.
• If you have multiple data ﬁles loaded for the same object you can choose which is used to color your

chosen draw method representation here

6. The “Drawing Method” pull down menu will let you choose a different visual representation model.

• To directly visualize potential data, use either “Isosurface” or “Volume Slice”
• VMD can also be used to visualize the corresponding electric ﬁeld by choosing “Field Lines”.

Displayed below are Volume Slice representations of electrostatic potential maps generated for an aquaporin sys-
tem. Computations were run using the periodic conjugate gradient solver for a 1 Å grid spacing, and FILLRATIO
of 2.0. For the systems using implicit water, the charge singularity removal methodology was used.

From Left to right: Vacuum, Water only, Water and 20 Å slab-like membrane, Water and 20 Å slab-like mem-

brane with 6 Å cylindrical channel region removed.

Often, the data ranges will not be consistent between potential distributions for different implicit solvent setups.
E.g. the range of the electrostatic values seen for vacuum will likely be larger than the range for implicit water.
The range of values displayed can be set manually to provide consistent color scaling for comparison.

95

6. PBSA

6.4.5. Adjusting the color scale of the color map

1. Select “Colors...” from the “Graphics” menu in the “VMD Main” window

• This should cause the “Color Controls” window to pop up

2. Select the “Color Scale” tab

• The color scheme can be selected from the “Method” pull down menu
• The “Offset” and “Midpoint” sliders can be used to adjust the scaling of the color map.

– If singularities are present, it may be difﬁcult to get a good scaling for volume maps generated
with ﬁne grid spacings. In this case, either re-run with singularity removal on, or set the color
scale range manually as shown in the next section.

When singularity removal is not employed, the presence of singularities will cause the range of the electrostatic
potential distribution near the atom centers to be much wider than near the molecular surface. This typically results
in very poor contrast particularly for implicit solvent since the high dielectric constant in the solvent region will
amplify the effect. This can be compensated for by manually setting the Color Scale Data Range.

6.4.6. Changing the color scale range

1. Select desired representation to modify

2. Select “Volume” Coloring Method and Select the desired volumetric map to rescale from the pull down

menu.

• Each time you change the volumetric map being displayed, you will need to repeat this, so it is a good
idea to make multiple representations for each potential data set rather than switching between them
on the same representation.

3. Select the “Trajectory” tab

4. You should see the automatically computed range in the “Color Scale Data Range:” boxes. The left hand
box controls the minimum value for the range, the right hand box controls the maximum value for the range.

5. Set the minimum and maximum values as needed to improve the contrast. Often the inner 10% to 30% of

the total (automatic) range will give good contrast for a one angstrom grid spacing.

6. Click on the “Set” button when you are ﬁnished

7. To return to the automatic scaling that was originally calculated by VMD, click the “Autoscale” button.

Electrostatic potential data can also be used as a color map for other drawing methods. You will need to ﬁrst load
the data into the molecule you wish to display.

6.4.7. Loading electrostatic potential data into an existing molecule

The names of the ﬁles are used as labels, so it is useful to rename them from “pbsa_phi.dx” to something more

descriptive before loading.

1. Select the molecule you wish to display the potential color map on in the “VMD Main” window

2. Go to the “File” menu in the VMD Main window.

3. Select “Load Data Into Molecule...”.

• This will bring up the “Molecule File Browser” window

4. Click on the “Browse...” button in the “Molecule File Browser” window

96

5. Select the ﬁle “pbsa_phi.dx” that was generated by pbsa using the ﬁle selection dialogue that pops up.

• The “Determine ﬁle type:” drop down menu should now read “DX”.

6.4. Visualization functions in pbsa

6. Click the “Load” button.

The data should now be loaded into the molecule you selected.

6.4.8. Using the electrostatic potential data as a color map

Once you have loaded a volumetric data ﬁle into a molecule, it can be used to generate a color map for any

representations of that molecules model.

1. Open the “Graphical Representations” window if it is not already open

• Select “Representations...” from the “Graphics” menu in the “VMD Main” window

2. Select the molecule you loaded the data into from the “Selected Molecule” pull down menu

3. Select the representation you wish to map the potential color map onto

4. Select the “Draw Style” tab if it is not already selected

5. Select “Volume” from the “Coloring Method” pull down menu

• Another pull down menu should appear next to it
• Choose the selection that corresponds to the data you just loaded, it should be the last one on the list if

it is the last one that was loaded.

VMD will attempt to automatically scale the color mapping used for Volumetric data that you load. The color scale
may be manually adjusted if needed (see previous section)

6.4.9. Loading and displaying the level set map

The level set used by pbsa to model the solute - solvent interface can be written to an output ﬁle in DX format

by setting OUTLVLSET to “true” in the input ﬁle.

Sample PB visualization input
&cntrl
inp=0
/
&pb
npbverb=1, space=1., sasopt=2,
phiout=1, phiform=2,
outlvlset=true
/

The level set will be written to a DX format volumetric data ﬁle named “pbsa_lvlset.dx”. This ﬁle can be used
to visualize the corresponding molecular surface. The level set ﬁle is loaded into VMD in the same manner as an
electrostatic potential data ﬁle. Cross sections can be viewed using the “Volume Slice” representation.

Shown below are the level sets for the aquaporin systems shown previously (no level set is shown for vacuum as

there is no dielectric interface being modeled in that system)

From left to right: Water, Water + Slab-like membrane, Water + Membrane with pore region

97

6. PBSA

6.4.10. Visualizing the molecular surface as an isosurface of the level set

The level set is constructed such that the molecular surface is the locus of all points where the level set is zero.
This allows us to use the Isosurface representation in VMD to display the solvent excluded surface by setting the
“Isovalue” to 0. Alternatively, if we wish to view the potential just outside the surface, we can set the “Isovalue”
to a number slightly higher than 0. E.g. 0.1 or 0.01.

1. Load the level set data ﬁle into the molecule.

• This is done using the same procedure as loading an electrostatic potential data ﬁle, but the level set

data ﬁle will be chosen instead of the potential data ﬁle.

2. Create a new Isosurface representation in the “Graphical Representations” window.

3. Select the volume map for the level set from the pull down menu

4. Choose an “Isovalue” at or slightly above 0.

5. Using the “Coloring Method” pull down menu, you may also use a previously loaded electrostatic potential
data ﬁle as a color map by selecting “Volume” and then selecting the appropriate volume map from the pull
down menu that appears.

• VMD will automatically assign color scale range every time.
• To compare multiple potential maps, it is often desirable to use the same color scale range for each.
The best way to do this is to make a new representation for each potential map and manually assign the
same color scale range to be identical for each (see previous section)

The examples below were generated for Aquaporin (1IH5 in the protein data bank) under various implicit solvent
options using a FILLRATIO of 2.0, grid spacing of 1Å. For each calculation, the periodic conjugate gradient
solver with singularity removal was used. The level set for the system modeling implicit water was used to build
the isosurfaces. The electrostatic potential data ﬁles were then overlayed as color maps with the color scale ranges
set to [-80000,80000].

From Left to right: Water only, Water + Slab Like Membrane, Water + Membrane with 6Å cylindrical pore.

98

6.4. Visualization functions in pbsa

6.4.11. Visualizing interior channels, voids, and solvent pockets

One of the common roles for membrane proteins is to act as a transmembrane channel, to allow speciﬁc sub-
stance to pass from one side of a membrane to another. Features such as solvent / ion channels or internal voids
will often be occluded from view by the exterior surface. One option that can allow these to be viewed is to use
the clipping plane tool in VMD.

1. Open the “Exensions” pull down menu in the “VMD Main” window and go to the “Visualization” submenu

and select “Clipping Plane Tool”.

2. The “Clip Tool” window should pop up.

3. The “Distance” slider allows clipping to be set

4. The “Normal” slider sets the normal of the clipping plane.

• The “ﬂip” button on the right will let you clip from front to back, which will be useful to clip the

occluding exteriro surface from the view and reveal the interior.

The clipping tool was used to reveal the internal pore region for the aquaporin system setups used in the previous
section.

From Left to right: Water only, Water + Slab like Membrane, Water + Membrane with pore region excluded.

As an alternative, the level set map generated using PORTYPE=1 with the implicit membrane option will allow
a cylindrical region to be excluded from the membrane level set. The corresponding isosurface will show any
interior cavities or voids which fall within this region for isovalues at or slightly above 0 (since the level set at the
membrane-solute interface will be below 0). See the previous section for details on writing and loading the level
set ﬁle.

Shown below is the level set isosurface for the aquaporin system with implicit water plus a membrane with a
cylindrical region removed. The corresponding potential data was again overlayed as a color map. The surface of
the channel region, and the membrane-solvent interface planes are now clearly visible.

6.4.12. Importing / Modifying Atomic Radii to VMD from the prmtop ﬁle

Currently, VMD does not support loading radii for atoms directly from the prmtop ﬁle when it loads a molecule.

These values can be loaded relatively easily using the tkconsole, however. To do so:

99

6. PBSA

1. select “Tk Console” from the “Extensions” menu in the “VMD Main” window.

• The “VMD TkConsole” window will then open

2. Be sure that the atom you want to import radii for is the top molecule on the list in the VMD Main window.

If it is not, you will need to replace “top” with the appropriate ID

3. Type or copy and paste the following lines, but DO NOT hit enter yet.

set prot [atomselect “top” all]
$prot set radius {#RadiiList#}

4. You will now need to replace #RadiiList# with the one from the prmtop ﬁle.

a) Open the prmtop ﬁle for the molecule using a text editor
b) ﬁnd the section that starts with “%FLAG RADII”
c) Highlight/Select the list of numbers that follows “%FORMAT(5E16.8)”
d) Copy the list (usually done by selecting “Copy” from the “Edit” menu in your text editor)
e) Go back to the “VMD TkConsole” window
f) Highlight/Select #RadiiList#
g) Select “Paste Ctrl-v” from the “Edit” menu in the “VMD TkConsole” window

5. Now hit return

• If this was successful, you should now have the correct radii for each atom in the molecule.
• you can have the console print the list of all radii by typing:

$prot get radius

• For a more human readable printout, use:

for {set ind 0} {$ind<[llength $rad]} {incr ind} \
{puts "Atom $ind radius is [lindex $rad $ind]"}

These radii are used by VMD to display the VDW surface (made by selecting “VDW” from the “Drawing
Method” pull down menu in the “Graphical Representations” window). One useful trick is to set them to be a
small amount larger (say .01 Å) than those used to generate the surface. This will ensure that the color map will
represent the external ﬁeld just outside of the molecule. To modify the radii type or copy the following in the Tk
Console:

set rad [$prot get radius]
for {set ind 0} {$ind<[llength $rad]} {incr ind} \
{lset rad $ind [expr [lindex $rad $ind] +.01]}

The above code will increase all atomic radii by .01 angstroms. This can be changed if a different amount is
desired. (The code assumes you already followed steps 1 through 5 otherwise $prot will be undeﬁned!)

6.5. pbsa in sander and NAB

6.5.1. Electrostatic forces/gradients in pbsa

Force calculation in the ﬁnite-difference Poisson-Boltzmann method is straightforward, though not a trivial
issue. It can be shown, by using the variation of the electrostatic free energy, that the electrostatic force density
consists of three components, viz., the reaction ﬁeld force, the dielectric boundary force, and the ionic force. [239]
Since the ionic force is much smaller in absolute value than the other two components, we only include the reaction
ﬁeld force and the dielectric boundary force in this release.

100

6.5. pbsa in sander and NAB

The reaction ﬁeld force only exists where there are atomic charges, so that it is straightforward to be mapped
onto atoms. In contrast, the dielectric boundary force exists on the molecular surface where the dielectric constant
changes. The surface force, or pressure, cannot be easily mapped onto atoms. This is because a force-mapping
procedure from the molecular surface to atoms apparently needs the derivatives of molecular surface with respect
to atomic positions. However such derivatives do not exist for the widely used molecular surface deﬁnition, i.e.,
the solvent excluded surface (SES). We are actively developing an analytical molecular surface deﬁnition that is
consistent with the widely used SES deﬁnition for the numerical PB methods so that this difﬁculty will be overcome
in future releases.

Temporarily, a partial solution in the mapping of dielectric boundary force as described by Gilson et al[239]
is implemented for PB dynamics and minimization when the SES deﬁnition is used. The stability of the MD
simulation has been much improved with a more accurate mapping method of analytical SES.

6.5.2. Example for pbsa in sander

All pbsa functionalities are available in sander and all input options are exactly the same as in the standalone

pbsa. An apparent exception is IPB: you need to really set IPB to nonzero in order to invoke pbsa functionalities.
All other default values of PB options in sander are same as those in pbsa for single point calculations, whereas
there are some options that have different recommended or default values when PB minimization or dynamics is
enabled. These options are

space=0.25
arcres=0.125
fscale=4
eneopt=2
bcopt=6
frcopt=2

The SPACE, ARCRES and FSCALE are all set for higher resolution of the grid so that the force calculation can
be more accurate. The charge view method (ENEOPT = 2, FRCOPT = 2) is used here because it has been tested
to be able to run stable molecular dynamics simulations. Plus, BCOPT is set to 6 to remove charge singularity for
the same stability purpose. An example input for PBMD is given as follows

Sample PB visualization input
&cntrl
imin=0, ntx=1, irest=0,
ipb=2, ntb=0,
ntc=2, ntf=2,
tempi=100, temp0=100, ntt=3, gamma_ln=1,
nstlim=100000, dt=0.002,
ntpr=100, ntwr=100000, ntwx=100,
/
&pb
npbgrid=500, nsnba=5,
/

IPB is explicitly set to 2 to enable PB dynamics. The NPBGRID option is set to 500, which means the ﬁnite
difference grid is regenerated every 500 dynamics steps. NSNBA = 5 means the atom-based pairlist is generated
every 5 steps. Please refer to Chapter 19 for the other &cntrl options. Note that the above input can be used with
sander only.

6.5.3. Example for pbsa in NAB

pbsa functionalities are available in NAB as a part of the standard build. However the available input options

are limited, please refer to the table in Section 39.1 for the list of available pbsa input options. The structures and

101

6. PBSA

parameters are supplied by NAB’s facility. Here is a sample of calls in a NAB program to the mm_options()
routine, in order to run pbsa:

mm_options("ntpr=1, cut=99.0"); // No solute-solute cutoff
mm_options("ipb=2"); // Use PBSA
mm_options("accept=0.0001"); // Convergence criterion
mm_options("dprob=1.4"); // Solvent probe radius for SASA
mm_options("radiopt=1"); // Useatom-type/charge-based radii
mm_options("fillratio=4"); // Ratio of the grid dimension over the solute dimension for the coarse grid

6.6. GPU accelerated pbsa

The GPU version of pbsa is called pbsa.cuda. In the Amber 2019 release, some bottleneck setup routines of pbsa
are also ported into the GPU code. A new biconjugate gradient (BiCG) GPU solver is added for solving the linear
system using the second-order IIM (IPB=6) or improved harmonic average methods (IPB=7/8), which generate
unsymmetrical matrices. Together with the GPU-supported solvers, pbsa.cuda is fully GPU-enabled, though the
full GPU support is only available for IPB=2. The workﬂow and additional bottlenecks are still in the process of
optimization. Based on the pbsa.cuda, a GPU-supported MMPBSA is under development.

For the numerical solver phase, our test shows that Geometric Multigrid (MG), Jacobi-preconditioned CG, and
Red-black SOR are among the optimal ones.[214][215] Our analysis shows that a speedup ratio of about 7 can be
achieved for the overall time, while depending on the solvers and tested systems. Note that the timing measurement
is preliminary and we expect more efﬁciency gain as the optimization is ongoing.

While the GPU code is considered to be production ready, it is still evolving and has not been tested to the
same extent as the CPU code. Users should excercise caution when using pbsa.cuda. The error checking on
the GPU is not as verbose as it is on the CPU. In particular, simulation failures such as failed PB setup or other
simulation instabilities, may manifest themselves as CUDA launch errors or GPU download failures. These are not
informative error messages. If you encounter problems during a simulation on the GPU you should ﬁrst try to run
the identical simulation on the CPU to ensure that it is not your simulation setup causing the problems. Feedback
and questions should be posted to the Amber mailing list (see http://lists.ambermd.org/). Future development will
aim for more robust code and user-friendly interface, and more performance-boost.

This section of the manual describes supported features, accuracy and memory considerations, installation and
other aspects of pbsa.cuda at the time of the release. Note that the rapidly changing nature of this ﬁeld means the
frequent updates are likely. You should refer to the AmberTools update page (see http://ambermd.org/bugﬁxesat.html)
for the most up to date information.

6.6.1. Supported features

pbsa.cuda supports only linear FDPB solvers. The available solver options for this release are MG,

Jacobi-preconditioned CG, Red-black SOR. The BiCG solver is also available for solving linear systems with
unsymmetrical matrices. While among the available solvers, MG is clearly the best solver for large systems as
shown in our analysis. To use this feature, the solver option of pbsa.cuda must be speciﬁed as:

solvopt=2 (for MG)

solvopt=3 (for Jacobi-preconditioned CG)

or

or

solvopt=4 (for Red-black SOR)

MG solver is very fast to converge, usually in a few steps with the acceptance criterion of 10−4. For a higher
criterion such as 10−6 for very large systems, the MG solver may fail to converge due to the single precision used.
To overcome this issue, we have hooked up the MG solver to the Jacobi-preconditioned CG when the residual

102

6.6. GPU accelerated pbsa

norm no longer decreases rapidly, to utilize both the efﬁciency of MG and the stability of Jacobi-preconditioned
CG. Make sure you reset MAXITN to a much larger number, i.e. 5000 (versus the default value of 100 for the
default solver). This is to prevent premature termination of the Jacobi-preconditioned CG solver. Currently, the
free boundary condition or the conductor boundary condition (NBC) is supported for all GPU solvers. In
addition, the periodic boundary condition (PBC) is also supported for the Jacobi-preconditioned CG solver or the
BiCG solver. The latter option is useful when simulating periodic systems such as those with membranes. The
boundary condition options to use are:

bcopt=5, or 1 (for NBC)

or

bcopt=10 (for PBC)

We strongly recommend BCOPT=1 for NBC. This is the conductor boundary and has zero cost to set up, but its
solvation energies are very close to those with BCOPT=5 for typical proteins that we have tested. Once
SOLVOPT and BCOPT options are set as above, all other standard serial pbsa features will be supported as is;
you should refer to the previous sections on the usage of the CPU version of pbsa. An example input of single
point solvation free energy calculation using the MG solver in pbsa.cuda is as follows:

&cntrl

ntx=1, imin=1, ipb=2, inp=0

/
&pb

npbverb=1, istrng=0, epsout=80.0, epsin=1.0, space=.5,
accept=0.0001, dprob=1.4, radiopt=1, fillratio=1.5,
smoothopt=0, arcres=0.0625, nfocus=1,
bcopt=1, solvopt=2, maxitn=3000

/

6.6.2. Supported GPUs

pbsa.cuda has been developed based on the NVIDIA CUDA environment and thus only runs on NVIDIA GPUs
at present. Since the GPU code is written in the single precision mode thus there is no requirement for GPU
hardware to support double precision calculations. Consistent with the Amber CUDA requirements, compute
capability 3.0 or above is required. We tested the released code and found it functions well on multiple NVIDIA
GPUs, including Quadro P5000, TITAN Xp, GeForce GTX 1080, and GeForce RTX 2080. We expect that most
mid- to high-end GPUs are supported.

Currently selection of which GPU is used for single GPU runs is automatic if the GPUs are set to process-
exclusive mode (nvidia-smi -c 3), but the recommended approach is to use the CUDA_VISIBLE_DEVICES
environment variable to select which GPU should be used. More details are provided in the section 6.6.4.

6.6.3. Accuracy consideration and memory usage

pbsa.cuda was developed in single precision as single precision operations are widely supported with high
efﬁciency on most consumer-grade GPUs. Nevertheless, double precision operations are possible, but are at a sig-
niﬁcant performance disadvantage. Speciﬁcally we adopted a hybrid precision scheme: the linear system solution
uses single precision, while the linear system setup (i.e. molecular surface and mapping of dielectric constants
etc) and the post-processing of energy and force use double precision, except that with IPB=2, the reaction energy
calculation, the level set density evaluation and the surface area non-bonded list determination use single precision
as they have been ported to GPUs. Extensive tests of electrostatic solvation energy shows that correlation coefﬁ-
cients between hybrid and double precision codes are 1.0 for both 10−3 and 10−6 convergence criteria. Maximum
relative errors are 3.9× 10−3 and 5.8× 10−6, respectively.
Memory usage is crucial for GPU implementations since memory is often limited on most consumer-grade
GPUs. In the Jacobi-preconditioned CG implementation, typical GPU memory usage is about 92× Ngrid bytes,

103

6. PBSA

where Ngrid is the number of grid nodes when discretizing the system with the ﬁnite difference method. While in
the MG implementation, where the uniﬁed memory is used, the typical GPU memory usage is about 75× Ngrid
bytes. If the MG–Jacobi-PCG hybrid solver is involved in the computation with tighter convergence criteria, the
typical GPU memory usage is about 135 × Ngrid bytes. Our analysis of the MG solver showed that NVIDIA
Titan Xp cards, which have 12 GB GPU memory, are sufﬁcient to successfully run all our 144 stress tests until
host memory hit the limit ﬁrst. On the older NVIDIA GTX 980 Ti cards with ∼6 GB GPU memory, the MG
implementation is able to successfully complete calculations with ∼ 75.0 million grid points given sufﬁcient host
memory. Worth noting is that for extremely large grids, for example those with at least one billion grid points, the
MG implementation generally requires about 70 GB memory, which is far beyond the available memory on most
consumer-grade GPU cards. You can refer to NVIDIA hardware manage tool nvidia-smi to obtain the runtime
memroy allocation information.

6.6.4. Installation and testing

pbsa.cuda must be built separately from the standard serial pbsa installation. Before attempting to build the
GPU version of pbsa, we recommend you ﬁrst build and test at least the serial version of Amber and AmberTools.
This would help to ensure that issues related to standard compilation on your hardware and operating system are
resolved before you work with the more demanding GPU-related compilation and testing issues. Of course, you
should also be familiar with the Amber compilation and test procedures.

It is assumed that you have already correctly installed and tested the CUDA environment. Additionally the envi-

ronment variable CUDA_HOME should be set to point to your NVIDIA Toolkit installation and $CUDA_HOME/bin/
should be in your $PATH. We recommend users to use CUDA 9.x or CUDA 10.x to use the MG solver, which
relies on advanced data managements, such as uniﬁed memory, which are only available in CUDA 8.0 or higher.

To build and install pbsa.cuda, please follow the general instructions for installing CUDA programs, in Sec.

20.6.5. Next you can run the tests using the default GPU with:

cd $AMBERHOME/AmberTools/test
export CUDA_VISIBLE_DEVICES=1
make test.cuda

# choose the device you wish to test

Note on some intel platforms, you need to use a larger stack size other than the system default setting to avoid
stack overﬂow fails when running pbsa.cuda. The following command should do the trick:

ulimit -s unlimited

To determine the device ID for the available hardware in your system, you can run NVIDIA’s deviceQuery
executable included in the CUDA SDK, after unsetting CUDA_VISIBLE_DEVICES environment variable:

unset CUDA_VISIBLE_DEVICES
deviceQuery

104

7. Reference Interaction Site Model

In addition to explicit and continuum implicit solvation models, Amber also has a third type of solvation model
for molecular mechanics simulations, the reference interaction site model (RISM) of molecular solvation[240–
253]. In AmberTools, 1D-RISM is available as rism1d. 3D-RISM is available as an option in NAB, MMPBSA.py
and sander. rism3d.snglpnt is a simpliﬁed, standalone interface, ideal for calculating solvation thermodynamics on
individual structures and trajectories. Details speciﬁc to using sander and sander.MPI can be found in Chapter 19.

7.1. Introduction

RISM is an inherently microscopic approach, calculating the equilibrium distribution of the solvent, from which
all thermodynamic properties are then determined. Speciﬁcally, RISM is an approximate solution to the Ornstein-
Zernike (OZ) equation[241, 250, 251, 254, 255]

h(r12,Ω1,Ω2) = c(r12,Ω1,Ω2) + ρ

dr3 dΩ3 c(r13,Ω1,Ω3)h(r32,Ω3,Ω2),

(7.1)

where r12 is the separation between particles 1 and 2 while Ω1 and Ω2 are their orientations relative to the vector
r12. The two functions in this relation are h, the total correlation function, and c, the direct correlation function.
The total correlation function is deﬁned as

hab(rab,Ωa,Ωb) ≡ gab(rab,Ωa,Ωb)− 1,

where gab is the pair-distribution function, which gives the conditional density distribution of species b about a. In
cases where only radial separation is considered, for example by orientational averaging over site α of species a
and site γ of species b, gives the familiar one dimensional site-site radial distribution function, gαγ (rαγ ).
For real mixtures, it is often convenient to speak in terms of a solvent, V, of high concentration and a solute, U,
of low concentration. A generic case of solvation is inﬁnite dilution of the solute, i.e., ρU → 0. We can rewrite
Equation (7.1), in the limit of inﬁnite dilution, as a set of three equations:

hVV(r12,Ω1,Ω2) = cVV(r12,Ω1,Ω2) + ρV

hUV(r12,Ω1,Ω2) = cUV(r12,Ω1,Ω2) + ρV

hUU(r12,Ω1,Ω2) = cUU(r12,Ω1,Ω2) + ρV

dr3 dΩ3 cVV(r13,Ω1,Ω3)hVV(r32,Ω3,Ω2),

dr3 dΩ3 cUV(r13,Ω1,Ω3)hVV(r32,Ω3,Ω2),

dr3 dΩ3 cUV(r13,Ω1,Ω3)hVU(r32,Ω3,Ω2).

(7.2)

(7.3)

(7.4)

(cid:90)

(cid:90)
(cid:90)
(cid:90)

Equation (7.3) is directly relevant for biomolecular simulations where we are often interested in the properties of
a single, arbitrarily complex solute in the solution phase. Solutions to Equation (7.3) can be obtained using 3D-
RISM. However, a solution to Equation (7.2) for pure solvent is a necessary prerequisite and is readily obtained
from 1D-RISM.

To obtain a solution to the OZ equations it is necessary to have a second equation that relates h and c or uniquely

deﬁnes one of these functions. The general closure relation is[254]

g(r12,Ω1,Ω2) = exp [−β u(r12,Ω1,Ω2) + h(r12,Ω1,Ω2)− c(r12,Ω1,Ω2) + b(r12,Ω1,Ω2)]

(7.5)

u is the potential energy function for the two particles and b is known as the bridge function (a non-local functional,
representable as inﬁnite diagrammatic series in terms of h [254]). It should be noted that u is the only point at
which the interaction potential enters the equations. Depending on the method used to solve the OZ equations, u

105

7. Reference Interaction Site Model

is generally an explicit potential. In principle, it should now be possible to solve our two equations. For example,
we may wish to use SPC/E as a water model. Inputting the relevant aspects of the SPC/E model into u, 1D-RISM
can be used to calculate the equilibrium properties of the SPC/E model. A different explicit water model will yield
different properties.

A fundamental problem for all OZ-like integral equation theories is the bridge function, which contains multiple
integrals that are readily solved only in special circumstances. In practice, an approximate closure relation must be
used. While many closures have been developed, at this time only three are implemented in 3D-RISM: hypernetted-
chain approximation (HNC), Kovalenko-Hirata (KH) and the partial series expansion of order-n (PSE-n).

For HNC, we set b = 0, giving[254]

gHNC(r12,Ω1,Ω2) = exp (−β u(r12,Ω1,Ω2) + h(r12,Ω1,Ω2)− c(r12,Ω1,Ω2))

= exp (t∗(r12,Ω1,Ω2))

(7.6)
where t∗ is the renormalize-indirect correlation function. HNC works well in many situations, including charged
particles, but has difﬁculties when the size ratios of particles in the system are highly varied and may not always
converge on a solution when one should exist. Also, as the bridge term is generally repulsive, HNC allows particles
to approach too closely, overestimating non-Coulombic interactions[251].

KH is a combination of HNC and the mean spherical approximation (MSA), the former being applied to the
spatial regions of solvent density depletion (g < 1), including the repulsive core, and the latter to those of solvent
density enrichment (g > 1), such as association peaks[250, 251]
t∗(r12,Ω1,Ω2)
exp
1 +t∗(r12,Ω1,Ω2)

for g(r12,Ω1,Ω2) ≤ 1
for g(r12,Ω1,Ω2) > 1

gKH(r12,Ω1,Ω2) =

(cid:40)

(7.7)

(cid:16)

(cid:17)

.

Like HNC, KH handles Coulombic systems well but overestimates non-Coulombic interactions. Unlike HNC, it
does not have difﬁculties with highly asymmetric particle sizes and readily converges to stable solutions for almost
all systems of practical interest. The reliability of the KH closure makes it particularly suitable for molecular
mechanics calculations.

PSE-n offers the ability to interpolate between KH and HNC. Here, the exponential regions of solvent density

enrichment are treated as a Taylor expansion,

gPSE-n(r12,Ω1,Ω2) =

t∗(r12,Ω1,Ω2)
exp
i=0 (t∗(r12,Ω1,Ω2))i/i!
∑n

for g(r12,Ω1,Ω2) ≤ 1
for g(r12,Ω1,Ω2) > 1

.

(7.8)

In the case of n = 1, the KH closure is obtained, while in the limit of n → ∞ HNC is recovered. This allows a
balance between the numerical stability of KH and the often better accuracy of HNC.

7.1.1. 1D-RISM

1D-RISM is used to calculate bulk properties of the solvent and is a prerequisite for 3D-RISM, for which the
primary result is the bulk solvent site-site susceptibility in reciprocal space, χVV(k). As its name would suggest,
1D-RISM is a one-dimensional calculation. The six-dimensional OZ equations are reduced to one dimension (ra-
dial separation) via the fundamental RISM approximation[241–244, 254, 255], which produces the intramolecular
pair correlation matrix,

(7.9)
where α and γ label the different atom types in the model. Note that atoms of the same type in RISM theory
have the same Lennard-Jones and Coulomb parameters. For example, most three site water models have two
RISM types, oxygen and hydrogen. Depending on the model, propane, C3H8, may have two carbon types and two

ωαγ (k) = sin(krαγ )/(krαγ )

106

(cid:40)

(cid:16)

(cid:17)

7.1. Introduction

hydrogen types. Equation (7.2) then becomes

hαγ (r) = ∑
µν

(cid:90)

1

dr(cid:48)dr(cid:48)(cid:48)ωαµ ((cid:12)(cid:12)r− r(cid:48)(cid:12)(cid:12))cµν ((cid:12)(cid:12)r(cid:48) − r(cid:48)(cid:48)(cid:12)(cid:12))(cid:2)ωνγ (r(cid:48)(cid:48)) + ρνhνγ (r(cid:48)(cid:48))(cid:3)
(cid:90)

eik·rdk

ωc [1− ρωc]

−1 ω

(cid:104)

(cid:105)

=

=

(2π)3
∞
∑

0

ω(k)c(k)ω(k) [ρc(k)ω(k)]n .

αγ

(7.10)

Equation (7.10) must be complemented with one of the ﬁve closures currently supported by rism1d (see Sub-
section 7.4.1). In 1d, these are site-site closures and there is no orientational dependence. For example, the HNC
closure (Eq. (7.6)) becomes,

(r) = exp(cid:2)−β uαγ (r) + hαγ (r)− cαγ (r)(cid:3) .

gHNC
αγ

(7.11)

Equation (7.10), with KH, HNC or PSE-n closures, is readily applicable to liquid mixtures, with site indices
of the site-site correlation functions enumerating interaction sites on all (different) species in the solution and the
intramolecular matrix (7.9) set equal to zero for sites α,γ belonging to different species.

A dielectrically consistent version of 1D-RISM theory (DRISM) enforces the proper dielectric asymptotics of
the site-site correlation functions, and so provides the self-consistent dielectric properties of electrolyte solution
with polar solvent and salt in a range of concentrations, including the given dielectric constant of the solution
[256].

The 1D-RISM integral equations are then solved for the site-site direct correlation function in an iterative man-
ner, accelerated by the modiﬁed direct inversion of the iterative subspace (MDIIS) [251, 257]. All correlation
functions are represented as one-dimensional grids and the convolution integrals in Equation (7.10) are performed
in reciprocal space by making use of a fast Fourier transform applied to the short-range parts of all the correlations,
while the electrostatic asymptotics are separated out and Fourier transformed analytically [251–253].

1D-RISM is a general method and not restricted to water or pure solvents. For example, 1D-RISM may be used
to treat solutions of aqueous alkali and halide ions at various concentrations [258]. The output from 1D-RISM can
then be used for complex solutes, such as DNA [259], in 3D-RISM.

7.1.2. 3D-RISM

With the results from 1D-RISM, a 3D-RISM calculation for a speciﬁc solute can be carried out. For 3D-RISM
calculations, only the solvent orientational degrees of freedom are averaged over and Equation (7.3) becomes[249,
250]

(cid:90)

(cid:0)r− r(cid:48)(cid:1) χVV

αγ (r(cid:48)),

hUV
γ

(r) = ∑
α

dr(cid:48)cUV
α

(7.12)

where χVV

αγ (r) is the site-site susceptibility of the solvent, obtained from 1D-RISM and given by

αγ (r) = ωVV
χVV

αγ (r) + ραhVV

αγ (r).

3D-RISM supports HNC, KH and PSE-n closures (see Sections 7.6.1, 39.1 and 34.3.1). As with the 1D-RISM

closures, these are constructed by analogy from Eqs. 7.6-7.8. For example, HNC becomes

(cid:16)−β uUV

γ

(cid:17)

gHNC,UV
γ

(r) = exp

(r) + hUV

γ

(r)− cUV
γ

(r)

.

(7.13)

As with 1D-RISM, correlation functions are represented on (3D) grids, convolution integrals are performed in
reciprocal space and a self-consistent solution is iteratively converged upon using the MDIIS accelerated solver.
There is one 3D grid for each solvent type for each correlation function. For example, for a solute in SPC/E water
there will be both gUV
H (r) will give the fractional density of water
hydrogen a that location of real-space.

O (r) grids. Each point on the gUV

H (r) and gUV

107

7. Reference Interaction Site Model

To properly treat electrostatic forces in electrolyte solution with polar molecular solvent and ionic species, the
electrostatic asymptotics of all the correlation functions (both the 3D and radial ones) are treated analytically [251,
252, 260]. The non-periodic electrostatic asymptotics are separated out in the direct and reciprocal space and the
remaining short-range terms of the correlation functions are discretized on a 3D grid in a non-periodic box large
enough to ensure decay of the short-range terms at the box boundaries [260]. The convolution of the short-range
terms in the integral equation (7.12) is calculated using 3D fast Fourier transform [261, 262]. Accordingly, the
electrostatic asymptotics terms in the thermodynamics integral (7.15) below are handled analytically and reduced
to one-dimensional integrals easy to compute [260].

With a converged 3D-RISM solution for hUV and cUV, it is straightforward to calculate solvation thermody-
namics. From the perspective of molecular simulations, the most important thermodynamic values are the excess
chemical potential of solvation (solvation free energy), µex and the mean solvation force, fUV
(Ri), on each solute
atom, i. µex can be obtained through analytical thermodynamic integration for HNC,

µex,HNC = kBT ∑
α
(cid:90)

µex,KH = kBT ∑
α

ρV
α

KH ,

and PSE-n,

(cid:90)

dr

(cid:20)1

2

µex,PSE-n = kBT ∑
α

ρV
α

2

dr

ρV
α

(cid:20)1
(cid:90)
(cid:0)hUV
α (r)(cid:1)2 − cUV
(cid:20)1
α (r)(cid:1)2 Θ(cid:0)−hUV
(cid:0)hUV
(cid:0)hUV
α (r)(cid:1)2 − cUV

α (r)− 1
2

hUV
α (r)cUV

dr

2

α (r)− 1
2

α (r)(cid:1)− cUV

α (r)

i

(cid:21)

hUV
α (r)cUV

α (r)

,

α (r)− 1
2

α (r)cUV
hUV

α (r)

(cid:21)

(7.14)

,

(7.15)

α (r)(cid:1)(cid:35)
Θ(cid:0)hUV

,

(7.16)

− (t∗ (r))n+1
(n + 1)!

where Θ is the Heaviside function.

Analogous versions of Eqns. 7.6, 7.15 and 7.16 are used in 1D-RISM. While these are used for DRISM they
are have been derived for XRISM. Furthermore, these equations have been derived a number of different ways
with slightly different functional forms of the − 1
2 hc term [250, 263–266]. These different functional forms are
equivalent in XRISM but not in DRISM. The form introduced by Pettitt and Rossky [264] is the most popular
in the literature and the default selection in rism1d. It is possible to have rism1d evaluate and output all three
functional forms (see Output) but, for DRISM, none of these expressions are strictly correct.

The force equation

fUV
i

(Ri) = −∂ µex
∂Ri

= −∑

α

ρα

drgUV

α (r)

∂ uUV

α (r− Ri)
∂Ri

(cid:90)

is valid for all closures with a path independent expression for the excess chemical potential, such as HNC, KH
and PSE-n closures implemented in 3D-RISM [240, 267–269].

In addition to closure speciﬁc expressions for the solvation free energy, other approximations also exist. The

Gaussian ﬂuctuation (GF) approximation[270, 271] is given as

(cid:90)

(cid:20)

(cid:21)

µex,GF = kBT ∑
α

ρV
α

dr

−cUV

α (r)− 1
2

α (r)cUV
hUV

α (r)

(7.17)

and has been shown to yield improved absolute solvation free energies for both polar and non-polar solutes[271,
272] but not necessarily for relative free energies[273]. It is not associated with a particular closure but is typically
used in place of the expression for a given closure.

Eqs. (7.14)-(7.16) give the total solvation free energy, ∆Gsol, but it is often useful to decompose this into elec-
trostatic (solvent polarization), ∆Gpol, and non-electrostatic (dispersion and cavity formation), (∆Gdis + ∆Gcav),
terms. Conceptually, we can divide the path of the thermodynamic integration into two steps: ﬁrst the solute
without partial charges is inserted into the solvent (dispersion and cavity formation) and then partial charges are

108

introduced, which polarize the solvent,

µex = ∆Gsol = ∆Gpol + ∆Gdis + ∆Gcav.

∆Gsol is produced by a 3D-RISM calculation on the charged solute. ∆Gpol is then the difference of the two
calculations. As a point of reference, generalized-Born and Poisson-Boltzmann methods calculate only ∆Gpol and,
typically, use a calculation involving solvent accessible surface area to predict ∆Gdis + ∆Gcav.

7.1. Introduction

7.1.3. Analytic Temperature Derivatives

For the thermodynamic analysis of solvation, it is often useful to calculate the energetic and entropic contribu-
tions, εsolvand −T Ssolv respectively, to the solvation free energy. It has been shown that it is possible to analytically
decompose the solvation free energy into these two contributions when the solvation free energy has a closed ana-
lytical form, such as with HNC and KH closure [274]. In what follows, the analytical expression of energetic and
entropic contributions to the solvation free energy are derived in the framework of 1D-RISM theory with HNC
closure. The similar derivation can be applied to other closures as well as to the framework of 3D-RISM theory.
At this time, temperature derivatives are implemented for with HNC, KH and PSE-n closures in both 1D- and
3D-RISM [275].

The solvation free energy of species U in a solution consisting of N total species is expressed in the RISM-HNC

framework as

µex,U
HNC = kBT

on U

∑
α

N

∑

M=1

on M

∑
γ

ργ

(cid:90)

(cid:20)1

2

dr

(cid:0)hαγ (r)(cid:1)2 − cαγ (r)− 1

hαγ (r)cαγ (r)

.

2

(cid:21)

The differentiation of the solvation free energy with respect to the temperature T leads to

(cid:90)

(cid:34)
hαγ (r)·δT hαγ (r)−δT cαγ (r)− 1
2

dr

δT hαγ (r)·cαγ (r)− 1
2

(cid:35)
hαγ (r)·δT cαγ (r)

.

δT µex,U

HNC = µex,U

HNC +kBT

on U

∑
α

N

∑

M=1

on M

∑
γ

ργ

where δT is T ∂
can be rearranged as

∂ T . Since µex,U

εsolv,U = −kBT

on U

∑
α

N

∑

M=1

on M

∑
γ

ργ

HNC = εsolv,U − T Ssolv,U, we have δT µex,U

(cid:34)
hαγ (r)· δT hαγ (r)− δT cαγ (r)− 1
2

HNC = −T Ssolv,U and therefore the above equation
(cid:35)
hαγ (r)· δT cαγ (r)

δT hαγ (r)· cαγ (r)− 1
2

(cid:90)

dr

.

(7.18)

It is noted that the solvation energy εsolv,U can be viewed as consisting of two contributions: one arising from
creation of a polarized cavity (in pure solvent) and the other corresponding to the energy of embedding the solute
molecule into the cavity. The former is the solvent reorganization energy and the latter is the average
solute-solvent interaction energy that is obtained as ∑α ∑γ ργ

(cid:82) druαγgαγ.

The temperature derivatives of correlation functionsδT h(r) and δT c(r) can be obtained by solving the tempera-

ture derivative of RISM-HNC equations

and

δT h(k) = w(k)δT c(k)w(k) + ρw(k)δT c(k)h(k) + ρw(k)c(k)δT h(k)

(cid:105)
(cid:104) uαγ (r)
kBT + δT hαγ (r)− δT cαγ (r)

δT hαγ (r) =

(hαγ (r) + 1).

Some practical examples can be found in [276], [277] and [275].

109

7. Reference Interaction Site Model

7.1.4. Treecode Summation for Electrostatic Interactions

One of the most computationally expensive parts of the non-periodic 3D-RISM calculation is computing Coulomb
potential between the solute sites and solvent grid in real-space and the related long-range asymptotics of the direct
and total correlation functions in both real- and reciprocal-space [273]. These functions must be computed on Nbox
grid points from M solute atoms, which is an O(MNbox) operation and can become prohibitively expensive for
large systems. While the cost of reciprocal-space calculations can be mitigated using a simple cutoff in wavelength
(see the asympKSpaceTolerance option in Sections 7.6.1, 7.7.2.1, and 39.1), such a treatment would lead to
large errors for real-space calculations. Instead, we employ cluster-particle treecodes, which are a class of fast
summation methods that can be used to reduce the cost of computing the interactions between the Nbox grid point
targets and M solute atom sources to O((M + Nbox)log(Nbox)).

To speed up computation, the treecode replaces a collection of far-ﬁeld particle-particle interactions with one
particle-cluster interaction, where the clusters are nodes within a hierarchical octtree. This treecode requires three
parameters: a multipole acceptance criterion (MAC), θ, a Taylor series expansion order parameter, p, and a maxi-
mum target number per leaf, N0 [278]. The MAC determines if the cluster and particle are well-separated and the
interaction is evaluated, or if further children in the tree of target clusters are traversed. If the ratio of the radius
of the cluster of targets to the distance between the cluster center and a source particle is less than θ, then the
interaction is evaluated. Otherwise, we traverse the children clusters of the target cluster. The Taylor series expan-
sion order parameter p speciﬁes the order of the Taylor expansion for evaluating the cluster-particle interaction. A
recurrence relation is used to calculate the Taylor coefﬁcients. N0 determines the maximum number of targets in a
leaf target cluster, i.e., a node at the lowest level of the octtree. If a target leaf-source particle interaction fails the
MAC, then the interactions are evaluated directly.

When such a procedure is used, the potential, V , at a target site,xi, due to a collection of M source particles, y j,
with associated charges, q j, can be written as the sum of the direct interactions for the leaf and the Taylor series
expansions that may be computed at each level,

V (xi) = ∑
y j∈D

q jφ (xi,y j) +

L

∑

l=1

q jφ (xi,y j),

∑
y j∈Il

where φ is a general potential function. L is the number of tree levels, where level 1 is the root cluster and level L
denotes the leaves. A target site will then belong to a nested sequence of clusters, xi ∈ CL ⊆ ... ⊆ CL, where cluster
Cl is at level l. The direct calculation is only performed for source terms not well-separated from the targets, as
determined by the MAC.

When the targets in a cluster, Cl, are well-separated from a set of source sites, a Taylor expansion is used to
approximate the potential. Here, the cluster’s geometric center is denoted xl
c and Il denotes the list of all source
particles y j that are well separated from cluster Cl but not from cluster C1, ...,Cl−1. Expanding the second term
φ (xi,y j) about xl

c, the center of cluster l, gives

(cid:17)k

xi − xl

c

(cid:16)

(cid:16)

(cid:17)(cid:16)

(cid:17)

,

∑
y j∈Il

q j

q jφ (xi,y j) ≈ ∑
y j∈Il
p
∑
(cid:107)k(cid:107)=0

=

p

∑
(cid:16)
(cid:107)k(cid:107)=0

1
k!

(cid:17)(cid:16)

mk

xl
c

∂ k
x φ

xi − xl

c

xl
c,y j

(cid:17)k

,

(cid:17)

(cid:16)

xl
c

q j(−1)(cid:107)k(cid:107)ak

= ∑
y j∈Il

xl
c,y j

ak (xi,y j) =

1
k!

∂ k
y φ (xi,y j) .

where the coefﬁcients mk are

mk

and the Taylor coefﬁcients ak are

Note that this is a Taylor series in three dimensions, where (cid:107)k(cid:107) = k1 + k2 + k3, k! = k1!k2!k3!, ∂ k

(xi − xc)k = (xi1 − xc1)k1 (xi2 − xc2)k2 (xi3 − xc3)k3, and 1,2,3 denote the three respective Cartesian directions.

y = ∂ k1y1 ∂ k2y2 ∂ k3y3 ,

110

7.2. Practical Considerations

Previous work [279, 280] established recurrence relations for Coulomb and screened Coulomb interactions. The
cluster-particle treecode in 3D-RISM employs recurrence relations to calculate Taylor coefﬁcients for Coulomb
interactions as well as the asymptotic direct correlation and total correlation functions. The Taylor series for the
Coulomb potential and the asymptotic direct correlation function converge exactly to their respective interactions;
the Taylor series for the asymptotic total correlation function, however, uses an additional far ﬁeld approximation
which does not exactly approach the underlying interaction.

See section 7.2.3 and Table 7.2 for suggested settings.

7.1.5. Molecular Reconstruction

3D spatial distributions of solvation thermodynamics can provide insights into the role of water in a binding
site, potentially identifying waters that can or cannot be easily displaced. Such maps can be easily obtained from
the integrands of the relevant functions, such as the excess chemical potential, Eq. (7.16), or solvation energy, Eq.
(7.18). However, since 3D-RISM is a site-site theory, separate distribution grids are produced for the each solvent
site; e.g., one for each of hydrogen and oxygen. The result of simply adding these together is messy and difﬁcult
to interpret.

To obtain molecule thermodynamic distributions, qualitatively similar to those produced by grid inhomogeneous
solvation theory, we use the intramolecular correlation function, Eq. (7.9), to reconstruct the molecular spatial
distribution [281]. We begin by considering an arbitrary thermodynamic quantity, A (r), and identifying a central
site, α, such as oxygen in water. Then the molecular distribution is approximated by

A (r) ≈ Aα (r) + gα (r) ∑
γ(cid:54)=α

ωαγ (r)∗ Aγ (r) .

Since the intramolecular correlation function contains the distance between two sites in the same molecule, the
convolution, ∗, radially projects Aγ (r) the bond length distance, rαγ. The result is then multiplied by the pair
distribution function of the central site, which weights the contributions by the relative density of the central site.
For example, the molecular excess chemical potential of water would be calculated as

µex (r) ≈ µex

O (r) + gO (r)ωOH (r)∗ µex

O (r) .

The excluded volume voxels are zeroed out in this approach, so integrating the molecular reconstruction does not
yield the same result as integrating the site distribution grids, though it may be close to the value provided by UC
or PC+ corrections.

At this time, the method is only implemented for water and assumes that oxygen is the ﬁrst site. The method can
be turned on using the molReconstruct ﬂag in sander, rism3d.snlgpnt, or NAB, in which case the molecular
reconstruction is output in addition to any requested site-based thermodynamic distributions, such as the excess
chemical potential or entropy.

7.2. Practical Considerations

7.2.1. Computational Requirements and Parallel Scaling

Calculating a 3D-RISM solution for a single solute conformation typically requires about 100 times more com-
puter time than the same calculation with explicit solvent or PB. While there are other factors to consider, such as
sampling conﬁned solvent or overall efﬁciency of sampling in the whole statistical ensemble at once, this can be
prohibitive for many applications. Memory is also an issue as the 3D correlation grids require anywhere from a
few megabytes for the smallest solutes to gigabytes for large complexes. A lower bound and very good estimate

111

7. Reference Interaction Site Model

for the total memory required is

Total memory ≥ 8bytes×

Nbox NV

2NMDIIS
(cid:124) (cid:123)(cid:122) (cid:125)
+ 1(cid:124)(cid:123)(cid:122)(cid:125)
 4(cid:124)(cid:123)(cid:122)(cid:125)

c,residual

u

asymptotics

(cid:125)

Npropagate

past solutions

+ Ndecomp
polar decomp

(cid:124) (cid:123)(cid:122) (cid:125)
1(cid:124)(cid:123)(cid:122)(cid:125)

+

FFT scratch

(cid:124)
(cid:123)(cid:122)
+ 2(cid:124)(cid:123)(cid:122)(cid:125)

g,h

NV






(Nbox + 2NyNz)

where Nbox = Nx×Ny×Nz is the total number of grid points, NV is the number of solvent atom species and NMDIIS
is the number of MDIIS vectors used to accelerate convergence. uUV, cUV and the residual of cUV are stored in
real-space only and require a full grid for each solvent. cUV and its residual also require NMDIIS grids for the
MDIIS routine (see the mdiis_nvec keyword) and Npropagate grids to make use of solutions from previous solute
conﬁgurations to improve the initial guess (see the npropagate keyword). If a polar/non-polar decomposition is
requested (see the polardecomp keyword) an additional set of grids for past solutions with no solute charges is
kept (Ndecomp = 2); by default this is turned off (Ndecomp = 1). The full real space grid plus an additional 2NyNx
grid points are needed (due to the FFT) for g and h for each solvent species and for the four grids required
to compute the long range asymptotics. Memory, therefore, scales linearly with Nbox while computation time
scales as O(Nbox log(Nbox)) due to the requirements of calculating the 3D fast Fourier transform (3D-FFT). To
overcome these requirements, two options are available beyond optimizations already in place, multiple time steps
and parallelization. Multiple time step methods are available only in sander (Chapter 19) and are applicable to
molecular dynamics calculations only. Parallelization is available for all calculations but is limited by system size
and computational resources.

Both sander and NAB have MPI implementations of 3D-RISM (see Section 7.5.5 for NAB compiling instruc-
tions) that distribute both memory requirements and computational load. As memory is distributed, the aggregate
memory of many computers can be used to perform calculations on very large systems. Memory distribution is
handled by the FFTW 3.3 library so decomposition is done along the z-axis. If a variable solvation box size is
used, the only consideration is to avoid specifying a large, prime number of processes (≥ 7). For ﬁxed box sizes,
the number of grids points in each dimension must be divisible by two (a general requirement) and the number
of grid points in the z-axis must be divisible by the number of processes. sander.MPI also has the additional
consideration that the number of processes cannot be larger than the number of solute residues; NAB does not suffer
from this limitation.

7.2.2. Output

gUV, hUV and cUV ﬁles can be output for 3D-RISM calculations and are useful for visualization and calculation of

so there is one ﬁle for each solvent atom type for each requested frame. Each ﬁle is(cid:0)348 + Nbox × 16 1

thermodynamic quantities. These use the ASCII Data Explorer (DX) ﬁle format (See http://ambermd.org/FileFormats.php)

(cid:1) bytes,

which can quickly ﬁll disk space. Also, very few visualization programs are capable of displaying both molecular
and volumetric trajectories.

3

7.2.3. Numerical Accuracy

Numerical accuracy depends on the residual tolerance speciﬁed for the numerical solution at runtime and the
solvation box physical size and grid spacing. In most cases, you will need to test these parameters to ensure you
have the accuracy required. As a rough guide, the numerical error in the solvation free energy is related to the
tolerance by

(7.19)
Molecular dynamics [240], minimization and trajectory post-processing [273] have different requirements for
the maximum residual tolerance. Molecular dynamics does well with a tolerance of 10−5 and npropagate=5.
Minimization requires tolerances of 10−11 or lower and is typically limited to drms ≥ 10−4. Trajectory post-
processing for MM/RISM should use enough digits to obtain the necessary accuracy when differences in solvation

ε∆Gsolv ≈ 10× tolerance.

112

< 0

ljTolerance

0

> 0

7.2. Practical Considerations

Fixed box size with

dimensions of solvbox. LJ

cutoff ﬁt to box size and

correction applied.

Fixed box size with

dimensions of solvbox. No

LJ cutoff or correction

applied.

Error.

Fixed box size with

dimensions of solvbox. LJ
cutoff with ljTolerance

applied. Correction applied if
the box size is large enough.
Box size is selected to ﬁt the
cutoff. Correction applied if
the box size is large enough.

ljTolerance=tolerance/10
and the box size is selected to

ﬁt the cutoff. Correction

applied.

Box size determined by

buffer. LJ cutoff ﬁt to box
size and correction applied.

Box size determined by
buffer. No LJ cutoff or

correction applied.

Box size determined by

buffer. Correction applied if
the box size is large enough.

< 0

r
e
f
f
u
b

0

> 0

Table 7.1.: The relationship between ljTolerance, tolerance, buffer, and solvbox in determining 3D-RISM

solvent box and Lennard-Jones cutoff values.

free energy are computed. For example, if a error < 0.2kcal/mol is required for ∆∆Gsolv, then ∆Gsolv should
be computed with an absolute error of 0.1kcal/mol. The relative error required to achieve this depends on the
magnitude of ∆Gsolv.

Almost all applications should use a grid spacing of 0.3 to 0.5 Å or smaller. A larger grid spacing quickly leads
to severe errors in thermodynamic quantities. Smaller grid spacing may be necessary for some applications (e.g.,
mapping potentials of mean force).

The size of the solvation box can be set in a number of ways; e.g., setting the box size directly, setting a buffer
distance between the solute and the edges of the solvent box or should typically be at least 14 Å for water or
larger for ionic solutions. The solvation box size should be increased until the thermodynamic properties converge
(see Section 7.5.1). Systems with a neutral solute or non-ionic solvent are the simplest case, as solvent box size
associated errors are primarily due to the truncation of the Lennard-Jones potential. Fortunately, this error can be
corrected for if a cutoff is applied and the cutoff does not extend beyond the solvent box. In general, when using
this correction, a cutoff where

(7.20)
does not affect numerical precision of the calculation. Since long range Coulomb interactions are handled analyt-
ically by the long range asymptotics functions [252, 273], the solvent box size can be determined by the cutoff
distance in many cases, which is calculated from the maximum error in the Lennard-Jones calculation and is de-
termined at run time by the combination of ljTolerance, tolerance, buffer, and solvbox values used. The
behavior is summarized in Table 7.1 on page 113.

α (rcut) ≤ tolerance/10
uLJ

For calculations with charged solutes in ionic solvent, the absolute size of the box required for sufﬁcient nu-
merical accuracy will depend on the absolute charge of the concentration of ions. Generally, lower ion concentra-
tions require larger solvent boxes. Here, we recommend experimenting with different buffer sizes and setting the
Lennard-Jones tolerance according to Eq. (7.20).

Independent of solvent-box size and grid spacing, time can be saved by truncating the reciprocal space expres-

sions for the long range asymptotics. In general, a cutoff where

α (kcut) ≤ tolerance/10
ˆc(as)

(7.21)

does not affect numerical precision of the calculation. The cutoff in reciprocal space is determined by asympKSpaceTolerance.

For solutes with more than 1000 atoms, it becomes beneﬁcial to replace the direct sum, real-space calculations of
the Coulomb and long-range asymptotic interactions with treecode fast summation. Table 7.2 contains suggested
parameter choices for treecode summation based off experience. Some calculated values are more sensitive than
others, so we recommend experimenting with these settings for your system.

113

7. Reference Interaction Site Model

treecodeMAC

Total Correlation Function
Direct Correlation Function

Coulomb

0.3
0.3
0.3

max
max
max

(cid:16)
(cid:16)
(cid:16)

treecodeOrder
2, log10(tolerance)+5.7
2, log10(tolerance)+1.9
2, log10(tolerance)+1.4

−0.7
−0.8
−0.8

(cid:17)
(cid:17)
(cid:17)

treecodeN0

500
500
500

Table 7.2.: Suggested 3D-RISM treecode parameters.

7.2.4. Solvation Free Energy Corrections

3D-RISM with HNC-like closures is known to overestimate the non-polar component of the solvation free
energy. Several alternate expressions for the solvation free energy have been developed to correct this and are
based all, or in part, on the partial molar volume (PMV) of the solute. These include the Universal Correction
(UC) [282], Ng Bridge Correction (NgB) [283] and the Pressure Correction Plus (PC+/3D-RISM) correction [284].
3D-RISM currently implements UC and PV+/3D-RISM as runtime options. NgB results can be calculated from
the standard thermodynamic output if the polarDecomp option is used but is not implemented directly. UC and
NgB are both parameterized corrections. So, parameters for these corrections must be used only with the .xvv
ﬁle used to create them. Our implementation of UC uses the excess chemical potential of the closure rather than
the GF functional, as we have found this provides better results in general [275]. All of these corrections have
been almost exclusively used with pure water under ambient conditions, though there are promising results for UC
with non-polar liquids.[285] Using these methods with different solvents and co-solvents is a subject of on-going
research.

7.3. Work Flow

Using 3D-RISM with SANDER or NAB for molecular dynamics, minimization or snapshot analysis is very
similar to using implicit solvent models like GBSA or PBSA. However, some additional preliminary setup is
required, the extent of which depends on the solvent to be used.

3D-RISM requires detailed information of the bulk solvent in the form of the site-site susceptibility, χVV, and
properties such as the temperature and partial charges. This is read in as an .xvv ﬁle, which is produced by a
1D-RISM calculation. If another 3D-RISM calculation is to be preformed with any details of the bulk solvent
changed (e.g., temperature or pressure) a new .xvv ﬁle must be produced. Examples of precomputed .xvv ﬁles
for SPC/E and TIP3P water can be found in $AMBERHOME/AmberTools/test/rism1d.

Special care must be taken when producing .xvv ﬁles for use with 3D-RISM, particularly with respect to grid
parameters. It is important that the spatial extent of the grid be large enough to capture the essential long range
features of the solvent while the spacing must be ﬁne enough to sample the short-range structure. A grid spacing
of 0.025 Å is sufﬁcient for most applications. The number of grid points required, which will determine the
physical length of the grid in Å, generally depends on the properties of the solvent. Low concentration aqueous
salt solutions typically require much larger grids than pure bulk water. A good indicator that the grid is large
enough is convergence of delhv0 in the .xvv ﬁle. When converged, delhv0 should retain four to ﬁve digits of
precision when the number of grid points is doubled.

The ability of 3D-RISM to perform temperature derivatives and calculate solvation energy and entropy requires
.xvv ﬁles with with temperature dependence information. rism1d must be run with entropicDecomp option turned
on (Section 7.4.1). The version number in the .xvv ﬁle header indicates the maximum information available. Ver-
sion 1.001 (current) allows temperature derivatives and solvation entropies and energies for all reported quantities.
Version 1.000 (since Amber12) does not allow temperature derivatives of the PMV or solventation energies and
entropies of PMV-based corrections. Version 0.001 does not have information for any temperature derivatives.

1D-RISM calculations require details of the some bulk properties of the solvent, such as temperature and di-
electric constant, and an explicit model of the molecular components. These are read in from one or more .mdl
ﬁles, depending on the composition of the solvent. Several .mdl ﬁles are included in the Amber11 distribution
and can be found in $AMBERHOME/dat/rism1d/model. These include many of the explicit models for solvent and

114

7.3. Work Flow

ions used with the Amber force ﬁelds. Other solvents models may be used by creating appropriate MDL ﬁles. See
Section 7.8 for format details.

7.3.1. Solution Convergence

The default parameters for 3D-RISM are selected to provide the best performance for the majority of systems.

In cases where a convergence is not achieved, the strategies below may be useful.

7.3.1.1. Closure Bootstrap

When a PSE-n or HNC closure is desired, the most effective method to overcome convergence issues is to use
a low order closure solution as a starting guess. The KH closure should be the starting point as it is numerically
robust and, typically, converges easily in the vast majority of case. After this, higher orders of PSE-n can be used
until the desired closure is reached. The procedure for 1D-RISM and 3D-RISM differs slightly in practice.

1D-RISM rism1d can use restart ﬁles to implement this approach (see Section Subsection 7.4.1). First, run
rism1d with the KH closure to convergence. Then use the .sav ﬁle as input for the next highest closure. The root
name of the .sav ﬁle must be the same as your .inp ﬁle. To avoid overwriting lower order solutions, name the ﬁles
by closure or use separate directories. You will have to rename the .sav ﬁles as you go.

3D-RISM All 3D-RISM interfaces have closure bootstrapping builtin via the closure and tolerance keywords.
Closures should be speciﬁed as an ordered list with last closure being the highest order closure. The solutions of
the intermediate closures can have a high tolerance. The default tolerance for intermediate closures is 1 and there
is no observed beneﬁt to tolerances less than 1e-2. See details in Subsection 7.6.1, Subsection 7.7.2.1 and Section
39.1.

7.3.1.2. MDIIS Settings

MDIIS default setting are appropriate for most cases. Should your residual diverge or the solver get stuck on a

particular value, you can try modest adjustments.

Decrease mdiis_del mdiis_del controls the step size of MDIIS. A smaller step size can help convergence but if
this is set too small it can cause convergence problems. For rism1d, this should be no lower than 0.1 or 0.2. For
3D-RISM, it should be 0.5 at the lowest.

Increase mdiis_nvec This is the number of trial solutions that are saved for predicting a new solution. The
optimal number for rapid convergence is typically 10 for 3D-RISM and 20 for 1D-RISM. However, for 3D-RISM,
the default choice of 5 requires much less memory and is computationally faster even though more iterations are
required. Increasing the mdiis_nvec may help for 3D-RISM but is unlikely to help for 1D-RISM.

Increase mdiis_restart Occasionally, the MDIIS routine goes in the wrong direction and the residual increases
signiﬁcantly. If it increases more than mdiis_restart then the MDIIS routine selects the solution with the lowest
residual and purges the other trial solutions. The default value of 10 can be too aggressive and cause the solver to
cycle. Increasing the value to 100 or 1000 sometimes allows the solver to recover from a misstep.

7.3.1.3. Parameter Annealing

Chargeless, hot gases are the easiest systems to converge. For 1D-RISM, this can be used to bootstrap a solution
in a similar manner to closure bootstrapping. By slowly turning on charges, lowering the temperature or increasing
the density, a converged solution may be reached. This only works for 1D-RISM because it requires restarting
from a previous solution. As with closure bootstrapping, ﬁles should be carefully renamed during the procedure.
There is no general protocol but the parameter increment should be reduced as the target value is approached. E.g.,
turning on charges in a linear fashion usually isn’t helpful.

115

7. Reference Interaction Site Model

7.3.1.4. Forceﬁeld selection

The forceﬁeld may affect convergence due to the number of solvent sites involved or the particular parameters

of the forceﬁeld.

Number of Sites Molecules with more sites are more difﬁcult to converge. Six or more sites is already difﬁcult
to converge and more that 10 may not be possible under any circumstances. One solution is to use a united atom
or coarse grained forceﬁelds to reduce the number of sites.

Alternate Parameterization Some parameter sets simply yield a stiffer set of equations to solve. Choosing an
alternate parameter set may allow convergence with only small differences in the numerical results. For example,
the cSPC/E water model with SPC/E Joung/Cheatham ions is easier to converge at higher ion concentrations in
1D-RISM than cTIP3P water with TIP3P Joung/Cheatham ions. Both models give nearly identical results in RISM
at lower concentrations but NaCl in cTIP3P water will not converge above 0.5 M for the PSE-3 closure despite
using all of the above methods.

7.4. rism1d

1D-RISM calculations are carried out with rism1d, and require only one input ﬁle with an .inp sufﬁx. The

input ﬁle is listed on the command line without this sufﬁx.

rism1d inputfile

Parameters for the calculation are read in from parameters name list.

7.4.1. Parameters

Note that these keywords are not case sensitive.

Theory

theory

closure

[DRISM] The 1D-RISM theory to use.
DRISM Dielectrically consistent RISM (recommended).
XRISM Extended RISM.

[KH] The type of closure to use.
KH Kovalenko-Hirata (recommended).
PSEn Partial serial expansion of order n. E.g., “PSE3”.
HNC Hyper-netted chain equation.
PY Percus-Yevick.

entropicDecomp [1] Solve another set of integral equations to calculate the temperature derivative. This typically
adds less than 50% to the compute time and yields an energy/entropy decomposition of the excess
chemical potential for all species and sites.
0 Do not calculate the temperature derivative.
1 Calculate the temperature derivative.

[0.025] Grid spacing in real space in Å.

[16384] Number of grid points. Should be a product of small prime factors (2, 3 and 5).

Grid Size

dr

nr

116

7.4. rism1d

Output

outlist

[] Indicates what output ﬁles to produce. Output ﬁle names use the root name of the input ﬁle with
an extension listed below. This is a list of any combination of the following characters in any order,
upper or lower case.
U U VV(r) Solvent site-site potential in real space, inputfile.uvv (see http://ambermd.org/FileFormats.php).
X χVV(k) Solvent site-site susceptibility in reciprocal space. Required input for 3D-RISM, inputfile.xvv

(see http://ambermd.org/FileFormats.php).

G GVV(r) Solvent site-site pair distribution function in real-space, inputfile.gvv (see http://ambermd.org/FileFormats.php).
B BVV(r) Solvent site-site bridge correction in real space, inputfile.bvv (see http://ambermd.org/FileFormats.php).
T Thermodynamic properties of the solvent, inputfile.therm (see http://ambermd.org/FileFormats.php).
E exNVV(r), exNVV Solvent site-site running, inputfile.exnvv, and total, inputfile.n00 (see

http://ambermd.org/FileFormats.php), excess coordination numbers in real space.

N NVV(r) Solvent site-site running coordination numbers in real space, inputfile.nvv (see http://ambermd.org/FileFormats.php).
Q exQVV Solvent site-site excess total charge of site γ about α, inputfile.q00 (see http://ambermd.org/FileFormats.php).
S SVV(k) Solvent site-site structure factor in reciprocal space, inputfile.svv (see http://ambermd.org/FileFormats.php).

rout

kout

ksave

progress

selftest

[0] Largest real space separation in Å for output ﬁles. If 0 then all grid points will be output.

[0] Largest reciprocal space separation in Å-1 for output ﬁles. If 0 then all grid points will be output.

[-1] Output an intermediate solution every ksave steps. If ksave <= 0 then no intermediate restart
ﬁles are written. If any restart ﬁles are present at run time (.sav sufﬁx) they are automatically used.
However, such ﬁles are non-portable binary ﬁles.

[1] Write the current residue to standard output every progress iteration. If progress <= 0 then
residue is not reported.

[0] If ‘1’, perform a self-consistency check and output the results to inputfile.self.test. Only
tests applicable to the input parameters and system are performed. The results will depend on the
input parameters (e.g., ‘tolerance’) used.

Species keywords

For each molecular species in the solvent mixture, a species name list should be provided.

density

[] (Required.) Density of the species in M. See ’units’ below.

units

model

[‘M’] Units for density value. Options are ‘M’ (molar), ‘mM’ (millimolar), ‘1/A^3’ (number per
Å3), ‘g/cm^3’ (g/cm3) or ‘kg/m^3’ (kg/m3).

[] (Required.) Relative or absolute path to and name of the .mdl ﬁle with the parameters for this
solvent molecule.

Solution Convergence

rism1d uses MDIIS to accelerate convergence. The default parameters for this method are usually near optimal
but some systems can be difﬁcult to converge. In such cases it may be useful to use a small step size (mdiis_del=0.1
or 0.2). Occasionally, the target tolerance of 10−12 can not be achieved. A tolerance of 10−10 to 10−11 is often
sufﬁcient but it is advisable to check how sensitive your calculations are to this.

mdiis_nvec [20] Number of MDIIS vectors to use.

mdiis_del [0.3] MDIIS step size.

117

7. Reference Interaction Site Model

mdiis_restart [10] If the current residual is mdiis_restart times larger than the smallest residual in memory,
then the MDIIS procedure is restarted using the lowest residual solution stored in memory. Increasing
this number can sometimes help convergence.

tolerance [1e-12] Target residual tolerance for the self-consistent solution.

maxstep

[10000] Maximum number of iterations to converge to a solution.

extra_precision [1] Controls the use of extra precision routines at key points in the 1D-RISM solver. This can
be useful for achieving low tolerances or for very large box lengths but increases computational cost.
Strongly recommended for solutions with charged particles (e.g., salts).

0

1

No extra precision routines are used.
Sensitive matrix multiplication and addition routines are done in extra precision. A
small computational cost is incurred.

Solvent Description

temperature [298.15] Temperature in Kelvin.

dieps

nsp

Other

smear

[] (Required.) Dielectric constant of the solvent.

[] (Required.) Number of species (molecules) in the solutions. Also indicates the number of species
name lists to follow.

[1.0] Charge smear parameter in Å for long range asymptotics corrections.

adbcor

[0.5] Numeric parameter for DRISM.



7.4.2. Example

Mixed ionic solvent.



&PARAMETERS
THEORY='DRISM', CLOSURE='KH',

!Theory

!Grid size and spacing
!Output

NR=16384, DR=0.025,
OUTLIST='x', ROUT=384, KOUT=0,
MDIIS_NVEC=20, MDIIS_DEL=0.3, TOLERANCE=1.e-12,
KSAVE=-1,
PROGRESS=1,
MAXSTEP=10000,
SMEAR=1, ADBCOR=0.5,
TEMPERATURE=310, DIEPS=78.497, NSP=3 !bulk solvent properties

!Check pointing
!Output frequency
!Maximum iterations
!Electrostatics

!MDIIS

/
&SPECIES
!SPC/E water

DENSITY=55.296d0,
MODEL="../../../dat/rism1d/model/SPC.mdl"

!very close to 0.0333 1/A3

/
&SPECIES

!Sodium
units='mM'
DENSITY=100,
MODEL="../../../dat/rism1d/model/Na+.mdl"

/
&SPECIES

118

!Chloride
units='g/cm^3'
DENSITY=35.45e-4,
MODEL="../../../dat/rism1d/model/Cl-.mdl"

/

7.5. 3D-RISM in NAB

7.5. 3D-RISM in NAB



3D-RISM functionality is available in NAB and is built as part of the standard install procedure. MPI function-
ality for 3D-RISM in NAB requires some additional information at compile time, described in Section 7.5.5. At
this time, standard molecular dynamics and minimization with non-polarizable force ﬁelds are supported.

7.5.1. Solvation Box Size

The non-periodic solvation box super-cell can be deﬁned as variable or ﬁxed in size. When a variable box size
is used, the box size will be adjusted to maintain a minimum buffer distance between the atoms of the solute and
the box boundary. This has the advantage of maintaining the smallest possible box size while adapting to changes
of solute shape and orientation. Alternatively, the box size and grid spacing can be explicitly speciﬁed at run-time
and used for the duration of the calculation.

Regardless of how the solvation box is deﬁned, the “center” of the solute is placed in the middle of the box. The
center of the solute and how it is placed in the solvent box is controlled with the centering keyword. Generally,
centering=1 (center=center-of-mass) is the default and should be used for MD and centering=2 (center=center-of-
geometry) should be used for minimization. Center-of-mass and center-of-geometry are conserved quantities in
each method respectively.

Other options for solute centering are available for special situations. To restrict the absolute position of grid-
points to be integer multiples of the grid-spacing (e.g., (2.5 Å,3.0 Å) for a grid spacing of 0.5 Å) use centering=3
for center-of-mass and centering=4 for center-of-geometry. To perform centering only on the ﬁrst calculation (i.e.,
ﬁrst step of MD or minimization or ﬁrst frame of a trajectory analysis), use the negative integer corresponding to
the desired center deﬁnition. This allows the solute to drift in the solvent box. Finally, with some care, it is possible
to achieve custom centering using centering=0. Here, no solute centering is performed and the solvent grid has an
origin of (0,0,0) and a center of ( x-length
2 + dz). If you use centering=0, it is advisable to
use a ﬁxed-size solvent box.

2 + dx, y-length

2 + dy, z-length

Solvent box dimensions have a strong effect on the numerical precision of 3D-RISM. See Subsection 7.2.3 for

recommendation on selecting an appropriate box size and resolution.

7.5.2. I/O

All 3D-RISM options, including input and output ﬁles, are speciﬁed using mm_options() (see Section 39.1).
Generated output ﬁles can be quite large and numerous. For each type of correlation, a separate ﬁle is produced
for each solvent atom type. The frequency that ﬁles are produced is controlled by the ntwrism parameter. For
every time step that output is produced, a new set of ﬁles is written with the time step number in the ﬁle name. For
example, a molecular dynamics calculation using an SPC/E water model with ntwrism=2 and guvfile=guv will
produce two ﬁles on time step ten: guv.O.10.dx and guv.H1.10.dx.

7.5.3. Examples

Molecular Dynamics

...
mm_options("ntpr=100, ntpr_md=100");
mm_options("dt=0.002");
mm_options("rattle=1");

//Large time step
//Use RATTLE

119

7. Reference Interaction Site Model

mm_options("cut=999.0");

mm_options("rism=1");
mm_options("xvvfile=../rism1d/spc/spc.xvv.save"); //1D-RISM input
...

//No solute-solute
//cut off
//Use 3D-RISM-KH

Minimization

...
mm_options("ntpr=1, cut=999.0");

//No solute-solute
//cut off
//Use 3D-RISM-KH

mm_options("rism=1");
mm_options("xvvfile=../rism1d/spc/spc.xvv.save"); //1D-RISM input
//Low tolerance
mm_options("tolerance=1e-11");
//No solute-solvent
mm_options("solvcut=999.0");
//cut off
//Center solute
//using center-
//of-geometry

mm_options("centering=2");

...

7.5.4. Thermodynamic Output

When nptrism(cid:54)= 0 thermodynamic data about the solvent is output as a table of solute and solvent information.

When using the NAB and rism3d.snglpnt interfaces, units are indicated in the key table or as indicated below.

7.5.4.1. Solute Information

solutePotentialEnergy [kcal/mol] provides the total potential energy of the solute and its decomposition into
the potential energy terms. The solvation free energy for the current 3D-RISM closure is included as this
corresponds to the solvation forces the solute would experience. The energy terms, in order, are Total, LJ,
Coulomb, Bond, Angle, Dihedral, H-Bond, LJ-14, Coulomb-14, Restraints, and 3D-RISM.

7.5.4.2. Solvent Information

Solvent information consists of core set of thermodynamic information and optional solvation free energy cor-
rections. Temperature derivatives and polar/non-polar decomposition is performed when entropicDecomp and
polarDecomp options are used. Temperature derivatives names have a postﬁx of _dT, except for free energies,
which are decomposed into solvationEnergy and -TS. Polar/non-polar components have polar or apolar added to
the front of the quantity name.

rism_excessChemicalPotential [kcal/mol] Excess chemical potential or solvation free energy for the selected

closure (see Section 7.1.2).

rism_excessChemicalPotentialGF [kcal/mol] (Optional) Excess chemical potential or solvation free energy us-

ing the Gaussian ﬂuctuation functional (see Eq. (7.17)).

rism_excessChemicalPotentialPCPLUS [kcal/mol] (Optional) Excess chemical potential or solvation free en-

ergy using the PC+/3D-RISM functional (see Section 7.2.4).

rism_excessChemicalPotentialUC [kcal/mol] (Optional) Excess chemical potential or solvation free energy us-

ing the UC functional (see Section 7.2.4).

120

7.6. rism3d.snglpnt

rism_solventPotentialEnergy [kcal/mol] Interaction energy between the solute and solvent, calculated from

(cid:90)

∆Usol = ∑
α

ρα

drgUV

α (r)uUV

α (r).

rism_excessParticlesCorrected [#] Excess number of solvent particles compared to a uniform distribution at

bulk density.

rism_excessChargeCorrected [e] Excess charge of solvent particles compared to a uniform distribution at bulk

density.

rism_KirkwoodBuff [Å3] All space integral of the total correlation function.

rism_DCFintegral [Å3] All space integral of the direct correlation function.

7.5.5. Compiling MPI 3D-RISM

Executables compiled with mpinab and 3D-RISM must link to both C and Fortran MPI libraries, which is not
the default behavior of most MPI compilers. As there are a wide variety of MPI implementations and no standards
for naming Fortran libraries, 3D-RISM is not included by default when compiling mpinab. The additional steps
required to include 3D-RISM in mpinab are

1. If

a) you are using OpenMPI 1.7 or higher or MPICH, proceed to step 2.
b) you are not using OpenMPI 1.7 or higher or MPICH, identify the Fortran 77 libraries corresponding to
your MPI implementation. These will be found in the lib directory for your MPI implementation and
will likely contain "f" or "f77" in the ﬁle name. Set the XTRA_FLIBS environment variable to contain
the compiler directive to link the library.
For example, the OpenMPI 1.6 and MPICH2 library ﬁles are libmpi_f77.a and libfmpich.a respectively
(the sufﬁx may vary) and XTRA_FLIBS could be explicitly set as:

OpenMPI export XTRA_FLIBS="lmpi_usempif08 -lmpi_mpifh"
MPICH2 export XTRA_FLIBS=-lfmpich

2. Run conﬁgure and specify both -mpi and -rismmpi. For example:

./configure -mpi -rismmpi gnu

3. For dynamically linked executables (the default), set your LD_LIBRARY_PATH environment variable to the

location of your MPI library:
export LD_LIBRARY_PATH=$MPIHOME/lib
$MPIHOME is the base directory for you MPI installation.

where

7.6. rism3d.snglpnt

3D-RISM functionality is also available in the command line tools rism3d.snglpnt and rism3d.snglpnt.MPI in-
stalled at compile time. These programs perform single point 3D-RISM calculations on trajectories and individual
solute snapshots. No other processing is done to the structures so unwanted solvent molecules should be removed
before hand. Except for minimization and molecular dynamics, all 3D-RISM features are available. Thermody-
namic data is always output (see Section 7.5.4). Note that these executables are built by NAB so please see Section
7.5.5 to ensure rism3d.snglpnt.MPI is built.

121

7. Reference Interaction Site Model

7.6.1. Usage

3D-RISM speciﬁc command line keywords generally correspond to keyword options available in NAB’s mm_options

(see Section 39.1). If run without input, rism3d.snglpnt prints default settings for all parameters.

--pdb PDB file (Required, input.) PDB ﬁle for the solute. Coordinates are only used if a restart or trajectory

ﬁle is not supplied.

--prmtop prmtop file (Required, input.) Parameter topology ﬁle for the solute.

--rst restart file (Optional, input.) Coordinates for the solute in restart format.

--y|traj trajectory file (Optional, input.) Trajectory for the solute in NetCDF or ASCII format.

--xvv XVV file (Required, input.) Bulk solvent susceptibility ﬁle from 1D-RISM (see http://ambermd.org/FileFormats.php).

--guv GUV root (Optional, output.) Root name for 3D solvent pair distribution ﬁles.

--cuv CUV root (Optional, output.) Root name for 3D solvent direct correlation ﬁles.

--huv HUV root (Optional, output.) Root name for 3D solvent total correlation ﬁles.

--uuv UUV root (Optional, output.) Root name for 3D solvent potential [kT ] ﬁles.

--asymp asymptotics root (Optional, output.) Root name for 3D real-space long range asymptotics for total
and direct correlation ﬁles. This will produce one ﬁle for each of C and H for each frame requested
and does not include the solvent site charge. Multiply the distribution by the solvent site charge to
obtain the long-range asymptotics for that site.

--quv QUV root (Optional, output.) Root name for 3D solvent charge density distribution ﬁles. This is the

charge density [e/Å] at each grid point with contributions from all solvent types.

--chgdist charge distribution root (Optional, output.) Root name for 3D solvent charge distribution ﬁles.

This gives a point charge [e] at each grid point with contributions from all solvent types.

--exchem

(Optional.) Root name for 3D excess chemical potential distribution ﬁles.

--solvene (Optional.) Root name for 3D solvation energy distribution ﬁles.

--entropy (Optional.) Root name for 3D solvation entropy distribution ﬁles.

--potUV

(Optional.) Root name for 3D solute-solvent potential energy distribution ﬁles.

--molReconstruct (Optional.) For any thermodynamic distributions requested, also out the molecular recon-

struction (see section 7.1.5).

--volfmt

(Optional.) Format of volumetric data ﬁles. May be dx for DX ﬁles or xyzv for XYZV format (see
http://ambermd.org/FileFormats.php).

--closure closure name (Optional.) A whitespace separated list of one or more of KH, HNC or PSEn where
“n” is a positive integer. If more than one closure is provided, the 3D-RISM solver will use the
closures in order to obtain a solution for the last closure in the list when no previous solutions are
available. The solution for the last closure in the list is used for all output. This can be useful for
difﬁcult to converge calculations (see §7.3.1).

--closureorder closure order (Deprecated.) Speciﬁes the order of the PSE-n closure if the closure name is

given as “PSE” or “PSEN” (no integers).

--noasympcorr (Optional.) Turn off long range asymptotic corrections for thermodynamic output only. Long-

range asymptotics are still used to calculate the solution.

122

7.6. rism3d.snglpnt

--buffer distance (Optional.) Minimum distance between the solute and the edge of the solvent box. Use this
with --grdspc. Incompatible with --ng and --solvbox. See §7.2.3 for details on how this affects
numerical accuracy and how this interacts with ljTolerance, and tolerance.

--solvcut distance (Optional.) Sets Lennard-Jones cutoff distance for periodic calculations. If ’-1’ or no value

is speciﬁed then the buffer distance is used.

--grdspc 3D grid spacing (Optional.) Comma separated linear grid spacings for x, y and z dimensions. Use

this with --buffer. Incompatible with --ng and --solvbox.

--ng 3D grid points (Optional.) Comma separated number of grid points for x, y and z dimensions. Use this

with --solvbox. Incompatible with --buffer and --grdspc.

--solvbox 3D box length (Optional.) Comma separated solvation box side length for x, y and z dimensions.
Use this with --ng. Incompatible with --buffer and --grdspc. See §7.2.3 for details on how this
affects numerical accuracy and how this interacts with ljTolerance, and tolerance.

--tolerance residual target (Optional.) A whitespace separated list of maximum residual values for solu-
tion convergence. When used in combination with a list of closures it is possible to deﬁne different
tolerances for each of the closures. This can be useful for difﬁcult to converge calculations (see
§7.3.1). For the sake of efﬁciency, it is best to use as high a tolerance as possible for all but the last
closure. See §7.2.3 for details on how this affects numerical accuracy and how this interacts with
ljTolerance, buffer, and solvbox. Three formats of list are possible.
one tolerance All closures but the last use a tolerance of 1. The last tolerance in the list is used

by the last closure. In practice this, is the most efﬁcient.

two tolerances All closures but the last use the ﬁrst tolerance in the list. The last tolerance in the

list is used by the last closure.

n tolerances Tolerances from the list are assigned to the closure list in order.

--ljTolerance Lennard-Jones accuracy (Optional.) Determines the Lennard-Jones cutoff distance based on
the desired accuracy of the calculation. See §7.2.3 for details on how this affects numerical accuracy
and how this interacts with tolerance, buffer, and solvbox.

--asympKSpaceTolerance reciprocal space long range asymptotics accuracy (Optional.) Determines
the reciprocal space long range asymptotics cutoff distance based on the desired accuracy of the cal-
culation. See §7.2.3 for details on how this affects numerical accuracy. Possible values are
< 0

asympKSpaceTolerance=tolerance/10,
no cutoff, and
given value determines the maximum error in the reciprocal-space long range asymp-
totics calculations.

0
> 0

--treeDCF flag (Optional.) Use direct sum or the treecode approximation to calculate the direct correlation

function long-range asymptotic correction.
0 Use direct sum.
1 Use treecode approximation.

--treeTCF flag (Optional.) Use direct sum or the treecode approximation to calculate the total correlation

function long-range asymptotic correction.
0 Use direct sum.
1 Use treecode approximation.

--treeCoulomb flag (Optional.) Use direct sum or the treecode approximation to calculate the Coulomb poten-

tial energy.

123

7. Reference Interaction Site Model

0 Use direct sum.
1 Use treecode approximation.

--treeDCFMAC acceptance criterion (Optional.) Treecode multipole acceptance criterion for the direct cor-

relation function long-range asymptotic correction.

--treeTCFMAC acceptance criterion (Optional.) Treecode multipole acceptance criterion for the total corre-

lation function long-range asymptotic correction.

--treeCoulombMAC acceptance criterion (Optional.) Treecode multipole acceptance criterion for the Coulomb

potential energy.

--treeDCFOrder order (Optional.) Treecode Taylor series order for the direct correlation function long-range

asymptotic correction.

--treeTCFOrder order (Optional.) Treecode Taylor series order for the total correlation function long-range
asymptotic correction. Note that the Taylor expansion used does not converge exactly to the TCF
long-range asymptotic correction, so a very high order will not necessarily increase accuracy.

--treeCoulombOrder order (Optional.) Treecode Taylor series order for the Coulomb potential energy.

--treeDCFN0 leaf size (Optional.) Maximum number of grid points contained within the treecode leaf clus-
ters for the direct correlation function long-range asymptotic correction. This sets the depth of the
hierarchical octtree.

--treeTCFN0 leaf size (Optional.) Maximum number of grid points contained within the treecode leaf clus-
ters for the total correlation function long-range asymptotic correction. This sets the depth of the
hierarchical octtree.

--treeCoulombN0 leaf size (Optional.) Maximum number of grid points contained within the treecode leaf

clusters for the Coulomb potential energy. This sets the depth of the hierarchical octtree.

--mdiis_del step size (Optional.) MDIIS step size.

--mdiis_nvec # of vectors (Optional.) Number of previous iterations MDIIS uses to predict a new solution.

--mdiis_restart # of vectors (Optional.) If the current residual is mdiis_restart times larger than the
smallest residual in memory, then the MDIIS procedure is restarted using the lowest residual solution
stored in memory. Increasing this number can sometimes help convergence.

--maxstep step number (Optional.) Maximum number of iterative steps per solution.

--npropagate # old solutions (Optional.) Number of previous solutions to use in predicting a new solution.

--polarDecomp (Optional.) Decomposes solvation free energy into polar and non-polar components. Note that

this typically requires 80% more computation time.

--entropicDecomp (Optional.) Decomposes solvation free energy into energy and entropy components. Also
performs temperature derivatives of other calculated quantities. Note that this typically requires 80%
more computation time and requires a .xvv ﬁle version 1.000 or higher (see §7.1.3 and 7.3).

--gf

--pc+

(Optional.) Compute the Gaussian ﬂuctuation excess chemical potential functional (see §7.1.2).

(Optional.) Compute the PC+/3D-RISM excess chemical potential functional (see §7.2.4).

--uccoeff a,b[,a1,b1] (Optional.) Compute the UC excess chemical potential functional with the provided
coefﬁcients (see §7.2.4). a and b are the coefﬁcients for the original UC functional, though using
the closure excess chemical potential functional. a1 and b1 are optional and provide temperature
dependence to the correction (UCT in [275]).

124

7.7. 3D-RISM in sander

--centering method (Optional.) Select how solute is centered in the solvent box.

-4 Center-of-geometry with grid-point rounding. Center on ﬁrst step only.
-3 Center-of-mass with grid-point rounding. Center on ﬁrst step only.
-2 Center-of-geometry. Center on ﬁrst step only.
-1 Center-of-mass. Center on ﬁrst step only.
0 No centering. Dangerous.
1 Center-of-mass. Center on every step. Recommended for molecular dynamics.
2 Center-of-geometry. Center on every step. Recommended for minimization.
3 Center-of-mass with grid-point rounding.
4 Center-of-geometry with grid-point rounding.

--verbose level (Optional.)

0 No output.
1 Print the number of iterations required to converge.
2 Print convergence details for each iteration.

7.7. 3D-RISM in sander

3D-RISM functionality is available in sander and is built as part of the standard install procedure. MPI func-
tionality for 3D-RISM in sander requires some additional information at compile time, described in Section 7.5.5.
Some features speciﬁc to sander are discussed here.

7.7.1. Multiple Time Step Methods for 3D-RISM

At this time, the computational cost of 3D-RISM is still prohibitive for performing calculations at each step of
molecular dynamics calculations. One of the most effective ways to reduce this computational burden is to reduce
the number of solutions calculated by using multiple time step (MTS) methods. Two MTS methods, r-RESPA and
force-coordinate extrapolation (FCE), are implemented for 3D-RISM in sander and can be combined such that
solutions are only calculated once every 4 ps [286].

r-RESPA[287, 288] and I-Verlet[289] impulse MTS algorithms are widely used methods to reduce the compu-
tational load of long-range interactions while maintaining the desirable properties of energy conservation and time
reversibility. Impulse MTS can be invoked for 3D-RISM independent of the existing r-RESPA implementation
using the RISMnRESPA variable. For typical biomolecular simulations, impulse MTS is limited to a maximum
step size of 8 fs if using the optimized Nose-Hoover thermostat (ntt=9) and 5 fs[290] for the Langevin thermostat.
Since the computational load of calculating all internal interactions of the solute is small compared to the 3D-RISM
calculation, it is recommend to use dt=0.001, nrespa=1 and RISMnRESPA=2 or 5, depending on the integrator.
To overcome the stability limitation of impulse MTS, FCE uses one of several available extrapolation methods
to efﬁciently predict the forces for some time steps rather than computing a full 3D-RISM solution[240, 291].
In the simplest extrapolation scheme, corresponding to FCEntrans=0, forces, {F}, on NU solute atoms for the
current time step tk are approximated as a linear combination of forces from the n previous time steps obtained
from 3D-RISM calculations,

{F}(k) =

akl {F}(l) ,

l ∈ 3D-RISM steps.

n

∑

l=1

(7.22)

The weight coefﬁcients akl are obtained by expressing the current set of coordinates, {R}(k), as a linear combination
of coordinates from the n previous time steps for which 3D-RISM calculations were performed. That is, the current
set of coordinates is projected onto the basis of n previous solute arrangements by minimizing the norm of the

125

7. Reference Interaction Site Model

Figure 7.1.: Multiple time step methods in 3D-RISM. RISMnRESPA(= 5) is the number of base time steps between
application of solvation forces (exact or extrapolated). FCEnbasis(= 4) is the number of previous
solutions used to extrapolate forces, in this case four previous solutions. Once FCEnbasis solutions
have be calculated, exact 3D-RISM forces are calculated every FCEstride(= 2)×RISMnRESPA time
steps; solvation forces are otherwise obtained through extrapolation.

difference between the current 3× NU matrix of coordinates {R}(k) and the corresponding linear combination of
the previous ones {R}(l),

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12){R}(k) − n

∑

l=1

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2

minimize

akl {R}(l)

.

Coefﬁcients akl are then used in Equation (7.22)to extrapolate forces at the current intermediate time step. Simi-
larly, the known coordinates for the current time step can be approximated from previous time steps as

{R}(k) =

akl {R}(l) .

N

∑

l=1

Five extrapolation methods are available (FCEntrans=0-4, see below) and each differs in computational cost
along with the largest permitted outer time step, ranging from 20 fs (FCEntrans=4 with Langevin dynamics,
ntt=3) all the way up to 4 ps (FCEntrans=6 using OIN, ntt=9). The latter procedures utilize a more complex
extrapolation protocol than pictured above, involving a rotation of the outer basis coordinates and coefﬁcient weight
normalization and minimization. For a detailed description of these methods, please refer to [291] and [286]. Note
that FCE MTS does not conserve energy and is not time reversible.

Combined impulse FCE MTS calculations (see Figure 7.1) start the simulation using impulse MTS, where
full RISM-3D solutions are computed every RISMnRESPA time steps until the requested size for the basis set,
FCEnbasis, is achieved. After a large enough basis set is collected, 3D-RISM calculations are only performed
once every FCEstride× RISMnRESPA time steps, and FCEnbase of FCEnbasis saved coordinates are used for
one of the above extrapolation procedures every RISMnRESPA intermediate time steps. The FCEnbase coordinates
represent an optimized subset of FCEnbasis, found through distance minimization with the current solute coordi-
nate. Note that large inaccuracies in the force extrapolation can ensue if FCEnbase is equal to the number of solute
degrees freedom.

7.7.2. 3D-RISM in sander

Full 3D-RISM functionality is available in sander as part of the standard install procedure. However, some
methods available in sander are not compatible with 3D-RISM, such as QM/MM simulations. At this time, only
standard molecular dynamics, minimization and trajectory post-processing with non-polarizable force ﬁelds are
supported. With the exception of multiple time step features, 3D-RISM keywords in sander are identical to those
in NAB, rism3d.snglpnt and MMPBSA.py.

3D-RISM speciﬁc command line options for sander are

126

}RISMnRESPAFCEstride X RISMnRESPAFCEnbasisForceTimeextrapolatedsolvation forcessolvationforces7.7. 3D-RISM in sander

sander [standard options] -xvv xvvfile -guv guvroot -huv huvroot

-cuv cuvroot -uuv uuvroot -asymp asympfile
-quv quvroot -chgdist chgdistroot
-exchem exchemroot -solvene solveneroot -entropy entropyroot -potUV potUVroot

xvvﬁle input description of bulk solvent properties, required for 3D-RISM calculations. Produced by rism1d.

guvroot output root name for solute-solvent 3D pair distribution function, GUV(R). This will produce one ﬁle for

each solvent atom type for each frame requested.

huvroot output root name for solute-solvent 3D total correlation function, HUV(R). This will produce one ﬁle for

each solvent atom type for each frame requested.

cuvroot output root name for solute-solvent 3D total correlation function, CUV(R). This will produce one ﬁle for

each solvent atom type for each frame requested.

uuvroot output root name for solute-solvent 3D potential energy function, U UV(R), in units of kT . This will

produce one ﬁle for each solvent atom type for each frame requested.

asympﬁle output root name for solute-solvent 3D long-range real-space asymptotics for C and H. This will
produce one ﬁle for each of C and H for each frame requested and does not include the solvent site charge.
Multiply the distribution by the solvent site charge to obtain the long-range asymptotics for that site.

quvroot output root name for solute-solvent 3D charge density distribution [e/Å]. This will produce one ﬁle that

combines contributions from all solvent atom types for each frame requested.

chgdistroot output root name for solute-solvent 3D charge distribution [e]. This will produce one ﬁle that com-

bines contributions from all solvent atom types for each frame requested.

exchemroot output root name for 3D excess chemical potential distribution ﬁles.

solveneroot output root name for 3D solvation energy distribution ﬁles.

entropyroot output root name for 3D solvation entropy distribution ﬁles.

potUVroot output root name for 3D solute-solvent potential energy distribution ﬁles.

Generated output ﬁles can be large and numerous. For each type of correlation, a separate ﬁle is produced for each
solvent atom type. The frequency that ﬁles are produced is controlled by the ntwrism parameter. Every time step
that output is produced, a new set of ﬁles is written with the time step number in the ﬁle name. For example, a
molecular dynamics calculation using an SPC/E water model with ntwrism=2 and -guv guv on the command line
will produce two ﬁles on time step ten: guv.O.10.dx and guv.H1.10.dx.

7.7.2.1. Keywords

With the exception of irism, which is found in the &cntrl name list, all 3D-RISM options are speciﬁed in the

&rism name list.

irism

[0] Use 3D-RISM. Found in &cntrl name list.

= 0 Off.
= 1 On.

127

7. Reference Interaction Site Model

Closure Approximation

closure

[KH] Comma separate list of closure approximations. If more than one closure is provided, the 3D-
RISM solver will use the closures in order to obtain a solution for the last closure in the list when no
previous solutions are available. The solution for the last closure in the list is used for all output.

= KH Kovalenko-Hirata (KH).
= HNC Hyper-netted chain equation (HNC).
=PSEn Partial series expansion of order-n (PSE-n), where “n” is a positive integer.

Solvation Free Energy Corrections

gfCorrection [0] Compute the Gaussian ﬂuctuation excess chemical potential functional (see §7.1.2).

= 0 Off.
= 1 On.

pcpluscorrection [0] Compute the PC+/3D-RISM excess chemical potential functional (see §7.2.4).

= 0 Off.
= 1 On.

uccoeff

[0,0,0,0] Compute the UC excess chemical potential functional with the provided coefﬁcients (see
§7.2.4). a and b are the coefﬁcients for the original UC functional, though using the closure excess
chemical potential functional. a1 and b1 are optional and provide temperature dependence to the
correction (UCT in [275]).

Long-range asymptotics Long-range asymptotics are used to analytically account for solvent distribution be-
yond the solvent box. Long-range asymptotics are always used when calculating a solution but can be omitted for
the subsequent thermodynamic calculations, though it is not recommended.

asympcorr [T] Use long-range asymptotic corrections for thermodynamic calculations.

= T Use the long-range corrections.
= F Do not use long-range corrections.

treeDCF

[1] Use direct sum or the treecode approximation to calculate the direct correlation function long-
range asymptotic correction.

0 Use direct sum.
1 Use treecode approximation.

treeTCF

[1] Use direct sum or the treecode approximation to calculate the total correlation function long-
range asymptotic correction.

0 Use direct sum.
1 Use treecode approximation.

treeCoulomb [0] Use direct sum or the treecode approximation to calculate the Coulomb potential energy.

0 Use direct sum.
1 Use treecode approximation.

treeDCFMAC [0.1] Treecode multipole acceptance criterion for the direct correlation function long-range asymp-

totic correction.

128

7.7. 3D-RISM in sander

treeTCFMAC [0.1] Treecode multipole acceptance criterion for the total correlation function long-range asymptotic

correction.

treeCoulombMAC [0.1] Treecode multipole acceptance criterion for the Coulomb potential energy.

treeDCFOrder [2] Treecode Taylor series order for the direct correlation function long-range asymptotic correc-

tion.

treeTCFOrder [2] Treecode Taylor series order for the total correlation function long-range asymptotic correc-
tion. Note that the Taylor expansion used does not converge exactly to the TCF long-range asymp-
totic correction, so a very high order will not necessarily increase accuracy.

treeCoulombOrder [2] Treecode Taylor series order for the Coulomb potential energy.

treeDCFN0 [500] Maximum number of grid points contained within the treecode leaf clusters for the direct
correlation function long-range asymptotic correction. This sets the depth of the hierarchical octtree.

treeTCFN0 [500] Maximum number of grid points contained within the treecode leaf clusters for the total cor-

relation function long-range asymptotic correction. This sets the depth of the hierarchical octtree.

treeCoulombN0 [500] Maximum number of grid points contained within the treecode leaf clusters for the Coulomb

potential energy. This sets the depth of the hierarchical octtree.

Solvation Box The non-periodic solvation box super-cell can be deﬁned as variable or ﬁxed in size. When a
variable box size is used, the box size will be adjusted to maintain a minimum buffer distance between the atoms
of the solute and the box boundary. This has the advantage of maintaining the smallest possible box size while
adapting to changes of solute shape and orientation. Alternatively, the box size can be speciﬁed at run-time. This
box size will be used for the duration of the sander calculation.

Solvent box dimensions have a strong effect on the numerical precision of 3D-RISM. See Subsection 7.2.3 for

recommendation on selecting an appropriate box size and resolution.

solvcut

[buffer] Sets Lennard-Jones cutoff distance for periodic calculations. If ’-1’ or no value is speciﬁed
then the buffer distance is used.

Variable Box Size

buffer

[14] Minimum distance in Å between the solute and the edge of the solvent box. See §7.2.3 for details
on how this affects numerical accuracy and how this interacts with ljTolerance, and tolerance.

< 0 Use ﬁxed box size (ng3 and solvbox).
>= 0 Buffer distance.

grdspc

[0.5,0.5,0.5] Linear grid spacing in Å.

Fixed Box Size

ng3

[] Sets the number of grid points for a ﬁxed size solvation box. This is only used if buffer< 0.

nx,ny,nz

Points for x, y and z dimensions.

solvbox

[] Sets the size in Å of the ﬁxed size solvation box. This is only used if buffer< 0. See §7.2.3
for details on how this affects numerical accuracy and how this interacts with ljTolerance, and
tolerance.

lx,ly,lz

Box length in x, y and z dimensions.

129

7. Reference Interaction Site Model

Solution Convergence

tolerance [1e-5] A list of maximum residual values for solution convergence. When used in combination with a
list of closures it is possible to deﬁne different tolerances for each of the closures. This can be useful
for difﬁcult to converge calculations (see Subsection 7.4.1 for details). For the sake of efﬁciency, it
is best to use as high a tolerance as possible for all but the last closure. For minimization a tolerance
of 1e-11 or lower is recommended. See §7.2.3 for details on how this affects numerical accuracy and
how this interacts with ljTolerance, buffer, and solvbox. Three formats of list are possible.

one tolerance All closures but the last use a tolerance of 1. The last tolerance in the list is used

by the last closure. In practice this, is the most efﬁcient.

two tolerances All closures but the last use the ﬁrst tolerance in the list. The last tolerance in the

list is used by the last closure.

n tolerances Tolerances from the list are assigned to the closure list in order.

ljTolerance [-1] Determines the Lennard-Jones cutoff distance based on the desired accuracy of the calculation.
See §7.2.3 for details on how this affects numerical accuracy and how this interacts with tolerance,
buffer, and solvbox.

asympKSpaceTolerance [-1] Determines the reciprocal space long range asymptotics cutoff distance based on the
desired accuracy of the calculation. See §7.2.3 for details on how this affects numerical accuracy.
Possible values are
< 0

asympKSpaceTolerance=tolerance/10,

0

> 0

no cutoff, and
given value determines the maximum error in the reciprocal-space long range asymp-
totics calculations.

mdiis_del [0.7] “Step size” in MDIIS.

mdiis_nvec [5] Number of vectors used by the MDIIS method. Higher values for this parameter can greatly

increase memory requirements but may also accelerate convergence.

mdiis_restart [10] If the current residual is mdiis_restart times larger than the smallest residual in memory,
then the MDIIS procedure is restarted using the lowest residual solution stored in memory. Increasing
this number can sometimes help convergence.

mdiis_method [2] Specify implementation of the MDIIS routine.

= 0 Original. For small systems (e.g. < 643 grid points) this implementation may be faster than the

BLAS optimized version.

= 1 BLAS optimized.
= 2 BLAS and memory optimized.

maxstep

[10000] Maximum number of iterations allowed to converge on a solution.nrespa

npropagate [5] Number of previous solutions propagated forward to create an initial guess for this solute atom

conﬁguration.

= 0 Do not use any previous solutions
= 1..5 Values greater than 0 but less than 4 or 5 will use less system memory but may introduce

artifacts to the solution (e.g., energy drift).

130

7.7. 3D-RISM in sander

Minimization and Molecular Dynamics

centering [1] Controls how the solute is centered/re-centered in the solvent box.

= -4 Center-of-geometry with grid-point rounding. Center on ﬁrst step only.
= -3 Center-of-mass with grid-point rounding. Center on ﬁrst step only.
= -2 Center-of-geometry. Center on ﬁrst step only.
= -1 Center-of-mass. Center on ﬁrst step only.
= 0 No centering. Dangerous.
= 1 Center-of-mass. Center on every step. Recommended for molecular dynamics.
= 2 Center-of-geometry. Center on every step. Recommended for minimization.
= 3 Center-of-mass with grid-point rounding.
= 4 Center-of-geometry with grid-point rounding.

zerofrc

[1] Redistribute solvent forces across the solute such that the net solvation force on the solute is zero.
= 0 Unmodiﬁed forces.
= 1 Zero net force.

Trajectory Post-Processing

apply_rism_force [1] Calculate and use solvation forces from 3D-RISM. Not calculating these forces can save

computation time and is useful for trajectory post-processing.
= 0 Do not calculate forces.
= 1 Calculate forces.

Multiple Time Steps Multiple time step features are only available in sander.
rismnrespa [1] rismnrespa× dt =RISM RESPA multiple time step. 8 fs is the maximum time step if using
optimized-isokinetic integrator (ntt=9), and 5 fs using Langevin dynamics (ntt=3). “1” corresponds
to no multiple time stepping.

fcestride [0] fcestride× rismnrespa× dt = FCE multiple time step, also called outer time step, i.e., full
3D-RISM solutions are performed every fcestride× rismnrespa steps. In between full solutions
extrapolated force impulses are applied every rismnrespa steps. “1” corresponds to no multiple
time stepping.
= 0 No FCE multiple time stepping.
= 1 Invokes the FCE code but yields the same trajectories as 0.
>= 1 Invoke FCE with 3D-RISM solutions every fcestride× rismnrespa steps.

fcenbasis [20] Number of previous full solutions to store, fcenbase of these are used for the force extrapola-

tion. If FCE is not desired this can be set to 1 to reduce memory usage.

fcenbase

fcesort

[20] The number of previous solutions to use for the force extrapolation. This is a subset of fcenbasis
and must be <= fcenbasis. If fcenbase < fcenbasis, then an optimized subset of fcenbasis is
found through minimization of the square distances with the current coordinate - the fcenbase clos-
est solutions are chosen. Options for this selection can be found in the commands that follow.

[0] Sort the fcenbase basis vectors for the extrapolation according to increasing distance from the
current coordinate. May decrease roundoff errors.
= 0 No sorting is performed (default).

131

7. Reference Interaction Site Model

= 1 Sorting is performed.

fcecrd

[0] The coordinates used for the FCE method.
= 0 The absolute x, y, z position of each neighbor atom (with translations due to centering).
= 1 For predicting the forces on atom i, use the distance of each neighbor atom as the “coordinate”.
This has one third the number of coordinates to use in the prediction. Also, directional infor-
mation is lost.

= 2 For predicting the forces on atom i, use the x, y, z position of each neighbor atom with atom i as

the origin. Recommended.

fceweigh

[0] Use weighted coordinates for the force extrapolation. Works with fcetrans = [1], [2], or [3].
= 0 No weighting of the coordinates is performed (default).
= 1 Weighting of basis coordinates in the extrapolation. Expensive but more precise.

fceenormsw [0] Balancing minimization of the squared norm of the basis expansion coefﬁcients from least
squares ﬁtting. Speciﬁes the magnitude of the parameter ε2 of an additional constraint added to
the least squares ﬁtting problem that balances the equations and resulting coefﬁcients, improving the
quality and stability of the force extrapolation. Used only if fcetrans=2.
= 0 No weight minimization is performed (default).
> 0 Minimization is performed with speciﬁed balancing parameter fceenormsw. This parameter
should in general be small as the squared norm is being minimized, and should be optimized to
the value that produces the most accurate results from simulation.

[0] The method of transformation of the outer basis coordinates and the method of ﬁnding expansion
coefﬁcients in the least squares minimization problem. It can signiﬁcantly affect the permitted size
of the outer time step. Transformations involve a non-Eckhart rotation of all fcenbasis coordinates.
In the least squares minimization problem, for the QR decomposition method, normalization is used
if fcenbase > solute degrees of freedom.
= 0 (Default) No coordinate transformation of the outer basis coordinates. Fast but not precise and
should only be invoked if using small outer time steps (up to 200fs). Method of QR decompo-
sition is used for ﬁnding expansion coefﬁcients from least squares minimization.

= 1 Transformation of basis coordinates with respect to the ﬁrst (most recent) basis coordinate, from
these the fcenbase subset is selected by minimum distance from current (also rotated) coor-
dinate. QR decomposition is used for the least squares minimization. Permits large outer time
steps on the order of several picoseconds. Fastest with regard to [2] and [3].

= 2 ASFE extrapolation:

like [1], transformation of basis coordinates with respect to ﬁrst basis
point, but normal equations method is utilized instead of QR, with additional squared norm
minimization, speciﬁed by fceenormsw. An extra precision and stability is gained with small,
positive values of fcernormsw. Most advanced method in Amber 15. This represents the ASFE
extrapolation scheme as laid out in [291].

= 3 (place holder, same as 2 above)
= 4 Basic force extrapolation - no coordinate transformation, weighting, selecting, and sorting. Only
small outer time steps, on the order of tens of fs, are permitted. This is the method as imple-
mented in Amber 11.

= 5 GSFE extrapolation 1: Individual transformation and selecting with respect to the current co-
ordinate of each atom using a neighbouring scheme complemented by the e-minimization and
ifreq-scheme (see fceifreq below) as well as all other developed techniques. It is recommended
for large macromolecules of greater than 10 Å in size and can be used with very large outer
steps (up to order of several picoseconds). See [292]for detailed explaination. This represents
the one of the two new GSFE extrapolation schemes (Generalized Solvent Force-coordinate
Extrapolation) as presented in [292].

fcetrans

132

7.7. 3D-RISM in sander

= 6 GSFE extrapolation 2: Individual transformation and selecting with respect to the post coordi-
nate of each atom using a neighbouring scheme compemented by the e-minimization and the
full ifreq-support. It is recommended for large macromolecules and can be used with huge
outer steps (up to order of several picoseconds). It appears to be better than the above case
fcetrans=5 (partial ifreq-support version) because it can be exploited with larger number (up
to N~100-200) of basic points providing a higher accuracy (with nearly the same computa-
tional efforts as the fcetrans=5-version at N~30), but may require more memory. Note that at
any values of fceifreq, both the approaches have the same scheme for building the index mask
which maps the extended set to the best subset and differ in the way of constructing the trans-
formation matrix. At fceifreq=1, these two approaches are equivalent. This is the second GSFE
scheme presented in [292] and [286] and represents the most advanced 3D-RISM solvent force
extrapolation scheme available in AMBER to date.

fceifreq

Extended to basic mapping list updating frequency used in the GSFE FCE extrapolation schemes
above. If fceifreq=1 then fcetrans=6 is equivalent to fcetrans=5. See [292]for detailed explaination.
Default value is 1.

fcentfrcor Net force correction ﬂag for GSFE force extrapolation (fcetrans=5 and fcetrans=6). If fcentfrcor >
0, a correction factor is subtracted from the extrapolated forces. See [292]for in depth explaination.
Default is 0.

Output

ntwrism

[0] Indicates that solvent density grid should be written to ﬁle every ntwrism iterations.
= 0 No ﬁles written.
>= 1 Output every ntwrism time steps.

molReconstruction [0] For any thermodynamic distributions requested, also out the molecular reconstruction

(see section 7.1.5).

volfmt

verbose

[‘DX’] Format of volumetric data ﬁles. May be ’dx’ for DX ﬁles or ’xyzv’ for XYZV format. See the
AmberTools manual for more information.

[0] Indicates level of diagnostic detail about the calculation written to the log ﬁle.
= 0 No output.
= 1 Print the number of iterations used to converge.
= 2 Print details for each iteration and information about what FCE is doing every progress itera-

tions.

write_thermo [1] Print solvation thermodynamics in addition to standard sander output. The format is the same

as that found in NAB and rism3d.snglpnt.

polarDecomp [0] Decomposes solvation free energy into polar and non-polar components. Note that this typically

requires 80% more computation time.
= 0 No polar/non-polar decomposition.
= 1 Polar/non-polar decomposition.

entropicDecomp [0] Decomposes solvation free energy into energy and entropy components. Also performs
temperature derivatives of other calculated quantities. Note that this typically requires 80% more
computation time and requires a .xvv ﬁle version 1.000 or higher (see §7.1.3 and 7.3).
= 0 No entropic decomposition.
= 1 Entropic decomposition.

progress

[1] Display progress of the 3D-RISM solution every kshow iterations. 0 indicates this information
will not be displayed. Must be used with verbose > 1.

133

7. Reference Interaction Site Model

7.7.2.2. Example

Molecular Dynamics (imin=0)

molecular dynamics with 3D-RISM and impulse MTS
&cntrl

ntx=1, ntpr=100, ntwx=1000,ntwr=10000,
nstlim=10000,dt=0.001,
ntt=3, temp0=300, gamma_ln=20,
ntb=0,
cut=999.,

!No shake or r-RESPA
!Langevin dynamics
!Non-periodic
!Calculate all
!solute-solute
!interactions

irism=1,

/
&rism

rismnrespa=5,
fcenbasis=10,fcestride=2,fcecrd=2

!r-RESPA MTS
!FCE MTS

/

Minimization (imin=1)

Default XMIN minimization with 3D-RISM
&cntrl

imin=1, maxcyc=200,
drms=1e-3,
ntmin=3,
ntpr=5,
ntb=0,
cut=999.,

!RMS force. Can be as low as 1e-4
!XMIN

!Non-periodic
!Calculate all
!solute-solute interactions

irism=1

/
&rism

tolerance=1e-11,
solvcut=9999,

centering=2

!Low tolerance
!No cut-off for
!solute-solvent interactions
!Solvation box centering
!using center-of-geometry

/

Trajectory Post-Processing (imin=5)

Trajectory post-processing with 3D-RISM
&cntrl

!Single-point energy calculation
!on each frame
!Non-periodic
!Calculate all
!solute-solute interactions

ntx=1, ntpr=1, ntwx=1,
imin=5,maxcyc=1,

ntb=0,
cut=9999.,

irism=1

/
&rism

134

tolerance=1e-4,
apply_rism_force=0,
npropagate=1

!Saves some time compared to 1e-5
!Saves some time. Forces are not used.
!Saves some time and 4*8*Nbox bytes
!of memory compared to npropagate=5.

7.8. RISM File Formats

/

7.8. RISM File Formats

7.8.1. MDL

Solvent MoDeL (MDL) ﬁles use the prmtop speciﬁcation. Each of the following sections may appear in the ﬁle

in any order. The Fortran string format speciﬁcations can be different from the recommend values below.

%VERSION VERSION_STAMP = Vxxxx.yyy DATE = mm:dd:yy hh:mm:ss

The current version of the format is 0001.000. Date should be the date and time the ﬁle is created.

%FLAG TITLE
%FORMAT(20a4)

Optional description of the ﬁle.

%FLAG POINTERS
%FORMAT(10I8)

Deﬁnes the lengths of arrays in the ﬁle.

NATOM

NSITE

Number of physical atoms in the model.

Number of unique solvent sites (share common Lennard-Jones parameters and partial charges).

%FLAG ATMNAME
%FORMAT(20a4)

CHARACTER(len=4)(NSITE) Four character name of each solvent site.

%FLAG MASS
%FORMAT(5e16.8)

REAL*8(NSITE) Mass of each solvent site (amu).

%FLAG CHG
%FORMAT(5e16.8)

REAL*8(NSITE) Partial charge for each solvent site, 18.2223e (

%FLAG LJEPSILON
%FORMAT(5e16.8)

(cid:112)

kT Å).

REAL*8(NSITE) Lennard-Jones ε for each solvent site (kcal/mol).

%FLAG LJSIGMA
%FORMAT(5e16.8)

REAL*8(NSITE) Lennard-Jones rmin/2 (sometimes called σ∗

αγ =(cid:112)εαεγ

U LJ

(cid:32)(cid:18) rmin,α + rmin,γ

/2) for each solvent site (Å)

(cid:19)12 − 2

(cid:18) rmin,α + rmin,γ

2r

2r

Note that this is related to the commonly used σ as

σ = rmin2−1/6.

(cid:19)6(cid:33)

.

135

7. Reference Interaction Site Model

%FLAG MULTI
%FORMAT(10I8)

INTEGER*4(NSITE) Multiplicity of each solvent site. This should sum to NATOM.

%FLAG COORD
%FORMAT(5e16.8)

REAL*8(3*NATOM) xyz-coordinates of each atom (Å).

7.8.2. XVV

The .xvv ﬁle provides all of the bulk-solvent information required for 3D-RISM. This includes information
about the solvent model, thermodynamic state and the necessary correlation functions. .xvv ﬁles use the prmtop
speciﬁcation. Each of the following sections may appear in the ﬁle in any order. The format speciﬁcations can be
different from the recommend values below.

1D- and 3D-RISM now use version 1.000 of the ﬁle format. Differences include

• additional information about solvent, such as mass, number of sites per species, coordinates;

• RISM’s internal system of units is now used;

• temperature derivative, DELHV0_DT and XVV_DT, are included when available (see 7.4.1);

• and SIGV has been replaced by RMIN2V.

All 3D-RISM interfaces still support the original 0.001 version of the format. For detailed information on version
0.001, please see the AmberTools 1.5 manual.

%VERSION VERSION_STAMP = V0001.000 DATE = mm:dd:yy hh:mm:ss

The current version of the format is 0001.000. Date should be the date and time the ﬁle is created.

%FLAG POINTERS
%FORMAT(10I8)

Deﬁnes the lengths of arrays in the ﬁle.

NR

NV

NSP

Number of 1D grid points in χVV

ab (k).

Number of total solvent sites.

Number of solvent species (molecules).

%FLAG THERMO
%FORMAT(1PE24.16)

REAL(8)(6) Temperature [K], dielectric constant, inverse Debye length (κ) [Å], compressibility [Å−3], grid spac-

ing [Å], charge smear [Å].

%FLAG ATOM_NAME
%FORMAT(20A4)

CHARACTER(len=4)(NSITE) Four character name of each solvent site.

%FLAG MTV
%FORMAT(10I8)

INTEGER(4)(NSITE) Multiplicity of each solvent site.

136

7.8. RISM File Formats

%FLAG NVSP
%FORMAT(10I8)

INTEGER(4)(NSP) Number of sites for each solvent species.

%FLAG MASS
%FORMAT(1P5E16.8)

REAL(8)(NSITE) Mass of each solvent site (g/mol).

%FLAG RHOV
%FORMAT(1P5E16.8)

REAL(8)(NSITE) Number density of each solvent site (Å−3).

REAL(8)(NSITE) Partial charge for each solvent site multiplied by the square root of the Coulomb constant,

%FLAG QV
%FORMAT(1P5E16.8)

(cid:112)

(cid:112)

~18.2223 (

kT Å).

%FLAG QSPV
%FORMAT(1P5E16.8)

~18.2223 (

kT Å).

REAL(8)(NSPECIES) Net charge for each solvent species multiplied by the square root of the Coulomb constant,

%FLAG EPSV
%FORMAT(1P5E16.8)

REAL(8)(NSITE) Lennard-Jones ε for each solvent site (kT ).

%FLAG RMIN2V
%FORMAT(1P5E16.8)

REAL(8)(NSITE) Lennard-Jones rmin/2 (σ∗

/2) for each solvent site (Å).

%FLAG DELHV0
%FORMAT(1P5E16.8)

(cid:112)

REAL(8)(NSITE) Long range Coulomb correction for each solvent site (

kT Å).

%FLAG DELHV0_DT
%FORMAT(1P5E16.8)

(cid:112)

REAL(8)(NSITE) (Optional) Temperature derivative long range Coulomb correction for each solvent site (

kT Å).

%FLAG COORD
%FORMAT(1P5E16.8)

REAL(8)(3*sum(MTV)) Coordinates of all atoms (not sites) for each solvent species with the dipole moment

aligned with the z-axis (Å).

%FLAG XVV
%FORMAT(1P5E16.8)

REAL(8)(NR,NSITE,NSITE) χVV

ab (k). This array is stored in column major order. That is, the NR index varies

fastest.

%FLAG XVV_DT
%FORMAT(1P5E16.8)

REAL(8)(NR,NSITE,NSITE) (Optional) δT χVV

ab (k). This array is stored in column major order. That is, the NR

index varies fastest.

137

7. Reference Interaction Site Model

7.8.3. Site-site functionals

All .*vv ﬁles, except .xvv (see §7.8.2), provide the separation dependence of all site-site pairings for a particular
functional and use the same format. The ﬁrst four lines have a “#” in the ﬁrst character column, provide a descrip-
tion of the contents of the ﬁle and indicate site-site pairs. The ﬁrst data column is the site-site separation and the
remaining columns provide the value of the functional for the site-site pair at this separation.

The following example is for the direct correlation function (.cvv) for pure water. A standard, ‘two-site’ water

model is used, consisting of oxygen (O) and hydrogen (H1). This gives one solvent species with two atoms.

#RISM1D ATOM-ATOM INTERACTIONS: DIRECT CORRELATION VS. SEPARATION [A]
#S=SPECIES, A=ATOM
#
#

SEPARATION
SEPARATION

S1A1:S1A2

S1A2:S1A2

S1A1:S1A1

H1:H1

H1:O

O:O

0.00000000E+000 -3.81875841E+002
2.50000000E-002 -3.81695327E+002

1.64156197E+002 -9.24562553E+001
1.64139031E+002 -9.24384608E+001

7.8.4. Thermodynamics

Thermodynamic output is divided into global, species and site properties sections. Global properties are gen-
erally not decomposable into species or site contributions (e.g., pressure). Species properties are the values for
individual molecular species, for example, the excess chemical potential of a single molecule. Some of these
properties, such as the partial molar volume, may not be decomposible into individual sites. Site properties are
contributions from individual sites. Values for sites from the same species will sum to give the total value for the
species.

The ﬁle format is white-space delimited with the ﬁrst three columns giving a description, variable name and
units of the property calculated. The remaining columns contain the calculated values for the system, species or
site. Descriptive lines are indicated with a leading “#”.

The following example is for a standard, ‘two-site’ water model is used, consisting of oxygen (O) and

hydrogen (H1), at standard temperature and density. In this calculation, energy/entropy free energy
decomposition is also performed. I.e., EXCHEMsp = ESOLVsp− TSsp.

Variable
xi
Pvir
FE

Variable
EXCHEMsp
ESOLVsp

#Global properties
#Description
Compressibility
Pressure_(Virial)
Excess_free_energy
#Species properties
#Description
Excess_chemical_potential
Solvation_energy
-Temperature*solvation_entropy -TSsp
Partial_molar_volume
#Site properties
#Description
Excess_chemical_potential
Solvation_energy
-Temperature*solvation_entropy -TSv

PMV

Variable
EXCHEMv
ESOLVv

Units
[10e-4/MPa]
[MPa]
[kcal/mol]

Value

4.73552130E+000
2.51627507E+003
-1.03698038E+003

Units
[kcal/mol]
[kcal/mol]
[kcal/mol]
[A^-3]

SPC

-2.79190339E+000
-1.16421825E+001
8.85027911E+000
3.00300236E+001

Units
[kcal/mol]
[kcal/mol]
[kcal/mol]

O
-6.47897321E+000
-1.19565867E+001
5.47761350E+000

H1

3.68706981E+000
3.14404192E-001
3.37266562E+000

7.8.5. Total excess values

.n00 and .q00 ﬁles provide the total excess coordination number and charge about each solvent site. The total

excess of site γ around site α is

(cid:90) ∞

0

nextot
αγ = ργ

hαγ (r)dr,

while the total excess charge is

qextot
αγ = qγnextot
αγ

.

138

7.8. RISM File Formats

These values are presented in their respective ﬁles as nsite × nsite arrays. Any asymmetry in these arrays is due to
numerical error. .q00 ﬁles additionally provided the total excess charge from all sites.

The following example gives the total excess charge for a standard, ‘two-site’ water model is used, consisting

of oxygen (O) and hydrogen (H1), at standard temperature and density.

#Total excess coordinated charge [e] of column site about row site

O

H1

Total charge

O
H1

7.92607232E-001 -7.92607230E-001
7.92607231E-001 -7.92607229E-001

1.67181313E-009
2.44386922E-009

7.8.6. DX volumetric data

By default, 3D correlation functions from 3D-RISM calculations use the ASCII version of the Data Explorer
(DX) ﬁle format for volumetric data on regular grids as deﬁned in the DX user manual: http://opendx.
informatics.jax.org/docs/html/pages/usrgu068.htm#HDREDF.

Header

object 1 class gridpositions counts Nx Ny Nz

INTEGER*4. Number of grid points in the x dimension.

INTEGER*4. Number of grid points in the y dimension.

INTEGER*4. Number of grid points in the z dimension.

origin Ox Oy Oz

REAL*8. x coordinate of grid origin in Cartesian space.

REAL*8. y coordinate of grid origin in Cartesian space.

REAL*8. z coordinate of grid origin in Cartesian space.

delta dx 0 0
delta 0 dy 0
delta 0 0 dz

REAL*8. Linear grid size between in the x dimension.

REAL*8. Linear grid size between in the y dimension.

REAL*8. Linear grid size between in the z dimension.

object 2 class gridconnections counts Nx Ny Nz
object 3 class array type double rank 0 items N data follows

INTEGER*4. N = Nx× Ny× Nz.

Nx

Ny

Nz

Ox

Oy

Oz

dx

dy

dz

N

Data

data(i,j,k) data(i,j,k+1) data(i,j,k+2)

data(i,j,k) REAL*8. Three data values per line with the last (z) index varying fastest for a total of N values.

Footer

object "Untitled" call field

139

7. Reference Interaction Site Model

7.8.7. XYZV volumetric data

An alternate format for volumetric data is the simple ASCII x-y-z-value (XYZV) format. The x-, y- and

z-coordinates each grid point is written on a line followed by the value of the grid point. There is no header or
footer. For example,

...
-7.10789855E+000 -1.12570084E+001 -1.61284113E+001
1.35771922E-006
-2.10789855E+000 -1.12570084E+001 -1.61284113E+001 -5.32279347E-006
2.89210145E+000 -1.12570084E+001 -1.61284113E+001 -1.58802759E-005

140

8. Empirical Valence Bond

8.1. Introduction

Chemical reactivity can be formulated within the empirical valence bond (EVB) model[293, 294], whereby
the reactive surface is deﬁned as the lowest adiabatic surface obtained by diagonalization of the potential energy
matrix in the representation of non-reactive diabatic states. These diabatic states can be described by a force ﬁeld
approach, such as Amber, or by a prescription incorporating information from ab initio calculations. The coupling
elements in the matrix embody all the physics needed for describing transitions between the diabatic states.

As an example, the intramolecular proton transfer reaction in malonaldehyde (Figure 8.1) can be described by a

two-state EVB matrix

(cid:21)

(cid:20) V11 V12

V21 V22

V =

(8.1)

where valence bond state 1 represents the reactant state (RS) with the proton H9 bonded to O8 and valence bond
state 2 represents the product state (PS) with the proton bonded to O7. The matrix elements V11 and V22 are
simply the energies of the reactant and product systems. The off-diagonal elements of this symmetric matrix, i.e.
V12 = V21, couple these diabatic states.

Amber provides several options for computing the V12 resonance integrals. In its simplest form, V12 is set to
a constant value which provides an EVB surface that reproduces experimental or ab initio barrier heights. More
ﬂexibility can be introduced into V12 by employing an exponential or Gaussian function of the coordinates. It has
recently been shown [295, 296] that a linear combination of distributed Gaussian functions is the most accurate
and ﬂexible form for V12. With a set of distributed Gaussians, V12 can be ﬁt to high-level electronic structure data
using the following form,

Bi jK g (q,qK,i, j,αK)

NDim

∑
i≥ j≥0

K

12(q) = ∑
V 2
(cid:18)

12(q) = [V11(q)−V (q)] [V22(q)−V (q)]
V 2

(cid:19)

(cid:20)

g (q,qK,0,0,αK) =

1 +

αK|q− qK|2

1
2

exp

−1
2

αK|q− qK|2

Figure 8.1.: Intramolecular proton transfer in malonaldehyde.

(cid:21)

(8.2)

(8.3)

(8.4)

141

CCCOOHH975138426RSPSHHCCCOOHH975138426HH8. Empirical Valence Bond

(cid:20)

(cid:21)

g (q,qK,i,0,αK) = (q− qK)i exp

−1
2
g (q,qK,i, j,αK) = (q− qK)i (q− qK) j exp

(cid:20)

αK|q− qK|2

−1
2

αK|q− qK|2

(cid:21)

(8.5)

(8.6)

where g(q,qK,i, j,αK) are s-, p-, and d-type Gaussians at a number of points, qK, on the potential energy surface,
NDim is the total number of internal coordinates, V is the ab initio energy and B is a vector of coefﬁcients. It
is important to note that a nonstandard s-type Gaussian is employed to precondition the resulting set of linear
equations that is passed to a GMRES[297] (aka DIIS[298, 299]) solver. For a more exhaustive discussion of the
DG EVB method please see reference [296]. Additionally, the EVB facility in Amber can perform MD or energy
optimization on the EVB ground-state surface and biased sampling along a predeﬁned reaction coordinate (RC).
Nuclear quantization based on the Feynman path integral formalism [300–302] is also possible.

8.2. General usage description

The EVB facility is built on top of the multisander infrastructure in Amber. (Section 19.11) As such, the user
will need to build the parallel version of sander in order to utilize the EVB feature. Information for each EVB
diabatic state is obtained from separate (simultaneous) instances of sander. The energies and forces of all the states
are communicated via MPI to the master node, which is responsible for computing the EVB energy and forces and
broadcasting these to the other nodes for the next MD step.

The required input ﬁles are (1) an EVB multisander group ﬁle containing per line all the command line options
for each sander job, (2) the mdin, coordinate, and parmtop ﬁles speciﬁed in the group ﬁle, and (3) the EVB input
ﬁles. At the top level, an EVB calculation is invoked as follows:

mpirun -np <# procs> sander.MPI -ng <# groups> -groupfile <EVB group file>

The contents of the EVB group ﬁle is similar to that for a conventional multisander execution, with the addition
of a command line ﬂag -evbin for specifying the name of the EVB input ﬁle. Below is an example of an EVB
group ﬁle:

# Malonaldehyde RS: H9 bonded to O8
-O -i mdin -p mr.top -c mr.crd -o mr.out -r mr.rst -evbin input.mr
# Malonaldehyde PS: H9 bonded to O7
-O -i mdin -p mp.top -c mr.crd -o mp.out -r mp.rst -evbin input.mp

Each line corresponds to a diabatic state, and comments are preceded by a # symbol in the ﬁrst column of a line.
Now, it is important to notice in the above example that the starting conﬁgurations for both sander jobs are the
same, although the topology ﬁles are different. This constraint guarantees that the system starts in a physically
meaningful part of conﬁguration space. Furthermore, it is critical that the atom numbers (delineating the atom
locations in the coordinate and parmtop ﬁles) are identical among the EVB diabatic states. In Figure 8.1, for
example, the atom numbers of the RS and PS malonaldehydes are identical. The only additional ﬂag in the &cntrl
namelist of the mdin ﬁle is ievb, which has the following values

ievb

Flag to run EVB

= 0

= 1

No effect (default)
Enable EVB. The value of imin speciﬁes if the sander calculation is a molecular dy-
namics (imin=0) or an energy minimization (imin=1). The variable evb_dyn in the
&evb namelist of the EVB input ﬁle reﬁnes this choice to specify if the calculation
type is on the EVB ground-state surface, on a mapping potential, or on a biased poten-
tial.

The argument of the command line ﬂag -evbin provides the name of the EVB input ﬁle. Corresponding to the
above group ﬁle example, the inputs for EVB state 1 are provided in the ﬁle input.mr and those for EVB state 2

142

are provided in input.mp. For the case of constant coupling between the EVB states, the ﬁle input.mr may look
like the following:

8.2. General usage description

ntw_evb = 50,

nmodvdw = 1,

= "constant",
= "egap_umb",

# Malonaldehyde RS: proton (H9) bound to O8
&evb nevb = 2, nbias = 1, nmorse = 1,
xch_type
evb_dyn
dia_shift(1)%st = 1, dia_shift(1)%nrg_offset = 0.0,
dia_shift(2)%st = 2, dia_shift(2)%nrg_offset = 0.0,
xch_cnst(1)%ist = 1, xch_cnst(1)%jst = 2,
xch_cnst(1)%xcnst = 12.5,
egap_umb(1)%ist = 1, egap_umb(1)%jst = 2,
egap_umb(1)%k = 0.005, egap_umb(1)%ezero = 0.0,
morsify(1)%iatom = 8, morsify(1)%jatom = 9, morsify(1)%D = 356.570,
morsify(1)%a = 1.046, morsify(1)%r0 = 1.000,
modvdw(1)%iatom = 9, modvdw(1)%jatom = 7,
/

and the ﬁle input.mp may appear as follows:

ntw_evb = 50,

nmodvdw = 1,

nbias = 1, nmorse = 1,

= "constant",
= "egap_umb",

# Malonaldehyde PS: proton (H9) bound to O7
&evb nevb = 2,
xch_type
evb_dyn
dia_shift(1)%st = 1, dia_shift(1)%nrg_offset = 0.0,
dia_shift(2)%st = 2, dia_shift(2)%nrg_offset = 0.0,
xch_cnst(1)%ist = 1, xch_cnst(1)%jst = 2,
xch_cnst(1)%xcnst = 12.5,
egap_umb(1)%ist = 1, egap_umb(1)%jst = 2,
egap_umb(1)%k = 0.005, egap_umb(1)%ezero = 0.0,
morsify(1)%iatom = 7, morsify(1)%jatom = 9, morsify(1)%D = 356.570,
morsify(1)%a = 1.046, morsify(1)%r0 = 1.000,
modvdw(1)%iatom = 9, modvdw(1)%jatom = 8,
/

The above EVB ﬁles specify that the system is described by a two-state model, the coupling between the two-states
is a constant, and the dynamics is umbrella sampling along an energy gap RC. Since the reactant and product states
are identical by symmetry, no adjustments of the relative energies of the diabatic states are performed. The constant
value coupling between the two states is parameterized such that the EVB barrier reproduces the ab initio barrier of
~ 3 kcal/mol (RMP2/cc-pVTZ level). Lastly, the standard Amber harmonic bond interactions involving the proton
with the donor and acceptor oxygens are replaced by Morse functions and certain van der Waals interactions are
excluded.

This parameterization of the EVB surface to provide observables that match either results from high-level quan-
tum chemistry calculations or experimental measurements is the trickiest aspect of the EVB model. However, after
the EVB surface has been calibrated, the user has access to reactive chemical dynamics simulation timescales and
lengthscales which would be otherwise inaccessible using conventional ab initio MD approaches. The distributed
Gaussian EVB framework provides a systematic procedure for computing V12 from ab initio data.

Now, let us suppose that the constant coupling prescription does not provide the detailed features needed to
describe the reaction pathway. Furthermore, we ﬁnd that the coupling as a function of the coordinates can be
described adequately (from comparison to ab initio data) using a Gaussian functional form. How should one
modify the above EVB input ﬁles to obtain a more accurate reactive surface? We need to change the xch_type
variable from “constant” to “gauss” as well as replace the variable xch_cnst by the variable xch_gauss(:), which
contains the parameters for the Gaussian functional form. Of course, these parameters need to be optimized to
provide the more accurate surface. The modiﬁcations to the EVB input ﬁles look something like the following,

143

8. Empirical Valence Bond

= "constant",
= "gauss",

...
xch_type
xch_type
...
xch_cnst(1)%ist = 1, xch_cnst(1)%jst = 2,
xch_cnst(1)%xcnst = 12.5,
xch_gauss(1)%ist = 1, xch_gauss(1)%jst = 2,
xch_gauss(1)%iatom = 8, xch_gauss(1)%jatom = 7,
xch_gauss(1)%a = 11.0, xch_gauss(1)%sigma = 0.0447,
xch_gauss(1)%r0 = 2.3,
...

where the cross-through lines have been replaced by those below them. Access to the exponential functional form
or the distributed Gaussian approximation to V12 entails similar changes to the input ﬁles. Please see $AMBER-
HOME/test/evb for examples.

8.3. Biased sampling

When a reactive event is described by an intrinsic high free energy barrier, molecular dynamics on the EVB
ground-state surface will not adequately sample the important transition state region. Under these conditions,
chemical reactions are rare events and sampling on the EVB surface effectively reduces to sampling on a diabatic
surface. One framework for enhancing the sampling of rare events is through modiﬁcation of the system Hamilto-
nian with the addition of biasing potentials. The EVB facility in Amber offers several options for biased sampling:
(1) Ariel Warshel’s mapping potential approach[293] (2) Dave Case’s umbrella sampling on an energy gap RC (3)
umbrella sampling on a distance RC and (4) umbrella sampling on a difference of distances RC.

In the mapping potential framework, the system Hamiltonian (and hence, the molecular dynamics) is described

by the modiﬁed potential

Vλ = (1− λ )Vii + λVf f

(8.7)
where Vii is the EVB matrix element for the initial state and Vf f is the EVB matrix element for the ﬁnal state. As
the value of the mapping potential parameter λ changes from 0 to 1, the system evolves from the initial state to the
ﬁnal state. As an example, for λ = 0.50, the system Hamiltonian is an equal linear combination of the initial and
ﬁnal states and molecular dynamics sample the region in the vicinity of the transition state. Each mapping potential
Vλ samples only a portion of the reaction coordinate. In practice, a series of mapping potentials are used to bias
the sampling across the entire range of the RC. The average distribution of the RC for each mapping potential is
then unbiased and the set of unbiased distributions are combined to give the potential of mean force (PMF) on the
EVB ground-state surface. Figure 8.2 shows a PMF for the malonaldehyde intramolecular proton transfer reaction
as obtained from 9 mapping potential simulations with λ ranging from 0.10 to 0.90 at 0.10 intervals.

In the umbrella sampling framework, the system Hamiltonian is described by the modiﬁed potential

V (n)
biased(q) = Vel0(q) +V (n)

= Vel0(q) +

RC(q)− RC(n)
0

k(n)(cid:104)

umb(q)
1
2

(cid:105)2

(8.8)

where q is the set of system coordinates, k is the harmonic force constant parameter, and V (n)
umb is an umbrella
potential that is added to the original system potential Vel0 (obtained from diagonalization of the EVB matrix) to
bias the sampling towards a particular value of the reaction coordinate RC(n)
0 . The superscript (n) denotes that a
series of biased simulations, each enhancing the sampling of a particular window of the RC, is required to map out
the entire PMF. The number of umbrella sampling windows as well as the choice of values for the force constant

144

8.3. Biased sampling

Figure 8.2.: Potential of mean force along an energy gap RC for the intramolecular proton transfer in malonalde-

hyde as obtained from a series of mapping potential simulations.

evb_dyn
dependency
⇒
emap(:)
“evb_map”
⇒
egap_umb(:)
“egap_umb”
⇒
bond_umb(:)
“bond_umb”
“dbonds_umb” ⇒ dbonds_umb(:)
“qi_bond_pmf” ⇒
bond_umb(:)
“qi_bond_dyn” ⇒
bond_umb(:)
“qi_dbonds_pmf” ⇒ dbonds_umb(:)
“qi_dbonds_dyn” ⇒ dbonds_umb(:)

Table 8.2.: Derived variable types for EVB.

parameter and the RC equilibrium position will depend ultimately on the nature of the free energy landscape of the
system in question.

Results from the biased samplings then can be unbiased and combined using the weighted histogram analysis
method (WHAM)[303–305] to generate the PMF describing chemistry on the physically relevant EVB ground-
state potential energy surface, Vel0. Figure 8.3 depicts the PMF for the malonaldehyde intramolecular proton
transfer that is obtained from 13 umbrella sampling simulations with RC(n)
spanning the range -60 kcal/mol to +60
0
kcal/mol at 10 kcal/mol intervals. The supporting program to generate the PMF from a set of mapping potential or
from a set of umbrella sampling simulations can be obtained from the Amber website, http://ambermd.org.

Biased sampling is accessed through the nbias and evb_dyn variables in the EVB input ﬁle. The variable nbias
speciﬁes the number of biasing potentials to include in the system Hamiltonian. Mapping potential dynamics is
invoked using the assignment evb_dyn=“evb_map”. Biased sampling via umbrella potentials is invoked with the
assignment evb_dyn=“egap_umb”, evb_dyn=“bond_umb” or evb_dyn=“dbonds_umb”. Associated with each
choice of biased sampling approach is a derived type variable that provides the required parameters, as shown in
Table 8.2.

145

-75-50-250255075Collective Reaction Coordinate [kcal/mol]0123Potential of Mean Force [kcal/mol]8. Empirical Valence Bond

Figure 8.3.: Potential of mean force for the intramolecular proton transfer in malonaldehyde as obtained from a
series of umbrella sampling simulations along an energy gap RC. The distributions of the RC from all
the windows are combined using the WHAM procedure.

146

-75-50-250255075Collective Reaction Coordinate [kcal/mol]0123Potential of Mean Force [kcal/mol]9. sqm: Semi-empirical quantum chemistry

AmberTools contains its own quantum chemistry program, called sqm. This is code extracted from the QM/MM
portions of sander, but is limited to “pure QM” calculations. A principal current use is as a replacement for
MOPAC for deriving AM1-bcc charges, but the code is much more general than that. Presently, it is limited to
single point calculations and energy minimizations (geometry optimizations) for closed-shell systems. It supports
a wide variety of semi-empirical Hamiltonians, including many recent ones. An external electric ﬁeld generated
by a set of point charges can be included for single point calculations. Our plan is to add capabilities to subsequent
versions. The major contributors are as follows:

• The original semi-empirical support was written by Ross Walker, Mike Crowley, and Dave Case,[306] based

on public-domain MOPAC codes of J.J.P. Stewart.

• DFTB2 (SCC-DFTB) support was written by Gustavo Seabra, Ross Walker and Adrian Roitberg,[307] and

is based on earlier work of Marcus Elstner.[308, 309]

• Support for diagonal third-order corrections to SCC-DFTB was written by Gustavo Seabra and Josh Mcclel-

lan.

• DFTB3 was added by Andreas Goetz.

• Various SCF convergence schemes were added by Tim Giese and Darrin York.

• The PM6 Hamiltonian was added by Andreas Goetz and dispersion and hydrogen bond corrections were

added by Andreas Goetz and Kyoyeon Park.

• The extension for MNDO type Hamiltonians to support d orbitals was written by Tai-Sung Lee, Darrin York

and Andreas Goetz.

• The charge-dependent exchange-dispersion corrections of vdW interactions[310] was contributed by Tai-

Sung Lee, Tim Giese, and Darrin York.

• Support for reading user-deﬁned parameters for NDDO methods was added by Tai-Sung Lee and Darrin

York.

The DFTB/DFTB2 code was originally based on the DFT/DYLAX code by Marcus Elstner et al., but has since
been extensively re-written and optimized. The DFTB3 implementation is an extension of this code.

9.1. Available Hamiltonians

Available MNDO-type semi-empirical Hamiltonians are PM3,[311] AM1,[312] RM1,[313] MNDO,[314]
PDDG/PM3,[315] PDDG/MNDO,[315] PM3CARB1,[316], PM3-MAIS[317, 318], MNDO/d[319–321], AM1/d
(Mg from AM1/d[322] and H, O, and P from AM1/d-PhoT[323]) and PM6[324].

Also available is the density functional theory-based tight-binding (DFTB) Hamiltonian[307, 325, 326] and its
self-consistent-charge version with Taylor expansion up to second order (SCC-DFTB or DFTB2)[308] and third-
order (DFTB3)[327]. If you use the mio-1-1 parameters for DFTB2, you can add an empirical correction for
dispersion effects[328] and calculate CM3 charges[329] (both only for elements H, C, N, O, S, P). Diagonal third-
order corrections are available for DFTB2[330] with mio-1-1 parameters but it is recommended to perform full
DFTB3 simulations instead. Neither dispersion corrections nor halogen corrections are implemented for DFTB3.

The elements supported by each QM method are:

147

9. sqm: Semi-empirical quantum chemistry

• MNDO: H, Li, Be, B, C, N, O, F, Al, Si, P, S, Cl, Zn, Ge, Br, Cd, Sn, I, Hg, Pb

• MNDO/d: H, Li, Be, B, C, N, O, F, Na, Mg, Al, Si, P, S, Cl, Zn, Ge, Br, Sn, I, Hg, Pb

• AM1: H, C, N, O, F, Al, Si, P, S, Cl, Zn, Ge, Br, I, Hg

• AM1/d: H, C, N, O, F, Mg, Al, Si, P, S, Cl, Zn, Ge, Br, I, Hg

• PM3: H, Be, C, N, O, F, Mg, Al, Si, P, S, Cl, Zn, Ga, Ge, As, Se, Br, Cd, In, Sn, Sb, Te, I, Hg, Tl, Pb, Bi

• PDDG/PM3: H, C, N, O, F, Si, P, S, Cl, Br, I

• PDDG/MNDO: H, C, N, O, F, Cl, Br, I

• RM1: H, C, N, O, P, S, F, Cl, Br, I

• PM3CARB1: H, C, O

• PM3-MAIS: H, O, Cl

• PM6: H, He, Li, Be, B, C, N, O, F, Ne, Na, Mg, Al, Si, P, S, Cl, Ar, K, Ca, Sc, Ti, V, Cr, Mn, Fe, Co, Ni, Cu,
Zn, Ga, Ge, As, Se, Br, Kr, Rb, Sr, Y, Zr, Nb, Mo, Tc, Ru, Rh, Pd, Ag, Cd, In, Sn, Sb, Te, I, Xe, Cs, Ba, La,
Lu, Hf, Ta, W, Re, Os, Ir, Pt, Au, Hg, Tl, Pb, Bi

• DFTB/DFTB2/DFTB3: (Any atoms for which parameters are available from www.dftb.org)

The PM6 implementation has not been extensively tested for all available elements. Please check your results
carefully, possibly by comparison to other codes that implement PM6, if transition metal elements are present.
SCF convergence may be more difﬁcult to achieve for transition metal elements with partially ﬁlled valence shells.
If the PM6 Hamiltonian is used in a QM/MM simulation with sander using electrostatic embedding (see Section
10) or if an electric ﬁeld of external point charges is used, then the electrostatic interactions between QM and MM
atoms are modeled using the MNDO type core repulsion function for interactions between QM and MM atoms.
Parameters for the exponents α of the QM atoms are taken from PM3 (a default value of ﬁve is used for the
exponents α of the MM atoms as is the case for MNDO, AM1 and PM3). Since PM3 does not have parameters for
all elements that are supported by PM6, the missing exponents were deﬁned in an ad hoc manner (see the source
code in $AMBERHOME/AmberToosl/src/sqm/qm2_parameters.F90, variable alp_pm6). The magnitude of the
coefﬁcients α is probably not critical for the accuracy of QM/MM calculations but this should be tested on a case
by case basis. This does not affect QM calculations with sqm.

9.1.1. DFTB parameter ﬁles

In order to use DFTB2 or DFTB3 (qm_theory=DFTB2 or DFTB3) a set of integral parameter ﬁles is required.
The mio-1-1 parameter ﬁles for DFTB2 and 3ob-3-1 parameter ﬁles are distributed with Amber under a Creative
Commons Attribution-ShareAlike 4.0 International License, see http://creativecommons.org/licenses/by-sa/4.0/.
The parameters were obtained from the website www.dftb.org on February 22, 2017. You may want to check if
there are any updates to the parameters. If you perform DFTB simulations, in addition to Amber please cite the
publications describing the QM/MM and DFTB implementations as well as following references for the DFTB
parameters:

When using DFTB2 with mio-1-1 and following elements:

• O, N, C, H: M. Elstner, D. Porezag, G. Jungnickel, J. Elsner, M. Haugk, Th. Frauenheim, S. Suhai, G.

Seifert, Phys. Rev. B 58 (1998) 7260.

• S: T. A. Niehaus, M. Elstner, Th. Fruanheim, S. Suhai, J. Molec. Struct. (THEOCHEM) 541 (2001) 185.

• P: M. Gaus, Q. Cui, M. Elstner, J. Chem. Theory Comput. 7 (2011) 931-948.

When using DFTB3 with 3ob-3-1 and following elements:

148

9.2. Dispersion and hydrogen bond correction

• O, N, C, H: M. Gaus, A. Goez, M. Elstner, J. Chem. Theory Comput. 9 (2013) 338-354.

• P, S: M. Gaus, X. Lu, M. Elstner, Q. Cui, J. Chem. Theory Comput. 10 (2014) 1518-1537.

• Mg, Zn: X. Lu, M. Gaus, M. Elstner, Q. Cui, J. Phys. Chem. B 119 (2015) 1062-1082.

• Na, F, K, Ca, Cl, Br, I: M. Kubillus, T. Kubar, M. Gaus, J. Rezac, M. Esltner, J. Chem. Theory Comput. 11

(2015) 332-342.

Additional parameter ﬁles can be obtained from the website www.dftb.org. By default it is assumed that DFTB2
uses the mio-1-1 parameter set and DFTB3 the 3ob-3-1 parameter set and that the corresponding ﬁles with exten-
sion .skf reside in the directories $AMBERHOME/dat/slko/mio-1-1 and $AMBERHOME/dat/slko/3ob-3-1. If you
want to use other parameter sets and/or put the parameter ﬁles in other directories then you have to specify the
location in the input ﬁle (keyword dftb_slko_path, see section 9.3 for details).

Following parameter ﬁles for use with DFTB2 and the mio-1-1 parameter set are also distributed with Amber-
Tools: Dispersion parameters for H, C, N, O, P and S are available in the ﬁle $AMBERHOME/dat/slko/mio-1-
1/DISPERSION.INP_ONCHSP, CM3 parameters for the same atoms are in the ﬁle $AMBERHOME/dat/slko/mio-
1-1/CM3_PARAMETERS.DAT ﬁle, and two parametrizations for diagonal third-order SCC-DFTB terms (SCC-
DFTB-PA and SCC-DFTB-PR) are in the ﬁles DFTB_3RD_ORDER_PA.DAT and DFTB_3RD_ORDER_PR.DAT,
both located in the same directory.

9.2. Dispersion and hydrogen bond correction

An empirical dispersion and hydrogen bonding correction is implemented for the MNDO type Hamiltonians
AM1 and PM6[331]. The empirical dispersion correction follows the formalism for DFT-D[332] and consists of a
physically sound r−6 term that is damped at short distances to avoid the short-range repulsion which can be written
as

Edis = −s6∑

fdamp(ri j,R0

i j)C6,i jr−6
i j ,

(9.1)

where ri j is the distance between two atoms i and j, R0

i j is the equilibrium van der Waals (vdW) separation
derived from the atomic vdW radii, C6,i j the dispersion coefﬁcient, and s6 a general scaling factor. The damping
function is given as

(cid:33)(cid:35)−1

i j

(cid:34)

(cid:32)

fdamp(ri j,R0

i j) =

1 + exp

−α

ri j
sRR0
i j

− 1

Bondi vdW radii[333] are used and for a pair of unlike atoms we have

R0
i j =

3

2

R0
ii
R0
ii

+ R0
j j
+ R0
j j

3
2 .

For the C6 coefﬁcients the following equation is used,

C6,i j = 2

(C2
(C6,iiN2

6, j jNe f f ,iNe f f , j)1/3

6,iiC2
e f f , j)1/3 + (C6, j jN2

e f f ,i)1/3 ,

.

(9.2)

(9.3)

(9.4)

where the Slater-Kirkwood effective number of electrons Ne f f ,i and the C6 coefﬁcients can easily be found in the
literature[332].

An empirical hydrogen bonding correction[331] that is transferable among different semiempirical Hamiltonians
and has been parametrized for use with the dispersion correction described above is also available. This correction
does not make the assumption of a speciﬁc acceptor/hydrogen/donor binding situation. Instead it considers the
hydrogen bond as a charge-independent atom- atom term between two atoms capable of serving as an acceptor
or donor (for example, O, N) and weights this by a function that accounts for the steric arrangement of the two

149

9. sqm: Semi-empirical quantum chemistry

atoms and the favorable positioning of a hydrogen atom inbetween. A damping function corrects for long- and
short-range behavior,

EH−bond =

fgeom fdamp,

CAB
r2
AB

fgeom = cos(θA)2 cos(φA)2 cos(ψA)2 cos(φB)2 cos(φB)2 cos(ψB)2 fbond,

(cid:18)

fdamp =

fbond = 1−

1 + exp[−60(rXH /1.2− 1)]

,

1

(cid:19)(cid:18)

1

1 + exp[−100(rAB/2.4− 1)]

1−

1

1 + exp[−10(rAB/7.0− 1)]

CAB =

CA +CB

2

.

(cid:19)

,

(9.5)

(9.6)

(9.7)

(9.8)

(9.9)

Here, CA and CB are the atomic hydrogen bonding correction parameters and the (torsion) angles in the function

fgeom are deﬁned similarly to an earlier hydrogen bond correction[334].

The hydrogen bond correction can be used both for single point energy calculations or geometry optimizations
with SQM and for molecular dynamics simulations with SANDER. However, we do not recommend the use for
molecular dynamics at present since cutoffs needed to be implemented for the calculation of fgeom of equation
(9.6). This and some other conditional evaluations give rise to discontinuities in the potential energy surface and
thus make this method unattractive for MD simulations.

9.3. Usage

The sqm program uses the following simple command line:

sqm [-O] -i <input-file> -o <output-file>

mdin is the default input-ﬁle name, and mdout is the default output-ﬁle name.As in other Amber programs, the
“-O” ﬂag allows the program to over-write the output ﬁle.

An example input ﬁle for running a simple minimization is shown here:



Run semi-empirical minimization

&qmmm

qm_theory='AM1',

qmcharge=0,

/

6
6
6
6
6
6
1
16
1
1
1
1
1



CG
CD1
CD2
CE1
C6
CZ
HE2
S15
H19
H29
H30
H31
H32

-1.9590
-1.2490
-2.0710
-0.6460
-1.4720
-0.7590
-1.5580
-2.7820
-3.5410
-0.7870
0.3730
-0.0920
-2.3790

0.1020
0.6020
0.8650
1.8630
2.1290
2.6270
2.7190
0.3650
0.9790
-0.0430
2.0450
3.5780
-0.9160

0.7950
-0.3030
1.9630
-0.2340
2.0310
0.9340
2.9310
3.0600
3.2740
-0.9380
-0.7840
0.7810
0.9010

The &qmmm namelist contains variables that allow you to control the options used. Following that is one line
per atom, giving the atomic number, atom name, and Cartesian coordinates (free format). The variables in the
&qmmm namelist are these:

qm_theory Level of theory to use for the QM region of the simulation (Hamiltonian). Default is to use the
semi-empirical Hamiltonian PM3. Options are AM1, RM1, MNDO, PM3-PDDG, MNDO-PDDG,

150





9.3. Usage

PM3-CARB1, MNDO/d (same as MNDOD), AM1/d (same as AM1D), PM6, DFTB2 (same as
DFTB), and DFTB3. The dispersion correction can be switched on for AM1 and PM6 by choosing
AM1-D* and PM6-D, respectively. The dispersion and hydrogen bond correction will be applied for
AM1-DH+ and PM6-DH+.

dftb_slko_path Path to the DFTB Slater-Koster parameter ﬁles. Defaults to ’$AMBERHOME/dat/slko/mio-
1-1/’ for DFTB2 and ’$AMBERHOME/dat/slko/3ob-3-1/’ for DFTB3. You can specify a different
directory here, which is assumed to be a subdirectory of ’$AMBERHOME/dat/slko/’ unless you
specify an absolute path.

dftb_disper Flag turning on (1) or off (0) the use of a dispersion correction to the DFTB2 energy (only for
mio-1-1 parameters). Requires qm_theory=DFTB2. It is assumed that you have the ﬁle DISPER-
SION.INP_ONCHSP in your $AMBERHOME/dat/slko/mio-1-1 directory. This ﬁle must be down-
loaded from the website www.dftb.org, as described in the beginning of this chapter. Only available
for elements H, C, O, N, P, S. (Default = 0)

dftb_3rd_order Third order diagonal corrections to DFTB2 with mio-1-1 parameters. Default=” (the empty

string which means no third order correction).
= ’PA’ Use the SCC-DFTB-PA parametrization, which was developed for proton afﬁnities. The
parameters will be read from the $AMBERHOME/dat/slko/DFTB_3RD_ORDER_PA.DAT ﬁle.
= ’PR’ Use the SCC-DFTB-PR parametrization, which was developed for phosphate hy-
The parameters will be read from the $AMBERHOME/dat/s-

reactions.

drolysis
lko/DFTB_3RD_ORDER_PR.DAT ﬁle.

= ’READ’ Parameters will be read from the mdin ﬁle, in a separate “dftb_3rd_order” namelist, which

must have the same format as the ﬁles above.

= ’ﬁlename’ Parameters will be read from the ﬁle speciﬁed by ﬁlename, in the “dftb_3rd_order”

namelist, which must have the same format as the ﬁles above.

dftb_chg

Flag to choose the type of charges to report when doing a DFTB calculation.
= 0 (default) - Print Mulliken charges.
= 2 Print CM3 charges. Only available for DFTB2 with mio-1-1 parameters for elements H, C, N,

O, S and P.

dftb_telec Electronic temperature, in K, used to accelerate SCC convergence in DFTB calculations. The elec-
tronic temperature affects the Fermi distribution promoting some HOMO/LUMO mixing, which can
accelerate the convergence in difﬁcult cases. In most cases, a low telec (around 100K) is enough.
Should be used only when necessary, and the results checked carefully. Default: 0.0K

dftb_maxiter Maximum number of SCC iterations before resetting Broyden in DFTB calculations. (default: 70

)

qmcharge

Charge on the QM system in electron units (must be an integer). (Default = 0)

spin

qmqmdx

Multiplicity of the QM system. Currently only singlet calculations are possible and so the default
value of 1 is the only available option. Note that this option is ignored by DFTB/SCC-DFTB, which
allows only ground state calculations. In this case, the spin state will be calculated from the number
of electrons and orbital occupancy.

Flag for whether to use analytical or numerical derivatives of the semiempirical electron repulsion
integrals. The default (and recommended) option is to use ANALYTICAL QM-QM derivatives.
= 1 (default) - Use analytical derivatives for QM-QM forces.
= 2 Use numerical derivatives for QM-QM forces. Note: the numerical derivative code has not been
optimised as aggressively as the analytical code and as such is signiﬁcantly slower. Numerical
derivatives are intended mainly for testing purposes.

151

9. sqm: Semi-empirical quantum chemistry

verbosity Controls the verbosity of QM/MM related output. Warning: Values of 2 or higher will produce a lot

of output.

= 0 (default) - only minimal information is printed - Initial QM geometry and link atom positions as

well as the SCF energy at every ntpr steps.

= 1 Print SCF energy at every step to many more signiﬁcant ﬁgures than usual. Also print the

number of SCF cycles needed on each step.

= 2 As 1 and also print info about memory reallocations, number of pairs per QM atom, QM core -

QM core energy, QM core - MM atom energy, and total energy.
= 3 As 2 and also print SCF convergence information at every step.
= 4 As 3 and also print forces on the QM atoms due to the SCF calculation and the coordinates of

the link atoms at every step.

= 5 As 4 and also print all of the info in kJ/mol as well as kcal/mol.

tight_p_conv Controls the tightness of the convergence criteria on the density matrix in the SCF.

=0 (default) - loose convergence on the density matrix (or Mulliken charges, in case of a SCC-
DFTB calculation). SCF will converge if the energy is converged to within scfconv and the
largest change in the density matrix is within 0.05*sqrt(scfconv).

= 1 Tight convergence on density(or Mulliken charges, in case of a SCC-DFTB calculation). Use
same convergence (scfconv) for both energy and density (charges) in SCF. Note: in the SCC-
DFTB case, this option can lead to instabilities.

Controls the convergence criteria for the SCF calculation, in kcal/mol. In order to conserve energy
in a dynamics simulation with no thermostat it is often necessary to use a convergence criterion of
1.0d-9 or tighter. Note, the tighter the convergence the longer the calculation will take. Values tighter
than 1.0d-11 are not recommended as these can lead to oscillations in the SCF, due to limitations in
machine precision, that can lead to convergence failures. Default is 1.0d-8 kcal/mol. Minimum
usable value is 1.0d-14.

scfconv

pseudo_diag Controls the use of ’fast’ pseudo diagonalisations in the SCF routine. By default the code will
attempt to do pseudo diagonalisations whenever possible. However, if you experience convergence
problems then turning this option off may help. Not available for DFTB/SCC-DFTB.

= 0 Always do full diagonalisation.
= 1 Do pseudo diagonalisations when possible (default).

pseudo_diag_criteria Float controlling criteria used to determine if a pseudo diagonalisation can be done. If
the difference in the largest density matrix element between two SCF iterations is less than this crite-
ria then a pseudo diagonalisation can be done. This is really a tuning parameter designed for expert
use only. Most users should have no cause to adjust this parameter. (Not applicable to DFTB/SCC-
DFTB calculations.) Default = 0.05

diag_routine Controls which diagonalization routine will be used during the SCF procedure. This is an ad-
vanced option to ﬁne-tune performance which has negligible effect on energies (and generally little
effect on geometries in the case of SQM energy minimizations). The speed of each diagonalizer is
a function of the number and type of QM atoms as well as the LAPACK library that the program
was linked to. As such there is not always an obvious choice to obtain the best performance. The
simplest option is to set diag_routine = 0 in which case the program will test each diagonalizer in
turn, including the pseudo diagonalizer, and select the one that gives optimum performance. As of
AmberTools 15 diag_routine = 0 is the default for both SQM and QMMM in Sander. Not available
for DFTB/SCC-DFTB.

= 0 Automatically select the fastest routine (default).

152

9.3. Usage

= 1 Use internal diagonalization routine.
= 2 Use lapack dspev.
= 3 Use lapack dspevd.
= 4 Use lapack dspevx.
= 5 Use lapack dsyev.
= 6 Use lapack dsyevd.
= 7 Use lapack dsyevr.

printcharges = 0 Don’t print any info about QM atom charges to the output ﬁle (default)

= 1 Print Mulliken QM atom charges to output ﬁle every ntpr steps.

print_eigenvalues Controls printing of MO eigenvalues.

= 0 Do not print MO eigenvalues
= 1 Print MO eigenvalues at the end of a single point calculation or geometry optimization (default)
= 2 Print MO eigenvalues at the end of every SCF cycle (only NDDO methods, not DFTB)
= 3 Print MO eigenvalues during each step of the SCF cycle (only NDDO methods, not DFTB)

qxd

Flag to turn on (=.true.) or off (=.false., default) the charge-dependent exchange-dispersion correc-
tions of vdW interactions[310].

parameter_file = ’PARAM.FILE’ Read user-deﬁned parameters from the ﬁle ’PARAM.FILE’. The ﬁrst three
space-separated entries (case insensitive) of each line will be interpreted as a user-modiﬁed
parameter in the sequence of parameter name, element name, and value. For example, a line
contains “USS Cl -111.6139480D0 “ will cause the USS parameter of the Cl element changed
to -111.6139480. A line beginning with “END” will stop the reading. This function currently
only works for MNDO, AM1, PM3, MNDO/d, and AM1/d. Also, when new nuclear core-core
parameters (FN, in PM3, AM1, and AM1/d) are re-deﬁned, the number of FNN parameter sets
(NUM_FN) also needs to be deﬁned. For example, if FNn3 (n = 1, 2, or 3) is deﬁned, then
NUM_FN needs to be set to 3 or 4.

peptide_corr = 0 Don’t apply MM correction to peptide linkages. (default)

itrmax

= 1 Apply a MM correction to peptide linkages. This correction is of the form Esc f = Esc f +
htype(itype)sin2 φ, where φ is the dihedral angle of the H-N-C-O linkage and htype is a con-
stant dependent on the Hamiltonian used. (Recommended, except for DFTB/SCC-DFTB.)

Integer specifying the maximum number of SCF iterations to perform before assuming that conver-
gence has failed. Default is 1000. Typically higher values will not do much good since if the SCF
hasn’t converged after 1000 steps it is unlikely to. If the convergence criteria have not been met
after itrmax steps the SCF will stop and the minimisation will proceed with the gradient at itrmax.
Hence if you have a system which does not converge well you can set itrmax smaller so less time is
wasted before assuming the system won’t converge. In this way you may be able to get out of a bad
geometry quite quickly. Once in a better geometry SCF convergence should improve.

maxcyc

Maximum number of minimization cycles to allow, using the xmin minimizer (see Section 39.4) with
the TNCG method. Default is 9999. Single point calculations can be done with maxcyc = 0.

ntpr

Print the progress of the minimization every ntpr steps; default is 10.

grms_tol

Terminate minimization when the gradient falls below this value; default is 0.02

153

9. sqm: Semi-empirical quantum chemistry

ndiis_attempts Controls the number of iterations that DIIS (direct inversion of the iterative subspace) extrap-
olations will be attempted. Not available for DFTB/SCC-DFTB. The SCF does not even begin to
exhaust its attempts at using DIIS extrapolations until the end of iteration 100. Therefore, for exam-
ple, if ndiis_attempts=50, then DIIS extrapolations would be performed at end of iterations 100 to
150. The purpose of not performing DIIS extrapolations before iteration 100 is because the existing
code base performs quite well for most molecules; however, if convergence is not met after 100
iterations, then it is presumed that further iterations will not yield SCF convergence without doing
something different, i.e., DIIS. Thus, the implementation of DIIS in SQM is a mechanism to try and
force SCF convergence for molecules that are otherwise difﬁcult to converge. Default 0. Maximum
1000. Minimum 0. Note that DIIS will automatically turn itself on for 100 attempts at the end of
iteration 800 even if you did not explicitly set ndiis_attempts to a nonzero value. This is done as a
ﬁnal effort to achieve convergence.

ndiis_matrices Controls the number of matrices used in the DIIS extrapolation. Including only one matrix is
the same as not performing an extrapolation. Including an excessive number of matrices may require
a large amount of memory. Not available for DFTB/SCC-DFTB. Default 6. Minimum 1. Maximum
20.

vshift

errconv

Controls level shifting (only NDDO methods, not DFTB). Virtual orbitals can be shifted up by vshift
(in eV) to improve SCF convergence in cases with small HOMO/LUMO gap. Default 0.0 (no level
shift).

SCF tolerance on the maximum absolute value of the error matrix, i.e., the commutator of the Fock
matrix with the density matrix. The value has units of hartree. The default value of errconv is suf-
ﬁciently large to effectively remove this tolerance from the SCF convergence criteria. Not available
for DFTB/SCC-DFTB. Default 1.d-1. Minimum 1.d-16. Maximum 1.d0.

qmmm_int When running QM calculations in the sqm program, an electric ﬁeld of external point charges can
be added. In this way, the electrostatic effect outside of the QM region can be modeled, making the
calculation a simpliﬁed QM/MM calculation without QM/MM vdW’s contribution. Like QM/MM
calculations (see Section 10), the method to couple QM and MM electrostatic interactions for exter-
nal charges and semiempirical Hamiltonians can be speciﬁed via the qmmm_int namelist variable.
The current implementation limits use of external charges to only single point energy calculations.
To run such a calculation, an additional ﬁeld, which begins with #EXCHARGES and ends with
#END, is required to specify the external point charges in the input. Each external point charge
must include atomic number, atom name, X, Y, Z coordinates and the charge in units of the electron
charge. An example input looks like:

single point energy calculation (adenine), with external charges (thymine)
&qmmm

qm_theory = ’PM3’,
qmcharge = 0,
maxcyc = 0,
qmmm_int = 1,

/
7
1
1
6
7
6
1
7
6

N
H
H
C
N
C
H
N
C

1.0716177 -0.0765366
0.0586915 -0.0423765
1.6443796 -0.0347395
1.6739638 -0.0357766
0.9350155 -0.0279801
1.5490760
0.8794435
2.8531510
3.5646109

1.9391390
2.0039181
2.7619159
0.7424316
-0.3788916
0.0012569 -1.5808009
0.0050260 -2.4315709
0.0258031 -1.8409596
0.0195446 -0.7059872

154

0.5994562
3.0747955 -0.0094480
1.5289786
4.0885824 -0.0054429
0.7872176
0.0253971
5.1829921
0.0375542
6.1882591
1.1738824
0.0412404 -0.5567274
4.9294871
0.0648755 -1.3036811
5.6035368

6 C
7 N
6 C
1 H
7 N
1 H
#EXCHARGESwill be
0.0413373
6 C -4.7106131
2.1738637 -0.03140
1 H -4.4267056
0.9186178
0.06002
2.7530256
1 H -4.4439282 -0.8302573
2.7695655
0.05964
0.0505530
1 H -5.7883971
2.0247280
0.03694
0.0219348
6 C -3.9917387
0.8663338 -0.25383
0.0169051 -0.3336520
6 C -4.6136833
0.03789
1 H -5.6909220
0.0269347 -0.4227183
0.16330
7 N -3.9211729 -0.0009646 -1.5163659 -0.47122
0.35466
1 H -4.4017172 -0.0036078 -2.4004924
6 C -2.5395897 -0.0149474 -1.5962357
0.80253
8 O -1.9416783 -0.0291878 -2.6573783 -0.63850
7 N -1.9256484 -0.0110593 -0.3638948 -0.58423
0.35404
1 H -0.8838255 -0.0216168 -0.3784269
0.8766724
6 C -2.5361367
0.71625
8 O -1.8674730
1.9120833 -0.60609
#END

0.0074651
0.0112093

9.3. Usage

155

10. QM/MM calculations

Sander supports the option of describing part of the system quantum mechanically in an approach known as a
hybrid (or coupled potential) QM/MM simulation. Semi-empirical neglect of diatomic overlap (NDDO)-type and
density functional tight binding (DFTB) Hamiltonians are supported natively by sander and the basic documen-
tation (e.g. what Hamiltonians are implemented, description of the input parameters) can be found in Chapter 9.
Here we limit our description to those features that are unique to the QM/MM interface implemented in sander.
More advanced Hamiltonians based on ab initio wave function theory (WFT) and density functional theory (DFT)
are supported via an interface to external QM software packages the use of which is described in section 10.2.

The built-in semi-empirical QM/MM support was written by Ross Walker and Mike Crowley, [306] based
originally on public-domain MOPAC codes of J.J.P. Stewart. The QM/MM generalized Born implementation uses
the model described by Pellegrini and Field[335] while regular QM/MM Ewald support is based on the work
of Nam et al.[336] with QM/MM PME support based on the work of Walker et al.[306]. SCC-DFTB support
was written by Gustavo Seabra, Ross Walker and Adrian Roitberg,[307] and is based on earlier work of Marcus
Elstner.[308, 309] Support for third-order SCC-DFTB was written by Gustavo Seabra and Josh McClellan.

10.1. Built-in semiempirical NDDO methods and SCC-DFTB

When running a QM/MM simulation in sander the system is partitioned into two regions, a QM region consisting
of the atoms deﬁned by either the qmmask or iqmatoms keyword, and a MM region consisting of all the atoms that
are not part of the QM region. For a typical protein simulation in explicit solvent the number of MM atoms will
be much greater than the number of QM atoms. Either region can contain zero atoms, giving either a pure QM
simulation or a standard classical simulation. For periodic simulations, the quantum region must be compact, so
that the extent (or diameter) of the QM region (in any direction) plus twice the QM/MM cutoff must be less than
the box size. Hence, you can deﬁne an "active site" to be the QM region, but in most cases could not ask that
all cysteine residues (for example) be quantum objects. The restrictions are looser for non-periodic (gas-phase
or generalized Born) simulations, but the codes are written and tested for the case of a single, compact quantum
region.

The partitioned system is characterized by an effective Hamiltonian which operates on the system’s wavefunc-

tion Ψ, which is dependent on the position of the MM and QM nuclei, to yield the system energy Ee f f :

He f f Ψ(xe,xQM,xMM) = Ee f f (xQM,xMM)Ψ(xe,xQM,xMM)

(10.1)

The effective Hamiltonian consists of three components - one for the QM region, one for the MM region and a
term that describes the interaction of the QM and MM regions, implying that likewise the energy of the system can
be divided into three components. If the total energy of the system is re-written as the expectation value of He f f
then the MM term can be removed from the integral since it is independent of the position of the electrons:

Ee f f =(cid:10)Ψ|HQM + HQM/MM|Ψ(cid:11) + EMM

(10.2)
In the QM/MM implementation in sander, EMM is calculated classically from the MM atom positions using
the Amber or CHARMM force ﬁeld equation and parameters, whereas HQM is evaluated using the chosen QM
method.

The interaction term HQM/MM is more complicated. By default, sander uses an electrostatic embedding scheme
(also referred to as additive scheme) in which the interaction of the MM point charges with the electrons of the
QM system as well as the interaction between the MM point charges and the QM nuclei (atomic cores for semi-
empirical methods) is explicitly taken into account. In other words, the MM region polarizes the QM electron
density. For the case where there are no covalent bonds between the atoms of the QM and MM regions the

156

10.1. Built-in semiempirical NDDO methods and SCC-DFTB

(cid:34)

interaction Hamiltonian is thus the sum of an electrostatic term and a Lennard-Jones (VDW) term and can be
written as

HQM/MM = ∑

q

∑

m

Qmhelectron(xe,xMM)− QmZqhcore(xQM,xMM) +

where the subscripts e, m and q refer to the electrons, the MM nuclei and the QM nuclei respectively. Here Qm is
the charge on MM atom m, Zq is the core charge (nucleus minus core electrons) on QM atom q, rqm is the distance
between atoms q and m, and A and B are Lennard-Jones interaction parameters. For systems that have covalent
bonds between the QM and MM regions, the situation is more complicated, as discussed later.

A more approximate form of the interaction term HQM/MM is referred to as mechanical embedding (or subtractive
QM/MM scheme). In this case the interactions between the QM and the MM region are obtained within the same
classical approximation that is used for the MM region, that is

(cid:33)(cid:35)

(cid:32)

A
r12
qm

− B
r6
qm

(cid:34)

(cid:32)

(cid:33)(cid:35)

HQM/MM = ∑

q

∑

m

QmQq
rqm

+

A
r12
qm

− B
r6
qm

(10.3)

(10.4)

where Qq is the classical MM point charge assigned to an atom in the QM region. Mechanical embedding is useful
to impose steric constraints on the embedded QM system, however, the electron density is not polarized by the
MM environment. An additional complication of this approach is that the point charges that are assigned to the
atoms in the QM region have to represent the electrostatic potential of the QM region during the whole course of
a QM/MM simulation.

If one evaluates the expectation values in Eq. 10.2 over a single determinant built from molecular orbitals

φi = ∑

j

ci jχ j

(10.5)

where the ci j are molecular orbital coefﬁcients and the χ j are atomic basis functions, the total energy depends upon
the ci j and on the positions xMM and xQM of the atoms. The energy is obtained by setting ∂ Ee f f /∂ ci j to zero which
leads to a self-consistent (SCF) procedure to determine the ci j, (with a modiﬁed Fock matrix that contains the
electric ﬁeld arising from the MM charges in the case of electrostatic embedding). Once the energy is known, the
forces on the atoms can be obtained by taking the derivative of the energy expression with respect to the positions
of the QM and MM atoms.

The main subtlety that arises in the case of electrostatic embedding is that, for a periodic system, there are
formally an inﬁnite number of QM/MM interactions; even for a non-periodic system, the (ﬁnite) number of such
interactions may be prohibitively large. These problems are addressed in a manner analogous to that used for pure
MM systems: a PME approach is used for periodic systems, and a (large) cutoff may be invoked for non-periodic
systems. Some details are discussed below.

10.1.1. The QM/MM interface and link atoms

The sections above dealt with situations where there are no covalent bonds between the QM and MM regions. In
many protein simulations, however, it is necessary to have the QM/MM boundary cut covalent bonds, and a number
of additional approximations have to be made. There are a variety of approaches to this problem, including hybrid
orbitals, capping potentials, and explicit link atoms. The last option is the method available in sander.

There are a number of ways to implement a link atom approach that deal with the way the link atom is positioned,
the way the forces on the link atom are propagated, and the way non-bonding interactions around the link atom are
treated. Each time an energy or gradient calculation is to be done, the link atom coordinates are re-generated from
the current coordinates of the QM and MM atoms making up the QM-MM covalent pair. The link atom is placed
along the bond vector joining the QM and MM atom, at a distance dL−QM from the QM atom. By default dL−QM is
set to the equilibrium distance of a methyl C-H atom pair (1.09 Å) but this can be set in the input ﬁle. The default
link atom type is hydrogen, but this can also be speciﬁed as an input.

Since the link atom position is a function of the coordinates of the "real" atoms, it does not introduce any new
degrees of freedom into the system. The chain rule is used to re-write forces on the link atom itself in terms

157

10. QM/MM calculations

of forces on the two real atoms that deﬁne its position. This is analogous to the way in which "extra points" or
"lone-pairs" are handled in MM force ﬁelds.

The remaining details of how the QM-MM boundary is treated are as follows: for the interactions surrounding
the link atom, the MM bond term between the QM and MM atoms is calculated classically using the classical
force ﬁeld parameters, as are any angle or dihedral terms that include at least one MM atom. The Lennard-Jones
interactions between QM-MM atom pairs are calculated in the same way as described in the section above with
exclusion of 1-2 and 1-3 interactions and scaling of 1-4 interactions. What remains is to specify the electrostatic
interactions between QM and MM atoms around the region of the link atom.

A number of different schemes have been proposed for handling link-atom electrostatics. Many of these have
been tested or calibrated on (small) gas-phase systems, but such testing can neglect some considerations that are
very important for more extended, condensed-phase simulations. In choosing our scheme, we wanted to ensure
that the total charge of the system is rigorously conserved (at the correct value) during an MD simulation. Further,
we strove to have the Mulliken charge on the link atom (and the polarity of its bond to the nearest QM atom)
adopt reasonable values and to exhibit only small ﬂuctuations during MD simulations. Link atoms interact with
the MM ﬁeld in exactly the same way as regular QM atoms. That is they interact with the electrostatic ﬁeld due
to all the MM atoms that are within the cutoff, with the exception of the MM link pair atoms (MM atoms that are
bound directly to QM atoms). VDW interactions are not calculated for link atoms. These are calculated between
all real QM atoms and all MM atoms, including the MM link pair atoms. For Generalized Born simulations the
effective Born radii for the link atoms are calculated using the intrinsic radii for the MM link pair atoms that they
are replacing.

In the case of electrostatic embedding the atoms that make up the QM region (including the MM link pair
atom) have their charges from the prmtop ﬁle essentially replaced with Mulliken charges. Hence it is important to
consider the issue of charge conservation. The QM region (including the link atoms) by deﬁnition must have an
integer charge. This is deﬁned by the &qmmm namelist variable qmcharge. If the MM atoms (including the MM
link pair atoms) that make up the QM region have prmtop charges that sum to the value of qmcharge then there is
no problem. If not, there are two options for dealing with this charge, deﬁned by the namelist variable adjust_q. A
value of 1 will distribute the difference in charge equally between the nearest nlink MM atoms to the MM link pair
atoms. A value of 2 will distribute this charge equally over all of the MM atoms in the simulation (excluding MM
link pair atoms).

10.1.2. A reformulated QM/MM interface for PM3

In the current version of Amber, a reformulated QM-MM core-charge potential (denoted as PM3/MM*) has
been implemented. This reformulated potential scales the interaction between a QM core and a MM charge for the
purpose of better description of the geometry and energy at the QM-MM interface:[337]

Ecore
QM/MM = Zaqm (sasa,smsm)

1 +

(10.6)

2 are exponential scale factors which depend on the QM atom only. Optimal values for f a

where Za is the effective core charge of QM atom a, qm is the partial charge on MM atom m, sa is an s orbital
on the QM atom, sm is a notional s orbital on the MM atom, Ram is the QM-MM interatomic distance, and f a
1
and f a
2 were
determined based on the PM3 Hamiltonian, and are available for H, C, N and O atoms (so the QM region is
limited to these four atoms; but the MM region is not restricted). Application of this reformulated potential shows
improved prediction of geometry and interaction energy at the QM-MM interface for hydrogen bonded small
molecule complexes typical of biomolecular interactions, without signiﬁcantly impacting the modeling of other
interaction types, such as dispersion dominant complexes.[337] In a QM/MM calculation, giving qmmm_int=3
along with qm_theory=PM3 will invoke this potential.

1 and f a

Based on PM3/MM*, further developments to the semi-empirical QM/MM coupling method have been intro-
duced – PM3/MMX2 (qmmm_int=4 and qm_theory=PM3) – which shares the same QM core-MM charge equation
with the PM3/MM* model. In addition, a QM parameter, ρmm, is introduced to each type of QM atoms in order
to "ﬁne-tune" the QM electron-MM charge interaction (Eq. 10.7). Although ρmm is a parameter for QM atom, the
subscript mm emphasizes that it is a MM-related property (eqn 3.xx). Parameters are currently available for H, C,
N, O and S QM atoms (manuscript in preparation).

158

(cid:20)

·(cid:16)−e− f a

|qm|
qm

2 ·Ram(cid:17)(cid:21)

1 ·Ram + e− f a

where

10.1. Built-in semiempirical NDDO methods and SCC-DFTB

∑

(cid:96)m

QM/MM = −qm(µaνa,smsm) = ∑
Eelectron
(cid:2)Ma

(cid:3) =

i j +(cid:0)ρa

lakMm
lmk

2la
∑

∑

(cid:104)

e2

r2

(cid:96)a

l

2la+lm

i=1

j=1

(cid:2)Ma

lakMm
lmk

(cid:3)
(cid:1)2(cid:105)−1/2

la+ρa
mm

(10.7)

(10.8)

10.1.3. Generalized Born implicit solvent

The implementation of Generalized Born (GB) for QM/MM calculations is based on the method described by
Pellegrini and Field.[335] Here, the total energy is taken to be Ee f f from Eq. 10.2 plus Egb from Eq. 4.2. In Egb,
charges on the QM atoms are taken to be the Mulliken charges determined from the quantum calculation; hence
these charges depend upon the molecular orbital coefﬁcients ci j as well as the positions of the atoms.

As with conventional QM/MM simulations, one then solves for the ci j by setting ∂ Ee f f /∂ ci j = 0. This leads
to a set of SCF equations with a Fock matrix modiﬁed not only by the presence of MM atoms (as in "ordinary"
QM/MM simulations), but also modiﬁed by the presence of the GB polarization terms. Once self-consistency is
achieved, the resulting Mulliken charges can be used in the ordinary way to compute the GB contribution to the
total energy and forces on the atoms.

10.1.4. Ewald and PME

The support for long range electrostatics in QM/MM calculations using electrostatic embedding is based on a
modiﬁcation of the Nam, Gao and York Ewald method for QM/MM calculations.[336] This approach works in a
similar fashion to GB in that Mulliken charges are used to represent long range interactions. Within the cutoff,
interactions between QM and MM atoms are calculated using a full multipole treatment. Outside of the cutoff the
interaction is based on pairwise point charge interactions. For semiempirical NDDO-type methods this leads to a
slight discontinuity at the QM/MM cutoff boundary and thus a small energy drift during QM/MM MD simulations
in the NVE ensemble. This energy drift can be avoided by using a switching function at the cutoff (see below).

The implementation in Ref [336] uses an Ewald sum for both QM/QM and QM/MM electrostatic interactions.
This can be expensive for large MM regions, and thus sander uses a modiﬁcation of this method by Walker and
Crowley[306] that uses a PME model (rather than an Ewald sum) for QM/MM interactions. This is controlled by
the qm_pme variable discussed below.

When running QM/MM Ewald or PME simulations in sander, if QM multipoles are involved in QM-MM
interactions (NDDO methods), a discontinuity in the QM-MM electrostatic potential occurs at the cutoff distance
due to the sudden change in the potential function (the difference between Eqs. 10.9 and 10.10) , thus resulting in
energy conservation problems in the simulation.

QM/MM = −qm(µaνa,smsm) + Zaqm(sasa,smsm)(1 + scale)
Er<cuto f f

Er>cuto f f
QM/MM =

qm(Za − ∑cµµ )

r

(10.9)

(10.10)

This problem can be avoided by applying a switching function to smoothly connect the two different potentials.

The QM/MM electrostatic potential using a switching function can thus be written as:

EQM/MM = Er<cuto f f

QM/MM s(r) + Er>cuto f f

QM/MM (1− s(r))

The switching function can be turned on or off via the &qmmm namelist variable qmmm_switch, for details see
section 10.1.6 below.

159

10. QM/MM calculations

10.1.5. Hints for running successful QM/MM calculations

Required Parameters and Prmtop Creation

QM/MM calculations without link atoms require mass, charges, van der Waals and GB radii in the prmtop
ﬁle. All bonds, angles, and dihedrals parameters involving QM atoms are neglected. In the case of electrostatic
embedding the charges are also neglected.
(Note that when SHAKE is applied to the QM reg, the bonds are
constrained to the ideal MM values, even when these are part of a QM region; hence, for this case, it is important
to have correct bond parameters in the QM region.) The simplest general prescription for setting things up is to
use antechamber and LEaP to create a reference force ﬁeld, since "placeholders" are required in the prmtop ﬁle
even for things that will be neglected. This also allows you to run comparison simulations between pure MM and
QM/MM simulations, which can be helpful if problems are encountered in the QM/MM calculations.

The use of antechamber to construct a pure MM reference system is even more useful when there are link atoms,

since here MM parameters for bonds, angles and dihedrals that cross the QM/MM boundary are also needed.

Choosing the QM region

There are no good universal rules here. Generally, one might want to have as large a QM region as possible,
but having more than 80-100 atoms in the QM region will lead to simulations that are very expensive. One should
also remember that for many features of conformational analysis, a good MM force ﬁeld may be better than a
semiempirical or DFTB quantum description. In choosing the QM/MM boundary, it is better to cut non-polar
bonds (such as C-C single bonds) than to cut unsaturated or polar bonds. Link atoms are not placed between bonds
to hydrogen. Thus cutting across a C-H bond will NOT give you a link atom across that bond. (This is not currently
tested for in the code and so it is up to the user to avoid such a situation.) Furthermore, link atoms are restricted
to one per MM link pair atom. This is tested for during the detection of link atoms and an error is generated if
this requirement is violated. This would seem to be a sensible policy otherwise you could have two link atoms too
close together. See the comments in qm_link_atoms.f for a more in-depth discussion of this limitation.

Choice of electrostatic cutoff

The implementation of the non-bonded cut off in QM/MM simulations is slightly different than in regular MM
simulations. The cut off between MM-MM atoms is still handled in a pairwise fashion. However, for QM atoms
any MM atom that is within qmcut of ANY QM atom is included in the interaction list for all QM atoms. This
means that the value of qmcut essentially speciﬁes a shell around the QM region rather than a spherical shell
around each individual QM atom. Ideally the cut off should be large enough that the energy as a function of the
cutoff has converged. For non-periodic, generalized Born simulations, a cutoff of 15 to 20 Å seems sufﬁcient in
some tests. (Remember that long-range electrostatic interactions are reduced by a factor of 80 from their gas-phase
counterparts, and by more if a nonzero salt concentration is used.) For periodic simulations, the cutoff only serves
to divide the interactions between "direct" and "reciprocal" parts; as with pure MM calculations, a cutoff of 8 or 9
Å is sufﬁcient here.

Parallel simulations

The built-in QM/MM implementation currently supports execution in parallel via the message passing interface
(MPI), however, the implementation is not fully parallel. At present all parts of the QM simulation are parallel
except the density matrix build and the matrix diagonalisation. For small QM systems these two operations do
not take a large percentage of time and so acceptable scaling can be seen to around 8 CPU cores (depending on
type of CPU and/or interconnect speed between compute nodes). For large QM systems the matrix diagonalisation
time will dominate and so the scaling will not be as good. In this case it may be beneﬁcial to choose a LAPACK
diagonalization routine in combination with a threaded library such as the Intel Math Kernel Library (MKL). For
details on how to choose the diagonalization routine see Section 9.3. The number of threads to be used for the
diagonalization is set via an environment variable of the operating system (typically OMP_NUM_THREADS).

160

10.1. Built-in semiempirical NDDO methods and SCC-DFTB

10.1.6. General QM/MM &qmmm Namelist Variables

An example input ﬁle for running a simple QM/MM MD simulation is shown here:



&cntrl

! Perform MD for 10,000 steps
! 2 fs time step

imin=0, nstlim=10000,
dt=0.002,
ntt=1, tempi=0.1, temp0=300.0, ! Berendsen temperature control
ntb=1,
ntf=2, ntc=2,
cut=8.0,
ifqnt=1

! Constant volume periodic boundaries
! Shake hydrogen atoms
! 8 angstrom classical non-bond cut off
! Switch on QM/MM coupled potential

/
&qmmm

qmmask=':753',
qmcharge=-2,
qm_theory='PM3', ! Use the PM3 semi-empirical Hamiltonian
qmcut=8.0

! Residue 753 should be treated using QM
! Charge on QM region is -2

! Use 8 angstrom cut off for QM region

/





The &qmmm namelist contains variables that allow you to control the options used for a QM/MM simulation. This
namelist must be present when running QM/MM simulations and at the very least must contain either the iqmatoms
or qmmask variable which deﬁne the region to be treated quantum mechanically. If ifqnt is set to zero then the
contents of this namelist are ignored.

For the QM region deﬁnition specify one of either iqmatoms or qmmask. Link atoms will be added automatically

along bonds (as deﬁned in the prmtop ﬁle) that cross the QM/MM boundary.

iqmatoms

comma-separated integer list containing the atom numbers (from the prmtop ﬁle) of the atoms to be
treated quantum mechanically.

qmmask

qmcut

Mask specifying the quantum atoms. E.g. :1-2, = residues 1 and 2. See mask documentation for
more info.

Speciﬁes the size of the electrostatic cutoff in Angstroms for QM/MM electrostatic interactions. By
default this is the same as the value of cut chosen for the classical region, and the default generally
does not need to be changed. Any classical atom that is within qmcut of any QM atom is included
in the pair list. For PME calculations, this parameter just affects the division of forces between
direct and reciprocal space. Note: this option only effects the electrostatic interactions between the
QM and MM regions. Within the QM region all QM atoms see all other QM atoms regardless of
their separation. QM-MM van der Waals interactions are handled classically, using the cutoff value
speciﬁed by cut.

qm_ewald

This option speciﬁes how long range electrostatics for the QM region should be treated.

= 0 Use a real-space cutoff for QM-QM and QM-MM long range interactions. In this situation QM
atoms do not see their images and QM-MM interactions are truncated at the cutoff. This is the
default for non-periodic simulations.

= 1 (default) Use PME or an Ewald sum to calculate long range QM-QM and QM-MM electrostatic

interactions. This is the default when running QM/MM with periodic boundaries and PME.

= 2 This option is similar to option 1 but instead of varying the charges on the QM images as the
central QM region changes the QM image charges are ﬁxed at the Mulliken charges obtained
from the previous MD step. This approach offers a speed improvement over qm_ewald=1,
since the SCF typically converges in fewer steps, with only a minor loss of accuracy in the
long range electrostatics. This option has not been extensively tested, although it becomes
increasingly accurate as the box size gets larger.

161

10. QM/MM calculations

kmaxqx,y,z Speciﬁes the maximum number of kspace vectors to use in the x, y and z dimensions respectively
when doing an Ewald sum for QM-MM and QM-QM interactions. Higher values give greater accu-
racy in the long range electrostatics but at the expense of calculation speed. The default value of 8
should be optimal for most systems.

ksqmaxq

qm_pme

Speciﬁes the maximum number of K squared values for the spherical cut off in reciprocal space
when doing a QM-MM Ewald sum. The default value of 100 should be optimal for most systems.

Speciﬁes whether a PME approach or regular Ewald approach should be used for calculating the
long range QM-QM and QM-MM electrostatic interactions.
= 0 Use a regular Ewald approach for calculating QM-MM and QM-QM long range electrostatics.
Note this option is often much slower than a pme approach and typically requires very large
amounts of memory. It is recommended only for testing purposes.

= 1 (default) Use a QM compatible PME approach to calculate the long range QM-MM electrostatic
energies and forces and the long range QM-QM forces. The long range QM-QM energies are
calculated using a regular Ewald approach.

qmmm_switch Speciﬁes whether a switching function shall be used at the cutoff for long range electrostatics
(applies only to NDDO methods). The lower and higher boundaries of the switching function are
user deﬁnable, see r_switch_lo and r_switch_hi.
= 0 (default). Do not use a switching function. This leads to slight discontinuities in the potential at

the cut off and thus an energy drift in NVE simulations.

= 1 Use a switching function. See also variables r_switch_hi and r_switch_lo.

r_switch_hi Speciﬁes the upper boundary of the switching function in Å (see qmmm_switch). Defaults to qmcut.

r_switch_lo Speciﬁes lower boundary of the switching function in Å (see qmmm_switch). Defaults to

r_switch_hi - 2.

qmgb

Speciﬁes how the QM region should be treated with generalized Born.
= 2 (default) As described above, the electrostatic and "polarization" ﬁelds from the MM charges and
the exterior dielectric (respectively) are included in the Fock matrix for the QM Hamiltonian.
= 3 This is intended as a debugging option and should only be used for single point calculations.
With this option the GB energy is calculated using the Mulliken charges as with option 2 above
but the fock matrix is NOT modiﬁed by the GB ﬁeld. This allows one to calculate what the GB
energy would be for a given structure using the gas phase quantum charges. When combined
with a simulation using qmgb=2, this allows the strain energy from solvation to be calculated.

qm_theory Level of theory to use for the QM region of the simulation. (Hamiltonian). Default is to use the

semi-empirical hamiltonian PM3. See the Section 9.3 for details.

Controls the way in which QM/MM interactions are handled in the direct space QMMM sum. This
controls only the electrostatic interactions. VDW interactions are always calculated classically us-
ing the standard 6-12 potential. Note: with the exception of qmmm_int=0 DFTB calculations
(qm_theory=DFTB) always use a simple mulliken charge - resp charge interaction and the value
of qmmm_int has no inﬂuence.
= 0 This turns off all electrostatic interaction between QM and MM atoms in the direct space sum.

Note QM-MM VDW interactions will still be calculated classically.

= 1 (default) QM-MM interactions in direct space are calculated in the same way for all of the
various semi-empirical hamiltonians. The interaction is calculated in an analogous way to
the the core-core interaction between QM atoms. The MM resp charges are included in the
one electron hamiltonian so that QMcore-MMResp and QMelectron-MMResp interactions are
calculated.

qmmm_int

162

10.1. Built-in semiempirical NDDO methods and SCC-DFTB

= 2 This is the same as for 1 above except that when AM1, PM3 or Hamiltonians derived from these
are in use the extra Gaussian terms that are introduced in these methods to improve the core-
core repulsion term in QM-QM interactions are also included for the QM-MM interactions.
This is the equivalent to the QM-MM interaction method used in CHARMM and DYNAMO.
It tends to slightly reduce the repulsion between QM and MM atoms at small distances. For
distances above approximately 3.5 angstroms it makes almost no difference.

= 3 Using this along with qm_theory=PM3 invokes a reformulated QM core-MM charge potential
at the QM-MM interface (Eq. 10.6). Current parametrization limits the QM region to H, C, N
and O atoms only; MM region is not restricted.[337]

= 4 Currently not in use.
= 5 Mechanical embedding: The electrostatic interaction between QM and MM atoms is treated on
the same level as within the MM region using the classical force ﬁeld point charges also for the
QM atoms. The electronic Hamiltonian does not contain the ﬁeld generated by the MM region
point charges and thus the electron density is not polarized by the MM environment. Does not
work with GB. Not extensively tested in presence of link atoms.

Controls whether SHAKE is applied to QM atoms. Using SHAKE on the QM region will allow
you to use larger time steps such as 2 fs with NTC=2. If, however, you expect bonds involving
hydrogen to be broken during a simulation you should not SHAKE for the QM region. WARNING:
the SHAKE routine uses the equilibrium bond lengths as speciﬁed in the prmtop ﬁle to reset the
atom positions. Thus while bond force constants and equilibrium distances are not used in the energy
calculation for QM atoms the equilibrium bond length is still required if QM SHAKE is on.
= 0 Do not shake QM H atoms.
= 1 Shake QM H atoms if SHAKE is turned on (NTC>1) (default).

qmshake

printdipole Controls whether the dipole moment shall be printed every ntpr steps.

= 0 Do not print the dipole moment (default).
= 1 Print the dipole moment of the QM region.
= 2 Print the total dipole moment of the QM and MM region.

writepdb

vsolv

= 0 Do not write a PDB ﬁle of the selected QM region. (default).
= 1 Write a PDB ﬁle of the QM region. This option is designed to act as an aid to the user to
allow easy checking of what atoms were included in the QM region. When this option is set a
crude PDB ﬁle of the atoms in the QM region will be written on the very ﬁrst step to the ﬁle
qmmm_region.pdb.

Controls whether solvent molecules shall be included into the QM region (requires settings in the
&vsolv namelist; see also section 10.3 on adaptive solvent QM/MM simulations, in particular the
namelist information in section 10.3.2.2).
= 0 Do not include solvent molecules into the QM region (default).
= 1 Include solvent molecules via simple solvent switching (requires &vsolv namelist).
= 2 Adaptive solvent QM/MM with ﬁxed number of solvent molecules in A and T regions (requires

&vsolv and &adqmmm namelists).

= 3 Adaptive solvent QM/MM with ﬁxed size of A and T regions (requires &vsolv and &adqmmm

namelists).

In addition to the above parameters, the following variables may be set, as described in Section 9.3:

qm_theory, dftb_disper, dftb_3rd_order , dftb_chg , dftb_telec , dftb_maxiter , qmcharge, spin, qmqmdx, ver-
bosity, tight_p_conv, scfconv, pseudo_diag, pseudo_diag_criteria, diag_routine, printcharges, qxd, parameter_ﬁle,
peptide_corr, and itrmax.

163

10. QM/MM calculations

10.1.7. Link Atom Speciﬁc QM/MM &qmmm Namelist Variables

The following options go in the &qmmm namelist and control the link atom behaviour.

lnk_dis

Distance in Å from the QM atom to its link atom. Currently all link atoms must be placed at the
same distance. A negative value of lnk_dis speciﬁes that the link atom should be placed directly on
top of the MM link pair atom. In this case the distance of the link atom from the QM region changes
as a function of time and the actual value of lnk_dis is ignored. Additionally this means that not all
link atoms will be placed at the same distance. Negative values of lnk_dis will work with regular
link atoms, such as hydrogen, but are really intended for use with pseudo atom / capping approaches.
Default = 1.09Å.

lnk_method This deﬁnes how classical valence terms that cross the QM/MM boundary are dealt with.

=1 (Default) in this case any bond, angle or dihedral that involves at least one MM atom, including
the MM link pair atom is included. This means the following (where QM = QM atom, MM =
MM atom, MML = MM link pair atom.):

Bonds = MM-MM, MM-MML, MML-QM

Angles = MM-MM-MM, MM-MM-MML, MM-MML-QM, MML-QM-QM

Dihedrals = MM-MM-MM-MM, MM-MM-MM-MML, MM-MM-MM-MML-QM, MM-

MML-QM-QM, MML-QM-QM-QM

=2 Only include valence terms that include a full MM atom, that is, count the MM link pair atom as
effectively being a QM atom. This option is designed to be used in conjunction with a pseudo
atom / capping type approach where the link atom is parameterized speciﬁcally to behave like
a uni-valent version of the MM atom it replaces. This option gives the following interactions:

Bonds = MM-MM, MM-MML

Angles = MM-MM-MM, MM-MM-MML, MM-MML-QM

Dihedrals = MM-MM-MM-MM, MM-MM-MM-MML, MM-MM-MML-QM, MM-MML-

QM-QM

lnk_atomic_no The atomic number of the link atoms. This selects what element the link atoms are to be. Default
= 1 (Hydrogen). Note this must be an integer and an atomic number supported by the chosen QM
theory.

adjust_q

This controls how charge is conserved during a QMMM calculation involving link atoms. When the
QM region is deﬁned the QM atoms and any MM atoms involved in link bonds have their RESP
charges zeroed. If the sum of these RESP charges does not exactly match the value of qmcharge then
the total charge of the system will not be correct.

= 0 No adjustment of the charge is done.
= 1 The charge correction is applied to the nearest nlink MM atoms to MM atoms that form link
pairs. Typically this will be any MM atom that is bonded to a MM link pair atom (a MM atom
that is part of a QM-MM bond). This results in the total charge of QM+QMlink+MM equaling
the original total system charge from the prmtop ﬁle. Requires natom-nquant-nlink >= nlink
and nlink>0.

= 2 (default) - This option is similar to option 1 but instead the correction is divided among all MM
atoms (except for those adjacent to link atoms). As with option 1 this ensures that the total
charge of the QM/MM system is the same as that in the prmtop ﬁle. Requires natom-nquant-
nlink >= nlink.

164

10.2. Interface for ab initio and DFT methods

10.1.8. Charge-dependent exchange-dispersion corrections of vdW interactions

The sqm program provides a new charge-dependent energy model consisting of van der Waals (vdW) and polar-
ization interactions between the quantum mechanical (QM) and molecular mechanical (MM) regions in a combined
QM/MM calculation. vdW interactions are commonly treated using empirical Lennard-Jones (L-J) potentials,
whose parameters are often chosen based on the QM atom type (e.g., based on hybridization or speciﬁc covalent
bonding environment). This strategy for determination of QM/MM nonbonding interactions becomes tedious to
parametrize and lacks robust transferability. Problems occur in the study of chemical reactions where the "atom
type" is a complex function of the reaction coordinate. This is particularly problematic for reactions, where atoms
or localized functional groups undergo changes in charge state and hybridization.

In sqm, this charge-dependent energy model was implemented based on a scaled overlap model for repulsive
exchange and attractive dispersion interactions that is a function of atomic charge. The model is chemically
signiﬁcant since it properly correlates atomic size, softness, polarizability, and dispersion terms with minimal
one-body parameters that are functions of the atomic charge[310].

This “Charge-dependent exchange-dispersion corrections of vdW interactions” can be invoked by the
“qxd=.true.” switch in the &qmmm namelist. Note that this model currently does not have any effect on pure
quantum calculations through sqm, the qxd correction is only added to QM/MM interactions in sander. The de-
fault values of qxd parameters are set to reproduce the regular L-J interactions of typical atom types (HC for H,
C* for C, N for N, OW for O, and parameters for F and Cl are optimized[310]) when the charge dependence
parameters are zero. There are eight qxd parameters (symbols used in the reference[310] are indicated in the
parentheses): qxd_s (s), qxd_z0 (ζ (0)), qxd_zq (ζq), qxd_d0 (α1), qxd_dq (3× B), qxd_q0 (α2), qxd_qq (3× B),
and qxd_neff (Ne f f (0)). All parameters can be modiﬁed through external user-deﬁned parameter ﬁles (see the
usage of ’parameter_ﬁle’ in Section 9.3).

10.2. Interface for ab initio and DFT methods

In addition to the built-in semi-empirical methods sander also supports QM/MM simulations with ab initio wave
function theory (WFT) and density functional theory (DFT) potentials via an interface to external QM software
packages[338]. The implementation makes use of the existing QM/MM infrastructure that has been developed
earlier for the semi-empirical methods. Thus, much of AMBER’s previous QM/MM functionality such as the user-
friendly link atom approach are available and the implementation remains simple and transparent to use without
any signiﬁcant additional steps in the simulation setup as compared to semi-empirical QM/MM simulations. At
present the interface supports several well-known and widely used QM software packages. Mechanical embedding
is available for

• ADF (Amsterdam Density Functional) [339, 340]

• GAMESS-US [341, 342]

• NWChem [343]

Mechanical and electrostatic embedding is available for

• Gaussian [344]

• Orca [345]

• Q-Chem[346][346]

• TeraChem [347]

• MRCC [348, 349]

• Fireball [350]

165

10. QM/MM calculations

While ADF, Gaussian, Q-Chem and TeraChem are commercial programs, GAMESS-US, NWChem, Orca, MRCC
and Fireball are available at no cost for academic research. Fireball, which implements a density functional theory-
based tight binding approach, requires compilation of sander with special ﬂags, see the section on Fireball below
for details. The interface has been written in a modular fashion and is easily extensible to support other QM
software packages. It is our intention to keep adding support for other software packages. If you are interested in
interfacing a speciﬁc program, please do not hesitate to contact us.

The interface was developed by Andreas Goetz (SDSC, UCSD) with help of Matthew Clark (SDSC) and support
by Ross Walker (SDSC, UCSD). Thanks are due to Christine Isborn and Todd Martinez (Stanford University) for
modiﬁcations to the TeraChem code to support this interface, to Mark Williamson (University of Cambridge) for
an initial version of the module that supports NWChem, Bence Hégely for contributing code that supports MRCC,
and Jesús Mendieta and José Ortega Mateo for contributing code that supports Fireball. If you make use of this
interface, please cite the following work:

• A. W. Götz, M. A. Clark, R. C. Walker, An extensible interface for QM/MM molecular dynamics simulations

with AMBER, J. Comput. Chem. 35, 95-108 (2014), DOI: 10.1002/jcc.23444

If you are using the interface with the TeraChem code, please cite in addition the following work:

• C. M. Isborn, A. W. Götz, M. A. Clark, R. C. Walker, T. J. Martínez, Electronic Absorption Spectra from
MM and ab initio QM/MM Molecular Dynamics: Environmental Effects on the Absorption Spectrum of
Photoactive Yellow Protein, J. Chem. Theory Comput. 8, 5092-5106 (2012), DOI: 10.1021/ct3006826

If you are using the interface with the MRCC code, please cite in addition the following work:

• B. Hégely, F. Bogár, G. G. Ferenczy, M. Kállay, A QM/MM program for calculations with frozen localized
orbitals based on the Huzinaga equation, Theoret. Chem. Acc. 134, 132 (2015), DOI: 10.1007/978-3-662-
49825-5_16

If you are using the interface with the Fireball code, please cite in addition the following work:

• J. I. Mendieta-Moreno, R. C. Walker, J. P. Lewis, P. Gómez-Puertas, J. Mendieta, J. Ortega, FIREBALL/AM-
BER: An efﬁcient local-orbital DFT QM/MM method for biomolecular systems, J. Chem. Theory Comput.
10, 2185-2193 (2014), DOI: 10.1021/ct500033w

Access to QM methods not available within Amber is also possible via the Amber interface to the PUPIL simulation
framework. For details, see refs. 351, 352. In what follows we will describe the new interface that is native to
sander.

10.2.1. Theory

As described in section 10.1, the Hamiltonian of a system that is partitioned into a QM region that is treated
with WFT and a classical region that is treated with MM consists of three components and the energy associated
with this Hamiltonian is obtained as the corresponding expectation value

E = (cid:104)Ψ|HQM + HQM/MM|Ψ(cid:105) + EMM.

(10.11)
A QM/MM calculation therefore requires not only to choose the WFT used in the QM region and the MM model
used for the MM region, but in addition also the form of the QM/MM Hamiltonian which describes the interaction
between the quantum and the classical region. The most simple approach is to neglect any electronic coupling
between the QM and the MM system and include only the classical non-bonded van der Waals (vdW) and electro-
static interactions between the QM and the MM atoms. This is useful to impose steric constraints on the embedded
QM system and commonly referred to as mechanical embedding. In most cases, however, it is better to allow for
an explicit polarization of the QM system due to the presence of the point charges on the MM atoms. This is
referred to as electronic embedding and the resulting interaction energy becomes

166

10.2. Interface for ab initio and DFT methods

(cid:90)

ρ(r)

QM/MM = ∑
Eelectronic
A∈MM
+ ∑
A∈QM,B∈MM

QA
(cid:34)(cid:18)σAB
|r− RA| dr + ∑
(cid:18)σAB

(cid:19)12 −

A∈QM,B∈MM

εAB

ZAQB
RAB

(cid:19)6(cid:35)

.

RAB

RAB

(10.12)

This QM/MM energy expression also holds for DFT and the terms represent, in order, the electrostatic interaction
between the QM electron density and the MM point charges, the electrostatic interation between the QM point
charge nuclei and the MM point charges, and the van der Waals repulsion between the QM and MM atoms.

The forces acting on an atom A in a QM/MM calculation are given in terms of derivatives of the total energy

expression (10.11) with respect to the Cartesian coordinates of the atom,

FA = −∇AEQM − ∇AEQM/MM − ∇AEMM,
A,∂ /∂ Rz

(10.13)
where ∇A = ∂ /∂RA = (∂ /∂ Rx
A). If a QM and an MM program are coupled for QM/MM calcula-
tions, the QM program will calculate the QM forces −∇AEQM acting on QM atoms and the MM program the MM
forces −∇AEMM acting on the MM atoms. All that remains, is to calculate the forces acting on QM and MM atoms
due to the QM/MM interaction energy, −∇AEQM/MM. For mechanical embedding this will be entirely handled by
the MM program. For electronic embedding the forces are given as

A,∂ /∂ Ry

QB(RA − RB)

∇AEelectronic

QM/MM = ZA ∑
B∈MM

R3
AB
= −ZAEMM(RA)−

(cid:90)

+ ∑
B∈MM

∂RA
ρ(r)EMM(r)dr + ∑
B∈MM

QB
|r− RB| dr + ∑
B∈MM
∇AV LJ
AB

∇AV LJ
AB

(10.14)

(cid:90) ∂ρ(r)

for the derivatives with respect to the positions of the QM atoms A where EMM is the electric ﬁeld generated by
the MM point charges and and V LJ

AB is the Lennard-Jones potential from (10.12) and

(cid:90)

+

∇BEelectronic

QM/MM = QB ∑
A∈QM

ZA(RB − RA)

R3
AB

ρ(r)

QB(RB − r)
|r− RB|3 dr + ∇BEmechanic

QM/MM

(10.15)

= −QBEQM(RB) + ∑
A∈QM

∇BV LJ
AB

for the derivatives with respect to the positions of the MM atoms B where EQM is the electric ﬁeld due to the QM
charge distribution. The contributions to the gradient due to the point charge interactions and due to the interaction
between the MM point charges and the QM electrons is evaluated by the QM program. Some QM programs do not
calculate the forces acting on the MM atoms (point charges) due to the presence of the QM system but in general
are able to return the electric ﬁeld EQM at arbitrary points in space which is then used to obtain these forces. The
van der Waals repulsion (Lennard-Jones interaction) between QM and MM atoms is treated by AMBER in the
same way as for semiempirical NDDO-type and DFTB methods.

10.2.2. General Remarks

When using the AMBER interface to external QM software packages for performing WFT or DFT based QM or
QM/MM MD simulations, it is absolutely critical to be aware of the capabilities and limitations of the QM method
to be employed. In particular, QM based MD can be more tricky than MM based MD in the sense that it is more
likely that the QM program can fail for example due to SCF convergence problems. This can be the case if the
geometry of the QM region is far from its ground state equilibrium, for example because a simulation is started
from a bad geometry or performed at high temperature.

We have gone to large efforts and analyzed a large set of test simulations to provide the best default parameters

167

10. QM/MM calculations

for the supported QM programs such that forces are computed with sufﬁcient accuracy to guarantee energy coser-
vation for constant energy MD simulations. Of particular importance are SCF convergence and associated integral
neglect thresholds and the size of the grid used for the numerical quadrature of the exchange-correlation (XC)
potential and energy for DFT calculations. However, other than providing appropriate input parameters, AMBER
does not have any control over the external program and it is at the user’s discretion to employ sensible input
parameters for the QM program and to prepare the system such that the simulations are started at a reasonable
starting structure.

In any case we highly recommend to write restart ﬁles frequently so that a simulation can be restarted without
loss of much computational time in the case that a simulation should crash. The interface also stores the last in-
and output ﬁles of the external QM program during each MD step. Should there be any problems with the QM
program, it is therefore possible to analyze the reasons and take appropriate countermeasures.

The interface requires data to be exchanged between sander and the QM program. The default operation of
the interface is based on ﬁle exchange and system calls and, during each step of a geometry optimization or an
MD simulation, writes an input ﬁle for the external program, starts a single point gradient calculation with the
external program, and reads the energy and forces from the external program’s output ﬁle (binary ADF checkpoint
or formatted GAMESS, Gaussian, ORCA, Q-Chem, MRCC or TeraChem output ﬁles). Data communication via
MPI is also implemented and currently supported by TeraChem. An exception is Fireball, which is interfaced as a
linked library against sander (see below).

10.2.3. Limitations

In principle, all types of simulations that are possible with sander are supported. There are, however, some
restrictions for simulations that require sander to run in parallel, in particular path integral molecular dynam-
ics (PIMD) and replica exchange molecular dynamics (REMD), see the discussion of Parallelization below. The
interface to external QM programs also lacks some features regarding solvent models in comparison to the semiem-
pirical MNDO and DFTB QM/MM implementation that is available in AMBER, the most critical ones are listed
here.

Generalized Born Generalized Born (GB) implicit solvent models are not supported if external QM programs
are used for the QM region.

Particle Mesh Ewald (PME) and Periodic Boundary Conditions The PME approach for treating long-range
electrostatic QM/MM and QM/QM interactions in periodic systems is currently not supported. It is possible to
use periodic boundary conditions but a cutoff is used for the point charges to be included in the QM Hamiltonian
(determined by &qmmm namelist variable qmcut) thus truncating the long-range QM/MM electrostatic interactions
in (10.12). This leads to discontinuities in the potential energy surface and poor energy conservation for MD runs
in the NVE ensemble. The user may consider running non-periodic simulations with a cutoff that is larger than the
system size thus effectively including all interactions.

10.2.4. Performance Considerations

The computational cost of DFT is comparable to Hartree–Fock (HF) theory which is the simplest WFT method
that serves as zeroth order approximation for more elaborate correlated WFT methods such as Møller–Plesset per-
turbation theory, conﬁguration interaction theory and coupled cluster theory. The calculations can be accelerated
by using density ﬁtting approaches, sometimes called resolution-of-identity (RI) approximation, which in the case
of DFT with exchange-correlation (XC) functionals that do not require admixture of exact HF-exchange, leads to
speedups of roughly one order of magnitude without compromising the accuracy of the results. Nevertheless, the
computational cost of DFT is in general two to three orders of magnitude higher than that of semiempirical QM
models. We recommend to carefully test the performance of the QM program to choose an optimal number of
processor counts for parallelized QM calculations. Typical simulation performance for typical QM system sizes of
tens of atoms will be on the order of a few picoseconds per day, depending on the underlying QM model chosen.

168

10.2. Interface for ab initio and DFT methods

10.2.5. Parallelization

The MPI parallel executable sander.MPI can be used to run QM/MM MD simulations with external QM software
in which the MM portion of the calculation is parallelized. However, the computational cost of the MM part is
usually small compared to the cost of the QM part. In order to execute the QM part of the calculation in parallel,
the external QM program has to be instructed to do so, as described in the sections below.

In the case of PIMD or REMD simulations that require a separate energy and force evaluation for each group
at each time step, the parallelized executable sander.MPI has to be used. Multiple processes can be launched per
group to parallelize the MM calculations. Care has to be taken to choose the right number of parallel threads in
the external QM program. For example, on a machine with 32 cores, a simulation with 16 beads or replicas can
run the external QM program with 2 threads in parallel to make maximum use of the available processing cores.
If the available processors are spread over multiple nodes, special care has to be taken to ensure that the different
instances of the external QM program are launched on the correct nodes.

It is possible to execute sander.MPI in parallel via MPI while also running MPI or OpenMP parallel versions
of the external QM program. Depending on the MPI implementation, this can, however, fail. In our experience,
MPICH and MVAPICH work well while OpenMPI does not work.

10.2.6. Usage

All that is required to use the interface is a working installation of AMBER and one or more of the supported

QM programs. In order to use the external program from within sander, the &cntrl namelist variable ifqnt = 1
must be set to enable QM calculations and the &qmmm namelist variable qm_theory = ’EXTERN’ must be set to
enable the external interface. The &qmmm namelist variable qmmask or iqmatoms is used for selecting the QM
region just as for QM/MM calculations with the semiempirical NDDO-type and DFTB approaches that are
natively available in AMBER. Charge and spin multiplicity for the QM region need to be deﬁned via the variables
qmcharge and spin, respectively, in the &qmmm namelist. For a QM MD simulation, the sander input ﬁle
therefore needs to contain





! example input for QM simulation with external QM program
&cntrl

...
ifqnt = 1,

/
&qmmm

! switch on QM/MM

qmmask = '@*',
qmcharge = 0,
spin = 1,
qm_theory = 'EXTERN', ! use external QM program

! select QM atoms (here: make all QM)
! charge on QM region (default = 0)
! spin multiplicity of QM region (default = 1)

/



For QM/MM simulations with electronic embedding (this is the default) we recommend to include all MM point
charges as external electric ﬁeld in the QM Hamiltonian to avoid problems with energy conservation. For non-
periodic simulations this can be achieved by setting the &qmmm namelist variable qmcut to a value larger than the
system size.

In addition either the &adf, &gms, &nw, &gau, &orc, &qc, &mrcc or &tc namelist must be present to use
either ADF, GAMESS, NWChem, Gaussian, ORCA, Q-Chem, MRCC or TeraChem, respectively, and to assign
parameters for the external QM program. Please refer to the ADF, GAMESS, NWChem, Gaussian, ORCA, Q-
Chem, MRCC or TeraChem user manual for details on settings for the ab initio or DFT calculations. A list
of namelist variables and their default setting is given below. The defaults have been chosen such that energy
conserving MD simulations in the NVE ensemble are possible. NWChem has not been extensively tested.

Properties that are calculated along the trajectory are printed to property ﬁles with names adf_job.ext,
gms_job.ext, gau_job.ext, orc_job.ext, qc_job.ext and tc_job.ext, where ext is either dip for dipole
moment (x, y, z component and absolute value) or chg for atomic charges, where supported. These property ﬁles

169

10. QM/MM calculations

are only written if requested and will be deleted at the beginning of a run, so back them up in case a trajectory
needs to be restarted.

All calculations with a spin multiplicity larger than one will automatically be performed in the framework of
an unrestricted formalism (as opposend to restricted open shell), that is with unrestricted HF (UHF), unrestricted
DFT (UDFT) and MP2 with a UHF reference wave function (UMP2).

In addition to controlling the external programs via the sander input ﬁle, you may supply a template input ﬁle
for the external program in order to provide input that is not supported via the program speciﬁc namelists. To
enable this option, you must set use_template = 1 in the program speciﬁc namelist. The format, name, and
input requirements for the template ﬁle vary with the external program as detailed in the corresponding program’s
documentation below. If you are using your own template, please make sure that the parameters of the QM method
(like SCF convergence threshold and XC quadrature grid size) yield sufﬁciently accurate forces. Please note that
program settings supplied via the program speciﬁc namelist are ignored if a template input ﬁle is used.

10.2.6.1. AMBER/ADF

To use ADF with the external interface, ADF must be properly installed on the working machine. In particular,
the executable adf must be in the search path. By default the Becke integration grid with quality “good” and the
ZLM ﬁt method with quality “good” is employed. If you prefer to use the old pair ﬁt method (or are using an older
ADF version that does not support the ZLM ﬁt), we recommend to use “ZORA/QZ4P” basis set for the density ﬁt
for sufﬁciently accurate forces.

Limitations At present only mechanical embedding is supported.

&adf Namelist variables

basis

core

Basis set type to be used in the DFT calculation. Valid standard basis set types are: SZ, DZ, DZP,
TZP, TZ2P, TZ2P+ and ZORA/QZ4P. (Default: basis = ’DZP’)

Type of frozen core to use. Allowed values are: None, Small, Medium, Large. (Default: core =
’None’)

zlmfit

Quality of density ﬁt with the ZLM ﬁt method. (Default: zlmﬁt = ’good’)

fit_type

Fit basis set type to be used for density ﬁtting with the old pair ﬁt method. Valid values are identical
to the available basis sets (SZ, DZ etc) in which case the ﬁt basis corresponding to the AO Basis will
be used. By default the ZLM ﬁt method will be used (Default: ﬁt_type = ”)

xc

Exchange-correlation functional to be used. Popular choices are ’LDA VWN’, ’GGA BLYP’, ’GGA
PBE’, ’HYBRID B3LYP’ and ’HYBRID PBE0’. Consult the ADF manual for all available options.
(Default: xc = ’GGA BLYP’)

scf_iter Maximum number of SCF cycles allowed. (Default: scf_iter = 50)

scf_conv

Threshold upon which to stop the SCF procedure. The tested error is the commutator of the Fock
matrix and the density matrix. Convergence is considered to be achieved if the maximum element of
the commutator (which is zero for an optimized wave function) is smaller than scf_conv. (Default:
scf_conv = 1.0d-06)

beckegrid Quality of Becke integration grid. Allowed values are: Normal, Good, VeryGood. (Default: core =

’Good’)

integration Numerical

integration accuracy for integration with olde teVelde-Baerends integration grid
(Voronoi cells). By default the Becke grid will be used. The old integration grid can be used by
specifying a number larger than 0, we recommend at least 5.0. (Default: integration = -1.0)

170

10.2. Interface for ab initio and DFT methods

num_threads Number of threads (and thus CPU cores) for ADF to use. Note that this is not required if you
are running in a queuing system as ADF will automatically use the full number of reserved cores.
(Default: num_threads = 0 [this causes ADF to use all available cores on a machine])

use_dftb

Speciﬁes whether DFTB shall be used with ADF’s DFTB program dftb. If use_dftb = 1 then DFTB
will be used and only variables charge and scf_conv will be considered. (Default: use_dftb = 0 [do
not use DFTB, regular DFT calculation]) - works only with older DFTB versions (prior to 2011).

exactdensity The exact (as opposed to ﬁtted) electron density is used for the evaluation of the exchange-

correlation potential if exactdensity = 1. (Default: exactdensity = 0)

use_template Determine whether or not to use a user-provided template ﬁle for running external programs.

(Default: use_template = 0)

ntpr

Controls frequency of printing for dipole moment to ﬁle adf_job.dip (Defaults to &cntrl namelist
variable ntpr)

dipole

Toggles writing of dipole moment to ﬁle adf_job.dip (Default: dipole = 0)

Example An input ﬁle for QM or (mechanical embedding) QM/MM MD with ADF using the PBE functional
and the TZP basis set therefore would have to contain


/

&adf

xc = 'GGA PBE',
basis = 'TZP',




This would execute a simulation in which the Beckgrid with quality quality good and the ZLM ﬁt with quality
good are used (see default values above).

Template input ﬁle The template ﬁle for ADF should be named adf_job.tpl and must contain the following
keywords:

BASIS ... END
SAVE TAPE21

You should not include the following (block) keywords in the template ﬁle as these are taken care of by sander:

UNITS
FRAGMENTS ... END
RESTART
GRADIENT
ATOMS ... END

10.2.6.2. AMBER/GAMESS-US

To use GAMESS with the external interface, GAMESS must be compiled on the target system. Make note of the
version number you specify during the GAMESS compilation process (default is 00 which makes the GAMESS
execution script rungms look for the executable gamess.00.x). If you use a different version number you must
specify it with the gms_version namelist variable. $GMS_PATH should be set to the path where the script rungms
is located (for example /opt/gamess/). We assume that the rungms script copies the output .dat ﬁles to the
directory from which GAMESS is invoked. If this is not the case, please modify the script rungms accordingly.

Limitations Only mechanical embedding is supported with GAMESS. The available QM models are limited to
HF, DFT and MP2 since only for these analytical gradients are available in GAMESS.

171

10. QM/MM calculations

&gms Namelist variables

basis

method

nrad

nleb

Basis set type to be used in the calculation. Presently supported are the Pople type basis sets STO-3G,
6-31G, 6-31G*, 6-31G**, 6-31+G*, 6-31++G*, 6-311G, 6-311G* and 6-311G**. Also supported
are the Karlsruhe valence triple zeta basis sets KTZV, KTZVP and KTZVPP (with none, one and
two polarization functions, respectively) and the Dunning-type correlation consistent basis sets CCn
(n = D, T, Q, 5, 6; ofﬁcially called cc-pVnZ) and ACCn (as CCn but augmented with a set of diffuse
function, ofﬁcially called aug-cc-pVnZ). (Default: basis = "6-31G*")

QM method to be used. At present, we support ’HF’ for Hartree–Fock, ’MP2’ for second order
Møller-Plesset perturbation theory and any of the supported DFT functionals. Popular choices for
for DFT functionals include BP86, BLYP, PBE, B3LYP or PBE0. (Default: method = "BP86")

Number of radial points in the Euler-MacLaurin quadrature of the XC potential and energy density.
(Default: nrad = 96)

Number of angular points in the Lebedev grids for the numerical quadrature of the XC potential
and energy density. (Default: nleb = 590 [The GAMESS default of 302 is not accurate enough to
conserve energy])

scf_conv

SCF convergence threshold. Convergence is reached when the absolute density change between two
consecutive SCF cycles is less than scf_conv}. (Default: scf_conv = 1.0D-06)

maxit

Maximum number of SCF iterations. (Default: maxit = 50)

gms_version This is the version number speciﬁed when building GAMESS. (Default: gms_version = 00)

num_threads Number of threads (and thus CPU cores) for GAMESS to use. Note that GAMESS may require a
special setup in the rungms script to be able to run using multiple threads. Unless num_threads is
explicitly speciﬁed, GAMESS will only use one thread (run on one core). (Default: num_threads =
1)

mwords

The maximum replicated memory which your job can use, on every node. This is given in units
of 1,000,000 words (as opposed to 1024*1024 words), where a word is deﬁned as 64 bits. You
may need to increase this value if GAMESS crashes due to not having enough memory allocated.
(Default: mwords = 50)

use_template Determine whether or not to use a user-provided template ﬁle for running external programs.

(Default: use_template = 0)

ntpr

chelpg

Controls frequency of printing for dipole moment and atomic charges to ﬁles gms_prop.ext (De-
faults to &cntrl namelist variable ntpr)

CHELPG charges are calculated if chelpg = 1. These charges are written to the ﬁle gms_prop.chg
(Default: chelpg = 0)

dipole

Toggles writing of dipole moment to ﬁle gms_prop.dip (Default: dipole = 0)

Example An input ﬁle for QM or (mechanical embedding) QM/MM MD with GAMESS using the PBE
functional and the 6-31G** basis set that should run GAMESS on 16 CPU cores therefore would have to contain





&gms

method = 'DFT',
dfttyp = 'PBE',
basis
num_threads = 16,

= '6-31G**',

/

172



Template input ﬁle The template ﬁle for GAMESS should be named gms_job.tpl and the $CONTRL card must
contain the following keywords:

10.2. Interface for ab initio and DFT methods

RUNTYP=GRADIENT
UNIT=ANGS
COORD=UNIQUE

You should not include the $DATA card in the template ﬁle as it is taken care of by sander.

10.2.6.3. AMBER/Gaussian

To use Gaussian with the interface, Gaussian 16, Gaussian 09, or Gaussian 03 must be properly installed on the

system and a g16, g09, or g03 executable must be in the path.

Limitations A cutoff is applied to QM/MM interactions in QM/MM simulations using electrostatic embedding
with and without PBCs. This leads to discontinuities in the potential energy surface and poor energy conservation.
In the case of QM/MM simulations without PBCs, this cutoff (qmcut variable in the &qmmm namelist) can be set
to a number that is larger than the simulated system, thus effectively not applying a cutoff. This is recommended.

&gau Namelist variables

basis

method

scf_conv

Basis set type to be used in the calculation. Any basis set that is natively supported by Gaussian
can be used. Examples are the single zeta, split valence or triple zeta Pople type basis sets STO-3G,
3-21G, 6-31G and 6-311G. The split-valence or triple zeta basis sets can be augmented with diffuse
functions on heavy atoms or additionally hydrogen by adding one or two plus signs, respectively,
as in 6-31++G. Polarization functions on heavy atoms or additionally hydrogens are used by adding
one or two stars, respectively, as in 6-31G**. (Default: basis = "6-31G*")

Method to be used in the calculation. Can either be one of the WFT models for which Gaussian
supports gradients, for example RHF or MP2, or some supported DFT functional. Popular choices
are BLYP, PBE and B3LYP. (Default: method = "BLYP")

Threshold upon which to stop the SCF procedure. The tested error is the commutator of the Fock
matrix and the density matrix. Convergence is considered to be achieved if the maximum element of
the commutator (which is zero for an optimized wave function) is smaller than scf_conv}. Set in the
form of 10−N. (Default: scf_conv = 8)

num_threads Number of threads (and thus CPU cores) for Gaussian to use. Unless num_threads is explicitly

speciﬁed, Gaussian will only use one thread (run on one core). (Default: num_threads = 1)

executable Optional name of the Gaussian executable. (Default: If a string for this namelist variable is not
speciﬁed then g16, g09, and g03 are tried in that order producing a fatal error if none are found.
Note that if a string is speciﬁed then it is a fatal error if that executable is not found.)

use_template Determine whether or not to use a user-provided template ﬁle for running external programs.

(Default: use_template = 0)

ntpr

Controls frequency of printing for dipole moment to ﬁle gau_job.dip (Defaults to &cntrl namelist
variable ntpr)

dipole

Toggles writing of dipole moment to ﬁle gau_job.dip (Default: dipole = 0)

mem

String that speciﬁes how much memory Gaussian should be allowed to use. (Default: ’256MB’)

173

10. QM/MM calculations



Example An input ﬁle for QM or QM/MM MD with Gaussian using the BP86 functional and the 6-31G**
basis set and running in parallel on 8 threads (using 1 GB of memory) therefore would have to contain



&gau

method = 'BP86',
basis
num_threads = 8,
mem='1GB',

= '6-31G**',

/



Template input ﬁle The template ﬁle for Gaussian should be named gau_job.tpl and should only contain the
route section of a Gaussian input ﬁle. The route section deﬁnes the method to be used and SCF convergence
criteria. Charge and spin multiplicity are speciﬁed via the &qmmm namelist. For example for a B3LYP
calculation with 6-31G* basis set, the route section would be:

#P B3LYP/6-31G* SCF=(Conver=8)

Do not include any information about coordinates or point charge treatment since this will all be handled by sander.
Also, do not include any Link 0 Commands (line starting with %) since these are handled by sander. If you want
to run Gaussian in parallel, specify the number of processors via the num_threads variable in the &gau namelist.

10.2.6.4. AMBER/Orca

To use Orca with the interface, Orca must be properly installed on the system, the Orca executables need to
reside in a directory that is in the search path. For convenience of use, namelist parameters in general correspond
to Orca keywords, see the Orca manual for details.

Limitations A cutoff is applied to QM/MM interactions in QM/MM simulations with and without PBCs. This
leads to discontinuities in the potential energy surface and poor energy conservation. In the case of QM/MM
simulations without PBCs, this cutoff (qmcut variable in the qmmm namelist) can be set to a number that is larger
than the simulated system, thus effectively not applying a cutoff. This is recommended.

Also note that ORCA only supports OpenMPI for parallel calculations.

&orc Namelist variables

Basis set type to be used in the calculation. Possible choices include svp, 6-31g, etc. See Orca
manual for a complete list. (Default: basis = "SV(P)")

Auxiliary basis set for correlation ﬁtting. See Orca manual for a complete list. (Default: basis =
"NONE")

Auxiliary basis set for Coulomb ﬁtting. See Orca manual for a complete list. (Default: basis =
"NONE")

Method to be used in the calculation. Popular choices include hf, pm3, blyp, and mp2. (Default:
method = "blyp")

General SCF convergence setting for simpliﬁed Orca input. Can take values ’TIGHTSCF’, ’VERY-
TIGHTSCF’, etc. (Default: convkey=’VERYTIGHTSCF’)

(Default: scfconv = -1, that is, not in use since we
SCF convergence threshold for the energy.
use the general convergence settings keyword convkey. Otherwise this would lead to SCF energy
convergence of 10−Nau, if set to N.)

basis

cbasis

jbasis

method

convkey

scfconv

174

10.2. Interface for ab initio and DFT methods

grid

Grid type used during the SCF for the XC quadrature in DFT. (Default: grid = 4, this corresponds to
Intacc = 4.34 for the radial grid and an angular Lebedev grid with 302 points. Conservatively chosen
together with ﬁnalgrid to conserve energy.)

finalgrid Grid type used for the energy and gradient calculation after the SCF for the XC quadrature in DFT.
(Default: ﬁnalgrid = 6, this corresponds to Intacc = 5.34 for the radial grid and an angular Lebedev
grid with 590 points. Conservatively chosen together with grid to conserve energy.)

maxiter

Maximum number of SCF iteractions. (Default maxiter = 100)

maxcore

Global scratch memory (in MB) used by Orca. You may need to increase this when running larger
jobs. See Orca manual for more information. (Default maxcore = 1024)

num_threads Number of threads (and thus CPU cores) for Orca to use. Note that Orca only supports OpenMPI.

(Default: num_threads = 1)

use_template Determine whether or not to use a user-provided template ﬁle for running external programs.

(Default: use_template = 0)

ntpr

Controls frequency of printing for the dipole moment to ﬁle orc_job.dip (Defaults to &cntrl
namelist variable ntpr)

dipole

Toggles writing of the dipole moment to ﬁle orc_job.dip (Default: dipole = 0)

Example An input ﬁle for QM or QM/MM MD with Orca using the BLYP functional, the SVP basis set
therefore would have to contain


/

&orc

method = 'blyp',
basis

= 'svp',




Template input ﬁle The template ﬁle for Orca should be named orc_job.tpl and must at least contain
keywords specifying the method and basis set to be used in the calculation, for example:

# ORCA input file for BLYP/SVP simulation
! BLYP SVP

You should not include the following keywords in the template ﬁle as these are taken care of by sander (like
setting the runtype and adding coordinates):

# NOT to be included in ORCA input file
!engrad
!energy # (or any run type)
%pointcharges
*xyzfile # (or any coordinates)

10.2.6.5. AMBER/Q-Chem

To use Q-Chem with the interface, Q-Chem must be properly installed on the system. The q-chem executable
needs to reside in a directory that is in the search path. For convenience of use, namelist parameters in general
correspond to Q-chem keywords, see the Q-Chem manual for details. The interface has been tested with Q-Chem
versions 4.0.0.1 and 4.1.1 for HF, DFT and MP2. Other methods have not been tested and could cause problems -
please be careful and verify that forces/energies used by sander are correct in this case.

175

10. QM/MM calculations

Limitations A cutoff is applied to QM/MM interactions in QM/MM simulations with and without PBCs. This
leads to discontinuities in the potential energy surface and poor energy conservation. In the case of QM/MM
simulations without PBCs, this cutoff (qmcut variable in the qmmm namelist) can be set to a number that is larger
than the simulated system, thus effectively not applying a cutoff. This is recommended.

&qc Namelist variables

basis

Basis set type to be used in the calculation. Possible choices include ’6-31g**’, ’cc-pVDZ’ etc. See
the Q-chem manual for a complete list. (Default: basis = ’6-31G*’ for DFT calculations and basis =
’cc-pVDZ’ for MP2)

auxbasis

Auxiliary basis set for density ﬁtting / RI methods. See Q-Chem manual for a complete list. (Default:
basis = ’rimp2-cc-pVDZ’ for RI-MP2 calculations, otherwise none)

method

Method to be used in the calculation. Popular choices include ’BLYP’ or other density function-
als, ’MP2’ and ’RIMP2’. Alternatively, the keywords exchange and correlation can be employed.
(Default: method = ’BLYP’)

exchange

Exchange method. Can be speciﬁed together with the correlation keyword in place of the combined
method keyword. (Default: exchange = ”)

correlation Correlation method. Can be speciﬁed together with the exchange keyword in place of the combined

method keyword. (Default: correlation = ”)

scf_conv

SCF convergence threshold. (Default: scfconv = 6)

num_mpi_prcs Number of MPI processes for Q-Chem to use. The total number of CPUs to be used is

num_mpi_prcs times num_threads. (Default: num_mpi_prcs = 1)

num_threads Number of threads for Q-Chem to use for each MPI process. Really this is number of threads. The
total number of CPUs to be used is num_mpi_prcs times num_threads. (Default: num_threads = 1)

use_template Determine whether or not to use a user-provided template ﬁle for running external programs.

(Default: use_template = 0)

ntpr Controls frequency of printing for the dipole moment to ﬁle qc_job.dip (Defaults to &cntrl namelist variable
ntpr)

dipole

guess

Toggles writing of the dipole moment to ﬁle qc_job.dip. This is currently not supported. (Default:
dipole = 0)

Toggles use of MOs from previous step as initial guess to accelerate SCF convergence. Any string
different from ’read’ will disable this. (Default: guess = ’read’)

Example An input ﬁle for QM or QM/MM MD with Q-Chem using MP2 with the cc-pVTZ basis set therefore
would have to contain





/

&qc

176

method = 'mp2',
basis

= 'cc-pVTZ',

Template input ﬁle The template ﬁle for Q-chem must be named qc_job.tpl and must only contain keywords
in the Q-Chem $rem input section that specify the QM method and basis set to be used in the calculation, for
example:

10.2. Interface for ab initio and DFT methods

EXCHANGE becke
CORRELATION lyp
BASIS 6-311G**
SCF_CONVERGENCE 7

The interface will take care of adding other keywords to the $rem section such as JOBTYPE and writing the
$molecule input ﬁle sections.

10.2.6.6. AMBER/MRCC

To use MRCC with the interface, the MRCC program suite must be properly installed on the system. The MRCC
driver program dmrcc needs to reside in a directory that is in the search path. For convenience of use, namelist
parameters in general correspond to MRCC keywords, see the MRCC manual for details. The interface has been
tested with the MRCC release from July 15, 2016 for HF and DFT. Other methods have not been tested but should
also work - please be careful and verify that forces/energies used by sander are correct in this case.

Limitations A cutoff is applied to QM/MM interactions in QM/MM simulations with and without PBCs. This
leads to discontinuities in the potential energy surface and poor energy conservation. In the case of QM/MM
simulations without PBCs, this cutoff (qmcut variable in the qmmm namelist) can be set to a number that is larger
than the simulated system, thus effectively not applying a cutoff. This is recommended.

&mrcc Namelist variables

basis

calc

dft

mem

Basis set type to be used in the calculation. Possible choices include ’6-31g**’, ’cc-pVDZ’ etc. See
the MRCC manual for a complete list. (Default: basis = ’6-31G*’)

Type of calculation, e.g. ’SCF’, ’B3LYP’, ’MP2’, ’CCSD(T)’, etc. (Default: calc = ’SCF’)

Can be speciﬁed to request a DFT calculation and specify the DFT method. (Default: dft = ’off’)

Memory that will be allocated for the calculation. (Default: mem = ’256MB’)

verbosity Controls the verbosity of the MRCC output ﬁle. (Default: verbosity = 2)

ntpr

Controls frequency of printing for the dipole moment to ﬁle mrcc_job.dip (Defaults to &cntrl
namelist variable ntpr)

do_dipole Toggles writing of the dipole moment to ﬁle mrcc_job.dip. (Default: dipole = 0)

nprintlog Frequency of storing MRCC output ﬁles during a minimization of molecular dynamics run. (Default:

keep only last output ﬁle, nprintlog = 0)

debug

Toggles debug mode, which prints subroutine calls and additional information about the AMBER/M-
RCC interface. (Default: no debugging, debug = 0)

use_template Requests use of a template ﬁle to generate MRCC input ﬁles to utilize all the capabilities of that
are not available through &mrcc namelist keywords. The template ﬁle is basically a truncated MINP
ﬁle (the default input ﬁle for MRCC) which only includes the MRCC keywords. (Default: do not
use a template input ﬁle, use_template = 0)

The following &mrcc namelist variables control multilayer calculations (i.e. QM/QM/MM or QM/QM/QM/MM
embedding[353]; the region highlighted in bold is controlled by the keyword). Only single point calculations are
currently possible with such mulitlayer calculations.

177

10. QM/MM calculations

embed

Speciﬁes the method of the embedding QM region (2. layer) in a QM/QM/MM (3 layer) calculation
or speciﬁes the method of the 3. layer in a QM/QM/QM/MM (4 layer) calculation. Please read the
MRCC manual for available options. (Default: embed = ’off’)

embedatoms Speciﬁes the active atoms of the embedded QM region (1. layer) in a QM/QM/MM (3 layer) calcu-
lation or speciﬁes the active atoms of the 1. and 2. layer in a QM/QM/QM/MM (4 layer) calculation.
Comma separated list of integers (Default: embedatoms = 0)

nmo_embed Speciﬁes the number of active MOs of the embedded QM region (1. layer) in a QM/QM/MM (3
layer) calculation or speciﬁes the number of active MOs of the 1. and 2. layer in a QM/QM/QM/MM
(4 layer) calculation.
= 0 The program automatically determines the MOs of the active region with the Boughton-Pulay

(BP) algorithm. (default)

> 0 Number of MOs that will be selected based on the Mulliken charges of the active atoms.

corembed

layer) in a
Speciﬁes the low-level correlation method of the embedding QM region (2.
QM/QM/MM (3 layer) calculation or speciﬁes the low-level correlation method of the 2.
layer
in a QM/QM/QM/MM (4 layer) calculation. Please read the MRCC manual for available options.
(Default: corembed = ’off’)

corembedatoms Speciﬁes the active atoms of the embedded QM region (1. layer) in a QM/QM/MM (3 layer)
calculation or speciﬁes the active atoms of the 1. layer in a QM/QM/QM/MM (4 layer) calculation.
Please note that the corembedatoms have to be a subset of the embedatoms if a 4 layer calculation is
requested. Comma separated list of integers (Default: corembedatoms = 0)

nmo_corembed Speciﬁes the number of active MOs of the embedded QM region (1. layer) in a QM/QM/MM (3
layer) calculation or speciﬁes the number of active MOs of the 1. layer in a QM/QM/QM/MM (4
layer) calculation.
= 0 The program automatically determines the MOs of the active region with the Boughton-Pulay

(BP) algorithm. (default)

> 0 Number of MOs that will be selected based on the Mulliken charges of the active atoms.

Examples An input ﬁle for QM or QM/MM MD with MRCC using DFT with the BLYP functional and the
cc-pVTZ basis set therefore would have to contain

&mrcc

calc = 'blyp',
basis

= 'cc-pVTZ',


/


An example input for a multilayer QM/QM/MM calculation with LCCSD(T) for a subset of QM atoms 7 to 12
embedded into the remainder of the QM region described by PBE (i.e. LCCSD(T)/PBE/MM) would be

&mrcc

= 'cc-pVTZ',

calc = 'LCCSD(T)',
basis
embed = 'PBE',
embedatoms = 7,8,9,10,11,12

/



This assumes that atoms 7-12 are part of the QM region. A 4-layer QM/QM/QM/MM calculation with
LCCSD(T) for atoms 7 to 12 embedded into LMP2 for atoms 13 to 16 and the remainder described by PBE (i.e.
LCCSD(T)/LMP2/DFT/MM) would be requested with

178







&mrcc

= 'cc-pVTZ',

calc = 'LCCSD(T)',
basis
embed = 'PBE',
embedatoms = 7,8,9,10,11,12,13,14,15,16,
corembed = 'LMP2',
corembedatoms = 7,8,9,10,11,12,

/

10.2. Interface for ab initio and DFT methods





Template input ﬁle The template ﬁle for MRCC must be named mrcc_job.tpl and must only contain keywords
that specify the QM method and basis set to be used in the calculation. Not to be included are following keywords:
qmmm, qmreg, dens, pointcharges, geom, embed, corembed, scﬁguess. The interface will take care of adding
other keywords and writing the coordinate input ﬁle section.

10.2.6.7. AMBER/TeraChem

To use TeraChem with the interface, TeraChem must be properly installed on the system. In particular, the
terachem executable needs to be in the search path. Namelist parameters correspond to TeraChem keywords, see
the TeraChem manual for details.

Limitations A cutoff is applied to QM/MM interactions in QM/MM simulations with and without PBCs. This
leads to discontinuities in the potential energy surface and poor energy conservation. In the case of QM/MM
simulations without PBCs, this cutoff (qmcut variable in the &qmmm namelist) can be set to a number that is
larger than the simulated system, thus effectively not applying a cutoff. This is recommended.

&tc Namelist variables

basis

method

dftd

Basis set type to be used in the calculation. Possible choices presently (TeraChem version 1.4) are
’STO-3G’, ’3-21G’, ’6-31G’ and ’6-311G’, ’3-21++G’ and ’6-31++G’ (Default: basis = ’6-31G’)

Method to be used in the calculation, can be either ’RHF’ or some supported DFT functional. Popular
choices are ’BLYP’, ’PBE’ and ’B3LYP’. (Default: method = ’BLYP’)

Determines whether dispersion corrections are applied in the case of DFT calculations. (Default:
dftd = ’no’)

precision Precision model setting (single vs double precision). (Default: precision = ’mixed’)

dynamicgrid Use coarse grid during early SCF iterations. (Default: dynamicgrid = ’yes’)

threall

Determines a variety of thresholds. (Default: threall = 1.0E-11)

convthre

maxit

dftgrid

ngpus

gpuids

SCF convergence threshold for the wavefunction. (Default: convthre = 3.0E-05, which leads to SCF
energy convergence of approximately 10−7 au or 10−4 kcal/mol)
Maximum number of SCF iterations. (Default: maxit = 100)

DFT grid to be employed for the numerical XC quadrature in DFT calculations. (Default: dftgrid =
1)

Determines how many GPUs are to be used. (Default: ngpus = 0, which uses all available GPUs)

If ngpus has a value other than zero, this determines the IDs of the GPUs to be used for the calcula-
tion. (Default: gpuids = 0, 1, 2, etc.)

executable Name of the TeraChem executable. (Default: executable = terachem)

179

10. QM/MM calculations

use_template Determine whether or not to use a user-provided template ﬁle for running external programs.

(Default: use_template = 0)

ntpr

Controls frequency of printing for dipole moment and atomic charges to ﬁles tc_job.ext. (Defaults
to &cntrl namelist variable ntpr)

charge_analysis Toggles writing of atomic charges to ﬁle tc_job.chg (Options: ’none’ or ’Mulliken’. Default:

dipole = ’none’)

dipole

Toggles writing of dipole moment to ﬁle tc_job.dip (Default: dipole = 0)

Example An input ﬁle for QM or QM/MM MD with TeraChem using the PBE functional and the 6-31G* basis
set therefore would have to contain


/

&tc

method = 'PBE',
basis

= '6-31G*',




Template input ﬁle The template ﬁle for Terachem should be named tc_job.tpl and must at least contain the
following keywords:

basis
method

Any content of the template ﬁle after a line containing the end keyword will be ignored.

You should not include the following keywords in the template ﬁle as these are taken care of by sander.

Instead, specify these via the &qmmm or &tc namelist:

run
charge
spinmult
coordinates
pointcharges
amber
gpus

10.2.6.8. AMBER/Fireball

To use Fireball with the QM/MM interface, a special version of sander must be compiled and linked against the
Fireball library (libﬁreball.a). The Fireball library can be obtained from the ﬁreball-qmd web site at https://ﬁreball-
qmd.github. Compilation requires the Intel compilers and Intel MKL library. You can compile a version of sander
that supports Fireball as follows (bash assumed):

export FIREBALLHOME=/path/to/fireball.a
export MKL_HOME=/path/to/Intel/MKL/library
cd $AMBERHOME
./configure -fireball intel
make install

It is possible to compile the MPI parallel version of sander in the same fashion. However, only the MM part of the
calculation will execute in parallel.

180

10.2. Interface for ab initio and DFT methods

Limitations A cutoff is applied to QM/MM interactions in QM/MM simulations with and without PBCs. This
leads to discontinuities in the potential energy surface and poor energy conservation. In the case of QM/MM
simulations without PBCs, this cutoff (qmcut variable in the &qmmm namelist) can be set to a number that is
larger than the simulated system, thus effectively not applying a cutoff.

Basis set Fireball requires a basis set, commonly provided in an “Fdata” directory. This directory contains all
the interactions (different contributions to the electronic Hamiltonian matrix elements) for the different types of
atoms (C, H, O, N, etc.) appearing in the QM region. In principle, the Fdata directory should be placed in the
working directory. Alternatively, the path where the Fdata directory is located can be deﬁned using the variable
basis in the &fb namelist variables (see below).

This Fdata directory can be downloaded from the ﬁreball-qmd web (https://ﬁreball-qmd.github). Advanced
users can also calculate their own Fdata using the create set of programs that can be found in the ﬁreball-qmd
github repository.

&fb Namelist variables

basis

Path to the Fdata directory. (Default: basis = ’./Fdata’)

max_scf_iterations Maximum number of iterations in the loop for the calculation of the self-consistent

charges. (Default: max_scf_iterations = 70)

sigmatol

Threshold for selc-consistency in the electronic structure calculations. (Default: sigmatol = 1.0E-08)

idftd3

DFTD3 dispersion correction. (No correction: idftd3 = 0; Dispersion correction for BLYP: idftd3 =
1; Default: idftd3 = 0)

iwrtcharges Writes atomic charges in ﬁreball output. (Default: iwrtcharges = 0)

iwrteigen Writes energy levels in ﬁreball output. (Default: iwrteigen = 0)

Fora complete list of all &fb Namelist variables, please visit http://nanosurf.fzu.cz/wiki/doku.php?id=ﬁreball

Example An input ﬁle for QM or QM/MM MD using AMBER/FIREBALL with all the default values would
just have to contain an empty &fb naemlist

As another example, a simulation using DFTD3 dispersion corrections for BLYP that also writes out the atomic
charges with Fdata in a central location of the user’s home directory would need the following input:

&fb

basis = '/home/fireball/Fdata',
idftd3 = 1,
iwrtcharges = 1

/

To launch the simulation, simply run sander as follows:

sander -O -i mdin -o mdout -p prmtop -c inpcrd -x mdcrd -r rstrt > amberfireball.out



181

&fb


/






10. QM/MM calculations

10.3. Adaptive solvent QM/MM simulations

Traditional QM/MM approaches are based on a static QM/MM partitioning in which atoms belonging to the
QM and MM regions are selected at the beginning of a molecular dynamics simulation. Such a static partitioning
cannot be applied if part of the bulk solvent in the vicinity of a region of interest needs to be included in the QM
region. Examples include cases in which the bulk solvent participates directly in a chemical reaction or in which
important interactions between the solute and the bulk solvent, such as polarization and charge transfer, are not
well parameterized at the QM/MM level and thus need to be described quantum mechanically. Due to molecular
diffusion, solvent molecules will constantly exchange between the QM and MM regions and thus require a special
treatment.

Several approaches have been developed that allow molecules to change their QM or MM character when cross-
ing the boundaries between the QM and MM regions. A good overview and comparison of these approaches
is available in the work by Bulo et al.[354]. One of the most accurate approaches is the difference-based adap-
tive solvation (DAS) method[355], in the following simply called adaptive QM/MM (adQM/MM). This method
is available in Amber through a parallelized implementation that has been developed by Andreas Goetz (SDSC)
with help from Ross Walker (SDSC), Rosa Bulo (Utrecht University) and Kyoyeon Park (UCSD). The useful-
ness of this adQM/MM approach for aqueous systems has been demonstrated with a development version of this
implementation[356]. If you publish work that results from using this implementation, please cite the following
work:

• A. W. Götz, K. Park, R. E. Bulo, F. Paesani, R. C. Walker, Efﬁcient adaptive QM/MM implementation:

Application to ion binding by peptides in solution, in preparation.

• R. E. Bulo, B. Ensing, J. Sikkema, L. Visscher, Toward a practical method for adaptive QM/MM simulations,

J. Chem. Theory Comput. 9, 2212-2221 (2009), DOI: 10.1021/ct900148e

In what follows we will describe the theoretical background of this implementation and how to perform adQM/MM
simulations. For an alternative approach, see section 10.4.

10.3.1. Theoretical background

In adQM/MM simulations, we distinguish three different regions, an active region (A), a transition region (T),
and the environment region (E). The active region contains both the part of the system that is permanently treated
quantum mechanically (similar to the QM region in regular QM/MM simulations) and the solvent molecules in its
vicinity that are also treated quantum mechanically. The E region is the part of the system that is treated at the MM
level. Within the T region, molecules change their character from purely QM to purely MM, that is, molecules in
the T region have partial QM and MM character, depending on their position within the T region. The T region that
connects the A and E regions is required to guarantee that the potential energy surface or forces remain continuous
throughout the simulation.

10.3.1.1. System partitioning

In the adQM/MM method[355], a partial MM character λ is assigned to each molecule in the T region. The

value of λ depends on the distance of the molecule from the center of the A region according to

0

1

λ (r) =

(r−RA)2(3RT−RA−2r)

(RT−RA)3

r ≤ RA
RA < r < RT
r ≥ RT

,

(10.16)

where RA and RT are the inner and outer radii delimiting the T region. The switching function thus interpolates
smoothly between QM (A region) and MM (E region).

The adQM/MM energy can be constructed as a weighted average of regular QM/MM energies due to all possible

2NT partitionings in which the NT molecules in the T region are assigned either to the QM or the MM region,

182

10.3. Adaptive solvent QM/MM simulations

EadQM/MM = ∑

a

σaEQM/MM

a

.

(10.17)

(cid:40)

The statistical coefﬁcients σa for the QM/MM partitionings are deﬁned on basis of the λ values deﬁned above,

σa =

0
min({λ}MM

a

)− max({λ}QM

a

)

i f max({λ}QM
i f max({λ}QM

a

a

) > min({λ}MM
) ≤ min({λ}MM

a

a

)
)

,

(10.18)

a

a

and {λ}MM

where {λ}QM
are the sets of λ values for a given QM/MM partitioning a that are assigned to the QM
and MM regions, respectively. Due to this choice of coefﬁcients, the weight σa of a QM/MM partitioning is zero if
the partition contains one or more MM molecules closer to the A region than any of the QM molecules. The total
number of nonzero QM/MM partitionings in an adQM/MM simulations is thus NT + 1. In addition it is guaranteed
that the weight of each partition varies smoothly from 0 to 1, removing discontinuities in the system dynamics that
would appear in standard QM/MM simulations if a molecule would change its character by diffusing in or out of
the QM region.

10.3.1.2. Force interpolation

The forces resulting from the adQM/MM energy 10.17 are a weighted sum of the force from each nonzero

QM/MM partitioning and also contain a term that depends on the derivatives of the weight functions,

(cid:34)

(cid:35)

FadQM/MM = −∑

a

σa

∂ EQM/MM

a
∂R

+

∂σa
∂R EQM/MM

a

.

(10.19)

This introduces an artiﬁcial dependence on the relative energies of the different QM/MM partitionings. Thus, in
place of the energy interpolation scheme, a force interpolation is applied in which the forces are given as

˜FadQM/MM = −∑

a

σa

∂ EQM/MM

a
∂R

.

(10.20)

The force interpolation does not conserve the energy from equation 10.17 but it is possible to deﬁne a conserved
quantity according to

where the correction term W is deﬁned through

˜EadQM/MM = EadQM/MM +W,

∂W
∂R = −∑

a

∂σa
∂R EQM/MM

a

.

(10.21)

(10.22)

The quantity ˜EadQM/MM is not a potential energy since it is only deﬁned along the path taken by the system during
the simulation. It is nevertheless useful to monitor this quantity to determine whether the simulation settings lead
to numerical stability. The correction term W can be expressed as the path integral of its force vector from equation
10.22, which can be discretized. For step n of an MD simulation it is given as
σa(i + 1)− σa(i− 1)

n

(10.23)

Wn =

∑

∑

i

a

EQM/MM
a

(i)

2

.

The Amber implementation uses exclusively the force interpolation scheme from equation 10.20 and optionally
computes the correction term W from equation 10.23 to enable monitoring of the conserved quantity ˜EadQM/MM
from equation 10.21.

183

10. QM/MM calculations

10.3.1.3. Alternative deﬁnitions of active, transition and environment regions

So far we have deﬁned the boundaries between the A, T, and E regions with the distances RA and RT from
the center of the active region. In this case both the A and the T regions have ﬁxed volumes but the number
of solvent molecules inside each region can vary during the simulation. Alternatively, we can ﬁx the number of
solvent molecules NA and NT within the A and T regions, respectively. In this case the volume of the A and
T regions as well as the radii RA and RT will vary during the course of a simulation. The advantage of ﬁxing
the number of solvent molecules in the T region is that the number of QM/MM partitionings that needs to be
considered also remains constant (NT + 1). This is useful to optimize load balancing in a parallel adQM/MM
implementation. The downside is that expression 10.23 does not strictly hold any more since the coefﬁcients σa
depend on the λ values which in turn depend on RA and RT. However, in practice, this is usually not an issue since
the conserved quantity ˜EadQM/MM needs monitoring only during simulation setup to choose settings that afford
sufﬁcient numerical stability. One thus can test simulation settings with ﬁxed radii RA and RT and then switch to
ﬁxed molecule numbers NA and NT for production runs.

10.3.2. Running adQM/MM simulations with sander

Performing simulations with the adQM/MM approach described above requires the MPI parallelized sander
executable sander.MPI. The implementation features a dual layer parallelization in which the calculations for all
individual QM/MM partitionings are performed in parallel. Each of these QM/MM calculations can in turn be run
in parallel. The parallelization across QM/MM partitionings is based on the multisander code infrastructure which
effectively runs independent copies of sander for each QM/MM partitioning (similar to the replica exchange, path
integral and thermodynamic integration implementations).

In order to run an adQM/MM simulation, the mdin input ﬁle needs to be set up similar to a regular QM/MM
simulation. The QM region as deﬁned in the &qmmm namelist deﬁnes the atoms that are in the permanent QM
region. In addition, the &qmmm namelist variable vsolv needs to be set to 2 or 3 for ﬁxed number of molecules
in the A and T region or ﬁxed size of A and T region, respectively. The following shows the minimum additions
to the mdin input ﬁle that are required to perform an adQM/MM simulation as compared to a traditional QM/MM
simulation with ﬁxed QM and MM regions:



# mdin file - minimum additional content for adaptive solvent QM/MM
&qmmm
...
adjust_q = 0, ! required, charge cannot be redistributed
vsolv = 2,

! switch on adQM/MM with fixed molecule numbers
!

in A and T region

/
&vsolv

nearest_qm_solvent = 6, ! number of solvent molecules in A region

/
&adqmmm

/



n_partition = 4, ! number of QM/MM partitionings

! = number of molecules in T region + 1

In this example, a ﬁxed number of solvent molecules is contained in the A region (6) and in the T region (3, since
the number of QM/MM partitionings is NT + 1). Thus, the volume of the A and T regions changes during the
simulation. Details of all namelist variables are collected below.

In addition, a groupﬁle for multisander is required. This groupﬁle should point all sander copies to the same

mdin input ﬁle, inpcrd coordinate ﬁle and prmtop parameter and topology ﬁle:

# groupfile for adaptive solvent QM/MM run with n_partition = 4
-O -i mdin -c inpcrd -p prmtop
-O -i mdin -c inpcrd -p prmtop
-O -i mdin -c inpcrd -p prmtop
-O -i mdin -c inpcrd -p prmtop



184









10.3. Adaptive solvent QM/MM simulations

If you explicitly specify output ﬁle names, make sure to give separate names to each group (for example
mdout.000, mdout.001 etc), see also the multisander documentation. The mutisander adQM/MM simulation
can then be executed with

mpirun -np 4 sander.MPI -rem 0 -ng 4 -groupfile groupfile







In this example, 4 MPI processes will be launched for 4 process groups (sander copies). The individual QM/MM
calculations for each partitioning would thus run in serial. To run the individual QM/MM calculations in parallel,
the number of MPI processes must be a multiple of the number of process groups.

Adaptive solvent QM/MM simulations can be performed both with the semiempirical NDDO-type and DFTB
methods that are native to sander or with QM methods that are available via the interface to external QM pro-
grams.
In the latter case, each process group will launch only one instance of the external QM program and
the parallelization of the QM part of the QM/MM calculations is determined by the settings for the external QM
program.

10.3.2.1. Important notes for system preparation and adQM/MM simulations

At the time of writing (release of AMBER 16) there is only a limited body of experience with adQM/MM
simulations documented in the literature. Running adQM/MM simulations requires careful simulation setup, in
particular regarding the size of the A and T regions. The A region needs to be sufﬁciently large to correctly describe
the physics of the system of interest. The T region on the other hand needs to be sufﬁciently large to minimize force
interpolation errors between the QM and MM regions. Since the cost of an adQM/MM simulation scales linearly
with the number of molecules in the T region, a tradeoff between accuracy and cost often needs to be made. This
in turn might lead to simulations that behave nicely for many time steps but eventually experience sudden, large
(unphysical) forces on atoms at the T region boundaries. Similarly, whether it is more appropriate to deﬁne the
center of the A region via an atom or the center of mass of the permanent QM region will affect the numerical
stability of a simulation, depending on the particular system. Likewise for determining the distances of the solvent
molecules via an atom or the center of mass of the solvent. In the case of water as solvent, problems can arise due
to autoprotolysis which can lead to the formation of hydroxide and hydronium ions in the A region. Since the MM
force ﬁeld is not parameterized for hydroxide or hydronium ions, these will experience strong (unphysical) forces
upon entering the T region. Careful monitoring of adQM/MM simulations and a bit of patience is thus advisable.
It is a good idea to monitor the size of the A and T region and to check coordinates of atoms in the QM regions of
all partitionings.

10.3.2.2. Namelist parameters for adaptive solvent QM/MM simulations

Adaptive solvent QM/MM simulations require setting the vsolv variable in the &qmmm namelist and setting

variables in the &vsolv and &adqmmm namelists.

&vsolv namelist parameters The &vsolv namelist contains parameters that describe which solvent molecules
are contained in the A region in addition to the permanent QM region that is deﬁned in the &qmmm namelist. This
namelist can be used without the &adqmmm namelist in a regular QM/MM simulation with sander if the variable
vsolv in the &qmmm namelist is set to 1 instead of 2 or 3 (see 10.1.6). In this case there is no transition region and
solvent molecules entering / leaving the QM region during the simulation would switch abruptly between QM and
MM description. This is not recommended since it will results in large unphysical forces whenever such a switch
occurs. However, this option is useful for post-processing of trajectories with single point QM/MM calculations in
which the solvent molecules closest to the permanent QM region are treated quantum mechanically.

nearest_qm_solvent_resname Residue name of the solvent that can exchange between QM and MM region

(Default: nearest_qm_solvent_resname = ’WAT’)

nearest_qm_solvent Number of solvent molecules in the A region (Default: nearest_qm_solvent = 0)

nearest_qm_solvent_fq Frequency of updating of the A region. Should be set to 1 (every MD step) for

adQM/MM simulations. (Default: nearest_qm_solvent_fq = 1)

185

10. QM/MM calculations

nearest_qm_solvent_center_id Determines the atom(s) of the solvent molecules that is used to calculate the

distance to the QM region.
= 0 Use the atom that is closest to the QM region. (default)
= -1 Use the center of mass.
> 0 Use this atom number within the solvent residue.

qm_center_atom_id Determines the atom of the permanent QM region that is used to calculate the distance to

the solvent molecules.
= 0 Use the atom of the permanent QM region that is closest to a solvent molecule. Not supported for
adQM/MM since the radii of the A and T region would remain undeﬁned - a common point of
reference is required for all solvent molecules. Useful only for post-processing of trajectories.
(default)

= -1 Use the center of mass of the permanent QM region.
> 0 Use this atom number. Note that this is an absolute atom number - obviously, you should choose

an atom that is in the permanent QM region.

verbosity Controls verbosity of vsolv output in the mdout ﬁle.

= 0 Standard verbosity. (default)
> 1 Increase verbosity.

&adqmmm namelist parameters If the &qmmm namelist variable vsolv is set to 2 or 3, an adQM/MM simula-
tion with a ﬁxed number of molecules in the A and T regions or ﬁxed size of the A and T regions, respectively, is
requested. Details of the adQM/MM simulation are set in the &adqmmm namelist as follows.
n_partition Deﬁnes the number of QM/MM partitions to be used. For vsolv=2 this also determines the number
of solvent molecules in the transition region, which is n_partition - 1. For vsolv=3 it has to be set
to the largest number of QM/MM partitionings that will be encountered for the chosen values of RA
and RT. (Default: n_partition = 1)
Deﬁnes the radius RA of the A region in Angstrom. Only relevant for vsolv=3. Needs to be changed
from the default value and requires setting of RT. (Default: RA = -1.0)
Deﬁnes the radius RT of the T region in Angstrom. Only relevant for vsolv=3. Needs to be changed
from the default value and requires setting of RA. (Default: RT = -1.0)

RA

RT

calc_wbk

Controls whether the book-keeping term W is calculated.
= 0 Do not calculate W . (default)
= 1 Calculate W via one-sided difference approximation (not recommended).
= 2 Calculate W via central-difference approximation, see equation 10.23. Requires additional com-

putations for (dis)appearing partitionings. (recommended if W is desired).

verbosity Controls verbosity of adQM/MM output in the mdout ﬁle.

= 0 Standard verbosity. (default)
= 1 Increase verbosity - write distances of residues in T region from center of A region to ﬁle
adqmmm_res_distances.dat and σa values to ﬁle adqmmm_weights.dat. These ﬁles get
overwritten at each program start.

= 2 Increase verbosity - write distances and σa values also to the mdout ﬁle. Also write λ values.

print_qm_coords Controls whether coordinates of the QM atoms in each partitioning are written to ﬁle.

= 0 Do not write coordinates. (default)
= 1 Write QM coordinates for all QM/MM paritionings in xyz format to ﬁles QM_coords.001 etc.

Files are overwritten upon each program call.

186

10.4. Adaptive buffered force-mixing QM/MM

10.4. Adaptive buffered force-mixing QM/MM

10.4.1. Introduction

In hybrid quantum mechanical – molecular mechanical (QM/MM) methods the reactive part of the system (i.e.
where a signiﬁcant change of the charge density distribution is expected) is described using a quantum mechanical
model while the rest of the system is treated using molecular mechanics. Conventional (“energy-mixing”) QM/MM
methods (convQM/MM) deﬁne a unique total energy function for the whole system that consists of three terms:
the energy of the QM model applied to the atoms in the QM region, the energy MM model applied to atoms in the
MM region and the interaction energy between the two regions:

EQM/MM(QM+MM) = EQM(QM) + EMM(MM) + EQM↔MM(QM+MM),

(10.24)
where the superscript represents the level of theory, while the region to which they are applied are indicated in
parentheses. The coupling between the quantum region and the surrounding atoms (EQM↔MM(QM+MM)) can
be taken into account in several ways. For example, in the more sophisticated approaches, the effects of the
MM charges are included in the quantum mechanical SCF calculation in the form of an externally applied ﬁeld.
Given a total energy, performing Hamiltonian or any other standard dynamics is straightforward. However, several
uncontrolled errors could potentially be introduced by such schemes. Representing the environment by a set
of point charges can over-polarise the QM region, and conversely the electrostatic effect of the ever-changing
quantum mechanical charge density on atoms at the edge of the MM region is quite different from what is assumed
when the MM force ﬁeld parameters are determined. The delicate balance that exists between the various non-
bonded MM terms is therefore no longer maintained across the QM-MM boundary. Furthermore, if adaptivity, i.e.
transitions of atoms between the two regions, is allowed, a new problem appears: in general there can be chemical
potential differences between the QM and MM regions for various species, and this results in a net ﬂow betwen the
regions, leading to unphysical density differences, structure and dynamics. Allowing adaptivity in this sense can
be important when the active region itself is mobile (e.g. penetration, adhesion, crack propagation), or diffusional
processes in the environment are relevant (e.g. water molecules, ions, residues enter and exit the QM region during
the dynamics). To overcome these problems the adaptive buffered “force-mixing” QM/MM (abfQM/MM) method
was introduced [357, 358]. The implementation of abfQM/MM was carried out by Letif Mones (University of
Cambridge) and Gabor Csanyi (University of Cambridge) with help from many others (see the article below).
When using this implementation in your work please cite the following papers:

• Noam Bernstein, Csilla Várnai, Iván Solt, Steven A. Winﬁeld, Mike C. Payne, István Simon, Mónika Fuxre-
iter and Gábor Csányi, QM/MM simulation of liquid water with an adaptive quantum region, Phys. Chem.
Chem. Phys., 14, 646–656 (2012), DOI: 10.1039/c1cp22600b

• Csilla Várnai, Noam Bernstein, Letif Mones and Gábor Csányi, Tests of an Adaptive QM/MM Calculation
on Free Energy Proﬁles of Chemical Reactions in Solution, |J. Phys. Chem. B, 117, 12202−12211 (2013),
DOI: 10.1021/jp405974b

• Letif Mones, Andrew Jones, Andreas W. Götz, Teodoro Laino, Ross C. Walker, Ben Leimkuhler, Gábor
Csányi and Noam Bernstein, Implementation of the Adaptive Buffered Force QM/MM method into CP2K
and Amber program packages, in preparation.

10.4.2. Technical details of abfQM/MM

In the abfQM/MM method two independent force calculations are performed at each MD step. The ﬁrst and
more time consuming calculation is an extended conventional QM/MM calculation, which is used for calculating
the forces of atoms treated quantum mechanically during the dynamics. We start with a core QM region, which
comprises atoms that will always be treated quantum mechanically throughout the simulation. This region is
enlarged (using a distance criterion, see below) to obtain the dynamical QM region which contains the atoms that
follow QM forces. The dynamical QM region is surrounded by a buffer region whose size can be determined by
simple force convergence tests [359, 360] and its construction in practice is based on geometrical considerations:
atoms or molecules that are within a speciﬁed distance from the dynamical QM region are added to the buffer

187

10. QM/MM calculations

region. From this ﬁrst calculation only the forces of the atoms in the dynamical QM region are kept and the rest
(namely the forces on atoms in the buffer region) are discarded. The second calculation is used for obtaining good
forces on MM atoms, especially important near the QM/MM boundary. For this, either fully MM representation
of the whole system is used or, alternatively, another QM/MM force calculation, but this time using a smaller
(reduced) QM region consisting of only the atoms in the core QM region. The abfQM/MM method is an abrupt
force mixing method, which means that the forces are not derived from a total energy expression but a simple
combination of the forces of the two calculations described above

FabfQM/MM
i

(QM+MM) =

(cid:26) FExtended

i
FReduced
i

if i is in the dynamical QM region,
otherwise,

(10.25)

where the superscripts Extended and Reduced denote that the forces are taken from the ﬁrst and second calculations
described above, respectively. The selection of the QM and buffer atoms is controlled by distance criteria. Using a
single distance criterion measured from some key atoms in the QM region, however, would lead to rapid ﬂuctuation
in the region deﬁnitions because atoms may cross and re-cross repeatedly. To reduce this effect, a hysteretic
algorithm can be applied using an inner (rin) and an outer (rout) radius [357]. Thus, an MM atom is redesignated
to be QM if its distance measured from the QM region (as deﬁned by a set of atoms always treated quantum
mechanically) is less than rin and a QM atom is redesignated to be MM if this distance is larger than rout. Similar
hysteretic algorithms are applied for the deﬁnition of the dynamical QM region as well as the buffer region.

The above deﬁnitions may lead to QM atoms that have covalent chemical bonds with MM atoms. This is not
necessarily a problem, as these bonded interactions can be treated in several ways from the point of view of carrying
out the the QM/MM calculation (e.g. link atoms, special pseudopotentials, frozen localized orbitals etc.). However,
none of these schemes are general, i.e. cutting some type of QM-MM bonds in this way might not yield reasonable
forces. For example, highly polarized bonds, bonds with bond order larger than 1 and delocalized bonds such as
those in aromatic rings should be protected from being cut. In the conventional, nonadaptive QM/MM scheme it is
easy to handle this problem, because the QM region is speciﬁed at the beginning of the simulation and the user can
pick a chemically sensible set of atoms. For our dynamically varying QM (and buffer) regions, chemically sensible
decisions have to be made algorithmically. Our implementation allows the user to specify a list of the breakable
types of bonds which the software then uses to build the regions automatically.

Finally, as in all force mixing schemes, the abfQM/MM scheme uses dynamical forces that are not conservative,
that is they are not the derivatives of a total energy function. This is the price we pay for adaptivity. The noncon-
servative nature of the dynamics necessitates the use of a thermostat to maintain the correct kinetic temperature
throughout the system. The strength of the thermostat we need to use in practice is similar to those that are con-
ventionally used in biomolecular simulations, which suggests that no ill effects will arise purely from the use of a
thermostat – the only caveat is that since the use of a thermostat is mandatory, strictly microcanonical simulations
cannot be performed. A simple Langevin thermostat is not appropriate in the presence of net heat generation (and
would lead to a steady state temperature deviation of several tens of degrees near the QM/MM boundary), so a
special adaptive thermostat (a combination of Langevin and Nose-Hoover thermostats) that is able to maintain the
correct temperature even in the presence of intrinsic heating or cooling is used [361].

10.4.3. Relation to other adaptive QM/MM methods

It is worth noting that the current implementation of abfQM/MM supports the use of several other adaptive
QM/MM methods. For example, setting r_qm_in, r_qm_out, r_buffer_in and r_buffer_out variables to 0 (for
deﬁnitions see the next section) leads to the adaptive conventional QM/MM (adconvQM/MM) technique that can be
considered also as the zero limit of the adaptive solvent QM/MM (adQM/MM) method [355] without a transition
region (see also section 10.3). In this case the extended and reduced systems are identical and the dynamics is
propagated by forces of a convQM/MM calculation whose QM region is adaptive. To save computational time for
adconvQM/MM the program ﬁrst performs the corresponding convQM/MM calculation and then a dummy full
MM calculation whose forces are discarded. Another limit can be obtained when r_buffer_in and r_buffer_out
variables are set to 0 (and all other radii are not). This method can be called unbuffered force mixing QM/MM
(unbuffQM/MM). It has been observed that the applicability of both adconvQM/MM and unbuffQM/MM depends

188

on several factors (system, QM method, size of core / qm regions etc.) and it is advised to perform a force
convergence test [359, 360] before using them.

10.4. Adaptive buffered force-mixing QM/MM

10.4.4. Technical glossary

10.4.4.1. Systems

• extended system: the ﬁrst (QM/MM) calculation, which is used for calculating the forces on atoms in the
dynamical QM region. To get converged forces on these atoms, a buffer region is added, leading to an
extended QM region.

• reduced system:

the second calculation, which is used for obtaining the MM forces. Either a full MM

representation can be used or a QM region that is smaller than the dynamical QM region.

10.4.4.2. Atom types

There are basically four regions in the abfQM/MM method depending on their role during the dynamics: the
core, the qm, the buffer and the mm regions. These sets are disjoint by deﬁnition. There are atoms which are
permanent members of a given region and there are others that can change their identity by moving from one
region to another. This section describes the different atom types and also gives their name and id used in the
implementation. Please note the distinction between the labels “QM” and “qm” atoms: the former indicates the
QM region used in the actual extended or reduced QM/MM calculations, while the latter is a label used to describe
those atoms that, together with the core atoms, follow dynamics using quantum mechanical forces.

• core atoms (id = 1-2): those atoms that constitute the QM region for the reduced system calculation. (The

QM atoms in the extended calculation are the core, the qm and buffer atoms together.)

• user speciﬁed core atoms (id = 1, tag = CORE_USER): core atoms speciﬁed by the user. These atoms are

permanent core atoms during the whole simulation.

– core extension atoms (id = 2, tag = CORE_EXT): core atoms selected by geometrical criteria around

the user speciﬁed core atoms. These atoms belong temporarily to the core region.
atomi ∈ {core extension atoms} ⇐⇒ atomi = f (rcore_in,rcore_out,{user speciﬁed core})

{core atoms} = {user speciﬁed core atoms}(cid:83){core extension atoms}

• qm atoms (id = 3-4): atoms, whose QM forces are used in the MD simulation similarly to core atoms but
qm atoms are excluded from the QM region in the reduced calculation. Their forces are calculated in the
extended QM/MM calculation.

– user speciﬁed qm atoms (id = 3, tag = QM_USER): qm atoms speciﬁed by the user. These atoms are

qm atoms during the whole simulation or occasionally can become core extension atoms.

– qm extension atoms (id = 4, tag = QM_EXT): qm atoms selected by geometrical criteria around the

core and user speciﬁed qm atoms. These atoms belong temporarily to the qm region.

atomi ∈ {qm extension atoms} ⇐⇒ atomi = f (rqm_in,rqm_out,{user speciﬁed qm}(cid:83){core atoms})
{qm atoms} = {user speciﬁed qm atoms}(cid:83){qm extension atoms}

• buffer atoms (id = 5-6): these atoms are in the buffer region. Although they are treated as QM atoms in the
extended calculation, forces on them from this calculation are discarded and they move with forces coming
from the reduced calculation in which they are treated with MM.

– user speciﬁed buffer atoms (id = 5, tag = BUFFER_USER): buffer atoms speciﬁed by the user. These
atoms are permanent buffer atoms during the whole simulation or occasionally can become qm or even
core extension atoms.

189

10. QM/MM calculations

– buffer extension atoms (id = 6, tag = BUFFER_EXT): buffer atoms selected by geometrical criteria

around the qm and core atoms. These atoms belong temporarily to the buffer region.

atomi ∈ {buffer extension atoms} ⇐⇒ atomi = f (rbuffer_in,rbuffer_out,{qm atoms}(cid:83){core atoms})
{buffer atoms} = {user speciﬁed buffer atoms}(cid:83){buffer extension atoms}

• mm atoms (id = 7, tag = MM): they are MM atoms in both the extended and reduced calculations. For the

MD the forces are obtained from the reduced calculation.

• QM atom selections in the reduced and extended QM/MM calculations:
{QM atoms in the reduced system} = {core atoms}

{QM atoms in the extended system} = {core atoms}(cid:83){qm atoms}(cid:83){buffer atoms}

10.4.5. Namelist parameters for adaptive buffer-forced QM/MM simulations

The abfQM/MM implementation requires only two calculations for each MD step, which are performed se-
quentially (ﬁrst the computationally more expensive extended then the reduced calculations are carried out). Con-
sequently, unlike adaptive solvent QM/MM (adQM/MM, section 10.3) the subroutines of abfQM/MM are called
directly from sander and no groupﬁle is needed. All abfQM/MM related variables should be speciﬁed in the
&qmmm namelist. An example of an abfQM/MM dynamics is shown below:



# mdin file - example for adaptive buffered-force QM/MM dynamics
&cntrl

! adaptive Langevin thermostat is used

...
ntt=6,
...
ifqnt=1,

/

&qmmm
...
abfqmmm=1,
r_core_in=3.0,
r_core_out=3.5,
r_qm_in=3.0,
r_qm_out=3.5,
r_buffer_in=4.0,
r_buffer_out=4.5,
coremask=':1',
qmmask=':112, 1129, 1824, 2395',
buffermask='',
corecharge=0,
qmcharge=0,
buffercharge=0,

/

! activate abf QM/MM
! inner radius for extended core region
! outer radius for extended core region
! inner radius for extended qm region
! outer radius for extended qm region
! inner radius for buffer region
! outer radius for buffer region
! core region mask

! qm region mask

! buffer region mask
! core region charge
! qm region charge
! buffer region charge





10.4.5.1. Basic namelist parameters

1 activates the adaptive buffered force-mixing method, default is 0 (no abf-QM/MM method is ap-
plied).

core atom list speciﬁcation (in ambmask format). Optional, by default (when it is missing or core-
mask=’ ’) it is an empty set and in this case the reduced system is the full MM representation. Note
that at least one of the coremask or qmmask sets has to be speciﬁed.

abfqmmm

coremask

190

10.4. Adaptive buffered force-mixing QM/MM

qmmask

qm atom list speciﬁcation (in ambmask format). Optional, by default (when it is missing or qm-
mask=’ ’) it is an empty set and in this case only atoms in the core region will be treated as QM
atoms during the dynamics. Note that at least one of the coremask or qmmask sets has to be speci-
ﬁed.

buffermask buffer atom list speciﬁcation (in ambmask format). Optional, by default (when it is missing or

buffermask=’ ’) it is an empty set.

corecharge Total charge of core atom list deﬁned in coremask, default is 0.

qmcharge

Total charge of qm atom list deﬁned in qmmask, default is 0.

buffercharge Total charge of buffer atom list deﬁned in buffermask, default is 0.

r_core_in Inner radius for determining core extension region around user speciﬁed core atoms. Default is 0.

r_core_out Outer radius for determining core extension region around the user speciﬁed core atoms. Default is

the value speciﬁed for r_core_in. If r_core_out < r_core_in then r_core_out = r_core_in.

r_qm_in

Inner radius for determining qm extension region around the core and user speciﬁed qm atoms.
Default is 0.

r_core_out Outer radius for determining qm extension region around the core and user speciﬁed qm atoms.

Default is the value speciﬁed for r_qm_in. If r_qm_out < r_qm_in then r_qm_out = r_qm_in.

r_buffer_in Inner radius for determining buffer extension region around the qm and core atoms. Default is 0.

r_core_out Outer radius for determining buffer extension region around the qm and core atoms. Default is the
value speciﬁed for r_buffer_in. If r_buffer_out < r_buffer_in then r_buffer_out = r_buffer_in.

10.4.5.2. Adaptive thermostats’ namelist parameters

ntt

gamma_ln

Besides the original thermostats in sander, new adaptive ones are also introduced to be able to
absorb the heat production due to the nonconservative force-mixing dynamics. The correspond-
ing thermostat can be activated using the ntt command. In general, 5 activates the Nose–Hoover
(chain)–Langevin, 6 the adaptive Langevin, 7 the adaptive Nose-Hoover chain and 8 the adaptive
Nose-Hoover (chain)–Langevin thermostat. For adaptive QM/MM ntt=6 or 8 should be used.
Collision frequency in ps−1

nchain

Number of thermostats in each Nose–Hoover chain of thermostats (default is 1)

10.4.5.3. Miscellaneous namelist parameters

selection_type Type of selection of the different regions. Default is the atom–atom distance based selection
(selection_type = 1). In this case a given atom is going to belong to an outer region if the distance
between the atom in question and any atom in the inner region is less or equal than the corresponding
criterion. Option 2 is the ﬂexible sphere selection: for each inner region the radius of the region is
calculated (as the largest distance between the centre of mass of the region and any atom belonging
to that region), and the distance between the edge of the inner region and the atom in question
will determine weather the atom belongs to the outer region or not. Option 3 is ﬁxed sphere based
selection: it is the same as option 2 except that only the edge of the innermost region is calculated
based on its atoms and then all the other region’s borders are calculated geometrically as concentric
spheres. For option 2 and 3 the radii of spheres are calculated using the centre region, which is either
deﬁned by the user (centermask) or it is the coremask if speciﬁed, otherwise it is qmmask. Note
that option 2 and 3 selects signiﬁcantly larger number of atoms than option 1.

191

10. QM/MM calculations

initial_selection_type Type of initial selection type. This command controls the initial selection if not an
abfqmmm restart is performed (i.e. read_idrst_ﬁle is not speciﬁed). Default is 0, which is the
middle sphere selection (i.e. the mean of the corresponding inner and outer radii). Option -1 uses
the inner and option 1 applies the outer radius for the ﬁrst selection.

center_type Type of calculation of center for selection_type = 2 and 3. Default is center of mass (option 1),

while option 2 is geometric center.

gamma_ln_qm Collision frequency of actual core and qm atoms in ps−1 when adaptive massive Langevin thermo-

stat is applied. Default value is the same as gamma_ln deﬁned in &cntrl session.

mom_cons_type Type of force correction for momentum conservation. Default is 1 when the extra force is dis-
tributed among the corresponding atoms as equal accelerations. Option 2 applies equal forces on
each atom. Options -1/-2 apply an acceleration/force proportional to the absolute value of the cur-
rent acceleration/force of each atom. The region of atoms where the force correction is distributed is
speciﬁed by mom_cons_region. Option 0 does not apply momentum conservation.

mom_cons_region Speciﬁes the region where the force correction for momentum conservation is distributed.
Default is 1 that distributes the correction among only current core+qm atoms, option 2 distributes
it among current core+qm+buffer atoms and option 3 distributes the forces on all atoms. When
mom_cons_region = 0 the distribution is applied only among core atoms.

fix_atom_list > 0 activates the ﬁxed atom list method, default is 0. In ﬁxed atom list mode the different regions
are extended only by those solvent molecules that satisfy the given geometrical criteria and no solute
atoms will be selected besides the user speciﬁed ones in the coremask, qmmask and buffermask.
Useful when only solvent exchange is expected.

solvent_atom_number Number of atoms in solvent molecule for ﬁxed atom list mode (ﬁx_atom_list > 0), default
is 3. Deﬁning this variable is important when the solvent is other than water and the solvent molecule
contains more (or less) than 3 atoms.

centermask Centre region atom list speciﬁcation. Optional, if not deﬁned then it is equal to coremask.

coremask is neither speciﬁed then centermask equals to qmmask.

If

oxidation_number_list_file File name of oxidation numbers. Each line in the ﬁle must be either a comment
(starting by ’!’ or ’#’) or a triplet: RES ATOM OXID, where RES can be ’all’ (speciﬁcation for all
residues), ’atom’ (speciﬁcation for a given atom), residue name or residue index. If RES (cid:54)= ’atom’
then ATOM is the atom type name that can be speciﬁed completely (e.g. HE2) or partially using ’*’
(e.g. H* or HE*). If RES = ’atom’ then ATOM is the atom index in the topology. OXID is the integer
oxidation number. Since different speciﬁcations can refer to the same atom, there is a hierarchy of
the assignment and the later step always overwrites the previous one: 1. RES = ’all’ with partial
atom type speciﬁcation (in the order of X* → XY* → XYZ* ), 2. RES = ’all’ with complete
atom type speciﬁcation (XYZ1), 3. speciﬁed residue type with partial atom type speciﬁcation, 4.
speciﬁed residue type with complete atom type speciﬁcation, 5. residue index with partial atom type
speciﬁcation, 6. residue index with complete atom type speciﬁcation, 7. atom index speciﬁcation.

ext_coremask_subset Possible core extension atom set. If speciﬁed only those atoms will be chosen according
to the corresponding geometrical criteria that can be also found in this list (in the case of ﬁxed atom
list method solvent residues having at least one atom in the set will be chosen). If not deﬁned then
by default it is the all atom list.

ext_qmmask_subset Possible qm extension atom set. If speciﬁed only those atoms will be chosen according to
the corresponding geometrical criteria that can be also found in this list (in the case of ﬁxed atom list
method solvent residues having at least one atom in the set will be chosen). If not deﬁned then by
default it is the all atom list.

192

10.4. Adaptive buffered force-mixing QM/MM

ext_buffermask_subset Possible buffer extension atom set. If speciﬁed only those atoms will be chosen ac-
cording to the corresponding geometrical criteria that can be also found in this list(in the case of
ﬁxed atom list method solvent residues having at least one atom in the set will be chosen). If not
deﬁned then by default it is the all atom list.

cut_bond_list_file File name of breakable bonds

regions
(core/qm/buffer). Each line in the ﬁle must be either a comment (starting by ’!’ or ’#’) or a triplet:
ATOM1 ARROW ATOM2. ATOM1 and ATOM2 are both either atom types or atom indexes. AR-
ROW speciﬁes the direction of bond breaking: if it is ’<=>’ then the bond can be split from both
directions, if it is ’=>’ or ’<=’ then the bond can be cut only from ATOM1 or ATOM2 directions,
respectively.

termination of different

intelligent

for

max_bonds_per_atom Maximum number of ligands around any atom in the system. This controls the size of
arrays for the intelligent termination. Default is 4 that is good for most biological systems. If there
are atoms having more than 4 ligands then adjustment is required.

n_max_recursive Intelligent termination scheme is a recursive subroutine to get a fast and reliable performance.
However, it may happen that according to the user speciﬁed breakable bonds a very large bond
network will be chosen for a given region. To avoid it this variable can be used to control the
maximum number of iterations: when the number of iteration reaches the value of n_max_recursive
the program terminates. Default value is 10000.

min_heavy_mass To keep low the number of atoms in each extension region, by default the geometrical region
selection algorithm measures the distances between only heavy atoms, and hydrogen atoms are as-
signed in a second step according to the heavy atoms they are bonded to. To extend the distance
based selection for H atoms as well, decrease the value from its default 4.0 below the atomic mass
of hydrogen (e.g. 0.0).

pdb_file

File name of a special abfQM/MM related pdb ﬁle generated during the dynamics. The ﬁrst 8
columns have the standard pdb format (’ATOM’, atom index, atom name, residue name, residue
index, Cartesian coordinates of atom), 9th column is the oxidation number, 10th and 11th columns
are the id number and tag according to abfQM/MM implementation, respectively, and the possible
following columns include the atom indexes of MM atoms having direct bond to the given atom
treated as QM atom in the extended calculation. Default name is abfqmmm.pdb.

ntwpdb

Frequency of printing out abfQM/MM information into pdb_ﬁle. Default value is 0 (no printing).
Using ntwpdb < 0 allows the user to perform a selection test. In this case neither dynamical nor
even point calculations are performed, the program terminates after printing the pdb ﬁle out.

read_idrst_file Name of abfQM/MM atom id restart ﬁle used for restarting simulations. In the beginning of
the simulation besides the user speciﬁed atoms those become also member of a given region that
are within the outer radius. For a given region if the outer radius differs from the inner one, in the
beginning of the dynamics the number of atoms will change until it reaches a dynamical equilibrium
ﬂuctuation. To avoid this natural transient period in a consecutive restart calculation one can use the
read_idrst_ﬁle generated in the previous run telling the program the abfQM/MM atom id’s of the
restart conﬁguration. Note that the safe use of read_idrst_ﬁle requires the same region speciﬁcations
as in the previous run.

write_idrst_file Name of abfQM/MM atom id restart ﬁle generated during the run. Default name of the ﬁle

is abfqmmm.idrst.

ntwidrst

Frequency of printing the abfQM/MM atom id restart ﬁle out. Default is 0 (no printing).

hot_spot

1 activates the hot spot–like adaptive calculation [362] in which the forces of atoms in the buffer
region are linear combinations of the forces obtained from the extended and reduced calculations
using a smoothing function. Default is 0 (no hot spot–like calculation is performed).

193

10. QM/MM calculations

10.5. SEBOMD: SemiEmpirical Born-Oppenheimer Molecular Dynamics

The sander program provides the ability to run SEBOMD (SemiEmpirical Born-Oppenheimer Molecular Dy-
namics) simulations. During a SEBOMD simulation, all atoms are considered as quantum atoms within the NDDO
semiempirical approach (e.g., AM1, PM3, etc). Therefore, unlike QM/MM methods, there is no link atom, no fron-
tier bond, no interaction between any QM and MM atoms (since there is no MM atom). Another consequence of
SEBOMD simulations is that the computational time requested to compute energy and forces at each step of a
molecular dynamics run can be (very) important. To allow for the computation of “large” systems (i.e., up to a
couple of thousands of atoms), an optional linear scaling divide and conquer strategy is implemented[363, 364].
Periodic boundary conditions with long-range electrostatic interactions through Ewald summation can also be ap-
plied. A detailed explanation of the implementation can be found in ref [365]. If you publish work that results
from using the SEBOMD in AMBER, please cite the following work:

• Antoine Marion, Hatice Gokcan, and Gerald Monard, SemiEmpirical Born-Oppenheimer Molecular Dy-
namics (SEBOMD) Within the Amber Biomolecular Package, J. Chem. Inf. Model., 59, 206–214 (2019),
DOI: 10.1021/acs.jcim.8b00605

The SEBOMD code implemented in sander is originated from the DivCon program developed in the Merz group
while at Pennsylvania State University:

• Steve L. Dixon, Arjan van der Vaart, Valentin Gogonea, James J. Vincent, Edward N. Brothers, Lance M.

Westerhoff and Kenneth M. Merz, Jr. DivCon99, The Pennsylvania State University, 1999.

Major contributors to the SEBOMD interface are as follows:

• Maintenance, code refactoring, debugging, testing by Gerald Monard

• Original roar interface by Gerald Monard and Arjan van der Vaart[366]

• Original sander port by Jennifer Thomas

• Ewald and Particle Mesh Ewald summation by Laurent Teixidor

• PIF and MAIS semiempirical correction implementation, peptidic corrections by Antoine Marion[367]

• Divide & Conquer parallel speed enhancement by Hatice Gokcan

10.5.1. Functionalities and limitations

The current SEBOMD implementation allows to run sander simulations with the following functionalities:

• molecular dynamics or energy minimization (imin = 0, 1, or 5)

• gas phase or periodic boundary conditions (as deﬁned in the topology ﬁle), no support for Generalized Born

solvent effect

• For PBC runs, different long range interactions handlers are possible: none, external Particle Mesh Ewald

using MM point charges as deﬁned in the topology ﬁle, or direct Mulliken Ewald summation.

• temperature regulation as implemented in sander (ntt ﬂag)

• pressure regulation: only barostat = 2 is supported (Monte Carlo barostat)

• parallel implemention (sander.MPI): only the Divide & Conquer approach can be used (method > 0)

• available hamiltonians: MNDO, AM1, AM1/d-PhoT, RM1, PM3, PM3/PDDG

• available corrections to PM3 hamiltonians: MAIS and PIF

194

10.5. SEBOMD: SemiEmpirical Born-Oppenheimer Molecular Dynamics

• as d-orbitals are not yet implemented in the SEBOMD code, only the following elements are implemented:
H, C, N, O, P, S, F, Cl, Br, I (except for AM1/d-PhoT for which the P element is not yet available because it
requires the d-orbital implementation)

• maximum number of atoms: 1000; maximum number of residues: 1000

Note: the SEBOMD code currently uses a static memory allocation as deﬁned in $AMBERHOME/Amber-
Tools/src/sebomd/sebomd.dim. Users wishing to simulation bigger systems will have to modify the SE-
BOMD source code and recompile.

10.5.2. Sample SEBOMD input

To run a SEBOMD calculation, a speciﬁc namelist (&sebomd) must be used. It contains all the necessary
information for the run. To inform sander that a SEBOMD simulation must be run, two steps are required: 1)
switch the ifqnt keyword to 1 (as for a QM/MM calculation); 2) deﬁne the qm_theory keyword in the &qmmm
namelist to ’SEBOMD’. Here is a sample mdin ﬁle for SEBOMD:

! example input for SEBOMD simulation
&cntrl

...
ifqnt = 1,

/
&qmmm

! switch on QM calculation

qm_theory = ’SEBOMD’, ! use specific SEBOMD routines

/
&sebomd

hamiltonian = ’AM1’,
charge = 0,

! Use the AM1 semiempirical hamiltonian
! total charge on the (full) system is 0

/

10.5.3. &sebomd namelist variables

charge

= Integer Net charge of the system (Default = 0).
Note: SEBOMD only supports closed shell molecular systems.

method

Algorithm for the SCF computation.

= 0 (Default) Standard closed-shell algorithm: the Fock matrix is diagonalized at each SCF iteration.
(Note: all subsetting parameters are ignored, only one subsystem containing all the atoms will
be generated).

= 1 Use linear scaling divide & conquer SCF algorithm. Buffer regions must be speciﬁed (dbuff1

and dbuff2). Subsystems are built on an atom-based principle.

= 2 Use linear scaling divide & conquer SCF algorithm. Buffer regions must be speciﬁed (dbuff1
and dbuff2). Subsystems are built on an residue-based principle (recommended option over
method=1).

= 3 Use linear scaling divide & conquer SCF algorithm. Buffer regions must be speciﬁed (dbuff1
and dbuff2). Subsystems are built on an heavy-atom-based principle: each heavy atom plus
its hydrogens deﬁne one subsystem and there are as many subsystems as the number of non-
hydrogen atoms.

= Integer When using divide and conquer method (method > 0): specify the number of subsystems
used to build the core. (default: ncore = 1)

= Float When using divide and conquer method (method > 0): specify the extent of the ﬁrst buffer
region from the core in Å. (default: dbuff1 = 6.0)

ncore

dbuff1

195

10. QM/MM calculations

dbuff2

= Float When using divide and conquer method (method > 0): specify the extent of the second buffer
region from the core in Å. (default: dbuff2 = 0.0)

hamiltonian Semiempirical hamiltonian to be used for energy and force calculations. All atoms within the

molecular system will be treated at this level of theory. Available semiempirical hamiltonians:

MNDO Request the use of MNDO semiempirical hamiltonian[314]
AM1 Request the use of AM1 semiempirical hamiltonian[312]
PM3 Request the use of PM3 semiempirical hamiltonian (default)[311]
PM3PDDG Request the use of PM3/PDDG semiempirical hamiltonian[315]
RM1 Request the use of RM1 semiempirical hamiltonian[313]
AM1/d-PhoT Request the use of AM1/d-PhoT semiempirical hamiltonian[323]

(Note: phosphorous (P) element is not yet implemented, therefore the AM1/d-PhoT hamilto-
nian is available only for H, C, N, O, S, F, Cl, Br and I elements)

modif

Modiﬁcation/corrections to the semiempirical energy. Some semiempirical methods have been ex-
tended to improve results, mostly in the case of intermolecular interactions. For the moment only
PM3 corrections to the energy are available. Possible values are:

none (default) no correction
PIF2 PM3 hamiltonian is modiﬁed for intermolecular core-core interactions according to the work
of Bernal-Uruchurtu et al. and Harb et al. [318, 368–370]. This correction can be applied
when using PM3 hamiltonian with a molecular system composed of one (or more) organic
molecule(s) in interaction with explicit water molecules. Intermolecular water-water core-core
interactions are computed using speciﬁc PM3-PIF parameters for aqueous solvent, while in-
termolecular organic-organic and organic-water intermolecular core-core interactions are com-
puted using another speciﬁc set of PM3-PIF parameters. The intermolecular PM3-PIF (PIF2
version) parameters are available only for the following interactions:

Water

Organic

Hw Ow H C N O Cl
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) ∅ (cid:88) (cid:88) ∅
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88) ∅
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) ∅ ∅ (cid:88) ∅

Hw (cid:88)
Ow (cid:88)
(cid:88)
H
(cid:88)
C
(cid:88)
N
(cid:88)
O
(cid:88)
Cl

((cid:88): intermolecular interaction parameters between the two considered atom types are available;
∅: no intermolecular parameter available)

PIF3 PIF3 is an extension of the PIF2 parameters in which organic hydrogens are distinguished be-
tween “hydrophylic” hydrogens and “hydrophobic” hydrogens[367]. In the case of hydrophylic
hydrogens, intermolecular interactions between the hydrogen atom and water molecules are
computed using PIF2 parameters. In the case of hydrophobic hydrogens, intermolecular in-
teractions between these hydrogen atoms and water molecules are computed using speciﬁc
parameters. The distinction between hydrophobic and hydrophylic hydrogens is performed
using the atom types as speciﬁed in the topology ﬁle. Hydrogen atom types which are consid-
ered as hydrophylic are: H, HO, HS, HW, hn, ho, hp, hs, hw, Ho, hO, hN, and
hR. Other hydrogen atom types are considered as hydrophobic.

MAIS1 MAIS extension of the PM3 hamiltonian in which intramolecular and intermolecular core-
core functions are replaced by speciﬁc MAIS functions. This option corresponds to the initial
work of Bernal-Uruchurtu et al.[317]. Parameters are only available for liquid water (H and O
elements).

196

10.5. SEBOMD: SemiEmpirical Born-Oppenheimer Molecular Dynamics

MAIS2 Second version of the MAIS extension. Parameters are only available for H, O, and Cl

elements[318].

longrange Select the type of long range interaction when using periodic boundary conditions:

= 0 (Default) No long range interaction. Only the minimum image convention.
= 1 Perform PME (Particle Mesh Ewald) summation using constant atomic charges extracted from

the topology ﬁle.

= 2 Perform an Ewald summation using Mulliken atomic charges extracted from the semiempirical
wavefunction. Long-range Ewald Mulliken charge effects are incorporated in the Fock matrix
of the system to polarize the wavefunction.

dpmax

SCF convergence criteria on the density matrix:

= 1e-7 (Default) SCF is considered as converged when density matrix elements between two con-
secutive SCF steps have not changed more than dpmax. The default value of 1e-7 ensures the
conservation of the total energy during NVE simulations. Larger values will speed-up calcu-
lations by using less SCF steps but the total energy may not be conserved during molecular
dynamics.

fullscf

Option to enable pseudo-diagonalization routines

= 0 enable pseudo-diagonalization routine when possible. This can speed-up SCF calculations. (de-

fault)

= 1 turn off pseudo-diagonalization. Full diagonalization of the Fock matrix is performed at each

iteration of the SCF cycle.

ipolyn

Option to activate polynomial interpolation of the guess density matrix

= 0 Use converged density matrix of the previous step as initial (guess) density matrix for the current

step. Recommended option for minimization.

= 1 Use polynomial interpolation of the density matrix elements from the last three steps as initial
(guess) density matrix for the current step. Recommended option for molecular dynamics runs.
(default)

screen

verbosity option for SEBOMD calculations

= 0 minimum output. (default)
= 1 output semiempirical energy details at each step
= 2 output semiempirical energy details + the composition of all subsystems when using method >

0.

lambda

= Float (default 1.0) Enable the computation of a mixed energy value between SEBOMD and full
MM computations. If lambda (cid:54)= 1.0, in addition to a semiempirical calculation, the energy of the full
system is evaluated at the MM level. Then energy and forces are mixed according to:

E pot = λ E(SEBOMD) + (1− λ )E(MM)

Since, sometimes, semiempirical potential energy surfaces are (very) different from MM surface, the
use of the lambda keyword permits to equilibrate MD more easily. For example, from an equilibrated
MM system, it is possible to run several SEBOMD simulations using different lambda values from
0.0 (full MM energy) to 1.0 (full QM energy) to obtain an equilibrated SEBOMD simulation.

charge_out Filename used to save atomic charges. Default = ’sebomd.chg’

197

10. QM/MM calculations

ntwc

peptcorr

Every ntwc steps, the (Mulliken) atomic charges will be written to the charge_out ﬁle. If ntwc = 0,
no atomic charge ﬁle will be written. Default = 0.
The format of the charge_out ﬁle is the following: every ntwc steps, the energy of the system is ﬁrst
written, then one line per atom is written, containing the x, y, z coordinates and the Mulliken atomic
charge of the atom.

ﬂag to apply force ﬁeld corrections on peptidic bonds
Some semiempirical methods do not correctly describe peptidic bond properties, leading to a pyra-
midal peptide bond nitrogen. An empirical force ﬁeld correction can be applied to force the planarity
of a peptide bond[371].
= 0 no peptidic correction. (default)
= 1 apply peptidic correction (see Ludwig et al. for details[371])

peptk

= Float The force constant of the peptidic correction (in kcal/mol).
AM1 default value: peptk = 5.9864
PM3 default value: peptk = 9.8526
MNDO default value: peptk = 6.1737

198

11. Using energies and forces from an external

library

From Amber20 on, it is possible to run simulations where the energies and forces are computed from an external
library. This allows the use of Amber features like restraints or REMD during the simulations, and the use of
AmberTools like CPPTRAJ for the analyses of the output ﬁles. The feature of calling external libraries is available
for both sander and pmemd, with both serial and MPI versions.

At the time of writing, the only external library that can be called is MBX, a software developed by the
Paesani group at UCSD that computes energies and forces for the MB-pol and MB-nrg many-body potentials
(http://paesanigroup.ucsd.edu/software/mbx.html). However, other external libraries can be easily inter-
faced, requiring only minor modiﬁcations to the current Amber source code (see $AMBERHOME/src/pmemd/s-
rc/external.F90 for pmemd and $AMBERHOME/AmberTools/src/sander/external.F90 for sander) and build sys-
tem.

11.1. Installation instructions

In order to make use of an external library from Amber, the ﬁrst step is to properly compile Amber with access

to the external library. For compilation the following steps need to be executed:

1. Add -DCMAKE_PREFIX_PATH=[path to where you installed the external library] into your

cmake command at amber20_src/build/run_cmake

2. (Re)compile Amber

If installing Amber using the old (legacy) build system (see section 2.5), the following must be done instead:

1. Set the appropriate environment variable that points to the installation path of the external library. In the case
of MBX you have to set the environment variable MBX_HOME. If you are using bash, this means executing the
following command: export MBX_HOME=[path to where you installed the external library]

2. Conﬁgure Amber with the external library. Example: ./configure -mbx [additional options] gnu

3. (Re)compile Amber

11.2. Simulation setup and input parameters

In order to use an external library you still have to set up a conventional Amber simulation with prmtop and
coordinates ﬁles, even though the parameters will not be used during the simulation because energies and forces
are provided by the external library. After you have set up your system, following changes are required to the
Amber mdin input ﬁle:

1. Add the ﬂag iextpot=1 into the main namelist &cntrl in your mdin ﬁle. If you do not set iextpot or
if you set iextpot=0, then you will perform the regular simulation with the force ﬁeld parameters in your
prmtop ﬁle.

2. Add a new namelist called &extpot into the mdin ﬁle. This namelist contains input parameters that control
which external library is in use, and parameters that are speciﬁc to a given external library. In the case of
MBX you have to specify the name of the json ﬁle that controls MBX. This is an example:

199

11. Using energies and forces from an external library

&extpot
extprog=’mbx’,
json=’mbx.json’,
/

200

Part III.

System preparation

201

12. Preparing PDB Files

The only required or useful data in a PDB ﬁle to set up AMBER simulations are: atom names, residue names,
and maybe chain identiﬁers (if more than one chain is present), and the coordinates of heavy atoms. Non-protein
structures (especially low-molecular-weight ligands) will cause problems unless extra libraries are loaded;water
and monatomic ions are generally recognized if their names in the PDB ﬁle correspond to the internal names in the
AMBER libraries.

The upshot is that most PDB ﬁles require some modiﬁcation before being used in Amber. Most of the

recommended steps given below can be achieved with the pdb4amber program with the reduce option:

pdb4amber -i orig.pdb -o new.pdb --reduce --dry

This converts the original pdb ﬁle into one likely to be more suitable for input into LEaP. But these programs
(which are described in Sections 12.4 and 12.5 below) cannot anticipate all situations, so you should still examine
the output pdb ﬁle to consider the points below.

12.1. Cleaning up Protein PDB Files for AMBER

This is a crucial step in the preparation and many potential problems and subsequent errors arise from omiting
this step! (But also note that these are guidelines for beginners: there are certainly circumstances where you may
wish to modify the ideas presented here.)

• Analyze the PDB ﬁle visually in any viewer that can represent (and maybe modify) the ﬁle. Alternatively,
use a text editor. Delete all parts which are judged irrelevant for the simulation. Be aware that anything not
protein or water will require you to prepare and load extra library ﬁles.

• If the x-ray unit cell in the PDB ﬁle contains more than one image, choose the entity you want to use and

delete the other(s).

• If there is a ligand, save it as an MDL standard data ﬁle (SDF). Many software packages are able to do this
directly. You may also save the ligand in PDB format and then use some other tools later to convert it into a
decent SDF ﬁle (including correct bond order and all hydrogens). It is crucial to keep the coordinates
of its heavy atoms at their original location. Then delete it from the PDB ﬁle. The ligand must treated
separately later.

• Delete all water molecules that are not considered relevant. Some waters might be essential for ligand
binding. If those waters are kept, they should be made part of the receptor (as distinct "residues"), not of the
ligand. LEaP recognizes water if the residue name is WAT or HOH. In later simulations, they may have to
be tethered (more or less strongly) to their original positions to prevent them from "evaporating".

• Apply the same delete procedure to ions, co-factors, and other stuff that has no special relevance for the

planned simulation.

• Get rid off all protein (or peptide) hydrogens that are explicitly expressed in the PDB ﬁle. The reduce
and LEaP utilities adds hydrogens automatically with predeﬁned names. Having hydrogens in PDB ﬁles
with names that LEaP does not recognize within its residue libraries leads to a total mess.

• Eventually, remove also all connectivity records. These are mostly referring to ligands, or, in some cases,
to disulﬁde links. The latter should be explicitly re-connected (see later) without relying on connectivity
records in the PDB ﬁle.

203

12. Preparing PDB Files

• The ﬁnal PDB ﬁle of the protein should only contain unique locations for heavy atoms of amino acids (and
maybe oxygens of speciﬁc water molecules). (In some PDB ﬁles, the same amino acid may be represented
by different states (conformations). You must decide which unique location you want to use later in the
simulations. If you don’t do anything, Amber will use the “A” conformation, which is generally the most
highly occupied one.) Missing atoms in amino acids are mostly allowed since LEaP can rebuild them if the
residue names are correct and if the atoms already present have correct names also.

• Make use of "TER" records to separate parts in the PDB ﬁle which are not connected covalently. This
is especially important in protein structures in which parts are missing (gaps). Not separating the loose ends
by a "TER" record may lead to strange (and wrong) behavior in LEaP or later in the simulations. Apply the
same rule to individual water molecules which you want to keep and separate each water by a "TER" record.

12.2. Residue naming conventions

Tautomeric and protonation states are not rendered in PDB ﬁles. If a deﬁned state for a residue is required, its
name in the PDB ﬁle must reﬂect the choice. The following subsections deal with these cases. Important: if you
change a residue name in a PDB ﬁle, make sure to change it for all atoms of that residue!

Note also that PDB ﬁles written by LEaP will keep the "special" names, which sometimes leads to annoying
effects in software packages which are not prepared for amino acids called HIE, HIP, CYX, and alike. You might
consider to change these names back to the standard prior to using these PDB ﬁles in other software packages. You
can also use the “-bres” option in ambpdb to do that.

Histidine can exist in three forms (δ , ε, and protonated). The PDB ﬁle must reﬂect the choice of the user.
In the current versions of LEaP command ﬁles included with AMBER, ε-histidine is the default, i.e., a
"HIS" residue in a PDB ﬁle will be translated automatically to HIE (for ε-histidine). If the residue is called
"HID" in the PDB ﬁle, the resulting residue for AMBER will become δ -histidine, while "HIP" will yield the
protonated form.

Cysteine can exist in free form or as part of a disulﬁde bridge. PDB residues named "CYS" are automatically
converted into a free cysteine with a SH side chain end. If the cysteine is known to be in a S-S bridge, the
residue name in the PDB ﬁle must be "CYX". In that case, no hydrogen is automatically added to the side
chain which ends in a bare sulfur. However, S-S bonds to pairing cysteines are not automatically made but
must be speciﬁed by the user.

Asp,Glu,Lys Sometimes the usually charged residues aspartate "ASP", glutamate "GLU", and lysine "LYS" might
have to be used in their uncharged form. The residue names must then be changed to "ASH", "GLH", and
"LYN", respectively. A neutral form of arginine is not foreseen in AMBER (as the pKa of arginine is around
12, it is always considered protonated).

Terminals: ACE, NHE, NME There are special N- and C-terminal cap residues which can be used to neutralize
3 for the N-terminal and COO− for the
the N- and C-terminal in peptide chains when the defaults (NH+
C-terminal) are not appropriate.
The "ACE" residue [−C(= O)−CH3] can be used to cap the N-terminal. The PDB entry of the capping
residue ACE must be:

1 CH3 ACE
ACE
2 C
3 O
ACE

resnumber
resnumber
resnumber

x
x
x

y
y
y

z
z
z




ATOM
ATOM
ATOM

Note the atom name "CH3" for this special carbon: another name is not allowed. Hydrogens should be
omitted. They are automatically added if the residue name and the heavy atom names are correct.
For capping the C-terminus, two possibilities are given. The ﬁrst one is a simple NH2 termination giving
[C(= O)− NH2]. This residue is called "NHE" in the PDB ﬁle and consists of a single atom to be named N:

204




ATOM






12.3. Chains, Residue Numbering, Missing Residues

1 N

NHE

resnumber

x

y

z

The second possible C-terminal cap is NH −CH3, resulting in [C(= O)− NH −CH3] at the C-terminal. Its
entry in the PDB ﬁle must have the residue name "NME" and has the following PDB entry:

ATOM
ATOM

1 N
NME
2 CH3 NME

resnumber
resnumber

x
x

y
y

z
z

As above for "ACE", the atom name for the carbon must be "CH3". "NHE" and "NME" residues are
automatically completed with hydrogens. Do not enter them explicitly.
The "ACE" residue should be the ﬁrst residue in a chain (strand) while "NHE" or "NME" should be the last.
If cap residues are used to terminate gaps in incomplete protein chains, they must appear at the exact gap
location, respecting N-terminal and C-terminal order. Gaps must be separated by a "TER" record in the PDB
ﬁle. See section 12.3.

12.3. Chains, Residue Numbering, Missing Residues

• AMBER preparation modules assume that residues in a PDB ﬁle are connected and appear sequentially in
the ﬁle. If not covalently connected (i.e., linked by an amide bond), the residues must be separated by "TER"
records in the PDB ﬁle. (Alternatively, the chainid must change on going from one chain to the next chain.)
Thus for example, a protein consisting of two chains should have a "TER" record after the ﬁnal residue of
the ﬁrst chain. Similarly, if residues are missing (e.g., not detected in x-ray, or cut by the user), the gap
should also be separated by a "TER" record. Terminal residues will be charged by default. If the user wants
to avoid this (especially for gaps), these residues should be capped (by ACE and NHE or NME).

• In general, LEaP and tools using it refer to the original input residue numbers. Thus, residues are numbered

(rather "named") according to the original PDB ﬁle for special commands like the disulﬁde connections.

• In output ﬁles from LEaP, residues will always be numbered starting from 1, irrespective of the original
numbering. Gaps are not considered either. Thus if a protein chain runs from 21 to 80, with residues 31 to
40 (i.e., 10 residues) missing, the ﬁnal numbering of residues will run from 1 to 50.
The ﬁnal residue numbers are the ones that must be used in later simulations to refer to individual residues
via AMBER masks or NAB atom expressions. For example, if a protein chain with residues from 30 to 110
is prepared for AMBER simulations, the ﬁnal numbering will go from 1 to 81. If the original residues 35
to 40 should be ﬁxed or tethered, the actual residues to be speciﬁed are 6 to 11. This can lead to serious
errors. So be careful about residue numbers. The script pytleap described later will always generate a new
PDB ﬁle with exact AMBER residue numbering and atom names. This PDB ﬁle should be used as reference
throughout all subsequent AMBER simulations. Above all, when using atom masks or atom expressions (see
Appendix 21), always check that they really refer to the desired atoms before running lengthy simulations.
Fixing or tethering wrong atoms are a common error which may easily go unnoticed.

12.4. pdb4amber

pdb4amber analyses PDB ﬁles and cleans them for further usage, especially with the LEaP programs of Amber.
This utility was originally written by Romain Wolf, but later modiﬁed (mainly by Hai Nguyen) to use the parmed
tools under the hood.

Typing pdb4amber on the command line without options (or followed by -h) produces the following help mes-

sage:

usage: pdb4amber [-h] [-i FILE] [-o FILE] [-y] [-d] [-s STRIP_ATOM_MASK]

[-m MUTATION_STRING] [-p] [--constantph] [--most-populous]
[--keep-altlocs] [--reduce] [--no-reduce-db] [--pdbid]

205








12. Preparing PDB Files

[--add-missing-atoms] [--model MODEL] [-l FILE] [-v]
[--leap-template] [--no-conect] [--noter]
[input]

positional arguments:

input

PDB input file (default: stdin)

optional arguments:

-h, --help
-i FILE, --in FILE
-o FILE, --out FILE
-y, --nohyd
-d, --dry
-s STRIP_ATOM_MASK, --strip STRIP_ATOM_MASK

show this help message and exit
PDB input file (default: stdin)
PDB output file (default: stdout)
remove all hydrogen atoms (default: no)
remove all water molecules (default: no)

Strip given atom mask, (default: no)

-m MUTATION_STRING, --mutate MUTATION_STRING

-p, --prot
--constantph
--most-populous
--keep-altlocs
--reduce
--no-reduce-db

--pdbid

--add-missing-atoms
--model MODEL

Mutate residue
keep only Amber-compatible residues (default: no)
rename GLU,ASP,HIS for constant pH simulation
keep most populous alt. conf. (default is to keep 'A')
Keep alternative conformations
Run Reduce first to add hydrogens. (default: no)
If reduce is on, skip using it for hetatoms. (default:
usual reduce behavior for hetatoms)
fetch structure with given pdbid, should combined with
-i option. Subjected to change
Use tleap to add missing atoms
Model to use from a multi-model pdb file (integer).
(default: use 1st model). Use a negative number to
keep all models

-l FILE, --logfile FILE

-v, --version
--leap-template
--no-conect
--noter



log filename
version
write a leap template for easy adaption (EXPERIMENTAL)
Not write S-S conect record
Not writing TERUsage: pdb4amber [options]

The new output ﬁle (speciﬁed with -o or --out) is a standard PDB ﬁle with all residues sequentially re-

numbered from 1 to N. In addition, several other ﬁles are created automatically:

• A text ﬁle with the output PDB ﬁle name and _renum.txt added. This is a table to help convert the renum-

bered residues into the original ones.

• A PDB ﬁle with the output PDB ﬁle name and _nonprot.pdb appended. This is a PDB ﬁle that contains only

non-protein residues (apart from water), i.e., mainly ligands and other stuff.

• When using -d (--dry), a PDB ﬁle with the output ﬁle name plus _water.pdb added. This ﬁle contains

exclusively the water that has been stripped from the original PDB ﬁle.

• A text ﬁle with the output PDB ﬁle name and _sslink attached, if disulﬁde bonds have been detected by
pdb4amber. This ﬁle might be used by the pytleap script to generate the correct disulﬁde bonds between
cysteines.

The following information is written to screen, but can also be captured into a text ﬁle by ending the command
line with ’2>’ e.g.:

pdb4amber -i pdbin.pdb -o pdbout.pdb [-options] 2> some_file_name.log

206



12.5. reduce

Chains: All chain indicators in the PDB ﬁle are listed. This is useful especially in cases where the x-ray unit cell
contains more than one image of a protein (or complex). In many cases, one is only interested in one main
peptide chain. A long list of different chains may indicate that the PDB ﬁle should cleaned manually prior
to using pdb4amber.

Insertions: Insertions are mostly ’artiﬁcial’ residue numbers to keep speciﬁc key residue numbers in large protein
families constant. pdb4amber discards insertion codes and re-numbers all residues from 1 to N. But the
insertions are listed to the screen and also included in the _renum.txt ﬁle.

Histidines: pdb4amber ﬁrst checks if the type of each histidine (HIE, HIP, HID) can be determined from explicit
hydrogens. Any histidines whose protonation state can not be determined are renamd to HIE. A message
alerts the user to all histidine residues (the residue numbers refer to the renumbered scheme!) to allow for
manual reassignment if so desired.

Non-standard residues: Non-standard residues (i.e., residues not automatically recognized by Amber) are listed.
Mostly they are ligands (sometimes co-factors, detergent, buffer components, etc.). The user must take
care of these separately. These residues are also found in the _nonprot.pdb ﬁle mentioned above. They are
removed from the ﬁnal output PDB ﬁle if the -p (--prot) option was chosen. Otherwise they are left also
in the output PDB ﬁle.

Cysteines in disulﬁde bonds: pdb4amber locates possible (most probable) disulﬁde bonds by checking the dis-
tance between SG (gamma sulfur) atoms in cysteines. If a distance SG-SG less than 2.5 Angstrom is found
between the SG atoms of two CYS, a disulﬁde bond is assumed. The respective CYS residues are renamed
to CYX (required for Amber) in the ﬁnal PDB output ﬁle. CONECT records are also printed in the ﬁnal
PDB output ﬁle which are then automatically recognized by tleap. The residue numbers of the CYX residues
refer to the renumbered scheme!

Gaps: pdb4amber tries hard (and mostly succeeds) in locating ’gaps’, i.e., missing residues in the PDB ﬁle. This
is done by checking distances of consecutive C-N atoms.
If such a distance is larger than 2 Angstrom,
pdb4amber considers that there is a gap between the two residues and reports the gap to the screen. The
listed residue numbers refer to the renumbered scheme! It is up to user to decide how to handle the gaps.
Doing nothing at all will most probably lead to trouble later! By simply introducing a TER record at the
gap, Amber (LEaP) will later introduce the charged N (NH3+) or C (COO-) terminals at the gap borders.
If far from the binding site, this might be OK (except in long and unconstrained MD, where such unnatural
charges will inevitably lead to unrealistic behavior). The better solution is to introduce ACE or NME caps at
the correct positions (in addition to a TER record separating the gap residues). This can be done in various
ways (e.g. with PyMol). The correct names of the newly introduced residues (ACE or NME) and atoms
(CH3 for the methyl carbon, C, N, O for the others) must be observed!

Missing atoms: pdb4amber tries to determine missing heavy atoms in standard amino acids and reports these.
Residue numbers refer to the renumbered sequence. Note that this has no implcations on further usage of
the ﬁle with LEaP since missing atoms are added automatically anyway. In some cases, this addition may
lead to clashes however and it might be useful to know which residues are actually affected by LEaP.

12.5. reduce

Reduce is a program for adding hydrogens to a Protein DataBank (PDB) molecular structure ﬁle. It was de-
veloped by J. Michael Word at Duke University in the lab of David and Jane Richardson. Reduce is described
in: Word, et. al. (1999) Asparagine and Glutamine: Using Hydrogen Atom Contacts in the Choice of Side-chain
Amide Orientation, J. Mol. Biol. 285, 1733-1747.

Both proteins and nucleic acids can have hydrogens added. HET groups can also be processed as long as
the atom connectivity is provided. A slightly modiﬁed version of the connectivity table provided by the PDB is
included. The latest version of reduce is available at http://kinemage.biochem.duke.edu/.

In most circumstances, the recommended command when using reduce to add hydrogens to a PDB ﬁle and

standardize the bond lengths of existing hydrogens is

207

12. Preparing PDB Files

reduce -build -nuclear coordfile.pdb > coordfileH.pdb

which includes the optimization of adjustable groups (OH, SH, NH3+, Met-CH3, and Asn, Gln and His sidechain
orientation). Disulﬁdes, covalent modiﬁcations, and connection of the ribose-phosphate nucleic acid backbone,
are recognized and any hydrogens eliminated by bonding are skipped. When an amino acid main-chain nitrogen
is not connected to the preceding residue or some other group, reduce treats it as the N-terminus and constructs an
NH3+ only if the residue number is less than or equal to an adjustable limit (1, by default). Otherwise, it considers
the residue to be the observable beginning of an actually-connected fragment and does not protonate the nitrogen.
Reduce does not protonate carboxylates (including the C-terminus) because it does not speciﬁcally consider pH,
instead modeling a neutral environment.

Hydrogens are positioned with respect to the covalently bonded neighbors and these are identiﬁed by name.
Nonstandard atom names are the primary cause of missing or misplaced hydrogens. If reduce tries to process a
ﬁle which contains hydrogens with nonstandard names, the existing hydrogens may not be recognized and may
interfere with the generation of new hydrogens. The solution may be to remove existing hydrogens before further
processing.

There are a number of other, more advance, options for reduce, which can be viewed by running:

reduce -h

12.6. packmol-memgen

packmol-memgen is a workﬂow to generate Amber-ready protein/membrane/ion/solvent systems by using
Memembed [372] as the protein orientation function, pdbremix [373] to estimate the volume and Packmol
[374, 375] as the packing engine. The software is also able to wrap simple Amber tasks, like parametrization
(“--parametrize”) and minimization (“--minimize”) of the generated system, or inclusion of solutes into the
water box. The workﬂow and main features have been described in:

• "PACKMOL-Memgen: A Simple-To-Use, Generalized Workﬂow for Membrane-Protein–Lipid-Bilayer
System Building" S. Schott-Verdugo and H. Gohlke Journal of Chemical Information and Modeling
59 (6), 2522-2528 doi:10.1021/acs.jcim.9b00269 [376].

A typical case scenario is, for example, to pack a bacterial membrane protein into a bacterial-like membrane
(such as DOPE:DOPG 3:1). To fulﬁll such a task, the following command line is sufﬁcient:

packmol-memgen --pdb NAME.pdb --lipids DOPE:DOPG --ratio 3:1

where “NAME.pdb” corresponds to the protein that is going to be packed, and the orders of the colon-separated
lists of lipids and ratio correspond to each other. These lists can be further expanded to any complex mixture
the user desires (e.g., “DOPC:DOPE:DOPS:CHL1”), specifying different compositions per leaﬂet (by separating with
"//", e.g. “DOPC:DOPE//DOPE:DOPS”), or even adding additional lipid bilayers every time the “--lipids” ﬂag is
used. The user has to be aware that, by increasing the complexity of the membrane bilayer, the packing time will
increase, but more importantly, the time required to equilibrate such a system will also increase. The output pdb is
made Amber readable through charmmlipid2amber.py.

The lipid names used are abbreviations of trivial names, where the ﬁrst and second letters correspond to the
acyl chains in positions sn-1 and sn-2, respectively, and the rest corresponds to the headgroup present (with the
exception of cholesterol):

<sn-1 tail><sn-2 tail><headgroup>

In case the ﬁrst letter is a D, it is assumed that both acyl chains are equal (e.g. DOPC, 1,2-dioleoyl-sn-glycero-
phosphocholine). Tables 12.1 and 12.2 show the abbreviations used.

208

Acyl chain full name (Acid)

Abbreviation

12.6. packmol-memgen

Lauric acid | 12:0

Myristoic acid | 14:0
Palmitic acid | 16:0
Stearic acid | 18:0
Oleic acid | 18:1(9)

L
M
P
S
O
A

Arachidonic acid | 20:4(5,8,11,14)

Docosahexaenoic acid | 22:6(4,7,10,13,16,19)
*D is the usual abbreviation. H is adopted to distinguish from diacyl phospholipids.

H (D)*

Table 12.1.: Acyl chain abbreviations used in packmol-memgen.

Head group full name
Phosphatidylcholine

Phosphatidylethanolamine

Phosphatidylglycerol

Phosphatidic acid
Phosphatidylserine

Cardiolipin

Abbreviation

PC
PE
PG
PA
PS
CL

Table 12.2.: Head group abbreviations used in packmol-memgen.

The list of available lipids has been extended considerably from the possible combinations obtainable from plain
Lipid17 (resulting in what we call Lipid17_ext). New headgroups include lysophospholipids, phosphatidylinositols
and cardiolipins; they should be handled with care, as they are still in development. With “--available_lipids”
a brief list of commonly used lipids will be printed. If you want a full list of the available lipids, you can use
“--available_lipids_all”, but be aware that about 4000 lipids are available at the moment. If you are looking
for something speciﬁc, grep this list and see if you ﬁnd the lipid you are interested in. From the available lipids,
lysophospholipids were included in AmberTools19, and cardiolipins are now included in AmberTools20. They use
Lipid17 parameters, with charges obtained through a multiconformational RESP ﬁt, using a capping strategy as
described for both Lipid11 [82] and Lipid14 [84]. The headgroups included can be found in Table 12.3.
The 4-letter names of the lysophospholipids describe the topology of the molecules. For example, for 2LPC (1-
palmitoyl-2-hydroxy-sn-glycero-3-phosphocholine), a lysophosphatidylcholine with a C16 fatty acid chain:

2

L

P

C

// "lyso" position, or where a tail was removed. In this case the tail in position sn-2 is "missing".

// "lyso", indicating that the lipid corresponds to a lysophospholipid.

// name of the tail present. Palmitoyl in this case.

// last letter of the name of the phospholipid head group. Choline in this case.

Cardiolipins follow similar rules as for phospholipids, with the name describing ﬁrst positions sn-1 and sn-2
of the glycerol moiety attached in position sn-1 of the central glycerol, followed by positions sn-1 and sn-2 of
the glycerol attached in position sn-3, ﬁnishing with CL. For example, PODOCL would be a POPA (1-palmitoyl
2-oleoyl PA) and a DOPA (1,2-dioleoyl PA) attached through their sn-3 phosphate in positions sn-1 and sn-3 of a
glycerol, respectively. The exception to this comes when all tails are equal; in this case, the preﬁx T (from tetra-)
is added. As an example, TOCL is a glycerol with two DOPA residues attached in positions sn-1 and sn-3 of the
glycerol moiety.

Additionally to the lysophospholipid head groups, experimental head groups of phosphatidylinositols with mul-
tiple phosphorylation and protonation states are included. The parameters were derived in a similar fashion as for
the lysophospholipids, including GLYCAM_06j (3.3) parameters for the inositol/phosphate part. The headgroups
of phosphatidylinositols can be found in Table 12.4 with the abbreviation used for packmol-memgen.

209

12. Preparing PDB Files

Description

Lipid17_ext Residue Name

1,3-bis(sn-glycero-3’-phospho)-sn-glycerol

1-hydroxy-sn-phosphatidylcholine
2-hydroxy-sn-phosphatidylcholine

1-hydroxy-sn-phosphatidylethanolamine
2-hydroxy-sn-phosphatidylethanolamine

1-hydroxy-sn-phosphatidylglycerol
2-hydroxy-sn-phosphatidylglycerol

CLI
PE2
PE1
PE2
PE1
PG2
PG1

Table 12.3.: Lipid17_ext cardiolipin and lysophospholipid head group residue names. For LIPID17 residue names,

check 3.9

To make use of lysophospholipids, phosphatidylinositols or cardiolipins, the parameter ﬁles within packmol-
memgen have to be loaded. The easiest way to do this is by using the “--parametrize” together with the
“--keep” ﬂags. These will generate a leap.in ﬁle, which can be edited by the user if required. WARNING!:
In the case of cardiolipins, packmol-memgen requires to specify bonds for the acyl tails in position sn-3 for the
headgroup explicitly! This means that if for any reason you try to use the "CLI" headgroup outside of packmol-
memgen, you need to make sure to set these bonds in LEaP yourself.

A new feature added in AmberTools20 is the inclusion of gaussian shaped constraints to the membrane surface.

This allows to generate shapes of curved or buckled membranes with the program according to:

f (x,y) = he(− x²

2c²− y²
2d² )

You can set the values of c, d or h by respectively listing the desired values after the "--xygauss" ﬂag and

regulate the shape of the resulting system. An example of a line to build a buckled membrane would be:

packmol-memgen --xygauss 50 5000 40 --dims 300 50 121 --tight_box --parametrize

where "--dims" sets the x, y and z dimensions, and "--tight_box" is required to parametrize the system with the
expected xy dimensions and avoid the curvature from relaxing. This will generate a DOPC (lipid used by default)
membrane "pinched" in the x-axis. Finding the right dimensions and shape values might take some trial and error.
You can check the systems while they are being packed by opening the intermediate PDB with a molecular viewer
like PyMOL to decide if the generated shape is as expected. Consider checking the newly implemented MC-
barostat baroscalingdir option for your simulations if you use curved membranes. A barostat controling only the
z-axis (baroscalingdir=3) allows to relax the simulation box while keeping the xy dimensions.

Even though packmol-memgen was designed for membrane packing, it can also be used to solvate only. This
can be particularly useful if a salt or a speciﬁc solute concentration is desired. For this, use a command line as
follows:

packmol-memgen --pdb NAME.pdb --solvate --cubic \
--solute SOLUTE.pdb --solute_con CONCENTRATION

where “SOLUTE.pdb” corresponds to a pdb ﬁle that contains the solute to be added, and “CONCENTRATION” is
either the number of molecules to add, the concentration in molar (by adding M as a sufﬁx, e.g. 1 M) or
the volume percentage (by adding % as a sufﬁx, e.g. 10%). The latter is estimated using a grid approach
on the input “SOLUTE.pdb”. A distance constraint can be set between the introduced solute and a protein with
"--solute_prot_dist", avoiding starting conformations close to a possible binding site.
For a complete set of available functionalities, please refer to the help included within the software by executing:

packmol-memgen --help

Note: Due to the complex packing problem and the possible initial clashes in the output, the user is encouraged
to shortly minimize the system using the CPU code of pmemd or sander. This can be done directly with the
“ --minimize” ﬂag.

210

12.6. packmol-memgen

Description

Lipid17_ext Residue Name Abbreviation

Protonated phosphate position

Phosphatidylinositol (PI)

PI-3’-phosphate

PI-4’-phosphate

PI-5’-phosphate

PI-3’,4’-bisphosphate

PI-3’,5’-bisphosphate

PI-4’,5’-bisphosphate

PI-3’,4’,5’-trisphosphate

PI
PI3
PH3
PI4
PH4
PI5
PH5
P2A
P2B
H2A
2-A
P2C
P2D
H2B
2-B
P2E
P2F
H2C
2-C
P3A
P3B
P3C
P3D
P3E
P3F
P3-
P3H

PI
PI3
PI3H
PI4
PI4H
PI5
PI5H
PI34A
PI34B
PI34H
PI34-
PI35A
PI35B
PI35H
PI35-
PI45A
PI45B
PI45H
PI45-
PI345A
PI345B
PI345C
PI345D
PI345E
PI345F
PI345-
PI345H

-
-
3
-
4
-
5
3
4
3,4
-
3
5
3,5
-
4
5
4,5
-
3,4
3,5
4,5
3
4
5
-

3,4,5

Table 12.4.: Lipid17_ext phosphatidylinositol head group residue names. For Lipid17 residue names, check 3.9

211

12. Preparing PDB Files

12.7. Building bilayer systems with AMBAT

An alternative tool for building bilayer systems is AMBAT (Amber Membrane Builder and Analysis Tool),
developed by Tarun Khanna and Ian Gould. This package consists of three tcl scripts for building and analyzing
membrane models and for inserting proteins into the bilayer. Instructions and the scripts themselves are in the
$AMBERHOME/AmberTools/src/AMBAT folder.

212

13. LEaP

13.1. Introduction





LEaP is the generic name given to the programs teLeap and xaLeap, which are generally run via the tleap
and xleap shell scripts. These two programs share a common command language but the xleap program has
been enhanced through the addition of an X-windows graphical user interface. The name LEaP is an acronym
constructed from the names of the older AMBER software modules it replaces: link, edit, and parm. Thus, LEaP
can be used to prepare input for the AMBER molecular mechanics programs.

LEaP is the basic tool to construct force ﬁeld ﬁles (see Fig. 1.1). Using tleap, the user can:



Read AMBER PREP input files
Read Amber PARM format parameter sets
Read and write Object File Format files (OFF)
Read and write PDB files
Construct new residues and molecules using simple commands
Link together residues and create nonbonded complexes of molecules
Modify internal coordinates within a molecule
Generate files that contain topology and parameters for AMBER and NAB



usage: tleap [ -I<dir> ] [ -f <file>|- ]

The command tleap is a simple shell script that calls teLeap with a number of standard arguments. Directories to
be searched are indicated by one or more “-I” ﬂags; standard locations are provided in the tleap script. The “-f”
ﬂag is used to tell tleap to take its input from a ﬁle (or from stdin if “-f -” is speciﬁed). If there is no “-f” ﬂag,
input is taken interactively from the terminal.

A key command for LEaP is loadPdb, which inputs sequence and structure information from Protein Databank

Files. Be sure to read Section 12 for information on how to “clean up” PDB ﬁles before loading them.

13.2. Concepts

In order to effectively use LEaP it is necessary to understand the philosophy behind the program, especially
the concepts of LEaP commands, variables, and objects. In addition to exploring these concepts, this section also
addresses the use of external ﬁles and libraries with the program.

13.2.1. Commands

A researcher uses LEaP by entering commands that manipulate objects. An object is just a basic building block;
some examples of objects are ATOMs, RESIDUEs, UNITs, and PARMSETs. The commands that are supported
within LEaP are described throughout the manual and are deﬁned in detail in the “Command Reference” section.

The heart of LEaP is a command-line interface that accepts text commands which direct the program to

perform operations on objects. All LEaP commands have one of the following two forms:

command argument1 argument2 argument3 ...
variable = command argument1 argument2 ...

For example:

edit ALA trypsin = loadPdb trypsin.pdb

213

13. LEaP

Each command is followed by zero or more arguments that are separated by whitespace. Some commands return
objects which are then associated with a variable using an assignment (=) statement. Each command acts upon
its arguments, and some of the commands modify their arguments’ contents. The commands themselves are case-
insensitive. That is, in the above example, edit could have been entered as Edit, eDiT, or any combination
of upper and lower case characters. Similarly, loadPdb could have been entered a number of different ways,
including loadpdb. In this manual, we frequently use a mixed case for commands. We do this to enhance the
differences between commands and as a mnemonic device. Thus, while we write createAtom, createResidue,
and createUnit in the manual, the user can use any case when entering these commands into the program.

The arguments in the command text may be objects such as NUMBERs, STRINGs, or LISTs, or they may be

variables. These two subjects are discussed next.

13.2.2. Variables

A variable is a handle for accessing an object. A variable name can be any alphanumeric string whose ﬁrst

character is an alphabetic character. Alphanumeric means that the characters of the name may be letters, numbers,
or special symbols such as “*”. The following special symbols should not be used in variable names: dollar sign,
comma, period (full stop), pound sign (hash), equals sign, space, semicolon, double quote, or the curly braces {
and }. LEaP commands should not be used as variable names. Unlike commands, variable names are
case-sensitive: “ARG” and “arg” are different variables. Variables are associated with objects using an
assignment statement not unlike that found in conventional programming languages such as Fortran or C.

mole = 6.02E23
MOLE = 6.02E23
myName = "Joe Smith"
listOf7Numbers = { 1.2 2.3 3.4 4.5 6 7 8 }

In the above examples, both mole and MOLE are variable names, whose contents are the same (6.02 × 1023).
Despite the fact that both mole and MOLE have the same contents, they are not the same variable. This is due to
the fact that variable names are case-sensitive. LEaP maintains a list of variables that are currently deﬁned. This
list can be displayed using the list command. The contents of a variable can be printed using the desc command.

13.2.3. Objects

The object is the fundamental entity in LEaP. Objects range from the simple, such as NUMBERs and STRINGs,
to the complex, such as UNITs, RESIDUEs and ATOMs. Complex objects have properties that can be altered using
the set command, and some complex objects can contain other objects. For example, RESIDUEs are complex
objects that can contain ATOMs and have the properties: residue name, connect atoms, and residue type.

NUMBERs

NUMBERs are simple objects holding double-precision ﬂoating point numbers. They serve the same function

as “double precision” variables in Fortran and “double” variables in C.

STRINGs

STRINGs are simple objects that are identical to character arrays in C and similar to character strings in

Fortran. STRINGs store sequences of characters which may be delimited by double quote characters. Example
strings are:

"Hello there"
"String with a "" (quote) character"
"Strings contain letters and numbers:1231232"

214

LISTs

LISTs are made up of sequences of other objects delimited by LIST open and close characters. The LIST open
character is an open curly bracket ({) and the LIST close character is a close curly bracket (}). LISTs can contain
other LISTs and be nested arbitrarily deep. Example LISTs are:

13.2. Concepts

{ 1 2 3 4 }
{ 1.2 "string" }
{ 1 2 3 { 1 2 } { 3 4 } }

LISTs are used by many commands to provide a more ﬂexible way of passing data to the commands. The zMatrix
command has two arguments, one of which is a LIST of LISTs where each subLIST contains between three and
eight objects.

PARMSETs (Parameter Sets)

PARMSETs are objects that contain bond, angle, torsion, and non-bonding parameters for AMBER force ﬁeld

calculations. They are normally loaded from force ﬁeld data ﬁles, such as parm94.dat, and frcmod ﬁles.

ATOMs

ATOMs are complex objects that do not contain any other objects. The ATOM object corresponds to the chem-
ical concept of an atom. Thus, it is a single entity that may be bonded to other ATOMs and used as a building
block for creating molecules. ATOMs have many properties that can be changed using the set command. These
properties are deﬁned below.

name This is a case-sensitive STRING property and it is the ATOM’s name. The names for all ATOMs in a
RESIDUE should be unique. The name has no relevance to molecular mechanics force ﬁeld parameters; it is
chosen arbitrarily as a means to identify ATOMs. Ideally, the name should correspond to the PDB standard,
being 3 characters long except for hydrogens, which can have an extra digit as a 4th character.

type This is a STRING property. It deﬁnes the AMBER force ﬁeld atom type. It is important that the charac-
ter case match the canonical type deﬁnition used in the appropriate force ﬁeld data (*.dat) or frcmod ﬁle.
For smooth operation, all atom types must have element and hybridization deﬁned by the addAtomTypes
command. The standard AMBER force ﬁeld atom types are added by the selected leaprc ﬁle.

charge The charge property is a NUMBER that represents the ATOM’s electrostatic point charge to be used in a

molecular mechanics force ﬁeld.

element The atomic element provides a simpler description of the atom than the type, and is used only for LEaP’s
internal purposes (typically when force ﬁeld information is not available). The element names correspond to
standard nomenclature; the character “?” is used for special cases.

position This property is a LIST of NUMBERs. The LIST must contain three values: the (X, Y, Z) Cartesian

coordinates of the ATOM.

RESIDUEs

RESIDUEs are complex objects that contain ATOMs. RESIDUEs are collections of ATOMs, and are either
molecules (e.g., formaldehyde) or are linked together to form molecules (e.g., amino acid monomers). RESIDUEs
have several properties that can be changed using the set command. (Note that database RESIDUEs are each
contained within a UNIT having the same name; the residue GLY is referred to as GLY.1 when setting properties.
When two of these single-UNIT residues are joined, the result is a single UNIT containing the two RESIDUEs.)

One property of RESIDUEs is connection ATOMs. Connection ATOMs are ATOMs that are used to make
linkages between RESIDUEs. For example, in order to create a protein, the N-terminus of one amino acid residue
must be linked to the C-terminus of the next residue. This linkage can be made within LEaP by setting the N

215

13. LEaP

ATOM to be a connection ATOM at the N-terminus and the C ATOM to be a connection ATOM at the C-terminus.
As another example, two CYX amino acid residues may form a disulﬁde bridge by crosslinking a connection atom
on each residue.

There are several properties of RESIDUEs that can be modiﬁed using the set command. The properties are

described below:

connect0 This deﬁnes the ﬁrst of up to three ATOMs that are used to make links to other RESIDUEs.

In
UNITs containing single RESIDUEs, the RESIDUE’s connect0 ATOM is usually deﬁned as the UNIT’s
head ATOM. (This is how the standard library UNITs are deﬁned.) For amino acids, the convention is to
make the N-terminal nitrogen the connect0 ATOM.

connect1 This deﬁnes the second of up to three ATOMs that are used to make links to other RESIDUEs. In
UNITs containing single RESIDUEs, the RESIDUE’s connect1 ATOM is usually deﬁned as the UNIT’s
tail ATOM. (This is done in the standard library UNITs.) For amino acids, the convention is to make the
C-terminal oxygen the connect1 ATOM.

connect2 This deﬁnes the third of up to three ATOMs that are used to make links to other RESIDUEs. In amino

acids, the convention is that this is the ATOM to which disulﬁde bridges are made.

restype This property is a STRING that represents the type of the RESIDUE. Currently, it can have one of
the following values: “undeﬁned”, “solvent”, “protein”, “nucleic”, or “saccharide”. Some of the LEaP
commands behave in different ways depending on the type of a residue. For example, the solvate commands
require that the solvent residues be of type “solvent”. It is important that the proper character case be used
when deﬁning this property.

name The RESIDUE name is a STRING property. It is important that the proper character case be used when

deﬁning this property.

UNITs

UNITs are the most complex objects within LEaP, and the most important. They may contain RESIDUEs and
ATOMs. UNITs, when paired with one or more PARMSETs, contain all of the information required to perform a
calculation using AMBER. UNITs can be created using the createUnit command. RESIDUEs and ATOMs can
be added or deleted from a UNIT using the add and remove commands. UNITs have the following properties,
which can be changed using the set command:

head

tail These deﬁne the ATOMs within the UNIT that are connected when UNITs are joined together using the
sequence command or when UNITs are joined together with the PDB or PREP ﬁle reading commands. The
tail ATOM of one UNIT is connected to the head ATOM of the next UNIT in any sequence. (Note: a TER
card in a PDB ﬁle causes a new UNIT to be started.)

box This property can either be null, a NUMBER, or a LIST. The property deﬁnes the bounding box of the UNIT.
If it is deﬁned as null then no bounding box is deﬁned. If the value is a single NUMBER, the bounding box
will be deﬁned to be a cube with each side being box Å across. If the value is a LIST, it must contain three
NUMBERs, the lengths of the three sides of the bounding box.

cap This property can either be null or a LIST. The property deﬁnes the solvent cap of the UNIT. If it is deﬁned
as null, no solvent cap is deﬁned. If it is a LIST, it must contain four NUMBERs. The ﬁrst three deﬁne the
Cartesian coordinates (X, Y, Z) of the origin of the solvent cap in Å, while the fourth deﬁnes the radius of
the solvent cap, also in Å.

Examples of setting the above properties are

set dipeptide head dipeptide.1.N
set dipeptide box { 5.0 10.0 15.0 }
set dipeptide cap { 15.0 10.0 5.0 8.0 }

216

13.3. Running LEaP

The ﬁrst example makes the amide nitrogen in the ﬁrst RESIDUE within “dipeptide” the head ATOM. The second
example places a rectangular bounding box around the origin with the (X, Y, Z) dimensions of ( 5.0, 10.0, 15.0 )
in Å. The third example deﬁnes a solvent cap centered at ( 15.0, 10.0, 5.0 ) Å with a radius of 8.0 Å. Note: the
set cap command does not actually solvate, it just sets an attribute. See the solvateCap command for a more
practical case.

Complex objects and accessing subobjects

UNITs and RESIDUEs are complex objects. Among other things, this means that they can contain other objects.

There is a loose hierarchy of complex objects and what they are allowed to contain. The hierarchy is as follows:

• UNITs can contain RESIDUEs and ATOMs.

• RESIDUEs can contain ATOMs.

The hierarchy is loose because it does not forbid UNITs from containing ATOMs directly. However, the convention
that has evolved within LEaP is to have UNITs directly contain RESIDUEs which directly contain ATOMs.

Objects that are contained within other objects can be accessed using dot “.” notation. An example would be a
UNIT which describes a dipeptide ALA-PHE. The UNIT contains two RESIDUEs each of which contain several
ATOMs. If the UNIT is referenced (named) by the variable dipeptide, then the RESIDUE named ALA can be
accessed in two ways. The user may type one of the following commands to display the contents of the
RESIDUE:

desc dipeptide.ALA
desc dipeptide.1

The ﬁrst command translates to “describe some RESIDUE named ALA within the UNIT named dipeptide”. The
second form translates as “describe the RESIDUE with sequence number 1 within the UNIT named dipeptide”.
The second form is more useful because every subobject within an object is guaranteed to have a unique sequence
number. If the ﬁrst form is used and there is more than one RESIDUE with the name ALA, then an arbitrary
residue with the name ALA is returned. To access ATOMs within RESIDUEs, either of the following forms of
command may be used:

desc dipeptide.1.CA
desc dipeptide.1.3

Assuming that the ATOM with the name CA has a sequence number 3 within RESIDUE 1, then both of the above
commands will print a description of the alpha-carbon of RESIDUE dipeptide.ALA or dipeptide.1. The reader
should keep in mind that dipeptide.1.CA is the ATOM, an object, contained within the RESIDUE named ALA
within the variable dipeptide. This means that dipeptide.1.CA can be used as an argument to any command that
requires an ATOM as an argument. However dipeptide.1.CA is not a variable and cannot be used on the left hand
side of an assignment statement.

13.3. Running LEaP

xleap -h or tleap -h

will give a list of command-line arguments (which are very simple). Once you have started either program, typing
“help” will bring up a lot of useful information about possible actions.

A ﬁle called leaprc is executed as a script ﬁle at the start of the LEaP session unless the user suppresses it with
a command line option. Sample ﬁles are in $AMBERHOME/dat/leap/cmd, and you may wish to copy one of these
to become "your" default ﬁle. LEaP will look ﬁrst for a learpc ﬁle in the user’s current directory, then in any
directories included with -I ﬂags.

The command line interface allows the user to specify a log ﬁle that is used to log all input and output within
the command line environment. The log ﬁle is named using the logFile command. The ﬁle has two purposes: to

217

13. LEaP

allow the user to see a complete record of operations performed by LEaP, and to help recover from (and recreate)
program crashes. Output from LEaP commands is written to the log ﬁle at a verbosity level of 2 regardless of the
verbosity level set by the user using the verbosity command. Each line in the log ﬁle that was typed in by the user
begins with the two characters "> " (a greater-than sign followed by a space). This allows the user to extract the
commands typed into LEaP from the log ﬁle to create a script ﬁle that can be executed using the source command.
This provides a type of insurance against program crashes by allowing the user to regenerate their interactive
sessions. An example of a command that will create a script to reenact a LEaP session is:

cat LOGFILE | grep "^> " | sed "s/^> //" > SOURCEFILE.x

Note that changes via graphical and table interfaces (xleap) are not captured by command-line traces.

tleap (terminal LEaP) is the non-graphical, command-line-only interface to LEaP. It has the same functionality
as the xleap main window (Universe Editor Command Window, described below), and uses standard text control
keys. xleap is a windowing interface to LEaP. In addition to the command-line interface contained in the Universe
Editor window, it has a Unit Editor (graphical molecule editor), an Atom Properties Editor, and a Parmset Editor.
These editors are discussed in subsequent subsections.

13.3.1. Universe Editor

The window that ﬁrst appears when the user starts xleap is called the Universe Editor. The Universe Editor is the
most basic way in which users can interact with xleap. It has two parts, the "command window," which corresponds
to the tleap command interface, and the "pulldown" items above the window, which provide mouse-driven methods
to generate speciﬁc commands for the command window, either directly or via popped-up dialog boxes. The items
in the pulldowns allow the user to generate commands using dialog boxes. To display the "File" pulldown, for
example, press the left mouse button on "File;" to select an item in the pulldown, keep the button down, move the
mouse to highlight the item, then release the mouse button. A dialog box will then pop up containing ﬁelds which
the user can ﬁll in, and lists from which values can be chosen; these will be used to generate commands for the
command window interface.

13.3.2. Unit Editor

When the user enters the edit command from the Universe Editor Command Window, the Unit Editor will be
displayed if the argument to the edit command is an existing UNIT or a nonexistent (i.e. new) object. The Parmset
Editor will be activated if the argument is a PARMSET. The Parmset Editor is discussed later in this subsection.

The Unit Editor has ﬁve parts. At the top of the window is a pulldown menu bar; below it is a set of buttons titled
"Manipulation" that deﬁne the mode of mouse activity in the graphics window, and below that, a list of elements
to select for the manipulation "Draw" mode (selecting one automatically selects "Draw" mode). Then comes the
graphical molecule-editing ("viewing") window itself, and at the very bottom a text window where status and errors
are reported.

Unit Editor Menu Bar

The menu bar has three pulldowns: "Unit," "Edit," and "Display."

Unit pulldown The Unit pulldown contains commands affecting the whole UNIT.

• "Check unit" – checks the UNIT in the viewing window for improbable bond lengths, missing force
ﬁeld atom types, close nonbonded contacts, and a non-integral and nonzero total charge. Information
is printed in the text window at the bottom of the Unit Editor.

• "Calculate charge" – the total electrostatic charge for the UNIT is displayed in the text window at the

bottom of the Unit Editor.

• "Build," "Add H & Build" – the coordinates of new atoms are adjusted according to hybridization
(See also the Edit pulldown’s "Relax” selection.)
(inferred from bonds) and standard geometries.
Newly-drawn ATOMs are marked as "unbuilt" until they are marked otherwise by one of the Build

218

13.3. Running LEaP

commands or by the Edit pulldown’s "Mark selection (un)built." The builder only builds coordinates
for unbuilt ATOMs. This allows users to draw molecules piecemeal and make adjustments as they
draw, without worrying that the builder is going to undo their work. "Add H & Build" adds hydrogens
to the ATOMs that do not have a full valence and builds coordinates for the hydrogens and any other
ATOMs that are marked "unbuilt." The number of hydrogens added to each ATOM is determined by
the hybridization and element type of each ATOM.

• "Import unit" – a selection window pops up for the user to incorporate a copy of another unit in the
current one. The imported unit will generally superimpose on the existing one. (Hint: select all atoms
in the current unit before doing this to simplify dragging them apart using the Manipulation Move
mode.)

• "Close" – Exit the Editor.

Edit pulldown The Edit pulldown contains commands relating to the currently- selected ATOMs in the viewer

window. Selection is described below in the "Manipulation buttons" section.

• "Relax selection" – performs a limited energy minimization of all selected ATOMs, leaving unselected
ATOMs ﬁxed in place, by relaxing strained bonds, angles, and torsions.
If atom types have been
assigned and can be found in the currently-loaded force ﬁeld, force ﬁeld parameters are used. If no
types are available then default parameters are used that are based on ATOM hybridization. This
command invokes an iterative algorithm that can take some time to converge for large systems. As the
algorithm proceeds, the modiﬁed UNIT will be continuously updated within the viewing window. The
user can stop the process at any time by placing the mouse pointer within the viewing window and
typing control-C. Since only internal coordinates are energy minimized, steric overlap can result.

• "Edit selected atoms" – pops up an Atom Properties Editor, a tool for examining/setting the properties
of the selected ATOMs. The Atom Properties Editor allows the user to edit the ATOM names, types
and charges in a convenient table format. It is described in a separate subsection below.

• "Flip chirality" – This command inverts the chirality of all selected ATOMs. In order for the chirality
to be inverted, the ATOM cannot be in more than one ring. The operation causes the lightest chains
leaving the ATOM to be moved so as to invert the chirality. If the ATOM has only three chains attached
to it, then only one of the chains will be moved.

• "Select Rings/Residues/Molecules" – expands the currently selected group of atoms to include all

partially-contained rings, residues, or molecules.

• "Show everything" – causes all ATOMs to become visible.
• "Hide selection" – makes all selected ATOMs invisible.
• "Show selection only" – makes only selected ATOMs visible.
• "Mark selection unbuilt/built" - see "Unit/Build," above.

Display pulldown The Display pulldown contains commands that determine what information is displayed within

the viewing window.

• "Names" – toggles display of ATOM names at each ATOM position.
• "Types" – toggles display of molecular mechanics atom types. The ATOM types are displayed within

parentheses "()".

• "Charges" – toggles display of the atomic charges.
• "Residue names" – toggles display of residue names. These are displayed at the position of the ﬁrst
ATOM, before any of that ATOM’s information that may be displayed. The residue names are dis-
played within angled brackets "<>".

• "Axes" – toggles display of the Cartesian coordinate axes. The origin of the axes coincides with the

origin of Cartesian space.

• "Periodic box" – toggles display of the periodic box, if the UNIT has one.

219

13. LEaP

Unit Editor manipulation buttons

The Manipulation buttons are Select, Twist, Move, Erase, and Draw. They determine the behavior of the mouse

left-button when the mouse pointer is in the Viewing Window.

Select This button allows one to select part or all of a UNIT in anticipation of a subsequent operation or action.
In the Select mode, the user can highlight ATOMs within the viewing window for special operations. The
mouse pointer becomes a pointing hand in the viewing window in this mode. Selected ATOMs are displayed
in a different color (or different line styles on monochrome systems) from all other ATOMs. Atoms can
be selected with the left-button in several ways: ﬁrst, clicking on an atom and releasing selects that atom.
Clicking twice in a row on an atom (at any speed) selects all atoms (this is a bug – only the residue should be
selected). Keeping the button down and moving to release on another atom selects all ATOMs in the shortest
chain between the two ATOMs, if such a chain exists. Finally, by ﬁrst pressing the button in empty space,
and holding it down as the mouse is moved, one can "drag a box" enclosing atoms of interest. Note that
a current selection can be expanded by using the "Edit" menubar pulldown select option to complete any
partial selection of rings, residues or molecules.
If the user holds down the SHIFT key while performing any of the above actions, the same effect will be
seen, except ATOMs will be unselected.

Twist Twist mode operates on previously-Selected atoms. The intention is to allow rotation about dihedrals; if too
many atoms are selected, odd transformations can occur. While in the Twist mode, the mouse pointer looks
like a curved arrow. Twisting is driven by holding down the left-button anywhere in the viewing window and
moving the mouse up and down. It is important to select a complete torsion (all four atoms) before trying to
"twist" it.

Move Like Twist, Move mode operates on previously-Selected atoms. While in the Move mode, the mouse pointer
looks like four arrows coming out of one central point. Holding down the left-button anywhere allows
movement of these atoms by dragging in any direction in the viewing plane. (The view can be rotated by
holding down the middle-button to allow any movement desired.) This option allows the user to move the
selected ATOMs relative to the unselected ATOMs.
To rotate the selected ATOMs relative to the unselected ones, press and drag the mode (left) button while
holding down the SHIFT key. The selected ATOMs will rotate around a central ATOM on a "virtual sphere"
(see the subsubsection below on the rotate (middle) button for more information on the "virtual sphere").
The user can change which ATOM is used as the center of rotation by clicking the mode (left) button on any
of the ATOMs in the window.

Erase Erase mode causes the mouse pointer to resemble a chalkboard eraser when it is in the viewing window.
Clicking the left-button will delete any atoms or bonds under this mouse pointer, one atom or bond per click.

Draw Choosing Draw is equivalent to choosing the default "Elements" atom in the next array of buttons; the initial
default is carbon. While in the Draw mode, the mouse pointer is a pencil when in the viewing window.
Clicking the left-button deposits an atom of the current element, while dragging the mouse pointer with the
left-button held down draws a bond: if no atom is found where the button is released, one is created.
When the mouse pointer approaches an ATOM, the end of the line connected to the pointer will "snap" to
the nearest ATOM. This is to facilitate drawing of bonds between ATOMs. Any bonds that are drawn will by
default be single bonds. To change the order of a bond, the user would move the mouse to any point along
the bond and click the mode (left) button. This will cause the order of the bond to increase until it is reset
back to a single bond. The user can cycle through the following bond order choices: single, double, triple,
and aromatic.
If the user rotates a structure as it is being drawn, she will notice that all of the ATOMs that have been
drawn lie in the same plane. New ATOMs are automatically placed in the plane of the screen. The fact that
LEaP places the new ATOMs in the same plane is not a handicap because once a rough sketch of part of
the structure is compete, the user can invoke one of LEaP’s two model building facilities ("Unit/Build" and
"Edit/Relax Selection" in the Unit Editor Menu bar) to build full three dimensional coordinates.

220

13.3. Running LEaP

Unit Editor Elements Buttons" "C, H, O, ..." These buttons put the viewing window in Draw mode if it is not in
that mode already, and select the drawing element. The more common elements have their own buttons, and
all elements are also found by pulling down the other elements button.

Unit Editor Viewing Window

The viewing window displays a projection of the UNIT currently being edited. The user can manipulate the
structure within the viewing window with the mouse. By moving the mouse and holding down the mouse buttons,
the user can rotate, scale, and translate the UNIT within the window. The functions attached to the mouse buttons
are:

Rotate (Middle button) By pressing the rotate (middle) button within the viewing window and dragging the
mouse, the user can rotate the UNIT around the center of the viewing window. While the rotate (mid-
dle) button is down, a circle appears within the viewing window, representing a "virtual sphere trackball."
As the user drags the mouse around the outside of the circle, the UNIT will spin around the axis normal to
the screen. As the user drags the mouse within the circle, the UNIT will spin around the axis in the screen,
perpendicular to the movement of the mouse. The structures that are being viewed can be considered to be
embedded within a sphere of glass. The circle is the projection of the edge of the sphere onto the screen.
Rotating a UNIT while the mouse is within the circle is akin to placing a hand on a glass sphere and turning
the sphere by pulling the hand. The rotate operation does not modify the coordinates of the ATOMs; rather,
it simply changes the user’s point of view.

Translate (Right button) By pressing the translate (right) button within the viewing window and dragging the
mouse around the viewing window, the user can translate the UNIT within the plane of the screen. The
structures will follow the mouse as it moves around the window. This operation does not modify the coordi-
nates of the UNIT.

Scale (middle plus right button) If the scale "button" (holding the middle and right buttons down at the same
time) is depressed, the user will change the size of the structures within the viewing window. Pressing the
scale (middle plus right) button and dragging the mouse up and down the screen will increase and decrease
the scale of the structures. This operation does not modify the coordinates of the UNIT.

Mode (left button) The function of the left button is determined by the current mode of the viewing window as
described in the "Manipulation" section, above. When the mouse enters the viewing window it changes
shape to reﬂect the current mode of the viewing window.

Spacebar Another always-available operation when the mouse pointer is in the viewing window is the keyboard
spacebar. It centers and normalizes the size of the molecule in the viewing window. This is especially useful
if the UNIT becomes "lost" due to some operation.
The functions of the middle and right buttons are ﬁxed and always available to the user. This allows the user
to change the viewpoint of the UNIT within the viewing window regardless of its current mode. The user
might ask why there are controls to translate in the plane of the screen, but not out of the plane of the screen.
This is because LEaP does not have depth-cueing or stereo projection and this makes it difﬁcult for users to
perceive changes in the depth of a structure. However, the user can rotate the entire UNIT by 90 degrees
which will orient everything so that the direction that was coming out of the screen becomes a direction
lying in the plane of the screen. Once the UNIT has been rotated using the rotate (middle) button, the user
can translate the structure anywhere in space. While it does take some getting used to, users can become
very adept at the combination of rotations and translations.

13.3.3. Atom Properties Editor

The Atom Properties Editor is popped up by the Unit Editor when the user selects the Edit selected atoms
command from the Edit pulldown. The Atom Properties Editor allows the user to edit the properties of ATOMs
using a convenient table format. ATOM properties are: name, type, charge, and element.

221

13. LEaP

13.3.4. Parmset Editor

If the user enters the command edit Foo in the Universe Editor and Foo is a PARMSET, then a Parmset Editor is
popped up. First, a window appears which contains a number of buttons. The buttons list the parameters that can
be edited – Atom, Bond, Angle, Proper Torsion, Improper Torsion, and Hydrogen Bond – and an option to close
the editor. Choosing one of the parameter buttons will pop up a Table Editor. This editor resembles that of the
Atom Properties Editor, having three parts: the Menu Bar, Status Window, and Table Window.

13.4. Basic instructions for using LEaP to build molecules

This section gives an overview of how LEaP is most commonly used. Detailed descriptions of all the commands

are given in the next section.

13.4.1. Building a Molecule For Molecular Mechanics

In order to prepare a molecule within LEaP for AMBER, three basic tasks need to be completed.
1. Any needed UNIT or PARMSET objects must be loaded;

2. The molecule must be constructed within LEaP;

3. The user must output topology and coordinate ﬁles from LEaP to use in AMBER.

The most typical command sequence is the following:

source leaprc.protein.ff14SB (load a force field)
x = loadPdb trypsin.pdb (load in a structure)
.... add in cross-links, solvate, etc.
saveAmberParm x prmtop prmcrd (save files)

There are a number of variants of this:

1. Although loadPdb is by far the most common way to enter a structure, one might use loadOff, or
loadAmberPrep, or use the zMatrix command to build a molecule from a Z-matrix. For small molecules,
e.g., ligand like, loadMol2 or loadMol3 are available. See the Commands section below for descriptions of
these options. If you do not have a starting structure (in the form of a PDB ﬁle), LEaP can be used to build
the molecule; you will ﬁnd, however, that this is not always a straightforward process. Many experienced
Amber users turn to other (commercial and non-commercial) programs to create their initial structures.

2. Be very attentive to any errors produced in the loadPdb step; these generally mean that LEaP has misread
the ﬁle. A general rule of thumb is to keep editing your input PDB ﬁle until LEaP stops complaining. It is
often convenient to use the addPdbAtomMap or addPdbResMap commands to make systematic changes from
the names in your PDB ﬁles to those in the Amber topology ﬁles; see the leaprc ﬁles in $AMBERHOME/-
dat/leap/cmd for examples of this. Be sure to read Section 12 for information on how to “clean up” PDB
ﬁles before loading them.

3. The saveAmberParm command cited above is appropriate for most force ﬁelds; for polarizable calculations

you will need to use saveAmberParmPol.

13.4.2. Amino Acid Residues

For each of the amino acids found in the LEaP libraries, there has been created an N-terminal and a C-terminal
analog. The N-terminal amino acid UNIT/RESIDUE names and aliases are prefaced by the letter N (e.g., NALA)
and the C-terminal amino acids by the letter C (e.g., CALA). If the user models a peptide or protein within LEaP,
they may choose one of three ways to represent the terminal amino acids. The user may use (1) standard amino
acids, (2) protecting groups (ACE/NME), or (3) the charged C- and N-terminal amino acid UNITs/RESIDUEs. If
the standard amino acids are used for the terminal residues, then these residues will have incomplete valences.
These three options are illustrated below:

222

13.5. Error Handling and Reporting

{ ALA VAL SER PHE }
{ ACE ALA VAL SER PHE NME }
{ NALA VAL SER CPHE }

The default for loading from PDB ﬁles is to use N- and C-terminal residues;
this is established by the
addPdbResMap command in the default leaprc ﬁles. To force incomplete valences with the standard residues,
one would have to deﬁne a sequence (“ x = { ALA VAL SER PHE }”) and use loadPdbUsingSeq, or use
clearPdbResMap to completely remove the mapping feature.

Histidine can exist either as the protonated species or as a neutral species with a hydrogen at the δ or ε position.
For this reason, the histidine UNIT/RESIDUE name is either HIP, HID, or HIE (but not HIS). The default “leaprc”
ﬁle assigns the name HIS to HIE. Thus, if a PDB ﬁle is read that contains the residue HIS, the residue will be
assigned to the HIE UNIT object. This feature can be changed within one’s own leaprc ﬁle.

The AMBER force ﬁelds also differentiate between the residue cysteine (CYS) and the similar residue which
participates in disulﬁde bridges, cystine (CYX). The user will have to explicitly deﬁne, using the bond command,
the disulﬁde bond for a pair of cystines, as this information is not read from the PDB ﬁle. In addition, the user
will need to load the PDB ﬁle using the loadPdbUsingSeq command, substituting CYX for CYS in the sequence
wherever a disulﬁde bond will be created.

13.4.3. Nucleic Acid Residues

The “D” preﬁx can be used to distinguish between deoxyribose and ribose units. Residue names like “A” or
“DA” can be followed by a “5” or “3” (“DA5”, “DA3”) for residues at the ends of chains; this is also the default
established by addPdbResMap, even if the “5” or “3” are not added in the PDB ﬁle. The “5” and “3” residues
are “capped” by a hydrogen; the plain and “3” residues include a “leading” phosphate group. Neutral residues
(nucleosides) capped by hydrogens end their names with “N”, as in “DAN”.

13.5. Error Handling and Reporting

In Amber version 18 changes were made to LEaP’s error processing. The ﬁrst set of changes involve error
handling. For input from a ﬁle (i.e., tleap invoked with -f ) execution is now terminated at the ﬁrst occurrence
of these errors: ﬁle input/output errors, illegal command syntax, illegal command arguments, and some command
parsing errors. The intent is to simplify error detection and to ease troubleshooting. For interactive input there is
no change in handling: LEaP continues to be forgiving of these errors in the hope that the user can recover in real
time.

The ﬁnal set of changes involve error reporting. LEaP produces four kinds of messages: errors, warnings, notes,
and processing messages. Messages beginning with "Fatal Error!" or "Error!" or "Error:" indicate a serious prob-
lem. Messages beginning with "Warning!" or "Warning:" indicate a potential problem that should be investigated.
Messages beginning with "Note." or "Note:" provide information worth noting. Messages that are not designated
by one of the above tags report processing status. Total counts of errors, warnings, and notes are outputted at the
end of LEaP. The intent is to simplify error detection by emitting clear and consistent messages.

As with all computational software, LEaP’s output should be carefully examined. Some error and warning
messages mention likely causes or contain suggested workarounds, but all such messages provide clues. Apply
common sense and the scientiﬁc method to troubleshoot. Typical ﬁrst steps are to verify input ﬁles and to search the
AMBER Mail Reﬂector for similar reported problems. Note that LEaP normally produces a log ﬁle that contains
these messages and more detailed output that can be inspected.

13.6. Commands

The following is a description of the commands that can be accessed using the command line interface in tleap,
or through the command line editor in xleap. Whenever an argument in a command line deﬁnition is enclosed
in square brackets (e.g., [arg]), then that argument is optional. When examples are shown, the command line is
prefaced by “> ”, and the program output is shown without this character preface.

223

13. LEaP

Some commands that are almost never used have been removed from this description to save space. You can use
the “help” facility to obtain information about these commands; most only make sense if you understand what the
program is doing behind the scenes.

13.6.1. add

add a b

UNIT/RESIDUE/ATOM a,b

Add the object b to the object a. This command is used to place ATOMs within RESIDUEs, and RESIDUEs

within UNITs. This command will work only if b is not contained by any other object.

The following example illustrates both the add command and the way the TIP3P water molecule is created for



the LEaP distribution.

> h1 = createAtom H1 HW 0.417
> h2 = createAtom H2 HW 0.417
> o = createAtom O OW -0.834
>
> set h1 element H
> set h2 element H
> set o element O
>
> r = createResidue TIP3
> add r h1
> add r h2
> add r o
>
> bond h1 o
> bond h2 o
> bond h1 h2
>
> TIP3 = createUnit TIP3
>
> add TIP3 r
> set TIP3.1 restype solvent
> set TIP3.1 imagingAtom TIP3.1.O
>
> zMatrix TIP3 {
> { H1 O 0.9572 }
> { H2 O H1 0.9572 104.52 }
> }
>
> saveOff TIP3 water.lib
Saving TIP3.
Building topology.
Building atom parameters.



13.6.2. addAtomTypes

addAtomTypes { { type element hybrid } { ... } ... }

Deﬁne element and hybridization for force ﬁeld atom types. This command for the standard force ﬁelds can be
seen in the default leaprc ﬁles. The STRINGs are most safely rendered using quotation marks. If atom types are
not deﬁned, confusing messages about hybridization can result when loading PDB ﬁles.

224





13.6. Commands

13.6.3. addIons and addIons2

addIons unit ion1 numIon1 [ion2 numIon2]
addIons2 unit ion1 numIon1 [ion2 numIon2]

Adds counterions in a shell around unit using a Coulombic potential on a grid. If numIon1 is 0 then the unit is
neutralized. In this case, ion1 must be opposite in charge to unit and ion2 must not be speciﬁed. Otherwise, the
speciﬁed numbers of ion1 [ion2 ] are added [in alternating order]. If solvent is present, it is ignored in the charge
and steric calculations, and if an ion has a steric conﬂict with a solvent molecule, the ion is moved to the center
of that solvent molecule, and the latter is deleted. (To avoid this behavior, either solvate _after_ addions, or use
addIons2.) Ions must be monatomic. This procedure is not guaranteed to globally minimize the electrostatic
energy. When neutralizing regular-backbone nucleic acids, the ﬁrst cations will generally be placed between
phosphates, leaving the ﬁnal two ions to be placed somewhere around the middle of the molecule. The default grid
resolution is 1 Å, extending from an inner radius of (maxIonVdwRadius + maxSoluteAtomVdwRadius) to an outer
radius 4 Å beyond. A distance-dependent dielectric is used for speed. addIons2 is the same as addIons, except
solvent and solute are treated the same.

13.6.4. addIonsRand

addIonsRand unit ion1 #ion1 [ion2 #ion2] [separation]

Adds counterions in a shell around unit by replacing random solvent molecules. If #ion1 is 0, the unit is neutralized
(ion1 must be opposite in charge to unit, and ion2 cannot be speciﬁed). Otherwise, the speciﬁed numbers of ion1
[ion2] are added [in alternating order]. If separation is speciﬁed, ions will be guaranteed to be more than that
distance apart in Angstroms.

Ions must be monoatomic. This procedure is much faster than addIons, as it does not calculate charges. Solvent
must be present. It must be possible to position the requested number of ions with the given separation in the
solvent.

13.6.5. addPath

addPath path

Add the directory in path to the list of directories that are searched for ﬁles speciﬁed by other commands. The
following example illustrates this command.

> addPath /disk/howard
/disk/howard added to file search path.

After the above command is entered, the program will search for a ﬁle in this directory if a ﬁle is speciﬁed in a
command. Thus, if a user has a library named “/disk/howard/rings.lib” and the user wants to load that library, one
only needs to enter load rings.lib and not load /disk/howard/rings.lib.

13.6.6. addPdbAtomMap

addPdbAtomMap list

The atom Name Map is used to try to map atom names read from PDB ﬁles to atoms within residue UNITs when
the atom name in the PDB ﬁle does not match an atom in the residue. This enables PDB ﬁles to be read in without
extensive editing of atom names. Typically, this command is placed in the LEaP startup ﬁle, “leaprc”, so that
assignments are made at the beginning of the session. list should be a LIST of LISTs. Each sublist should contain
two entries to add to the Name Map. Each entry has the form:

{ string string }

where the ﬁrst string is the name within the PDB ﬁle, and the second string is the name in the residue UNIT.

225

13. LEaP

13.6.7. addPdbResMap

addPdbResMap list

The Name Map is used to map RESIDUE names read from PDB ﬁles to variable names within LEaP. Typically,
this command is placed in the LEaP startup ﬁle, “leaprc”, so that assignments are made at the beginning of the
session. The LIST is a LIST of LISTs. Each sublist contains two or three entries to add to the Name Map. Each
entry has the form:

{ double string1 string2 }

where double can be 0 or 1, string1 is the name within the PDB ﬁle, and string2 is the variable name to which
string1 will be mapped. To illustrate, the following is part of the Name Map that exists when LEaP is started from
the “leaprc” ﬁle included in the distribution:

ADE --> DADE
: :
0 ALA --> NALA
0 ARG --> NARG
: :
1 ALA --> CALA
1 ARG --> CARG
: :
1 VAL --> CVAL

Thus, the residue ALA will be mapped to NALA if it is the N-terminal residue and CALA if it is found at the
C-terminus. The above Name Map was produced using the following (edited) command line:

> addPdbResMap {
> { 0 ALA NALA } { 1 ALA CALA }
> { 0 ARG NARG } { 1 ARG CARG } : :
> { 0 VAL NVAL } { 1 VAL CVAL }
> : :
> { ADE DADE } : :
> }

13.6.8. alias

alias [ string1 [ string2 ] ]

This command will add or remove an entry to the Alias Table or list entries in the Alias Table. If both strings are
present, then string1 becomes the alias to string2, the original command. If only one string is used as an argument,
then that string will be removed from the Alias Table. If no arguments are given to the command, the current
aliases stored in the Alias Table will be listed.

The proposed alias is ﬁrst checked for conﬂict with the LEaP commands and rejected if a conﬂict is found. A
proposed alias will replace an existing alias with a warning being issued. The alias can stand for more than a single
word, but also as an entire string so the user can quickly repeat entire lines of input.

13.6.9. bond

bond atom1 atom2 [ order ]

Create a bond between atom1 and atom2. Both of these ATOMs must be contained by the same UNIT. By
default, the bond will be a single bond. By specifying “-”, “=”, “#”, or “:” as the optional argument, order, the
user can specify a single, double, triple, or aromatic bond, respectively. Example:

bond trx.32.SG trx.35.SG

226

13.6.10. bondByDistance

bondByDistance container [ maxBond ]

Create single bonds between all ATOMs in the UNIT container that are within maxBond Å of each other. If
maxBond is not speciﬁed, a default distance will be used. This command is especially useful in building
molecules. Example:

13.6. Commands

bondByDistance alkylChain

13.6.11. check

check unit [ parms ]

This command can be used to check unit for internal inconsistencies that could cause problems when performing
calculations. This is a very useful command that should be used before a UNIT is saved with saveAmberParm or
its variants. Currently it checks for the following possible problems:

• long bonds

• short bonds

• non-integral total charge of the UNIT

• missing force ﬁeld atom types

• close contacts (< 1.5 Å) between nonbonded ATOMs

The user may collect any missing molecular mechanics parameters in a PARMSET for subsequent editing. In the
following example, the alanine UNIT found in the amino acid library has been examined by the check command:

> check ALA
Checking ’ALA’....
Checking parameters for unit ’ALA’.
Checking for bond parameters.
Checking for angle parameters.
Unit is OK.

13.6.12. combine

variable = combine list

Combine the contents of the UNITs within list into a single UNIT. The new UNIT is placed in variable. This
command is similar to the sequence command except it does not link the ATOMs of the UNITs together. In the
following example, the input and output should be compared with the example given for the sequence command.

> tripeptide = combine { ALA GLY PRO }
Sequence: ALA
Sequence: GLY
Sequence: PRO
> desc tripeptide
UNIT name: ALA !! bug: this should be tripeptide!
Head atom: .R<ALA 1>.A<N 1>
Tail atom: .R<PRO 3>.A<C 13>
Contents:
R<ALA 1>
R<GLY 2>
R<PRO 3>

227

13. LEaP

13.6.13. copy

newvariable = copy variable

In most cases, creates an exact duplicate of the object variable. Since newvariable is not pointing to the same
object as variable, changing the contents of one object will not alter the other object. Example:

> tripeptide = sequence { ALA GLY PRO }
> tripeptideSol = copy tripeptide
> solvateBox tripeptideSol TIP3PBOX 8 2

In the above example, tripeptide is a separate object from tripeptideSol and is not solvated. Had the user instead
entered

> tripeptide = sequence { ALA GLY PRO }
> tripeptideSol = tripeptide
> solvateBox tripeptideSol TIP3PBOX 8 2

then both tripeptide and tripeptideSol would be solvated since they would both refer to the same object.

Note that in a few instances, the copy command does not produce an exact copy. This is particularly relevant
when making copies of oligosaccharide residues. In these, the copy command invariably inverts chirality at the
anomeric carbon. The workaround for this is to use the copy command twice, where the second call inverts the
chirality back.

13.6.14. createAtom

variable = createAtom name type charge

Return a new and empty ATOM with name, type, and charge as its atom name, atom type, and electrostatic point
charge. (See the add command for an example of the createAtom command.)

13.6.15. createResidue

variable = createResidue name

Return a new and empty RESIDUE with the name name.
createResidue command.)

(See the add command for an example of the

13.6.16. createUnit

variable = createUnit name

Return a new and empty UNIT with the name name. (See the add command for an example of the createUnit
command.)

13.6.17. deleteBond

deleteBond atom1 atom2

Delete the bond between the ATOMs atom1 and atom2. If no bond exists, an error will be displayed.

228

13.6. Commands

13.6.18. desc

desc variable

Print a description of the object variable. In the following example, the alanine UNIT found in the amino acid
library has been examined by the desc command:

> desc ALA
UNIT name: ALA
Head atom: .R<ALA 1>.A<N 1>
Tail atom: .R<ALA 1>.A<C 9>
Contents: R<ALA 1>

Now, the desc command is used to examine the ﬁrst residue (1) of the alanine UNIT:

> desc ALA.1
RESIDUE name: ALA
RESIDUE sequence number: 1
Type: protein
Connection atoms:
Connect atom 0: A<N 1>
Connect atom 1: A<C 9>
Contents:
A<N 1>
A<HN 2>
A<CA 3>
A<HA 4>
A<CB 5>
A<HB1 6>
A<HB2 7>
A<HB3 8>
A<C 9>
A<O 10>

Next, we illustrate the desc command by examining the ATOM N of the ﬁrst residue (1) of the alanine UNIT:

> desc ALA.1.N
ATOM Name: N
Type: N
Charge: -0.463
Element: N
Atom flags: 20000|posfxd- posblt- posdrn- sel- pert- notdisp- tchd-

posknwn+ int - nmin- nbld-

Atom position: 3.325770, 1.547909, -0.000002
Atom velocity: 0.000000, 0.000000, 0.000000
Bonded to .R<ALA 1>.A<HN 2> by a single bond.
Bonded to .R<ALA 1>.A<CA 3> by a single bond.

Since the N ATOM is also the ﬁrst atom of the ALA residue, the following command will give the same output as
the previous example:

> desc ALA.1.1

13.6.19. groupSelectedAtoms

groupSelectedAtoms unit name

229

13. LEaP

Create a group within unit with the name name, using all of the ATOMs within unit that are selected. If the group
has already been deﬁned then overwrite the old group. The desc command can be used to list groups. Example:

groupSelectedAtoms TRP sideChain

An expression like “TRP@sideChain” returns a LIST, so any commands that require LISTs can take advantage of
this notation. After assignment, one can access groups using the “@” notation. Examples:

select TRP@sideChain
center TRP@sideChain

The latter example will calculate the center of the atoms in the “sideChain” group. (See the select command for
a more detailed example.)

13.6.20. help

help [string]

This command prints a description of the command in string. If no argument is given, a list of help topics is
provided.

13.6.21. impose

impose unit seqlist internals

The impose command allows the user to impose internal coordinates on unit. The list of RESIDUEs to impose the
internal coordinates upon is in seqlist. The internal coordinates to impose are in internals, which is an object of
type LIST.

The command works by looking into each RESIDUE within unit that is listed in seqlist and attempts to apply
each of the internal coordinates within internals. The seqlist argument is a LIST of NUMBERS that represent
sequence numbers or ranges of sequence numbers. A range of sequence numbers is represented by two element
LISTs that contain the ﬁrst and last sequence number in the range. The user can specify sequence number ranges
that are larger than what is found in unit, in which case the range will stop at the beginning or end of unit as
appropriate. For example, the range { 1 999 } will include all RESIDUEs in a 200 RESIDUE UNIT.

The internals argument is a LIST of LISTs. Each sublist contains a sequence of ATOM names which are of
type STRING followed by the value of the internal coordinate. An example of the impose command would be:

impose peptide { 1 2 3 } { { “N” “CA” “C” “N” -40.0 } { “C” “N” “CA” “C” -60.0 } }

This would cause the RESIDUE with sequence numbers 1, 2, and 3 within the UNIT peptide to assume an
α-helical conformation. The command

impose peptide { 1 2 { 5 10 } 12 } { { “CA” “CB” 5.0 } }

will impose on the residues with sequence numbers 1, 2, 5, 6, 7, 8, 9, 10, and 12 within the UNIT peptide a bond
length of 5.0 Å between the α and β carbon atoms. RESIDUEs without an ATOM named CB, such as glycine,
will be unaffected.

It is important to understand that the impose command attempts to perform the intended action on all residues in
the seqlist, but does not necessarily limit itself to acting only upon internals contained within those residues. That
is, the list does not limit the residues to consider. Rather, it is a list of all starting points to consider. In other words,
to specify a seqlist of { 3 4 } tells impose to attempt to set two torsions, one starting in residue 3 and the other
starting in residue 4. It does not specify that the torsion should only be set if the atoms are found within residues 3
and/or 4.

Because of this, one must be careful when setting torsions between two residues. It is necessary to know which

atoms are contained in which residues. Consider the following trisaccharide:

230

13.6. Commands

α-D-Glcp-(1-6)-β -D-Manp-(1-6)-β -D-Galp-OH

To build it most simply in leap requires the following directive. Note that the build order in leap is the reverse

of the standard order in which the residues are written above.

glycan = sequence { ROH 6LB 6MB 0GA }

A proper build of a 1-6 oligosaccharide linkage often requires setting three torsions. In the manner that residues
are deﬁned in the Glycam force ﬁelds, the atoms describing two of those torsions, φ and ψ, span two residues.
However, the atoms in the third, ω, exist entirely within one residue. In fact, they exist within all three glycan
residues in the example above. The following commands will set only the three torsions in the glycosidic linkage
between residues 4 (0GA) and 3 (6MB).

impose glycan { 4 } { { “H1” “C1” “O6” “C6” -60.0 } } # O6 & C6 are in residue 3
impose glycan { 4 } { { “C1” “O6” “C6” “C5” 180.0 } } # only C1 is in residue 4
impose glycan { 3 } { { “O6” “C6” “C5” “O5” 60.0 } } # all are in residue 3

The common misconception that the seqlist sets a limit on the residues affected can cause trouble in this case. For
example, this command

impose glycan { 4 3 } { { “H1” “C1” “O6” “C6” -60.0 } }

will ﬁnd all sequences beginning in residue 4 and in residue 3 that contain the serially bonded atoms H1 C1 O6
and C6. Therefore, in this case, it will set the speciﬁed torsions between residues 4 and 3 as well as between 3 and
2. Similarly, this command

impose peptide { 4 } { { “O6” “C6” “C5” “O5” 60.0 } }

will not affect any inter-residue linkage, but instead will set the C5-C6 torsion in the glucopyranoside (0GA) at the
non-reducing end of the oligosaccharide.

The ordering and content within the internals list is important as well. For these examples, consider the simple

peptide sequence:

peptide = sequence { ALA ALA ALA ALA }

The ordering of the internals speciﬁes the atoms to which the torsion set is applied. The impose command will
ﬁnd the ﬁrst atom in the internals list, check for the presence of a bonded second atom, and so forth. It will then
apply the action, here a torsion, to those four atoms. For example, this command:

impose peptide { 3 } { { “N” “CA” “C” “N” -40.0 } }

# between 3 and 4

will set the torsion between residues 3 and 4. However, this one:

impose peptide { 3 } { { “N” “C” “CA” “N” -40.0 } }

# between 3 and 2

will set the torsion between residues 3 and 2.

If at any point, the impose command does not ﬁnd an atom bonded to a previous atom in an internals list, it will
silently ignore the command. This is likely to occur in two instances. One, the atom simply might not exist in the
residue:

impose peptide { 3 } { { “N” “CA” “CB” “HB4” 10.0 } }

# no effect, silent

Here, of course, there is no atom named HB4 in alanine. Similarly, improper torsions are ignored. For example,
this command also has no effect:

impose peptide { 3 } { { “N” “HB1” “CA” “CB” 10.0 } }

# no effect, silent

because HB1 is not bonded to N.

Three types of conformational change are supported: Bond length changes, bond angle changes, and torsion
angle changes. If the conformational change involves a torsion angle, then all dihedrals around the central pair of
atoms are rotated. The entire list of internals is applied to each RESIDUE.

It is also important to note that the impose command performs its actions entirely using internal coordinates.
Because of this, it is difﬁcult to predict the resulting behavior when the coordinates are translated back to cartesian,
for example when writing a PDB ﬁle.

231

13. LEaP

13.6.22. list

List all of the variables currently deﬁned. To illustrate, the following (edited) output shows the variables

deﬁned when LEaP is started from the leaprc ﬁle included in the distribution:

> list A ACE ALA ARG ASN : : VAL W WAT Y

13.6.23. loadAmberParams

variable = loadAmberParams filename

Load an AMBER format parameter set ﬁle and place it in variable. All interactions deﬁned in the parameter set
will be contained within variable. This command causes the loaded parameter set to be included in LEaP’s list of
parameter sets that are searched when parameters are required. General proper and improper torsion parameters
are modiﬁed during the command execution with the LEaP general type “?” replacing the AMBER general type
“X”

> parm91 = loadAmberParams parm91X.dat
> saveOff parm91 parm91.lib

13.6.24. loadAmberPrep

loadAmberPrep filename [ prefix ]

This command loads an AMBER PREP input ﬁle. For each residue that is loaded, a new UNIT is constructed that
contains a single RESIDUE and a variable is created with the same name as the name of the residue within the
PREP ﬁle. If the optional argument preﬁx (a STRING) is provided, its contents will be preﬁxed to each variable
name; this feature is used to preﬁx UATOM residues, which have the same names as AATOM residues with the
string “U” to distinguish them.

> loadAmberPrep cra.in
Loaded UNIT: CRA

13.6.25. loadOff

loadOff filename

This command loads the OFF library within the ﬁle named ﬁlename. All UNITs and PARMSETs within the
library will be loaded. The objects are loaded into LEaP under the variable names the objects had when they were
saved. Variables already in existence that have the same names as the objects being loaded will be overwritten.
Any PARMSETs loaded using this command are included in LEaP’s library of PARMSETs that is searched
whenever parameters are required (the old AMBER format is used for PARMSETs rather than the OFF format in
the default conﬁguration). Example command line:

> loadOff parm91.lib
Loading library: parm91.lib
Loading: PARAMETERS

13.6.26. loadMol2

variable = loadMol2 filename

Load a Sybyl MOL2 format ﬁle into variable, a UNIT. This command is very much like loadOff, except that it
only creates a single UNIT.

232

13.6. Commands

13.6.27. loadPdb

variable = loadPdb filename

Load a Protein Data Bank (PDB) format ﬁle with the ﬁle name ﬁlename into variable, a UNIT. The sequence
numbers of the RESIDUEs will be determined from the order of residues within the PDB ﬁle ATOM records.
This function will search the variables currently deﬁned within LEaP for variable names that map to residue
names within the ATOM records of the PDB ﬁle. If a matching variable name is found then the contents of the
variable are added to the UNIT that will contain the structure being loaded from the PDB ﬁle. Adding the
contents of the matching UNIT into the UNIT being constructed means that the contents of the matching UNIT
are copied into the UNIT being built and that a bond is created between the connect0 ATOM of the matching
UNIT and the connect1 ATOM of the UNIT being built. The UNITs are combined in the same way UNITs are
combined using the sequence command. As atoms are read from the ATOM records their coordinates are written
into the correspondingly named ATOMs within the UNIT being built. If the entire residue is read and it is found
that ATOM coordinates are missing, then external coordinates are built from the internal coordinates that were
deﬁned in the matching UNIT. This allows LEaP to build coordinates for hydrogens and lone-pairs which are not
speciﬁed in PDB ﬁles.

> crambin = loadPdb 1crn

13.6.28. loadPdbUsingSeq

loadPdbUsingSeq filename unitlist

This command reads a PDB format ﬁle named ﬁlename. This command is identical to loadPdb except it does not
use the residue names within the PDB ﬁle. Instead, the sequence is deﬁned by the user in unitlist. For more
details see loadPdb.

> peptSeq = { UALA UASN UILE UVAL UGLY }
> pept = loadPdbUsingSeq pept.pdb peptSeq

In the above example, a variable is ﬁrst deﬁned as a LIST of united atom RESIDUEs. A PDB ﬁle is then loaded,
in this sequence order, from the ﬁle “pept.pdb”.

13.6.29. logFile

logFile filename

This command opens the ﬁle with the ﬁle name ﬁlename as a log ﬁle. User input and all output is written to the
log ﬁle. Output is written to the log ﬁle as if the verbosity level were set to 2. An example of this command is

> logfile /disk/howard/leapTrpSolvate.log

13.6.30. measureGeom

measureGeom atom1 atom2 [ atom3 [ atom4 ] ]

Measure the distance, angle, or torsion between two, three, or four ATOMs, respectively.

In the following example, we ﬁrst describe the RESIDUE ALA of the ALA UNIT in order to ﬁnd the identity
of the ATOMs. Next, the measureGeom command is used to determine a distance (determining simple angles and
dihedral angles are straightforward extensions). As shown in the example, the ATOMs may be identiﬁed using
atom names or numbers.
> desc ALA.ALA
RESIDUE name: ALA
RESIDUE sequence number: 1
Type: protein ....
> measureGeom ALA.ALA.3 ALA.ALA.CB
Distance: 1.52 angstroms

233

13. LEaP

13.6.31. quit

Quit the LEaP program.

13.6.32. remove

remove a b

Remove the object b from the object a. If a does not contain b, an error message will be displayed. This
command is used to remove ATOMs from RESIDUEs, and RESIDUEs from UNITs. If the object represented by
b is not referenced by any other variable name, it will be destroyed.

> dipeptide = combine { ALA GLY }
Sequence: ALA
Sequence: GLY
> desc dipeptide
UNIT name: ALA !! bug: this should be dipeptide!
Head atom: .R<ALA 1>.A<N 1>
Tail atom: .R<GLY 2>.A<C 6>
Contents: R<ALA 1> R<GLY 2>
> remove dipeptide dipeptide.2
> desc dipeptide UNIT name: ALA !! bug: this should be dipeptide!
Head atom: .R<ALA 1>.A<N 1>
Tail atom: null
Contents: R<ALA 1>

13.6.33. saveAmberParm

saveAmberParm unit topologyfilename coordinatefilename

Save the Amber/NAB topology and coordinate ﬁles for unit into the ﬁles named topologyﬁlename and coordinate-
ﬁlename respectively. This command will cause LEaP to search its list of PARMSETs for parameters deﬁning all
of the interactions between the ATOMs within unit. It produces topology ﬁles and coordinate ﬁles that are identical
in format to those produced by Amber PARM and can be read into Amber and NAB for calculations. The output
of this operation can be used for minimizations, dynamics, and thermodynamic perturbation calculations.

In the following example, the topology and coordinates from the all_amino94.lib UNIT ALA are generated:

> saveamberparm ALA ala.top ala.crd

13.6.34. saveMol2

saveMol2 unit filename type-flag

Write unit to the ﬁle ﬁlename as a Tripos mol2 format ﬁle. If type-ﬂag is 0, the Tripos (Sybyl) atom types will
be used; if type-ﬂag is 1, the Amber atom types present in unit will be used. Generally, you would want to set
type-ﬂag to 1, unless you need the Sybyl atom types for use in some program outside Amber; Amber itself has no
force ﬁelds that use Sybyl atom types.

13.6.35. saveOff

saveOff object filename

The saveOff command allows the user to save UNITs and PARMSETs to a ﬁle named ﬁlename. The ﬁle is written
using the Object File Format (off) and can accommodate an unlimited number of uniquely named objects. The
names by which the objects are stored are the variable names speciﬁed within the object argument. If the ﬁle

234

ﬁlename already exists, the new objects will be added to it. If there are objects within the ﬁle with the same names
as objects being saved then the old objects will be overwritten. The argument object can be a single UNIT, a single
PARMSET, or a LIST of mixed UNITs and PARMSETs. (See the add command for an example of the saveOff
command.)

13.6. Commands

13.6.36. savePdb

savePdb unit filename

Write unit to the ﬁle ﬁlename as a PDB format ﬁle. In the following example, the PDB ﬁle from the ALA unit is
generated:

> savepdb ALA ala.pdb

Warning: The PDB-like ﬁle created with this command is primarily useful for reading back into tLeap, or for
other Amber-related uses. It is consistent with Amber, but not with other aspects of the PDB standard (e.g. in atom
and residue names, etc.) Use the ambpdb program (see Section 31.1) if you need a ﬁle that more fully complies
with the PDB standard.

13.6.37. sequence

variable = sequence list

The sequence command is used to combine the contents of list, which should be a LIST of UNITs, into a new,
single UNIT. This new UNIT is constructed by taking each UNIT in list in turn and copying its contents into the
UNIT being constructed. As each new UNIT is copied, a bond is created between the tail ATOM of the UNIT
being constructed and the head ATOM of the UNIT being copied, if both connect ATOMs are deﬁned. If only one
is deﬁned, a warning is generated and no bond is created. If neither connection ATOM is deﬁned then no bond is
created. As each RESIDUE is copied into the UNIT being constructed it is assigned a sequence number which
represents the order the RESIDUEs are added. Sequence numbers are assigned to the RESIDUEs so as to
maintain the same order as was in the UNIT before it was copied into the UNIT being constructed. This
command builds reasonable starting coordinates for all ATOMs within the UNIT; it does this by assigning internal
coordinates to the linkages between the RESIDUEs and building the external coordinates from the internal
coordinates from the linkages and the internal coordinates that were deﬁned for the individual UNITs in the
sequence.

> tripeptide = sequence { ALA GLY PRO }

13.6.38. set

This command operates in two modes. In the ﬁrst, it sets default values for some parameters. In the second, it

sets speciﬁc properties to containers (for example, UNITs).

Defaults can be set in LEaP for the global parameters below with this usage:

set default parameter value

For example:

set default PBRadii mbondi

OldPrmtopFormat If set to “on”, the saveAmberParm command will write a prmtop ﬁle in the format used in
Amber 6 and earlier versions; if set to “off” (the default), it will use the new format. This is discouraged for
general use and is available mainly for backwards compatibility with programs that expect old-style topology
ﬁles or for testing.

235

13. LEaP

Dielectric If set to “distance” (the default), electrostatic calculations in LEaP will use a distance-dependent di-

electric; if set to “constant”, a constant dielectric will be used.

PdbWriteCharges If set to “on”, atomic charges will be placed in the “B-factor” ﬁeld of PDB ﬁles saved with the

savePdb command; if set to “off” (the default), no such charges will be written.

PBRadii Used to choose various sets of atomic radii for generalized Born or Poisson-Boltzmann calculations.
Options are: “bondi”, which gives values from Ref. [333], which should be used with igb = 7; “mbondi”,
which is the default, and the recommended parameter set for igb = 1 [198]; “mbondi2”, which is a second
modiﬁcation of the Bondi radii set [182], and should be used with igb = 2 or 5; “mbondi3”, which is a third
modiﬁcation of the Bondi radii set [25] recommended for use with igb = 8; and “amber6”, which is only to
be used for reproducing very early calculations that used igb = 1 [180].

nocenter If set to “on”, LEaP will not center the coordinates inside the box for a periodic simulation, but will
leave them unchanged (as it does for non-periodic simulations); if set to “off” (the default), centering of
coordinates will take place (as it always has, in previous versions of LEaP). Avoiding coordinate translations
can be useful to avoid changing reference (perhaps experimental) coordinates. This option may be especially
helpful for crystal simulations.

reorder_residues If set to “off” residues in the output will be left in the same order they were found in the input
ﬁle. The default behavior (“on”) is to place non-solvent residues ﬁrst, followed by solvent residues, followed
by solvent cap residues (if cap exists). “off” can, for example, be useful in crystal simulations (keep residues
belonging to each asymmetric unit separate), but note that turning residue ordering off is untested and may
lead to unforseen behavior. Only set to “off” if you know what you are doing!

The parameters listed below can be set for the speciﬁed containers within LEaP using the following syntax:

set container parameter object

Some examples:

set ATOM name "name"
set RESIDUE connect0 ATOM
my_system = loadPDB file.pdb
set my_system box {25 30 32}

For ATOMs:

name A unique STRING descriptor used to identify ATOMs.

type This is a STRING property that deﬁnes the AMBER force ﬁeld atom type.

charge The charge property is a NUMBER that represents the ATOM’s electrostatic point charge to be used in a

molecular mechanics force ﬁeld.

position This property is a LIST of NUMBERs containing three values: the (X, Y, Z) Cartesian coordinates of

the ATOM.

pertName This STRING is a unique identiﬁer for an ATOM in its ﬁnal state during a Free Energy Perturbation

calculation. This functionality is no longer implemented in Amber.

pertType This STRING is the AMBER force ﬁeld atom type of a perturbed ATOM. This functionality is no longer

implemented in Amber.

pertCharge This NUMBER represents the ﬁnal electrostatic point charge on an ATOM during a Free Energy

Perturbation. This function is no longer implemented in Amber.

For RESIDUEs:

236

13.6. Commands

connect0 This identiﬁes the ﬁrst of up to three ATOMs that will be used to make links to other RESIDUEs. In
a UNIT containing a single RESIDUE, the RESIDUE’s connect0 ATOM is usually deﬁned as the UNIT’s
head ATOM.

connect1 This identiﬁes the second of up to three ATOMs that will be used to make links to other RESIDUEs. In
a UNIT containing a single RESIDUE, the RESIDUE’s connect1 ATOM is usually deﬁned as the UNIT’s
tail ATOM.

connect2 This identiﬁes the third of up to three ATOMs that will be used to make links to other RESIDUEs. In

amino acids, the convention is that this is the ATOM to which disulﬁde bridges are made.

restype This property is a STRING that represents the type of the RESIDUE. Currently, it can have one of the

following values: “undeﬁned”, “solvent”, “protein”, “nucleic”, or “saccharide”.

name This STRING property is the RESIDUE name.

For UNITs:

head Deﬁnes the ATOM within the UNIT that is connected when UNITs are joined together: the tail ATOM of

one UNIT is connected to the head ATOM of the subsequent UNIT in any sequence.

tail Deﬁnes the ATOM within the UNIT that is connected when UNITs are joined together: the tail ATOM of one

UNIT is connected to the head ATOM of the subsequent UNIT in any sequence.

box This property deﬁnes the bounding box of the UNIT (container). If object is set to null then no bounding box
is deﬁned. If it is a single NUMBER, the bounding box will be deﬁned to be a cube with each side being
NUMBER Å across. If it is a LIST, it must contain three NUMBERs, the lengths (in Å) of the three sides of
the bounding box. Note that this command does not allow one to set the angles for the periodic system. See
the ChBox command to do that.

cap This property deﬁnes the solvent cap of the UNIT. If it is set to null then no solvent cap is deﬁned. Otherwise,
it should be a LIST of four NUMBERs; the ﬁrst three NUMBERs deﬁne the Cartesian coordinates (X, Y, Z)
of the origin of the solvent cap in Å, while the fourth deﬁnes the radius of the solvent cap, also in Å.

13.6.39. setBox

setBox solute enclosure [ distance ]

This command creates a periodic box around solute, which should be a UNIT. It does not add any solvent to the
system. setBox creates a cuboid box. The enclosure parameter determines whether the box encloses entire atoms
or just atom centers. The former case is speciﬁed by the STRING value "vdw" for enclosure and the latter case by
the STRING "centers". Use "centers" if the system has been previously equilibrated as a periodic box. The
minimum distance between any atom in solute and the edge of the periodic box is given by the distance
parameter; see the solvateBox command for more details.

> mol = loadpdb my.pdb
> setBox mol "vdw"

13.6.40. solvateBox and solvateOct

solvateBox solute solvent distance [ "iso" ] [ closeness ]
solvateOct solute solvent distance [ "iso" ] [ closeness ]

These two commands create periodic solvent boxes around solute, which should be a UNIT. solvateBox creates
a cuboid box, while solvateOct creates a truncated octahedron. solute is modiﬁed by the addition of copies of
the RESIDUEs found within solvent, which should also be a UNIT, such that the minimum distance between any

237

13. LEaP

atom originally present in solute and the edge of the periodic box is given by the distance parameter. The resulting
solvent box will be repeated in all three spatial directions.

If the distance parameter is a single NUMBER then the minimum distance is the same for the x, y, and z
directions, unless the STRING "iso" parameter is speciﬁed to make the box or truncated octahedron isometric. For
solvateBox if "iso" is used, the solute is rotated to orient the principal axes, otherwise it is just centered on the
origin. For solvateOct if the "iso" option is used, the isometric truncated octahedron is rotated to an orientation
used by the PME code, and the box and angle dimensions output by the saveAmberParm* commands are adjusted
for PME code imaging.In solvateBox, if the distance parameter is a LIST of three NUMBERS then the NUMBERs
are applied to the x, y, and z axes respectively. As the larger box is created and superimposed on the solute, solvent
molecules overlapping the solute are removed.In solvateOct, when a LIST is given for the distance parameter, four
numbers are given instead of three, where the fourth is the diagonal clearance. If 0.0 is given as the fourth number,
the diagonal clearance resulting from the application of the x,y,z clearances is reported. If a non-0 value is given,
this may require scaling up the other clearances, which is also reported. Similarly, if a single NUMBER is given,
any scaleup of the x,y,z buffer to accommodate the diagonal clip is reported.

The optional closeness parameter can be used to control how close, in Å, solvent ATOMs may come to solute

ATOMs. The default value of closeness is 1.0. Smaller values allow solvent ATOMs to come closer to solute
ATOMs. The criterion for rejection of overlapping solvent RESIDUEs is if the distance between any solvent
ATOM and its nearest solute ATOM is less than the sum of the two ATOMs’ van der Waals radii multiplied by
closeness.

> mol = loadpdb my.pdb
> solvateOct mol TIP3PBOX 12.0 0.75

13.6.41. solvateCap

solvateCap solute solvent position radius [ closeness ]

The solvateCap command creates a solvent cap around solute, which is a UNIT. solute is modiﬁed by the addition
of copies of the RESIDUEs found within solvent, which should also be a UNIT. The solvent box will be repeated
in all three spatial directions to create a large solvent sphere with a radius of radius Å.

The position argument deﬁnes where the center of the solvent cap is to be placed. If position is a UNIT, a
RESIDUE, an ATOM, or a LIST of UNITs, RESIDUEs, or ATOMs, then the geometric center of the ATOM or
ATOMs within the object will be used as the center of the solvent cap sphere. If position is a LIST containing three
NUMBERs, then it will be treated as a vector describing the position of the solvent cap sphere center.

The optional closeness parameter can be used to control how close, in Å, solvent ATOMs may come to solute
ATOMs. The default value of closeness is 1.0. Smaller values allow solvent ATOMs to come closer to solute
ATOMs. The criterion for rejection of overlapping solvent RESIDUEs is if the distance between any solvent
ATOM and its nearest solute ATOM is less than the sum of the two ATOMs’ van der Waals radii multiplied by
closeness.

This command modiﬁes solute in several ways. First, the UNIT is modiﬁed by the addition of solvent

RESIDUEs copied from solvent. Secondly, the “cap” parameter of solute is modiﬁed to reﬂect the fact that a
solvent cap has been created around the solute.

> mol = loadpdb my.pdb
> solvateCap mol TIP3PBOX mol.2.CA 12.0 0.75

13.6.42. solvateShell

solvateShell solute solvent thickness [ closeness ]

The solvateShell command adds a solvent shell to solute, which should be a UNIT. solute is modiﬁed by the
addition of copies of the RESIDUEs found within solvent, which should also be a UNIT. The resulting
solute/solvent UNIT will be irregular in shape since it will reﬂect the contours of the original solute molecule.
The solvent box will be repeated in three directions to create a large solvent box that can contain the entire solute

238

and a shell thickness Å thick. Solvent RESIDUEs are then added to solute if they lie within the shell deﬁned by
thickness and do not overlap with any ATOM originally present in solute. The optional closeness parameter can
be used to control how close solvent ATOMs can come to solute ATOMs. The default value of the closeness
argument is 1.0. Please see the solvateBox command for more details on the closeness parameter.

13.6. Commands

> mol = loadpdb my.pdb
> solvateShell mol TIP3PBOX 12.0 0.8

13.6.43. source

source filename

This command executes the contents of the ﬁle given by ﬁlename, treating them as LEaP commands. To display
the commands as they are read, see the verbosity command.

13.6.44. transform

transform atoms, matrix

Transform all of the ATOMs within atoms by a symmetry operation. The symmetry operation is represented as a
(3 × 3) or (4 × 4) matrix, and given as nine or sixteen NUMBERs in matrix, a LIST of LISTs. The general matrix
looks like:

r11 r12 r13 -tx r21 r22 r23 -ty r31 r32 r33 -tz 0 0 0 1
The matrix elements represent the intended symmetry operation. For example, a reﬂection in the (x,y) plane

would be produced by the matrix:

1 0 0 0 1 0 0 0 -1

This reﬂection could be combined with a 6 Å translation along the x-axis by using the following matrix:

1 0 0 6 0 1 0 0 0 0 -1 0 0 0 0 1

In the following example, wrB is transformed by an inversion operation:

transform wrpB { { -1 0 0 } { 0 -1 0 } { 0 0 -1 } }

13.6.45. translate

translate atoms direction

Translate all of the ATOMs within atoms by the vector given by direction, a LIST of three NUMBERs.

Example:

translate wrpB { 0 0 -24.53333 }

13.6.46. verbosity

verbosity level

This command sets the level of output that LEaP provides the user. A value of 0 is the default, providing the
minimum of messages. A value of 1 will produce more output, and a value of 2 will produce all of the output of
level 1 and display the text of the script lines executed with the source command. The following line is an
example of this command:

> verbosity 2
Verbosity level: 2

239

13. LEaP

13.6.47. zMatrix

zMatrix object zmatrix

The zMatrix command is quite complicated. It is used to deﬁne the external coordinates of ATOMs within object
using internal coordinates. The second parameter of the zMatrix command is a LIST of LISTs; each sub-list has
several arguments:

{ a1 a2 bond12 }

This entry deﬁnes the coordinate of a1, an ATOM, by placing it bond12 Å along the x-axis from ATOM a2. a2 is
placed at the origin if its coordinates are not deﬁned.

{ a1 a2 a3 bond12 angle123 }

This entry deﬁnes the coordinate of a1 by placing it bond12 Å away from a2 making an angle of angle123
degrees between a1, a2 and a3. The angle is measured in a right-hand sense and in the xy plane. ATOMs a2 and
a3 must have coordinates deﬁned.

{ a1 a2 a3 a4 bond12 angle123 torsion1234 }

This entry deﬁnes the coordinate of a1 by placing it bond12 Å away from a2, creating an angle of angle123
degrees between a1, a2, and a3, and making a torsion angle of torsion1234 degrees between a1, a2, a3, and a4.

{ a1 a2 a3 a4 bond12 angle123 angle124 orientation }

This entry deﬁnes the coordinate of a1 by placing it bond12 Å away from a2, and making angles angle123 degrees
between a1, a2, and a3, and angle124 degrees between a1, a2, and a4. The argument orientation deﬁnes whether
a1 is above or below a plane deﬁned by a2, a3 and a4. If orientation is positive, a1 will be placed so that the triple
product ((a3−a2) × (a4−a2)) · (a1−a2) is positive. Otherwise, a1 will be placed on the other side of the plane. This
allows the coordinates of a molecule like ﬂuoro-chloro-bromo-methane to be deﬁned without having to resort to
dummy atoms.

The ﬁrst arguments within the zMatrix entries (a1, a2, a3 and a4) are either ATOMs, or STRINGs containing
names of ATOMs that already exist within object. The subsequent arguments (bond12, angle123, torsion1234 or
angle124, and orientation) are all NUMBERs. Any ATOM can be placed at the a1 position, even one that has
coordinates deﬁned. This feature can be used to provide an endless supply of dummy atoms, if they are required.
A predeﬁned dummy atom with the name “*” (a single asterisk, no quotes) can also be used.

There is no order imposed in the sub-lists. The user can place sub-lists in arbitrary order, as long as they
maintain the requirement that all ATOMs a2, a3, and a4 must have external coordinates deﬁned, except for entries
that deﬁne the coordinate of an ATOM using only a bond length. (See the add command for an example of the
zMatrix command.)

13.7. Building oligosaccharides, lipids and glycoproteins

Build assistance available at GLYCAM-Web:
The approaches presented below have been automated, with many additional options available, at the

GLYCAM-Web site: www.glycam.org. The capabilities of the website are being expanded. Currently, the
available functionalities include:

Oligosaccharides, linear and branched
Glycoproteins, O- or N-linked, with multiple glycans
Builds of oligosaccharides via URL directive

Build assistance available in the AmberTools tests:
Examples in addition to those described below can be found in the AmberTools tests. The relevant ﬁles are

located in:

240

13.7. Building oligosaccharides, lipids and glycoproteins

Figure 13.1.: Schematic representation of disaccharide formation, indicating the need for open valences on carbon

and oxygen atoms at linkage positions.

$AMBERHOME/AmberTools/test/leap/glycam # main test directory
$AMBERHOME/AmberTools/test/leap/glycam/06EPb # extra points oligosaccharides
$AMBERHOME/AmberTools/test/leap/glycam/06j # main oligosaccharides
$AMBERHOME/AmberTools/test/leap/glycam/06j_10 # glycoprotein with ff10
$AMBERHOME/AmberTools/test/leap/glycam/06j_12SB # glycoprotein with ff12SB

PLEASE NOTE: The molecules in the test directories were constructed for the purpose of testing functionality in
AmberTools. They might not be ready for simulations as they are. Some might be in conﬁgurations with severe
clashes. Most structural issues can be resolved by manipulating appropriate torsions. The glycoprotein tests
contain usage examples for torsion manipulations using the impose command.

Each sub-directory below "glycam" contains tests relevant to speciﬁc force ﬁelds. To run an individual test,

saving all relevant output and intermediate ﬁles, change to the sub-directory and issue the command:

./Run.glycam evaluate

To return the directory to its previous state, run:

./Run.glycam clean

The 00_README ﬁle in the main directory contains more information about using the tests.

Additional notes about this section:

Before continuing in this section, you should review the GLYCAM naming conventions covered in Section 3.3.
After that, there are two important things to keep in mind. The ﬁrst is that GLYCAM is designed to build oligosac-
charides, not just monosaccharides. In order to link the monosaccharides together, each residue in GLYCAM will
have at least one open valence position. That is, each GLYCAM residue lacks either a hydroxyl group or a hy-
droxyl proton, and may be lacking more than one proton depending on the number of branching locations. Thus,
none of the residues is a complete molecule unto itself. For example, if you wish to build α-D-glucopyranose, you
must explicitly specify the anomeric -OH group (see Figure 13.1 for two examples).

The second thing to keep in mind is that when the sequence command is used in LEaP to link

monosaccharides together to form a linear oligosaccharide (analogous to peptide generation), the residue ordering
is opposite to the standard convention for writing the sequence. For example, to build the disaccharides illustrated
in Figure 13.1, using the sequence command in LEaP, the format would be:

upperdisacc = sequence { ROH 3GB 0GB }
lowerdisacc = sequence { OME 4GB 0GA }

241

OHOH2CHOHOOHHOHOH2CHOOOHH0GB3GBOH++OHOH2CHOHOOHHOHOH2CHOOOHHOHROHOHOH2CHOHOOHOHOH2COHOOHH0GA4GBOCH3++OMEHOHOH2CHOHOOHHOHOH2COHOOHHOCH313. LEaP

While the sequence command is the most direct method to build a linear glycan, it is not the only method. Alter-
natives that facilitate building more complex glycans and glycoproteins are presented below. For those who need
to build structures (and generate topology and coordinate ﬁles) that are more complex, a convenient interface that
uses GLYCAM is available on the internet (http://glycam.ccrc.uga.edu or http://www.glycam.org).
Throughout this section, sequences of LEaP commands will be entered in the following format:

command argument(s) # descriptive comment

This format was chosen so that the lines can be copied directly into a ﬁle to be read into LEaP. The number sign
(#) signiﬁes a comment. Comments following commands may be left in place for future reference and will be
ignored by LEaP. Files may be read into LEaP either by sourcing the ﬁle or by specifying it on the command line
at the time that LEaP is invoked, e.g.:

tleap -f leap_input_file

Note that any GLYCAM parameter set shipped with Amber is likely to be updated in the future. The cur-
rent version is GLYCAM_06j.dat. This ﬁle and GLYCAM_06j-1.prep are automatically loaded with the default
leaprc.GLYCAM_06j-1. The user is encouraged to check www.glycam.org for updated versions of these ﬁles.

13.7.1. Procedures for building oligosaccharides using the GLYCAM-06 parameters

13.7.1.1. Example: Linear oligosaccharides

This section contains instructions for building a simple, straight-chain tetrasaccharide:

α-D-Manp-(1-3)-β -D-Manp-(1-4)-β -D-GlcpNAc-(1-4)-β -D-GlcpNAc-OH

First, it is necessary to determine the GLYCAM residues that will be used to build it. Since the initial α-D-Manp
residue links only at its anomeric site, the ﬁrst character in its name is 0 (zero), indicating that it has no branches
or other connections, i.e., it is terminal. Since it is a D-mannose, the second character, the one-letter code, is M
(capital). Since it is an α-pyranose, the third character is A. Therefore, the ﬁrst residue in the sequence above is
0MA. Since the second residue links at its 3-position as well as at the anomeric position, the ﬁrst character in its
name is 3, and, being a β -pyranose, it is 3MB. Similarly, residues three and four are both 4YB. It will also be
necessary to add an OH residue at the end to generate a complete molecule. Note that in Section 13.7.3, below,
the terminal OH must be omitted in order to allow subsequent linking to a protein or lipid. Note also that when
present, a terminal OH (or OME etc) is assigned its own residue number.

Converting the order for use with the sequence command in LEaP, gives:

Residue name sequence: ROH 4YB 4YB 3MB 0MA
Residue number:

1

2

3

4

5

Here is a set of LEaP instructions that will build the sequence (there are, of course, other ways to do this):

source leaprc.GLYCAM_06j-1 # load leaprc
glycan = sequence { ROH 4YB 4YB 3MB 0MA } # build oligosaccharide

Using the sequence command, the φ angles are automatically set to the orientation that is expected on the basis
of the exo-anomeric effect (± 60°). If you wish to change the torsion angle between two residues, the impose
command may be used. In the following example, the ψ angles between the two 4YB residues and between the
4YB and the 3MB are being set to the standard value of zero.

impose glycan {3} { {C1 O4 C4 H4 0.0} } # set psi between 4YB (3) & 4YB (2)
impose glycan {4} { {C1 O4 C4 H4 0.0} } # set psi between 3MB (4) & 4YB (3)

You may now generate coordinate, topology and PDB ﬁles, for example:

saveamberparm glycan glycan.top glycan.crd # save top & crd
savepdb glycan glycan.pdb # save pdb file

242

13.7. Building oligosaccharides, lipids and glycoproteins

13.7.1.2. Example: Branched oligosaccharides

This section contains instructions for building a simple branched oligosaccharide. The example used here builds
on the previous one. Again, it will be assumed that the carbohydrate is not destined to be linked to a protein or a
lipid. If it were, one should omit the ROH residue from the structure. The branched oligosaccharide is

α-D-Manp-(1–3)-β -D-Manp-(1–4)-β -D-GlcpNAc-(1–4)-β -D-GlcpNAc-OH

6
|
α-D-Manp-1

Note that the β -D-mannopyranose is now branched at the 3- and 6-positions. Consulting Tables 3.5 to 3.8
informs us that the ﬁrst character assigned to a carbohydrate linked at the 3- and 6-positions is V. Thus, the name
of the residue called 3MB in the previous section must change to VMB.

Thus, when rewritten for LEaP this glycan becomes:

Residue name sequence: ROH 4YB 4YB VMB 0MA 0MA
Residue number:

1

2

3

4

5

6

To ensure that the correct residues are linked at the 3- and 6-positions in VMB, it is safest to specify these
linkages explicitly in LEaP. In the current example, the two terminal residues are the same (0MA), but that need
not be the case.

source leaprc.GLYCAM_06j-1 # load leaprc
glycan = sequence { ROH 4YB 4YB VMB } # linear sequence to branch

The longest linear sequence is built ﬁrst, ending at the branch point “VMB” in order to explicitly specify
subsequent linkages. The following commands will place a terminal, 0MA residue at the number three position:

set glycan tail glycan.4.O3 # set attachment point to the O3 in VMB
glycan = sequence { glycan 0MA } # add one of the 0MA’s

The following commands will link the other 0MA to the 6-position. Note that the name of the molecule changes
from “glycan” to “branch”. This change is not necessary, but makes such command sequences easier to read,
particularly with complex structures.

set glycan tail glycan.4.O6 # set attachment point to the O6 in VMB
branch = sequence { glycan 0MA } # add the other 0MA

It can be especially important to reset torsion angles when building branched oligosaccharides. The following set
of commands cleans up the geometry considerably and then generates a set of output ﬁles:

impose branch {4} { {H1 C1 O6 C6 -60.0} } # set phi torsion and
impose branch {4} { {C1 O6 C6 H6 0.0} } # set psi 0MA(6) & VMB
impose branch {4} { {H1 C1 O4 C4 60.0} } # set phi torsion and
impose branch {4} { {C1 O4 C4 H4 0.0} } # set psi 3MB & 4YB
impose branch {3} { {H1 C1 O4 C4 60.0} } # set phi torsion and
impose branch {3} { {C1 O4 C4 H4 0.0} } # set psi 4YB & 4YB
impose branch {5} { {H1 C1 O3 C3 -60.0} } # set phi torsion and
impose branch {5} { {C1 O3 C3 H3 0.0} } # set psi 0MA(3) & VMB
saveamberparm branch branch.top branch.crd # save top & crd
savepdb branch branch.pdb # save pdb

13.7.1.3. Example: Complex branched oligosaccharides

The following example builds a highly branched, high-mannose structure shown in Figure 13.2 . In this example,
it is especially important to note that when the branching is ambiguous, LEaP might not choose the attachment

243

13. LEaP

Figure 13.2.: Structure of Man-9, represented in the symbolic notation used by the Consortium for Functional

Glycomics. Here, =D-Manp and =D-GlcpNAc

point one wants or expects. For this reason, connectivity should be speciﬁed explicitly whenever the structure
branches. That is, one cannot specify the longest linear sequence and add branches later. The sequence command
must be interrupted at each branch point. Otherwise, the connectivity is not assured. In this example, a branch
occurs at each VMA (-3,6-D-Manp ) residue.

The following set of commands, given to tleap, will safely produce the structure represented in Figure13.2.



source leaprc.GLYCAM_06j-1
glycan = sequence { ROH 4YB 4YB VMB }
set glycan tail glycan.4.O6
glycan=sequence { glycan VMA }
set glycan tail glycan.5.O6
glycan=sequence { glycan 2MA 0MA }
set glycan tail glycan.5.O3
glycan=sequence { glycan 2MA 0MA }
set glycan tail glycan.4.O3
glycan=sequence { glycan 2MA 2MA 0MA }
impose glycan {3} { {H1 C1 O4 C4 60.0} }
impose glycan {3} { {C1 O4 C4 H4 0.0} }
impose glycan {4} { {H1 C1 O4 C4 60.0} }
impose glycan {4} { {C1 O4 C4 H4 0.0} }
impose glycan {5} { {H1 C1 O6 C6 -60.0} } # 1-6 Link from (5) to (4), Phi
impose glycan {5} { {C1 O6 C6 C5 180.0} } # 1-6 Link from (5) to (4), Psi
impose glycan {4} { {O6 C6 C5 O5 60.0} } # 1-6 Link from (5) to (4), Chi
impose glycan {10} { {H1 C1 O3 C3 -60.0} }
impose glycan {10} { {C1 O3 C3 H3 0.0} }
impose glycan {6} { {H1 C1 O6 C6 -60.0} }
impose glycan {6} { {C1 O6 C6 C5 180.0} }
impose glycan {5} { {O6 C6 C5 O5 -60.0} }
impose glycan {8} { {H1 C1 O3 C3 -60.0} }
impose glycan {8} { {C1 O3 C3 H3 0.0} }
impose glycan {7} { {H1 C1 O2 C2 -60.0} }
impose glycan {7} { {C1 O2 C2 H2 0.0} }
impose glycan {9} { {H1 C1 O2 C2 -60.0} }
impose glycan {9} { {C1 O2 C2 H2 0.0} }
impose glycan {11} { {H1 C1 O2 C2 -60.0} }
impose glycan {11} { {C1 O2 C2 H2 0.0} }
impose glycan {12} { {H1 C1 O2 C2 -60.0} }
impose glycan {12} { {C1 O2 C2 H2 0.0} }
saveamberparm glycan glycan.prmtop glycan.restrt



244





α2α2α2α3α2α6α6α3 β4  β4  β ΟΗ         13.7. Building oligosaccharides, lipids and glycoproteins

Figure 13.3.: DMPC

13.7.2. Procedures for building a lipid using GLYCAM-06 parameters

The procedure described here allows a user to produce a single lipid molecule without consideration for axial
alignment. Lipid bilayers are typically built in the (x,y) plane of a Cartesian coordinate system, which requires
the individual lipids to be aligned hydrophilic “head” to hydrophobic “tail” along the z-axis. This can be done
relatively easily by loading a template PDB ﬁle that has been appropriately aligned on the z-axis.

The lipid described in this example is 1,2-dimyristoyl-sn-glycero-3-phosphocholine or DMPC. For this example,
DMPC will be composed of four fragments: CHO, the choline “head” group; PGL, the phospho-glycerol “head”
group; MYR, the sn-1 chain myristic acid “tail” group; and MY2, the sn-2 chain myristic acid “tail” group. See
the molecular diagram in13.3 for atom labels (hydrogens and atomic charges are removed for clarity) and bonding
points between each residue (dashed lines). This tutorial will use only prep ﬁles for each of the four fragments.
These prep ﬁles were initially built as PDB ﬁles and formatted as prep ﬁles using antechamber. GLYCAM-
compatible charges were added to the prep ﬁles and a prep ﬁle database (GLYCAM_lipids_06h.prep) was created
containing all four ﬁles.

13.7.2.1. Example: Building a lipid with LEaP.

One need not load the main GLYCAM prep ﬁles in order to build a lipid using the GLYCAM-06 parameter set,
but it is automatically loaded with the default leaprc.GLYCAM_06j-1. Note that the lipid generated by this set of
commands is not necessarily aligned appropriately to create a bilayer along an axis. The commands to use are:





source leaprc.GLYCAM_06j-1 # source the leaprc for GLYCAM-06
loadamberprep GLYCAM_06_lipids.prep # load the lipid prep file
set CHO tail CHO.1.C5 # set the tail atom of CHO as C5.
set PGL head PGL.1.O1 # set the head atom of PGL to O1
set PGL tail PGL.1.C3 # set the tail atom of PGL to C3
lipid = sequence { CHO PGL MYR } # generate the straight-chain
# portion of the lipid
set lipid tail lipid.2.C2 # set the tail atom of PGL to C2
lipid = sequence { lipid MY2 } # add MY2 to the "lipid" unit
impose lipid {2} { {C1 C2 C3 O1 163} } # set torsions for
impose lipid {2} { {C2 C3 O1 C1 -180} } # PGL & MYR
impose lipid {2} { {C3 O1 C1 C2 180} }
impose lipid {2} { {O4 C1 C2 O1 -60} } # set torsions for
impose lipid {2} { {C1 C2 O1 C1 -180} } # PGL & MY2
impose lipid {2} { {C2 O1 C1 C2 180} }
# Note that the values here may not necessarily
# reflect the best choice of torsions.
savepdb lipid DMPC.pdb # save pdb file

245

O1C1C2C3C4C5C6C7C8C9C10O2C1C2C3C4C5C6C7C8C9C2C3O1O2C11C12C13C14C10C11C12C13C14C1O4PO2O3O1C5C4NC2C1C3MY2MYRCHOPGL13. LEaP



saveamberparm lipid DMPC.top DMPC.crd # save top and crd files



13.7.3. Procedures for building a glycoprotein in LEaP.

The LEaP commands given in this section assume that you already have a PDB ﬁle containing a glycan and
a protein in an appropriate relative conﬁguration. Thorough knowledge of the commands in LEaP is required in
order to successfully link any but the simplest glycans to the simplest proteins, and is beyond the scope of this
discussion. Several options for generating the relevant PDB ﬁle are given below (see Items 5a-5c).

The protein employed in this example is bovine ribonuclease A (PDBID: 3RN3). Here the branched oligosac-

charide assembled in the second example will be attached (N-linked) to ASN 34 to generate ribonuclease B.

13.7.3.1. Setting up protein pdb ﬁles for glycosylation in LEaP.

1. Delete any atoms with the “HETATM” card from the PDB ﬁle. These would typically include bound lig-
ands, non-crystallographic water molecules and non-coordinating metal ions. Delete any hydrogen atoms if
present.

2. In general, check the protein to make sure there are no duplicate atoms in the ﬁle. This can be quickly done
by loading the protein in LEaP and checking for such warnings. In this particular example, residue 119
(HIS) contained duplicate side chain atoms. Delete all but one set of duplicate atoms.

3. Check for the presence of disulﬁde bonds (SSBOND) by looking at the header section of the PDB ﬁle. 3RN3
has four disulﬁde bonds, between the following pairs of cysteine residues: 26—84, 40—95, 58—110, and
65—72. Change the names of these eight cysteine residues from CYS to CYX.

4. At present, it is possible to link glycans to serine, threonine, hydroxyproline and asparagine. You must re-
name the amino acid in the protein PDB ﬁle manually prior to loading it into LEaP. The modiﬁed residue
names are OLS (for O-linkages to SER), OLT (for O-linkages to THR), OLP (for O-linkages to hydrox-
yproline, HYP) and NLN (for N-linkages to ASN). Libraries containing amino acid residues that have been
modiﬁed for the purpose are automatically loaded when leaprc.GLYCAM_06j-1 is sourced. See the lists of
library ﬁles in3.3 for more information.

5. Prepare a PDB ﬁle containing the protein and the glycan, with the glycan correctly aligned relative to the

protein surface. There are several approaches to performing this including:

a) It is often the case that one or more glycan residues are present in the experimental PDB ﬁle. In this case,
a reasonable method is to superimpose the linking sugar residue in the GLYCAM-generated glycan
upon that present in the experimental PDB ﬁle, and to then save the altered coordinates. If you use this
method, remember to delete the experimental glycan from the PDB ﬁle! It is also essential to ensure
that each carbohydrate residue is separated from other residues by a TER card in the PDB ﬁle. Also
remember to delete the terminal OH or OMe from the glycan. Alternately, the experimental glycan may
be retained in the PDB ﬁle, provided that it is renamed according to the GLYCAM 3-letter code, and
that the atom names and order in the PDB ﬁle match the GLYCAM standard. This is tedious, but will
work. Again, be sure to insert TER cards if they are missing between the protein and the carbohydrate
and between the carbohydrate residues themselves.

b) Use a molecular modeling package to align the GLYCAM-generated glycan with the protein and save

the coordinates in a single ﬁle. Remember to delete the terminal OH or OMe from the glycan.

c) Use the Glycoprotein Builder tool at http://www.glycam.org. This tool allows the user to upload protein
coordinates, build a glycan (or select it from a library), and attach it to the protein. All necessary
AMBER ﬁles may then be downloaded. This site is also convenient for preprocessing protein-only
ﬁles for subsequent uploading to the glycoprotein builder.

246





13.7. Building oligosaccharides, lipids and glycoproteins

13.7.3.2. Example: Adding a branched glycan to 3RN3 (N-linked glycosylation).

In this example we will assume that the glycan generated above (“branch.pdb”) has been aligned relative to the
ASN 34 in the protein ﬁle and that the complex has been saved as a new PDB ﬁle (e.g., as “3rn3_nlink.pdb”). The
last amino acid residue should be VAL 124, and the glycan should be present as 4YB 125, 4YB 126, VMB 127,
OMA 128 and OMA 129.

Remember to change the name of ASN 34 from ASN to NLN. For the glycan structure, ensure that each residue
in the PDB ﬁle is separated by a “TER” card. The sequence command is not to be used here, and all linkages
(within the glycan and to the protein) will be speciﬁed individually.

Enter the following commands into xleap (or tleap if a graphical representation is not desired). Alternately, copy

the commands into a ﬁle to be sourced.



source leaprc.GLYCAM_06j-1 # load the GLYCAM-06 leaprc for ff14SB
source leaprc.protein.ff14SB # load the protein force field
glyprot = loadpdb 3rn3_nlink.pdb # load protein and glycan pdb file
bond glyprot.125.O4 glyprot.126.C1 # make inter glycan bonds
bond glyprot.126.O4 glyprot.127.C1
bond glyprot.127.O6 glyprot.128.C1
bond glyprot.127.O3 glyprot.129.C1
bond glyprot.34.SG glyprot.125.C1 # make glycan -- protein bond
bond glyprot.26.SG glyprot.84.SG # make disulfide bonds
bond glyprot.40.SG glyprot.95.SG
bond glyprot.58.SG glyprot.110.SG
bond glyprot.65.SG glyprot.72.SG
addions glyprot CL 0 # neutralize appropriately
solvateBox glyprot TIP3P BOX 8 # solvate the solute
savepdb glyprot 3nr3_glycan.pdb # save pdb file
saveamberparm glyprot 3nr3_glycan.top 3nr3_glycan.crd # save top, crd
quit # exit leap



13.7.4. Solvating a system with a speciﬁc number of molecules

Sometimes it is desirable to solvate a system with a target number of waters rather than specifying a particular

box size. The following script is a wrapper around LEaP which can be used for this purpose:

$AMBERHOME/AmberTools/src/etc/Solvate.sh

In addition to LEaP (really tleap), the script also makes use of cpptraj for determining molecule info.

13.7.4.1. Solvate.sh Usage

Solvate.sh <input_file>
Input File Options: (default)

target <#> Target # of waters to add.
buffer <buf> Initial buffer size (10.0).
bufx <buf> Initial buffer X size (mode 2|3 only, 10.0).
bufy <buf> Initial buffer Y size (mode 2|3 only, 10.0).
pdb <ﬁle> Solute PDB file name.
top <name> Output topology (solvated.parm7).
crd <name> Output coordinates (solvated.rst7).
leapin <ﬁle> LEaP input script for loading parameters etc.
ionsin <ﬁle> Optional LEaP input for loading ions etc (run after solvating).

247

13. LEaP

templeap <name> Name of temporary leap input script (temp.leap.in).
tol <#> Number of waters > target allowed, will be removed (2).
mode <#> Solvate mode: (0)- SolvateOct 1 - SolvateBox 2 - SolvateBoxXYZ (bufx

and bufy are scaled) 3 - SolvateBoxZ (bufx and bufy are fixed)

loadpdb {yes|no} If (yes), use ’loadpdb PDB’; otherwise <leapin> should set up

unit <molname>.

loadcmd <cmd> Command to load solute file; default ’loadpdb’.
soluteres <#> Number of solute residues.
molname <name> Solute molecule unit name (’m’).
solventunit <name> Solvent unit (TIP3PBOX). Recognized solvent units:

If blank try to guess from PDB.

TIP3PBOX

SPCBOX OPCBOX TIP4PEWBOX

First the ﬁle speciﬁed by leapin is read by LEaP, then the system is solvated, then the ﬁle speciﬁed by ’ionsin’ is
read in order to add ions etc.

13.7.4.2. Solvate.sh Example

Solvate an RNA tetranucleotide with 2500 TIP3P waters and 3 Na+ ions.
Input ﬁle: solvate.in

# Target number of waters
target 2500
# Initial guess for buffer
buffer 10
# Input PDB name
pdb rGACC.pdb
# Output topology name
top rGACC.tip3p.parm7
# Output coordinates name
crd rGACC.nomin.rst7
# Base leap input script
leapin leap.solvate.in
# Additional script for adding ions etc
ionsin leap.ions.in
# Tolerance (# of waters off from target allowed)
tol 3
# 0 - SolvateOct
mode 0

LEaP input: leap.solvate.in

source leaprc.RNA.OL3
set default pbradii mbondi2

LEaP Ions input: leap.ions.in

addions m Na+ 1
addions m Na+ 1
addions m Na+ 1

248

14. Reading and modifying Amber parameter ﬁles

This chapter describes the content of Amber parameter ﬁles, along with details about ParmEd (which can be
used to examine and modify prmtop ﬁles) and mdgx (which can be used to ﬁt force ﬁelds to quantum mechanical
and other target data).

14.1. Understanding Amber parameter ﬁles

Romain M. Wolf, Jason Swails, and David A. Case

This chapter provides a short description of Amber-compatible force ﬁeld parameter ﬁles is given. Only the
actual data in parameter (*.dat) ﬁles are discussed. The special issue of deriving partial charges is not addressed.
Also, more complex subjects dealing with parameters for implicit solvent (GB or PB) or polarisability computa-
tions are skipped. This text is meant as a documentation for users who want to understand parameter ﬁles, and in
some cases might be tempted to change or add some parameters. Most of the following documentation is found in
bits and pieces at various Amber-related sites and in tutorials or original Amber manuals and these various sources
have been helpful to put together this hopefully concise documentation.

14.1.1. Parameter Transfers between Force Fields

Transferring parameters from one force ﬁeld to another must respect the underlying functional form, the units in
which parameters are expressed in the parameter ﬁles, and also the exact procedures on how individual parameters
were obtained. In addition, attention must be paid to the methods used to deduce partial charges. Force ﬁelds
are self-consistent, i.e., all terms are interrelated and their actual values depend on the way they were derived.
Therefore, any parameter transfer between different force ﬁelds is dangerous, even when the functional form is the
same (or looks as if it were...).

Torsion terms are the most critical. Many torsion barriers and proﬁles are not easily assessed experimentally
and are often deduced from ab initio quantum mechanical (QM) computations on small fragments. Since QM
calculations offer many possibilities, the exact nature of these calculations (basis sets, Hartree-Fock and/or density
functionals, etc.) used to derive parameters should be known.

Special care must also be applied to 1-4 interactions, i.e., interactions between atoms separated by exactly three
consecutive bonds. Most Amber force ﬁelds for example assume that 1-4 interactions get a special treatment. See
section 14.1.6 for details. In many other force ﬁelds, the special treatment of 1-4 interactions is either different or
non-existent. This has an immediate inﬂuence on the torsion terms and resulting conformation energies. Therefore,
before transferring torsion terms, van der Waals parameters and partial charges from other force ﬁelds, check the
special treatment of 1-4 interactions in the source and the target force ﬁeld.

14.1.2. How Amber Routines Use the Parameter Files

Amber routines that perform actual calculations (sander, pmemd, etc...) do not read parameter ﬁles directly.
They use a special ﬁle type, the parameter-topology ﬁle (parmtop from now on), which contains all the information
required by the various energy functions in the computation routines. The parmtop ﬁle is speciﬁc to the molecular
system for which it was created and is directly related to the second required ﬁle, the coordinate ﬁle.1 Smallest
changes to the system (adding or removing atoms, or even changing the order of atoms in the coordinate ﬁle)
render the parmtop useless.

1This ﬁle can be in the Amber coordinate ’crd’ ﬁle format or, for some applications, also in PDB format.

249

14. Reading and modifying Amber parameter ﬁles

Although parmtop ﬁles are pure ASCII ﬁles, changing parameters directly in them by standard text editors is
strongly discouraged. In the worst case, computations will run without any warnings, but results might be totally
ﬂawed. The safest way to generate parmtop ﬁles is to use an Amber tool like tleap that has been used, tested, and
enhanced over a number of years and usually generates correct parmtop ﬁles, provided that the input is correct
and that all required information is available via fragment libraries and parameter ﬁles. The latest AmberTools
12.0 version (April 2012) includes the ParmEd python script of Jason Swails which is very useful to examine or
post-process parmtop ﬁles. However, only users with detailed knowledge on the exact format of parmtop ﬁles
should dare ﬁddling around with this data type.

14.1.3. "*.dat" and "frcmod.*" Files

The standard parameter ﬁles with the .dat extension are located in the folder $AMBERHOME/dat/leap/parm.
Adding or changing parameters directly in the parameter ﬁles delivered with an Amber distribution is not a good
idea for the following reasons: (a) you might mess up the parameter ﬁle, (b) you might have trouble to remember
and ﬁnd your changes later and add confusion when publishing results, (c) subsequent updates or patches might
overwrite your changes.

In the above mentioned folder, there are also various frcmod.* ﬁles. They have basically the same format as
the parameter *.dat ﬁles. See some of the examples provided in the Amber distributions. These ﬁles can be read
into tleap exactly like the standard *.dat ﬁles. They merge the default parameters in the *.dat ﬁle with the new
parameters in the frcmod.* ﬁles. More important, if the same parameters already exist in the *.dat ﬁles, the
parameters in the frcmod.* ﬁles overwrite the default *.dat parameters. This offers a handy way to add new or to
change original parameters without ever touching the default parameter ﬁles. Just make sure to read the respective
frcmod.* ﬁles in tleap when the new or altered parameters should be used.

14.1.4. Parameters Required for Amber Force Fields

The simplest form of the Amber force ﬁeld (neglecting implicit solvent or polarisation terms) uses the following

Hamiltonian:

bonds

Etotal = ∑
+ ∑
+ ∑
dihedrals
N−1
N
∑

angles

+

∑

kb(r− r0)2
kθ (θ − θ0)2
Vn[1 + cos(nφ − γ)]
(cid:34)

Ai j
R12
i j

− Bi j
R6
i j

+

qiq j
εRi j

i=1

j=i+1

(cid:35)

In this equation, the terms kb,r0,kθ ,θ0,Vn,γ,Ai j,Bi j are parameters to be speciﬁed in the parameter ﬁles men-
tioned in section 14.1.3 for the various Amber force ﬁelds.2 The meaning of these different parameters is outlined
in the following sections.

Equation 14.1 does not have a special term for out-of-plane motions. Amber routines handle these terms through

the same formulation as the torsion terms (see section 14.1.6).

Partial charges (qi,q j in equation 14.1), although parameters also, do not appear in parameter ﬁles, but are

assigned differently (see 14.1.7).

(14.1)

2Note that equation 14.1 does not use the (physically more correct) kb

2 , kθ

2 , and Vn

2 notations because it refers to the constants as they appear

in the actual parameter ﬁles.

250

14.1. Understanding Amber parameter ﬁles

14.1.5. Atom Types

Amber atom types can be one or two characters long. Uppercase (standard protein and nucleotide force ﬁelds),
lowercase (GAFF General Amber Force Field ), and mixed upper-lowercase (GLYCAM sugar force ﬁeld) are
allowed. Obviously, atom types must have a single, unique, deﬁnition.

If considering the deﬁnition a new atom type, think about the consequences. Of course, an atom type with an
identical name must not already exist in one of the standard force ﬁelds used in the Amber community. Depending
on how often and in how many combinations the atom type might occur, be also aware of the rather large number
of additional parameters that might be required. Especially for bond angles, this number can grow very rapidly.

A new atom type deﬁnition, if required, must be clear and precise. It should also be possible to treat the deﬁnition
in an automatic atom-type assignment procedure. Requiring users to visually verify and to change atom types by
hand will cause trouble and will make it impossible to use the force ﬁeld in automatic procedures that should not
require user intervention for this task.

14.1.6. Bonded Interaction Terms

Bond Stretching Terms

The ﬁrst row in equation 14.1 (page 250) is the harmonic term for bond stretching. In Amber-type parameter
ﬁles, the force constant kb is given for energy values in kcal/mol, with bond lengths in Å. The following line shows
an example from the GAFF force ﬁeld ﬁle gaff.dat.

The bond between a sp3 carbon (c3) and a hydroxyl oxygen (oh) has a default (equilibrium) value of 1.426 Å

and a force constant of 314.1 kcal/mol/Å2.

c3-oh 314.1 1.4260 SOURCE1 914 0.0129

The entrance in the parameter ﬁle starts with the deﬁnition of the bond (atomtype1 hyphen atomtype2), fol-
lowed by the force constant kb (in kcal/mol/Å2) and the equilibrium bond length r0 (in Å). Only the ﬁrst three
ﬁelds are relevant for computations. The other ﬁelds on the line above are mainly documentation.

As stated before, atom types in Amber FFs cannot have more than two characters. But if they have only one

character (e.g., a carbonyl carbon atom c), entries with a one-letter atom type must look like this:

c -oh 466.4 1.3060 SOURCE1 271 0.0041

i.e., the space is after the atom type, before the hyphen.

Starting with a space like on the next line might lead to problems.

c-oh 466.4 1.3060 SOURCE1 271 0.0041

This holds for all parameter ﬁle entries that use hyphens to separate atom types, i.e., also angle and torsion terms
(see following sections).

Angle Bending Terms

Angle bending terms are parameterised by a force constant kθ in kcal/mol/radian2 and an equilibrium angle

value θ0 in degrees. They have the format as shown below:

c3-c3-oh 67.720 109.430 SOURCE3 48 1.5023

The middle atom c3 is bonded to another c3 and to a hydroxyl oxygen oh. The equilibrium bond angle θ0 is 109.43
degrees and the force constant is 67.720 kcal/mol/radian2. Note that internally, angle deviations are computed in
π-radian2. The parmtop ﬁles also express the default ’equilibrium’ bond angles in radians. For example, the angle
of 109.43 degrees is internally represented as 1.9099 π-radians. Using degrees in the original parameter ﬁles is
obviously more convenient. Anything after the third ﬁeld, the equilibrium angle, is mainly documentation and not
required.

251

14. Reading and modifying Amber parameter ﬁles

Torsion Terms

The third row in equation 14.1 is the usual Fourier-series expansion for torsional terms. In Amber parameter

ﬁles, these entries require a careful explanation:

First, many torsion terms contain generic entries, using the notation ’X’ for ’any atom’. These terms are used
when the parameter ﬁle does not contain more speciﬁc terms for the same torsion. They are combined with
explicit terms when present. Entries with generic ’X’ atoms must always come before the more speciﬁc ones in the
parameter ﬁles.

Second, Amber parameter ﬁles use a special notation for torsions that require more than one torsional term (see

example towards the end of section 14.1.6).

Third, the parameter ﬁle entry not only contains the torsion barrier term Vn (in kcal/mol), the phase γ (degrees)
and the periodicity n, but also a divider (integer) which splits the torsion term into individual contributions for
each pair of atoms involved in the torsion.

Fourth, torsion entries can also contain information about the special scaling of 1-4 non-bonded interactions

(see section 14.1.6 on page 254).

Consider the following example, the default term for the torsion around a Csp3-Csp3 single bond:

X -c3-c3-X 9 1.400 0.000 3.000 JCC,7,(1986),230

The ﬁve relevant terms on this line are:

1. the deﬁnition (X -c3-c3-X)

2. the divider (9)

3. the barrier term (1.400)

4. the phase (0.000)

5. the periodicity (3.000)

Fields after the periodicity are mainly comment, except for the special ﬂags SCNB and SCEE, that, if present,
govern the special treatment of 1-4 non-bonded interaction (see section 14.1.6)

The torsional barrier term (the actual barrier divided by two) is 1.400 and the periodicity is 3. The phase is zero
in this example, meaning that a maximum energy is encountered at zero degrees. A phase of 180 degrees on the
other hand means that there is a minimum at 180 degrees. The divider is 9 because each Csp3 has three X attached
to it and each X ’sees’ three X attached to the other Csp3 (3 × 3 = 9).

For a torsion angle φ (deﬁned as X-c3-c3-X) of -60, 60, or 180 degrees, the torsion energy term would be zero:

× [1 + cos(3× φ − 0.0)] = 0

1.4
9

(14.2)

This corresponds to the staggered conformation, i.e., the lowest energy state in a X3C-CX3 connectivity like for

example ethane (H3C-CH3)

By rotating around the C-C bond, an eclipsed conformation where the X are exactly opposed is encountered

three times (periodicity = 3), namely at φ = 0, 120, or 240 (-120) degrees.

× [1 + cos(3× φ − 0.0)] = 0.3111

1.4
9

(14.3)

.

Since the divider is 9, we have to multiply the value of 0.3111 by 9 to get the full torsional barrier, i.e., 9×
0.3111 = 2.8 kcal/mol.3 This might be used for ethane for example and would be close to the experimental torsion
barrier (ca. 3 kcal/mol).

In GAFF however, there is also a speciﬁc term for hc-c3-c3-hc that would come into play for ethane. In this

case, the divider is 1, because the term is fully deﬁned.

3The actual barrier value of 2.8 kcal/mol here is twice the barrier term of 1.4 in the parameter ﬁle.

252

hc-c3-c3-hc 1 0.15 0.0 3. Junmei et al, 1999

Thus, using GAFF for ethane, this term counts 9 times because there are nine [hc,hc] pairs seeing each other.
Instead of equation 14.3, one would use

14.1. Understanding Amber parameter ﬁles

(14.4)
i.e., the total torsional term in ethane would be 9× 0.3 = 2.7 kcal/mol. The experimental torsional barrier value
of ca. 3 kcal/mol would be reached because of the additional van der Waals and Coulomb repulsion terms between
the staggered hydrogens.

0.15× [1 + cos(3× φ − 0.0)] = 0.3000

Assume a connectivity for which some terms are fully deﬁned (all four atom types are speciﬁed) while no
speciﬁc entry is given for others. In that case, the equations are combined. The speciﬁc terms are counted once
(divider = 1) and the remaining general terms are added according to

Vbarrier
divider

× [1 + cos(periodicity× φ − phase)]

(14.5)

Things get more complex when the Fourier series has more than one term. A typical example would be the
rotation around an amide bond R1-NH-C(=O)-R2. In this case, the trans amide (H and O on opposite sides,
φ = 180◦) is preferred over the cis-amide (H and O on the same side, φ = 0). The entry in the GAFF parameter
ﬁle for this torsion is

hn-n -c -o 1 2.50 180.0 -2. JCC,7,(1986),230
hn-n -c -o 1 2.00
0.0 1. J.C.cistrans-NMA

If the torsion deﬁnition has a "negative" periodicity (-2 in the case above), it tells programs reading the parameter
ﬁle that additional terms are present for that particular connectivity. The equation to be applied for hn-n -c -o is:

Etorsion = 2.00× [1 + cos(1× φ − 0.0)] + 2.50× [1 + cos(2× φ − 180.0)]

(14.6)
Equation 14.6 prefers the trans amide (φ = 180◦) over the cis amide (φ = 0) by 4 kcal/mol considering the
torsion term alone. However the more favourable Coulomb term (the 1-4 attractive interaction between the negative
carbonyl oxygen and the positive amide hydrogen) reduces the overall preference for the trans conformation close
to the experimental value of ca. 2 kcal/mol.

In addition, the following general terms have to be applied for the torsions involving R1 and R2 in the peptide

bond R1-NH-C(=O)-R2, in order to compute the high torsional barrier of an amide bond:

X -c -n -X 4 10.000 180.000 2.000

Torsional terms are obviously the most difﬁcult part to parametrize in a force ﬁeld. They are in a way the last
rescue to get torsional barriers right, after all other terms have been adjusted. Therefore, their transfer from one
force ﬁeld to the other is always most risky and acceptable only if all other involved terms in two force ﬁelds are
very similar. Transferability must always be validated.

Out-of-Plane Terms

Out-of-plane terms are handled via a Fourier term, similar to the torsion terms. But the four involved atoms are
not serially (linearly) bonded, they are "branched". The "central" atom is the atom that is forced into the plane of
the other three. For example, to keep a carbonyl group R1-C(=O)-R2 planar, the central C atom must be forced
into the plane of the other three connected items R1, R2, and O. The entry in the GAFF parameter ﬁle for this
term is

X -X -c -o 10.5 180. 2. JCC,7,(1986),230

Note that in Amber the central atom type (here c) is the third in the deﬁnition.The order of the remaining atoms
should (by deﬁnition) be alphabetic in atom type. The phase is always 180◦. In all-atom force ﬁelds, the periodicity
is always 2.

Out-of-plane terms are the only terms that are allowed to be "missing" in Amber parameter ﬁles. Common ones
are added automatically by tools like tleap. In many cases, these terms are "cosmetics" that avoid "in principle"

253

14. Reading and modifying Amber parameter ﬁles

planar structures from getting distorted under the inﬂuence of other forces (e.g., fused rings, planar nitrogens
with three substituents, etc...). The actual parameterisation is often intuitive and for many entries, the ("generic")
parameters are identical.

1-4 Non-Bonded Interaction Scaling

Figure 14.1.: 1-4 Interactions between atoms "1" and "4".

Non-bonded interactions between atoms separated by three consecutive bonds (as schematically shown in Figure
14.1) require a special treatment in Amber force ﬁelds. Although referring to non-bonded interactions, scaling
information is included in the torsion terms part of the parameter ﬁles.

By default, vdW 1-4 interactions are divided (scaled down) by a factor of 2.0, electrostatic 1-4 terms by a
factor of 1.2. These are default values for the protein force ﬁelds and GAFF, but not for sugar force ﬁelds GLY-
CAM_06EP and GLYCAM_06, for example, in which these interactions are not scaled at all.

Without any additional information, programs like tleap, used to prepare parmtop ﬁles, assume that the

standard scaling mentioned above is to be applied. However, this default can be overwritten in the torsion section
of the parameter ﬁle. An example is shown below for torsional terms in the GLYCAM_06j force ﬁeld:

S -Ng-Cg-H1 1 2.00 0.0 1. SCEE=1.0 SCNB=1.0 N-Sulfates
S -Ng-Cg-Cg 1 0.0 0.0 -3. SCEE=1.0 SCNB=1.0 N-Sulfates

The special notation SCEE=1.0 SCNB=1.0 following the standard torsion terms4 will tell tleap to prepare a
parmtop ﬁle which transfers these data into a special section, as shown below:

%FLAG SCEE_SCALE_FACTOR
%FORMAT(5E16.8)
scaling factors are entered here....
%FLAG SCNB_SCALE_FACTOR
%FORMAT(5E16.8)
scaling factors are entered here....

When using standard Amber force ﬁeld parameter ﬁles as delivered with AmberTools, the user does not need to
care about this. However, when adding additional parameters, especially torsion terms, one should be aware of
these scaling factors and decide if they should be default or altered.

14.1.7. Non-Bonded Terms

Van der Waals Parameters

The standard formulation of the 6-12 Lennard-Jones potential Vi, j between two atoms i and j is:

4In this case, the ﬁelds coming after the periodicity (ﬁeld 5), i.e., ﬁelds 6 and 7 are also read and are not ’just’ comment!

254

14.1. Understanding Amber parameter ﬁles

(14.7)

(14.8)

(cid:34)(cid:18)σi, j

ri, j

(cid:19)12 −

(cid:18)σi, j

ri, j

Vi, j = 4εi, j

(cid:19)6(cid:35)

(cid:34)(cid:18) Rmin

ri, j

(cid:19)12 − 2

(cid:18) Rmin

ri, j

(cid:19)6(cid:35)

Vi, j = εi, j

Here, ri, j is the distance separating the two atoms, εi, j is the depth of the potential well for the interaction of
atoms i and j, and σi, j is the distance where the potential is exactly zero, i.e., where ’repulsion’ starts for the two
atoms. Both εi, j and σi, j are speciﬁc for the pair of atoms (or more precisely, ’atom types’).

Another possible formulation of Vi, j, relating to the concept of van der Waals radii, is:

In this case, Rmin is the sum of the van der Waals radii, Ri + R j of atoms i and j, the contact distance at which

the potential is at its minimum, i.e., at a value of −ε.

Figure 14.2.: Example of Lennard-Jones potential: the used data are those for the c3 atom type in the gaff force

ﬁeld (vdW radius Rmin= 1.908 Å, ε = 0.1094 kcal/mol)

Combining equations (14.7) and (14.8) gives for the relation between σ and Rmin:

Rmin = 21/6σ or σ = 2−1/6Rmin

In force ﬁelds, the ’A,B’ notation of the Lennard-Jones potential is commonly used:

Vi, j =

Ai, j
r12
i, j

− Bi, j
r6
i, j

(14.9)

(14.10)

where Ai, j and Bi, j are speciﬁc parameters for atom type pairs i and j. The meaning of Ai, j and Bi, j are easily

deduced from equation (14.7):

A = 4εσ 12 and B = 4εσ 6

(14.11)

or, in terms of Rmin, using equation (14.8):

(14.12)
Van der Waals data in Amber force ﬁelds are given for each atom as a single data pair, a radius Rmin (’van der

min and B = 2εR6
min

A = εR12

Waals’ radius in Å) and an energy ε (kcal/mol) representing the depth of the potential well.

255

14. Reading and modifying Amber parameter ﬁles

These values are given at the end of the force ﬁeld parameter ﬁles. In protein force ﬁelds, lines above these data

show equivalences. For example the line

N NA N2 N* NC NB NT NY

indicates that all atom types following N (the amide nitrogen) inherit the same Lennard-Jones parameters. Thus,
no entry for NA, N2, ... has to be given explicitly.

For Amber force ﬁelds, cross terms involving different atom types i and j are evaluated according to the

Lorentz/Berthelot mixing rules:

σi, j = 0.5(σi,i + σ j, j) or Rmin,i, j = 0.5(Rmin,i + Rmin, j)

εi, j =(cid:112)εi,i · ε j, j

(14.13)

(14.14)

The parmtop ﬁle entries are in ’A’ and ’B’ terms to be used directly with equation 14.10, transforming the

[Rmin,ε] data pairs from the parameter ﬁles.

As an example, consider ethanol (CH3CH2OH) with the GAFF force ﬁeld. There are ﬁve different GAFF atom

types. Below are shown the corresponding [Rmin,ε] data pairs, as found in the gaff.dat parameter ﬁle:

h1 1.3870 0.0157 Veenstra et al JCC,8,(1992),963
hc 1.4870 0.0157 OPLS
ho 0.0000 0.0000 OPLS Jorgensen, JACS,110,(1988),1657
oh 1.7210 0.2104 OPLS c3 1.9080 0.1094 OPLS

Note that there are three different hydrogen types: hc, the default H atom connected to an aliphatic carbon, h1, a
hydrogen type connected to an aliphatic carbon with one electronegative substituent (the oxygen in this case), and
the hydroxyl hydrogen ho (for which van der Waals interactions are neglected in Amber).

Partial Charges

For Amber force ﬁelds, partial charges do not appear in parameter ﬁles. For proteins and nucleic acid force ﬁelds
that use fragment (residue) libraries, partial charges are pre-deﬁned and have been computed from electrostatic-
potential ﬁtting of high-level an initio QM. They are automatically assigned by tools like tleap. Library ﬁles are
found the folder $AMBERHOME/dat/leap/lib.

Below is shown the alanine (ALA) residue of the library ﬁle all_amino94.lib:

"N" "N" 0 1 131072 1 7 -0.415700
"H" "H" 0 1 131072 2 1 0.271900
"CA" "CT" 0 1 131072 3 6 0.033700
"HA" "H1" 0 1 131072 4 1 0.082300
"CB" "CT" 0 1 131072 5 6 -0.182500
"HB1" "HC" 0 1 131072 6 1 0.060300
"HB2" "HC" 0 1 131072 7 1 0.060300
"HB3" "HC" 0 1 131072 8 1 0.060300
"C" "C" 0 1 131072 9 6 0.597300
"O" "O" 0 1 131072 10 8 -0.567900

The partial charges for each atom are given in the last ﬁeld of each line.

For the GAFF force ﬁelds, there are various options to compute partial charges; the AM1-BBC method is
probably the best trade-off between quality and speed. There are other ﬁle types that can contain user-speciﬁed
partial charges, e.g., SYBYL mol2 ﬁles. See the antechamber documentation for details.

In parmtop ﬁles, partial charges are not entered as fragments of the electron charge, but are multiplied by the
square-root of 332.05 (= 18.22), because the factor 332.05 converts the Coulomb energy into kcal/mol when using
fragments of the electron charge in the Coulomb term of equation 14.1.

256

14.2. ParmEd

14.1.8. Final Remarks

Most parameters in Amber force ﬁelds have been tested on a large variety of structures. In rare cases, situations
are encountered where structures look "strange" or where results are obviously wrong. One should ﬁrst look
into details of the simulation conditions and settings before blaming the problem on actually ﬂawed force ﬁeld
parameters. Simple test cases are often helpful to resolve the enigma.

When changing or adding parameters and later publishing results, new parameter should be mentioned. Also,
the Amber developers team should be notiﬁed about possibly problematic parameters. This ensures that potential
errors are corrected via patches in later versions and it will help the entire user community.

14.2. ParmEd

ParmEd (parmed) is a topology ﬁle editor written in Python that enables high level control of the primary force
ﬁeld ﬁle in Amber: the prmtop ﬁle. ParmEd will modify the topology ﬁle and produce a new topology ﬁle that will
work with sander, pmemd, and NAB programs, and provides options unavailable otherwise. ParmEd currently
supports topology ﬁles created with both tleap and chamber (but support is very limited for those created with
tinker_to_amber).

14.2.1. Running parmed

parmed is used in a manner very similarly to cpptraj.

usage: parmed [-h] [-v] [-i FILE] [-p <prmtop>] [-c <inpcrd>] [-O]

[-l FILE] [--prompt PROMPT] [-n] [-e] [-s] [-r]
[<prmtop>] [<script>]

positional arguments:

<prmtop>
<script>

Topology file to analyze.
File with a series of ParmEd commands to execute.

optional arguments:

-h, --help
-v, --version

Input Files:

-i FILE, --input FILE

show this help message and exit
show program’s version number and exit

Script with ParmEd commands to execute. Default reads
from stdin. Can be specified multiple times to process
multiple input files.

-p <prmtop>, --parm <prmtop>

List of topology files to load into ParmEd. Can be
specified multiple times to process multiple
topologies.

-c <inpcrd>, --inpcrd <inpcrd>

List of inpcrd files to load into ParmEd. They are
paired with the topology files in the same order that
each set of files is specified on the command-line.

Output Files:

-O, --overwrite
-l FILE, --logfile FILE

Allow ParmEd to overwrite existing files.

Log file with every command executed during an
interactive ParmEd session. Default is parmed.log

Interpreter Options:

These options affect how the ParmEd interpreter behaves in certain cases.
--prompt PROMPT
-n, --no-splash

String to use as a command prompt.
Prevent printing the greeting logo.

257

14. Reading and modifying Amber parameter ﬁles

-e, --enable-interpreter

Allow arbitrary single Python commands or blocks of
Python code to be run. By default Python commands will
not be run as a safeguard for your system. Make sure
you trust the source of the ParmEd command before
turning this option on.

Error Handling:

These options control how ParmEd handles various errors and warnings that
appear occur during the course of Action execution
-s, --strict

-r, --relaxed

Prevent scripts from running past unrecognized input
and actions that end with an error. In interactive
mode, actions with unrecognized inputs and failed
actions prevent any changes from being made to the
topology, but does not quit the interpreter. This is
the default behavior.
Scripts ignore unrecognized input and simply skip over
failed actions, executing the rest of the script.
Unrecognized input in the interactive interpreter
emits a non-fatal warning.

Like with ptraj and cpptraj, if you do not supply the prmtop or the input_ﬁle, it will read the commands from
STDIN as you type them.

14.2.2. ParmEd commands (they are all case-insensitive)

All actions that work on a topology ﬁle will use the “parm <idx>|<name>” input sequence to operate on a
speciﬁed topology ﬁle. If present, either the topology ﬁle loaded <idx> topologies after the ﬁrst one or the topology
ﬁle loaded with the given <name> will be modiﬁed by that action. If absent, the LAST topology ﬁle loaded will
be modiﬁed. The <idx> ranges from 0 to the total number of loaded topologies minus 1.

(Note: if you actually have a topology ﬁle named “1” that is not the second loaded topology ﬁle, you will need
to address it via an index. That is, integers will always be assumed to be indices unless they are out of the topology
ﬁle range.)

14.2.2.1. addAtomicNumber

Usage: addAtomicNumber
Adds a section in the topology ﬁle with the ﬂag ATOMIC_NUMBER in order to identify speciﬁc elements.
Elements are matched based on their atomic masses in the MASS section of the topology ﬁle. An atom is assigned
an element by matching it with the element on the periodic table whose atomic mass is closest to the atom in
question. This approach should work for any atom whose mass is either unchanged from the LEaP output or if that
atom’s mass has only been changed to one of its isotopes.

14.2.2.2. addDihedral

Usage: addDihedral <mask1> <mask2> <mask3> <mask4> <phi_k> <per> <phase> <scee> <scnb> [type

<type>]

Adds a dihedral term (will NOT replace an existing dihedral) between atoms in mask1, mask2, mask3, and
mask4. The dihedral is deﬁned around the bond between the atoms in mask2 and mask3. Each mask must deﬁne
the same number of atoms. For mask1 deﬁnes atoms 1,2,3; mask2 deﬁnes atoms 11,12,13; mask3 deﬁnes atoms
21,22,23; and mask4 deﬁnes atoms 31,32,33, then 3 new dihedrals will be added. One between atoms 1, 11, 21,
and 31, another between atoms 2, 12, 22, and 32, and a third between atoms 3, 13, 23, and 33. The dihedrals will
be set with force constant phi_k, periodicity per, phase angle phase, 1-4 electrostatic scaling factor scee (this must
be speciﬁed – the default Amber value is 1.2 and the default GLYCAM and CHARMM value is 1.0), the 1-4 van
der Waals scaling factor scnb (this must be speciﬁed – the default Amber value is 2.0 and the default GLYCAM

258

14.2. ParmEd

and CHARMM value is 1.0). The type is either “normal” or “improper”. If this is an improper torsion, <mask3>
should represent the central atoms bonded to all other atoms in the improper torsion.

End-group interactions are excluded automatically if the two end atoms (atoms 1 and 4) are bonded or angled
to each other, or if they appear in a different dihedral. Otherwise, they are included. These are the same rules
that tleap uses when it creates the topology ﬁle, and correctly accounts for complex exclusion rules involving ring
systems (of size 4, 5, and 6) as well as multi-term torsion parameters.

14.2.2.3. addExclusions

Usage: addExclusions <mask1> <mask2>
Allows you to add arbitrary exclusions to the exclusion list. Every atom in <mask2> is added to the exclusion list
for each atom in <mask1> so that non-bonded interactions between those atom pairs will not be computed. NOTE
that this ONLY applies to direct-space (short-range) non-bonded potentials. For PME simulations, long-range
electrostatics between these atom pairs are still computed (in different unit cells).

14.2.2.4. addLJType

Usage: addLJType <mask> [radius <new_radius>] [epsilon <new_epsilon>] [radius_14 <new_radius14>]

[epsilon_14 <new_epsilon14>]

This command will assign all atoms speciﬁed in the given mask to a new van der Waals (VDW) atom type.
Note that several different Amber atom types may in fact be the same VDW type, so this command is designed to
give you control over changing just a single atom’s (or single Amber atom type’s) VDW parameters. Every atom
speciﬁed in the mask will be given the SAME type (but different from every other atom in the topology ﬁle), even
if their original VDW types are different. The parameters [new_radius] and [new_depth] are optional parameters
that specify that atom’s radius and well depth, which are combined with every other type’s radius and depth via
the canonical Amber combining rules. They default to the original value of the FIRST atom that is matched by the
mask.

Note that for chamber-created topology ﬁles (ONLY), each atom type has separate 1-4 parameters that may be
speciﬁed as well. Unspeciﬁed values will be taken from the default parameters of the ﬁrst atom type as described
above. Any attempt to supply the 1-4 parameters on a normal topology created with leap will result in an error.

See the command printLJTypes for additional information here. You can use this command to see if addLJType

may be necessary for what you’re trying to do.

14.2.2.5. addPDB

Usage: addPDB <ﬁlename> [elem] [strict] [allicodes]
This command replaces the add_pdb program that was released in previous AmberTools releases. It reads in a

PDB ﬁle <ﬁlename> and adds the following new sections to the topology ﬁle:

RESIDUE_CHAINID The chain ID of each residue (if it was added by tleap and not in the PDB ﬁle, a * is used)

RESIDUE_ICODE PDB insertion code

RESIDUE_NUMBER The original residue number of this residue in the PDB ﬁle

ATOM_ELEMENT Atomic element.

This

section is

redundant now that

the topology ﬁle has an

ATOMIC_NUMBER section. Therefore, this section is no longer printed by default.

The strict keyword turns residue mismatches (excluding solvent) into fatal errors. Note that for nucleic acids,
terminal residue names often do not match the residue names in the PDB ﬁle because of the added 5 or 3 to the
residue name (for the 5’ terminus and 3’ terminus, respectively).

The elem keyword will force the ATOM_ELEMENT section to be printed to the topology ﬁle, but the element
will be determined from the ATOMIC_NUMBER section (or atomic mass if the former is not present) rather than
the atom names as was done in the add_pdb program.

The allicodes keyword forces insertion codes to be printed even if every one will be blank. This allows parsers

that use that section to be sure it will always be present.

259

14. Reading and modifying Amber parameter ﬁles

Residues not in the PDB will be assigned a CHAINID of ’*’ and a RESIDUE_NUMBER of 0. While this action

is based on, and reproduces the key results of, the historical add_pdb program, it is a bit more ﬂexible.

14.2.2.6. add12_6_4

Usage: add12_6_4 [<mask>] [c4ﬁle <c4ﬁle> | watermodel <watermodel>] [polﬁle <polﬁle>] [tunfactor

<tunfactor>]

The add12_6_4 command is designed to create the prmtop ﬁles, which contain the C4 terms between the ions
and each atom type in the prmtop ﬁle. By using it together with the outparm command, there will be a new ﬂag
named "LENNARD_JONES_CCOEF" created in the end of the output prmtop ﬁle. The C4 terms between the
ions and "OW" atom type (which is the oxygen atom of the water molecule, here we assume the polarizability of
"HW" is equal to zero) has been determined. Detailed information can be found in the papers of Li, Merz and
co-workers.[117–119]

The C4 term between two different kinds of ions is calculated by following equation:

C4(M − X) = tun f actor× [

CM
4 (H2O)
α0(H2O)

× α0(X) +

CX
4 (H2O)
α0(H2O)

× α0(M)]

(14.15)

Where M and X mean two different kinds of ions which all have theirC4 values towards "OW" determined.
4 (H2O) are the two C4 values.α0(H2O) ,α0(M) , andα0(X) are the polarizabilities of "OW",

4 (H2O) andCX

Herein CM
"M", and "X", respectively.

The C4 terms between every other atom pair including ion are calculated by following equation (including ion

interact with itself, herein M represents ion, Y means the other atom type in the atom pair):

C4(M −Y ) = tun f actor× CM

4 (H2O)
α0(H2O)

× α0(Y )

(14.16)

Here we explain the Usage terms:
1. The <mask> is the ion which was treated as the ion center when adding the C4 terms. Please make sure its
corresponding "ATOMIC_NUMBER" is correct in the prmtop ﬁle, in that this is the criterion used in the code to
identify the metal ion. If you want to use 12-6-4 potentials for different kinds of ions in the prmtop ﬁle, please
specify all of these ions in the <mask> together (i.e. <mask> contains at least one ion for each kind) other than
performing several add12_6_4 commands for different kinds of ions one after another, because the the current
implementation doesn’t support the later situation. If no <mask> provided, default value :ZN.

2. To add the C4 term between the ion and the "OW" atom type (the oxygen atom in the water molecules), you
can either use your own <c4ﬁle> (in this way you need to create a <c4ﬁle> where the ﬁrst column is the Atom
Symbol plus charge and the second column is the corresponding C4 value) or use the C4 values stored in parmed
(in this way you only need to specify the watermodel you are using in the command line, either TIP3P, SPCE or
TIP4PEW). If nothing (neither your own <c4ﬁle> nor the water model you are using) is speciﬁed, the TIP3P water
model will be treated as the default and the related values stored in parmed will be used.

3. To add C4 terms between the ion and atom types besides "OW", you need a polarizability ﬁle of all the atom
types (the default ﬁle is $AMBERHOME/dat/leap/parm/lj_1264_pol.dat, you can also create and use your own
polﬁle where the ﬁrst column is the Amber Atom Type while the second column is polarizability), and a tunfactor
(which is shown in the previous equation - the default value is set as 1.0). The best tunfactor value for each force
ﬁeld may be different. You can also ﬁne tune the optimal value for a speciﬁc force ﬁeld if so inclined.

After using the add12_6_4 command in the parmed, please don’t forget to use the outparm command to output
the new prmtop ﬁle. One thing need to clarify: for the <c4ﬁle>, the ﬁrst column is Atom Symbol plus charge
(e.g., Na1, Mg2, Cl-1, ...) and the second column is the C4 value between the ion and the "OW" atom type; for
the <polﬁle>, the ﬁrst column is the AMBER Atom Type (e.g., HC, CT, N3, OS, Be2+, Mg2+, Ca2+ ...) while the
second column is the polarizability.

14.2.2.7. cd

This changes into the given directory (just like the UNIX cd command).

260

(14.17)

(14.18)

14.2.2.8. chamber

<a,b,c[,α,β ,γ]>|bounding] [-radii <radiusset>]

Usage:
chamber -top <RTF> -param <PAR> -str <STR> -psf <PSF> [-crd <CRD>] [-nocmap] [-box
CHAMBER (CHarmm↔AMBER) is a tool which enables the use of the CHARMM force ﬁeld within AM-
BER’s molecular dynamics engines (MDEs). If you make use of the CHARMM force ﬁeld in Amber, please cite
Ref. [81].

14.2. ParmEd

AMBER[30] and CHARMM[377, 378] are two approaches to the parametrization of classical force ﬁelds that
ﬁnd extensive use in the modeling of biological systems. The high similarity in the functional form of the two
potential energy functions used by these force ﬁelds, Eq.(14.19 and 14.20), gives rise to the possible use of one
force ﬁeld within the other MDE.
VAMBER = ∑

[1 + cos(nφ − γ)] (cid:54)

k (r− req)2 + ∑
(cid:35)
(cid:34)

angles

Ai j
R12
i j

− Bi j
R6
i j

+∑

i< j

bonds

+∑

i< j

k (θ − θeq)2 + ∑
(cid:20) qiq j

(cid:21)

dihedrals

Vn
2

εRi j

VCHARMM = ∑

bonds

kb (b− b0)2 + ∑

angles

kθ (θ − θ0)2 + ∑
ku (u− u0)2 + ∑
k (ω − ω0)2 + ∑
(cid:19)6(cid:35)
(cid:18) Rmini j

(cid:34)(cid:18) Rmini j

impropers

dihedrals

(cid:19)12 −

+

φ ,ψ

ri j

ri j

qiq j
εri j

+ ∑
Urey−Bradley
+ ∑

ε

nonbonded

kφ [1 + cos (nφ − δ )]

VCMAP

For the implementation of the CHARMM force ﬁeld within Amber, parameters that are of the same energy
term can be directly translated. However, there are differences in the functional forms of the two potentials, with
CHARMM having three additional bonded terms. With respect to the 1-4 non-bonded interactions, CHARMM
scales these in a different manner: the electrostatic scaling factor (scee) is 1.0 in CHARMM but 1.2 in Amber,
while the van der Waals scaling factor (scnb) is 1.0 within CHARMM but 2.0 in Amber. Additionally, CHARMM
uses a different set of parameters in the Lennard-Jones equation for the van der Waals interaction if the two atoms
are bonded 1-4 to each other.

The ﬁrst additional bonded term is CHARMM’s two-body Urey-Bradley term, which extends over all 1-3 bonds.
The second is a four-body quadratic improper term. The ﬁnal additional term is a cross term, named CMAP,
[379, 380], which is a function of two sequential protein backbone dihedrals. This term originates from differences
observed between classically calculated two-dimensional φ /ψ peptide free energy surfaces using the CHARMM22
force ﬁeld and those of experiment. CMAP is a numerical energy correction which essentially transforms the 2D
φ /ψ classical energy map to match that of a QM calculated map.

Support for these extra terms has required the development of extra sections to Amber’s extensible prmtop
format to accommodate this new information as well as modiﬁcations of the precision of existing sections. For
example, the CHARMM parameter ﬁle stores the equilibrium angle (θ0, Eq.14.20) parameter in degrees in its
parameter ﬁle, while Amber stores it in radians in the prmtop. However, during the conversion with chamber,
this becomes inexact when converted to radians. Within CHARMM this is done internally at runtime and the
inexactness is determined by the variable type that will hold the result of this conversion. However, for Amber, this
conversion is done at the chamber execution stage, and as a result is limited by the precision to which that speciﬁc
parameter is written to the prmtop ﬁle. Hence the precision of the ANGLE_EQUIL_VALUE has been increased;
similar changes were carried out for the CHARGE and VDW sections for the same reasons. Speciﬁcally, the
modiﬁed sections of the prmtop format and the additions to it are as follows:

%FLAG CTITLE
The keyword CTITLE is used in place of TITLE to specify that this is a CHAMBER prmtop.

261

14. Reading and modifying Amber parameter ﬁles

%FLAG FORCE_FIELD_TYPE
%FORMAT(i2,a78)
1 CHARMM 31 *>>>>>>>>CHARMM22 All-Hydrogen Topology File for Proteins <<
This section described the force ﬁeld in use. The initial integer speciﬁes the number of lines to be read. The

keyword CHARMM here indicates that this is the CHARMM force ﬁeld.

%FLAG CHARGE
%COMMENT Atomic charge multiplied by sqrt(332.0716D0) (CCELEC)
%FORMAT(3e24.16)
The default format for charge has been changed from 5e16.8 to 3e24.16

%FLAG CHARMM_UREY_BRADLEY_COUNT
%COMMENT V(ub) = K_ub(r_ik - R_ub)**2
%COMMENT Number of Urey Bradley terms and types
%FORMAT(2i8)
This additional section describes the number of CHARMM Urey-Bradley terms present and the total number of

Urey-Bradley types in use.

%FLAG CHARMM_UREY_BRADLEY
%COMMENT List of the two atoms and its parameter index
%COMMENT in each UB term: i,k,index
%FORMAT(10i8)
This additional section lists the atom indexes and parameter lookup index for each of the Urey-Bradley terms.

%FLAG CHARMM_UREY_BRADLEY_FORCE_CONSTANT
%COMMENT K_ub: kcal/mole/A**2
%FORMAT(5e16.8)
This additional section lists the force constant for each of the Urey-Bradley types.

%FLAG CHARMM_UREY_BRADLEY_EQUIL_VALUE
%COMMENT r_ub: A
%FORMAT(5e16.8)
This additional section lists the equilibrium value for each of the Urey-Bradley types.

%FLAG CHARMM_NUM_IMPROPERS
%COMMENT Number of terms contributing to the
%COMMENT quadratic four atom improper energy term:
%COMMENT V(improper) = K_psi(psi - psi_0)**2
%FORMAT(10i8)
This additional section lists the number of CHARMM improper terms present.

%FLAG CHARMM_IMPROPERS
%COMMENT List of the four atoms in each improper term
%COMMENT i,j,k,l,index i,j,k,l,index
%COMMENT where index is into the following two lists:
%COMMENT CHARMM_IMPROPER_{FORCE_CONSTANT,IMPROPER_PHASE}
%FORMAT(10i8)
This additional section lists the atom indices and index into the parameter arrays for each of the CHARMM

improper terms.

%FLAG CHARMM_NUM_IMPR_TYPES
%COMMENT Number of unique parameters contributing to the
%COMMENT quadratic four atom improper energy term

262

14.2. ParmEd

%FORMAT(i8)
This additional section lists the number of types present for the CHARMM impropers.

%FLAG CHARMM_IMPROPER_FORCE_CONSTANT

%COMMENT K_psi: kcal/mole/rad**2
%FORMAT(5e16.8)
This additional section lists the force constant for each CHARMM improper types.

%FLAG CHARMM_IMPROPER_PHASE

%COMMENT psi: degrees

%FORMAT(5e16.8)
This additional section lists the equilibrium phase angle for each of the CHARMM improper types.

%FLAG LENNARD_JONES_ACOEF

%FORMAT(3e24.16)
The default format for the Lennard Jones A and B coefﬁcients has been changed from 5e16.8 to 3e24.16.

%FLAG LENNARD_JONES_14_ACOEF

%FORMAT(3e24.16)
This additional section and the corresponding BCOEF section provide the alternative parameters for 1-4 VDW

interactions in the CHARMM force ﬁeld.

In concert with these prmtop additions, the appropriate modiﬁcations have to be made within sander and pmemd
to enable the calculation of the energy and derivatives corresponding to these new terms. The intention behind the
approach of creating a CHARMM enabled prmtop ﬁle is that the use of this prmtop ﬁle should be transparent
to the user. Once a CHARMM prmtop ﬁle is produced by chamber, the sander and pmemd dynamics engines
automatically detect the presence of CHARMM parameters in the prmtop ﬁle and automatically select the correct
parameters and code paths.

WARNING: The use of an unpatched Amber molecular dynamics engine with a chamber-generated prmtop ﬁle

will give undeﬁned behavior, leading to incorrect results. If you see the following error at runtime:

ERROR: Flag "TITLE" not found in PARM file

it most likely means that you are using an old pmemd or sander executable.

CHAMBER (CHarmm↔AMBER) is a tool which enables the use of the CHARMM force ﬁeld within AM-
BER’s molecular dynamics engines (MDEs). If you make use of the CHARMM force ﬁeld in Amber, please cite
Ref. [81].

AMBER[30] and CHARMM[377, 378] are two approaches to the parametrization of classical force ﬁelds that
ﬁnd extensive use in the modeling of biological systems. The high similarity in the functional form of the two
potential energy functions used by these force ﬁelds, Eq.(14.19 and 14.20), gives rise to the possible use of one
force ﬁeld within the other MDE.
VAMBER = ∑

[1 + cos(nφ − γ)] (cid:54)

k (r− req)2 + ∑
(cid:34)
(cid:35)

angles

Ai j
R12
i j

− Bi j
R6
i j

+∑

i< j

bonds

+∑

i< j

k (θ − θeq)2 + ∑
(cid:20) qiq j

(cid:21)

dihedrals

Vn
2

εRi j

(14.19)

263

14. Reading and modifying Amber parameter ﬁles

VCHARMM = ∑

bonds

kb (b− b0)2 + ∑

angles

kθ (θ − θ0)2 + ∑
k (ω − ω0)2 + ∑
ku (u− u0)2 + ∑
(cid:19)6(cid:35)
(cid:18) Rmini j

(cid:34)(cid:18) Rmini j

impropers

dihedrals

(cid:19)12 −

+

φ ,ψ

ri j

ri j

qiq j
εri j

+ ∑
Urey−Bradley
+ ∑

ε

nonbonded

kφ [1 + cos (nφ − δ )]

VCMAP

(14.20)

For the implementation of the CHARMM force ﬁeld within Amber, parameters that are of the same energy
term can be directly translated. However, there are differences in the functional forms of the two potentials, with
CHARMM having three additional bonded terms. With respect to the 1-4 non-bonded interactions, CHARMM
scales these in a different manner: the electrostatic scaling factor (scee) is 1.0 in CHARMM but 1.2 in Amber,
while the van der Waals scaling factor (scnb) is 1.0 within CHARMM but 2.0 in Amber. Additionally, CHARMM
uses a different set of parameters in the Lennard-Jones equation for the van der Waals interaction if the two atoms
are bonded 1-4 to each other.

The ﬁrst additional bonded term is CHARMM’s two-body Urey-Bradley term, which extends over all 1-3 bonds.
The second is a four-body quadratic improper term. The ﬁnal additional term is a cross term, named CMAP,
[379, 380], which is a function of two sequential protein backbone dihedrals. This term originates from differences
observed between classically calculated two-dimensional φ /ψ peptide free energy surfaces using the CHARMM22
force ﬁeld and those of experiment. CMAP is a numerical energy correction which essentially transforms the 2D
φ /ψ classical energy map to match that of a QM calculated map.

Support for these extra terms has required the development of extra sections to Amber’s extensible prmtop
format to accommodate this new information as well as modiﬁcations of the precision of existing sections. For
example, the CHARMM parameter ﬁle stores the equilibrium angle (θ0, Eq.14.20) parameter in degrees in its
parameter ﬁle, while Amber stores it in radians in the prmtop. However, during the conversion with chamber,
this becomes inexact when converted to radians. Within CHARMM this is done internally at runtime and the
inexactness is determined by the variable type that will hold the result of this conversion. However, for Amber, this
conversion is done at the chamber execution stage, and as a result is limited by the precision to which that speciﬁc
parameter is written to the prmtop ﬁle. Hence the precision of the ANGLE_EQUIL_VALUE has been increased;
similar changes were carried out for the CHARGE and VDW sections for the same reasons. Speciﬁcally, the
modiﬁed sections of the prmtop format and the additions to it are as follows:

%FLAG CTITLE
The keyword CTITLE is used in place of TITLE to specify that this is a CHAMBER prmtop.

%FLAG FORCE_FIELD_TYPE
%FORMAT(i2,a78)
1 CHARMM 31 *>>>>>>>>CHARMM22 All-Hydrogen Topology File for Proteins <<
This section described the force ﬁeld in use. The initial integer speciﬁes the number of lines to be read. The

keyword CHARMM here indicates that this is the CHARMM force ﬁeld.

%FLAG CHARGE
%COMMENT Atomic charge multiplied by sqrt(332.0716D0) (CCELEC)
%FORMAT(3e24.16)
The default format for charge has been changed from 5e16.8 to 3e24.16

%FLAG CHARMM_UREY_BRADLEY_COUNT
%COMMENT V(ub) = K_ub(r_ik - R_ub)**2
%COMMENT Number of Urey Bradley terms and types
%FORMAT(2i8)
This additional section describes the number of CHARMM Urey-Bradley terms present and the total number of

Urey-Bradley types in use.

264

%FLAG CHARMM_UREY_BRADLEY
%COMMENT List of the two atoms and its parameter index
%COMMENT in each UB term: i,k,index
%FORMAT(10i8)
This additional section lists the atom indexes and parameter lookup index for each of the Urey-Bradley terms.

14.2. ParmEd

%FLAG CHARMM_UREY_BRADLEY_FORCE_CONSTANT
%COMMENT K_ub: kcal/mole/A**2
%FORMAT(5e16.8)
This additional section lists the force constant for each of the Urey-Bradley types.

%FLAG CHARMM_UREY_BRADLEY_EQUIL_VALUE
%COMMENT r_ub: A
%FORMAT(5e16.8)
This additional section lists the equilibrium value for each of the Urey-Bradley types.

%FLAG CHARMM_NUM_IMPROPERS
%COMMENT Number of terms contributing to the
%COMMENT quadratic four atom improper energy term:
%COMMENT V(improper) = K_psi(psi - psi_0)**2
%FORMAT(10i8)
This additional section lists the number of CHARMM improper terms present.

%FLAG CHARMM_IMPROPERS
%COMMENT List of the four atoms in each improper term
%COMMENT i,j,k,l,index i,j,k,l,index
%COMMENT where index is into the following two lists:
%COMMENT CHARMM_IMPROPER_{FORCE_CONSTANT,IMPROPER_PHASE}
%FORMAT(10i8)
This additional section lists the atom indices and index into the parameter arrays for each of the CHARMM

improper terms.

%FLAG CHARMM_NUM_IMPR_TYPES
%COMMENT Number of unique parameters contributing to the
%COMMENT quadratic four atom improper energy term
%FORMAT(i8)
This additional section lists the number of types present for the CHARMM impropers.

%FLAG CHARMM_IMPROPER_FORCE_CONSTANT
%COMMENT K_psi: kcal/mole/rad**2
%FORMAT(5e16.8)
This additional section lists the force constant for each CHARMM improper types.

%FLAG CHARMM_IMPROPER_PHASE
%COMMENT psi: degrees
%FORMAT(5e16.8)
This additional section lists the equilibrium phase angle for each of the CHARMM improper types.

%FLAG LENNARD_JONES_ACOEF
%FORMAT(3e24.16)
The default format for the Lennard Jones A and B coefﬁcients has been changed from 5e16.8 to 3e24.16.

%FLAG LENNARD_JONES_14_ACOEF

265

14. Reading and modifying Amber parameter ﬁles

%FORMAT(3e24.16)
This additional section and the corresponding BCOEF section provide the alternative parameters for 1-4 VDW

interactions in the CHARMM force ﬁeld.

In concert with these prmtop additions, the appropriate modiﬁcations have to be made within sander and pmemd
to enable the calculation of the energy and derivatives corresponding to these new terms. The intention behind the
approach of creating a CHARMM enabled prmtop ﬁle is that the use of this prmtop ﬁle should be transparent
to the user. Once a CHARMM prmtop ﬁle is produced by chamber, the sander and pmemd dynamics engines
automatically detect the presence of CHARMM parameters in the prmtop ﬁle and automatically select the correct
parameters and code paths.

WARNING: The use of an unpatched Amber molecular dynamics engine with a chamber-generated prmtop ﬁle

will give undeﬁned behavior, leading to incorrect results. If you see the following error at runtime:

ERROR: Flag "TITLE" not found in PARM file

it most likely means that you are using an old pmemd or sander executable.

This command will read topology information from a CHARMM or XPLOR PSF ﬁle and write an AMBER
inpcrd and chamber-style prmtop ﬁle so the CHARMM force ﬁeld can be run in sander and pmemd. PSF ﬁles
generated by CHARMM, CHARMM-GUI, and VMD are all supported. PSF ﬁles are always generated using a set
of topology (RTF) ﬁles that deﬁne the residues (akin to library ﬁles in tleap)—these ﬁles deﬁne the connectivity
and atom types of all atoms in the system. Topology and parameter (PAR) ﬁles are always paired, so you must use
the parameter ﬁle here that matches the topology ﬁle you used to create the PSF originally. This is very important.
CHARMM stream ﬁles (that deﬁne both residue and parameter sections) are also supported, but must be speciﬁed
using the -str ﬂag. Do not pass any topology or parameter ﬁles to the -str ﬂag. The -top and -param ﬂags can be
speciﬁed multiple times.

NBFIX terms deﬁned in any stream or parameter ﬁles are read and implemented.

-top <RTF> CHARMM Residue Topology File (RTF). This is not needed if the atom types are deﬁned in the

parameter ﬁles (this seems to be true for CHARMM36 and probably later force ﬁelds).

-par <PAR> CHARMM Parameter ﬁle. This deﬁnes all of the CHARMM parameter ﬁles, and the one that corre-

sponds to the topology ﬁle used to create the PSF must be used.

-str <STR> CHARMM stream ﬁle. Any parameters stored in the stream ﬁle will be loaded.

-toppar <RTF|PAR> CHARMM RTF, parameter, or stream ﬁle—the type is automatically detected from the name.
All standard CHARMM ﬁles should work, but if you have changed the ﬁle name, you should use either
the -top, -par, or -str ﬂags above. Wild-cards are recognized, so you can do something like -toppar
toppar/*36_prot* to get all of the ﬁles that contain 36_prot in their name inside the toppar directory.

-psf <PSF> CHARMM/XPLOR/VMD Protein Structure File (PSF). This ﬁle deﬁnes the structure and topology

of the system.

-crd <CRD> File containing coordinates for the system. CHARMM coordinate, restart, and PDB ﬁles are all
supported. If this is a PDB ﬁle and a CRYST1 record deﬁnes a periodic box, the unit cell dimensions will
be set from this information. You can use the -box argument to override this.

-nocmap Ignore any CMAP terms that may be deﬁned. This is strongly discouraged unless you have a good

reason to do it.

-box <a,b,c[,α,β ,γ]>|bounding Deﬁnes the periodic box dimensions (and will override any PBC deﬁned in the
coordinate ﬁle). You can either give the keyword “bounding,” which will deﬁne the smallest possible or-
thorhombic box that encloses the centers of all atoms or you can give the unit cell dimensions. If you provide
only lengths, the box shape is assumed to be orthorhombic.

266

-radii <radiusset> The AMBER implicit solvent radius set. The options are equivalent to the “set PBRadii <ra-
diusset>” options in tleap. See page 236 for more information. Available choices are amber6, bondi, mbondi,
mbondi2, and mbondi3. Default choice is “mbondi” (same as tleap).

Note, after using this command, the created parm object will be the active parm. You need to use either the parmout
or outparm commands to actually print a topology ﬁle (and don’t forget to also print a coordinate ﬁle!)

14.2. ParmEd

Validation Starting with version c36a2 of CHARMM, a command (frcdump) has been implemented which
provides a validation route for alternate implementations of the CHARMM force ﬁelds. For a given system, this
command writes the various force ﬁeld potential energy contributions, as well as the energy gradient experienced
by each atom, to a ﬁle using a speciﬁc format and to a high precision. The same formatted output can also be
generated by the AMBER MDEs to facilitate comparison and to validate that the CHARMM force ﬁeld is being
implemented correctly in Amber’s MDEs.

An example section of a charmm script that will write this output to a ﬁle called charmm_gold_c36a2 is as

follows:

open unit 20 form write name charmm_gold_c36a2
frcdump unit 20
close unit 20

The analogous mdin section for Amber is as follows:

&debugf

do_charmm_dump_gold = 1,

/

Given this directive, the Amber MDE will stop after evaluating the potential energy of a system and write the
energy and forces pertaining to this to a (hardcoded) ﬁle called charmm_gold in the same directory as the mdin
ﬁle. The reader is invited to examine the various example test calculations within the $AMBERHOME/test/cham-
ber/dev_tests/ directory for in depth examples of the above. For such testing, it is recommended that both the
CHARMM binary and the Amber MDE binaries be compiled with the same compiler. Given that CHARMM
support within Amber and the chamber software is still somewhat experimental, the user is advised to carry out
such a comparison before running a long production run.

Known limitations / Issues This is a non-exhaustive list of the current known bugs and/or limitations with
chamber:

• CHARMM polarization models are not supported. (IPOL /= 0)

• The mdout ﬁle will contain extra potential energy ﬁelds pertaining to the CHARMM terms. This may break

or confuse third party scripts that parse such outputs.

• Third party scripts and/or tools which do not correctly parse the extensible prmtop format may have issues

with a chamber-generated prmtop ﬁle.

• The potential energy decomposition components (self, reciprocal, direct, adjusted) of the Particle Mesh
Ewald energy generated in the charmm_gold ﬁle when the do_charmm_dump_gold = 1 mdin option in
Amber do not match with the breakdown used in CHARMM, however, the summation and resulting forces
do match.

If other issues are found, the parmed authors would be very grateful if these could be reported to them, either via
the Amber mailing list and/or directly to the authors. Please ensure that prior to reporting an issue, the chamber
binary passes the test cases provided with AmberTools. Please provide a standalone example of the problem with
all input ﬁles present and a script reproducing the sequence of commands that triggers the problem. The posting
of large ﬁles (> 2 MB) to the Amber mailing list is not recommended; instead one should make the ﬁles available
on a website somewhere and provide a link to it with the posting to the list.

267

14. Reading and modifying Amber parameter ﬁles

14.2.2.9. change

Usage: change <property> <atom_mask> <new_value>
This command allows you to change the value of an atom’s property for every atom in a given mask to a new
value. The allowed atomic properties you can modify are the CHARGE (given in units of elementary atomic
charges), MASS (in g/mol), RADII (in Angstroms, these are the GB radii), SCREEN (the GB screening parame-
ters), ATOM_NAME, and AMBER_ATOM_TYPE (this is NOT the van der Waals type). Every atom in the mask
will be given the same new_value.

NOTE: The prmtop utility used here stores the partial CHARGE array in terms of elementary atomic charges.
All charges are multiplied by 18.2223 prior to being written to any new topology ﬁle (and is divided by that number
when read in from a topology ﬁle). Therefore, if you are changing speciﬁc atomic charges in this case, specify new
charges in elementary atomic charges.

NOTE: This command gives you access to speciﬁc atoms. If you want to change all of the GB radii to be

compatible with a speciﬁc GB model, see the changeRadii command.

14.2.2.10. changeLJPair

Usage: changeLJPair <mask1> <mask2> <Rmin> <epsilon>
This command changes a speciﬁc pairwise interaction between the atom type of the atoms in mask1 (these must
all be the same type) and the atoms in mask2 (these must all be the same type as well). Rmin and Depth are the
pre-combined values of these variables, which allows you to deﬁne your own combining rules for a speciﬁc pair
of atoms.

If you want to see which atoms this command will affect, you can use the printLJTypes with either of the given

masks to get a list of atoms that share the same type as the atoms in that mask.

This command is similar to NBFIX available through CHARMM.

14.2.2.11. changeLJ14Pair

Usage: changeLJ14Pair <mask1> <mask2> <Rmin> <epsilon>
This command is similar to changeLJPair above, except it alters the 1-4 Lennard Jones terms only. Note that
this command is only available for chamber-created topology ﬁles, and will result in an error if applied to a normal
topology created with leap.

14.2.2.12. changeLJSingleType

Usage: changeLJSingleType <mask> <Rmin> <epsilon>
This command allows you to change the radius and well depth of particular nonbonded atom types. It will
set new values for each interaction the selected type has with every other atom type (irrespective if changeLJPair
altered one of these terms before).

14.2.2.13. changeProtState

Usage: changeProtState <mask> <state #>
Changes the protonation state of a residue that is titratable via constant pH simulations in Amber. <mask> must
match all atoms of one, and only one, pH-active titratable residue. As of Amber 18, pH-active titratable residues
include AS4, GL4, CYS, TYR, HIP, LYS, and PRN.

14.2.2.14. changeRedoxState

Usage: changeRedoxState <mask> <state #>
Changes the redox state of a residue that is titratable via constant Redox Potential simulations in Amber. <mask>
must match all atoms of one, and only one, redox-active titratable residue. As of Amber 18, the only redox-active
titratable residue is HEH.

268

14.2. ParmEd

14.2.2.15. changeRadii

Usage: changeRadii <parameter_set>
Parameter set is one of the following: bondi, mbondi, mbondi2, mbondi3, amber6. This command will reset all

of the intrinsic GB radii to the speciﬁed set without having to recreate a topology ﬁle through leap.

14.2.2.16. checkValidity

Usage: checkValidity
Thoroughly checks the topology ﬁle for a wide range of errors. It also checks for common mistakes, like missing
disulﬁde bridges, for instance. More checks are done if a restart ﬁle is loaded prior to running this command. If
you are getting a strange error from a simulation engine, it may be worth using this to check the prmtop. Note that
this action, in particular, requires a version of Python 2.5 to 2.7.

14.2.2.17. deﬁneSolvent

Usage: deﬁneSolvent <residue_list>
This command will allow you to deﬁne custom solvent residues. The residue_list must be a comma-separated
list with no whitespace separating the residue names. This is important for the proper determination of the SOL-
VENT_POINTERS and ATOMS_PER_MOLECULE sections of the topology ﬁle. By default, HOH and WAT
residues are recognized as solvent.

14.2.2.18. deleteBond

Usage: deleteBond <mask1> <mask2> [verbose]
This command will delete all bonds in which one atom is in mask1 and the other atom is in mask2. It also deletes
all other valence terms (angles, Urey-Bradleys,* torsions, impropers, and CMAPs,*) in which a deleted bond was
a part. This is distinct from using setBond to assign a force constant of 0 because it also deletes other valence
terms and removes those atoms from the respective nonbonded exclusion lists (since they are no longer bonded to
each other).

If you use the “verbose” keyword, you will get a printout of every bond that is deleted.
*Some terms are only found in chamber-style topology ﬁles specifying a CHARMM force ﬁeld.

14.2.2.19. deleteDihedral

Usage: deleteDihedral <mask1> <mask2> <mask3> <mask4>
Deletes the dihedral around <mask2> and <mask3> in which the end-groups are <mask1> and <mask4>. For

multi-term dihedrals, it removes each term.

14.2.2.20. deletePDB

Usage: deletePDB
Deletes the ﬂags that are added by addPDB (see description above).

14.2.2.21. energy

Usage: energy [cutoff <cut>] [[igb <IGB>] [saltcon <conc>] | [Ewald]] [nodisper] [omm] [applayer] [plat-

form <platform>] [precision <precision model>] [decompose]

Computes the energy for a given structure. If you did not load a coordinate ﬁle on the command-line, you must
use loadRestrt (see below) in order to load a set of coordinates (and box dimensions for periodic simulations). The
options are:

cutoff <cut> The cutoff, in Angstroms, to use for the nonbonded cutoff. The default value is 1000 for non-periodic

systems and 8 for periodic systems.

269

14. Reading and modifying Amber parameter ﬁles

dumpfrc <ﬁlename> The ﬁle name to write atomic forces to. The format is a single header line starting with ’#’

followed by natom lines with the x, y, and z components of the force space-delimited.

Non-periodic options These options are applied only to non-periodic simulations. If the prmtop indicates peri-
odicity (i.e., IFBOX > 0), these options are ignored.

igb <IGB> GB model to use. Allowed values are 0, 1, 2, 5, 6, 7, and 8. The values 0 and 6 indicate vacuum
electrostatics. The other values match the options available in sander, pmemd, and NAB (see pages 69 and
826 for more details).

saltcon <conc> Salt concentration (in Molarity) to use when using GB implicit solvent. See page 71 for more

information.

Periodic options These options are applied only to periodic simulations. If the prmtop does not indicate period-
icity (i.e., IFBOX == 2), these options are ignored.

Ewald Use the Ewald sum to compute long-range electrostatics instead of Particle-Mesh Ewald (this is much

slower than PME for large systems). This is equivalent to setting ew_type=1 in sander.

nodisper Do not use the long-range dispersion correction to correct for Lennard-Jones interactions that are ex-

cluded beyond the cutoff. This is equivalent to setting vdwmeth=0 in sander and pmemd.

OpenMM-speciﬁc options Instead of using the sander-Python API to compute energies and forces, you can use
OpenMM. OpenMM must be installed and the Python application layer must be available for import. OpenMM
cannot currently handle octahedral boxes (or any non-orthorhombic box).

omm This keyword must be present in order to use the OpenMM engine instead of the sander Python package.

All following options are ignored unless this keyword is present

platform <platform> OpenMM compute platform to use. Options are CUDA, OpenCL, Reference, and CPU.

Consult the OpenMM manual for more details.

precision <precision model> OpenMM precision model to use. Options are single, double, and mixed. Refer-
ence is always double and CPU is always single. The mixed precision model (default) uses single precision
for calculations and double for accumulation.

decompose By default, OpenMM does not decompose energy contributions to different terms (e.g., bond, an-
gle, torsion, etc.). If present, this keyword will make ParmEd break the energies down as much as possible
(OpenMM does not compute non-bonded energy terms separately, so Lennard-Jones, 1-4 nonbonded inter-
actions, and electrostatics will all be conﬂated into a single term). Energy terms are always decomposed
when not using the OpenMM API.

applayer If present, this keyword will write a temporary topology ﬁle and load an OpenMM system using the sup-
port classes bundled with OpenMM directly (rather than using ParmEd’s internal OpenMM System creator).
This is provided as a way to validate the agreement between OpenMM’s application layer and ParmEd.

14.2.2.22. go

Usage: go
Stop reading commands and execute every command that has come before. This has exactly the same effect as
the End Of File (EOF) character. All commands in a script after “go” will be ignored. Placing “go” as the last
line of a script is the same as not including it at all (since the next line contains EOF, which executes the same
behavior). Thus, you can get the same behavior from the interactive session by either typing “go” or sending the
EOF character (which on unix is CTRL-D)

270

14.2. ParmEd

14.2.2.23. gromber

Usage: gromber <top_ﬁle> [deﬁne <DEFINE[=VAR]>] [topdir <directory>] [radii <radiusset>]
Load a Gromacs topology ﬁle with parameters as an Amber-formatted system. Note, if your Gromacs topology

ﬁle requires any include topology ﬁles (as most do), you will need to have Gromacs installed for this to work.

• <top_file>: The Gromacs topology ﬁle to load

• <coord_file>: The coordinate ﬁle to load into the system. Can be any recognized format (GRO, PDB,

mmCIF, inpcrd, etc.)

• define <DEFINE[=VAR]>: Preprocessor deﬁnes that control the processing of the Gromacs topology ﬁle.

• topdir <directory>: The directory containing all Gromacs include topology ﬁles. This is only necessary

if Gromacs is not installed in a location that ParmEd can ﬁnd.

• radii <radiusset>: The GB radius set to use. Can be mbondi, bondi, mbondi2, or amber6. Default is

mbondi

Gromacs topology ﬁles do not store the unit cell information. Therefore, in order to make sure that unit cell
information is properly assigned to the resulting system, the provided <coord_file> should contain unit cell
information (e.g., GRO, PDB, PDBx/mmCIF, and inpcrd ﬁles can all store box information).

ParmEd will try to locate the Gromacs topology directory using either the GMXDATA or GMXBIN environment
variables (which should point to the $PREFIX/share/gromacs or $PREFIX/bin directories, respectively, where
$PREFIX is the install preﬁx). If neither is set, the topology directory is located relative to the location of the
gmx (Gromacs 5+) or pdb2gmx (Gromacs 4 or older) in the user’s PATH. If none of the above is true, the default
installation location (/usr/local/gromacs/share/gromacs/top) is used. Any provided topdir will override
default choices (but only for this particular command – future gromber actions will use the default location again).

You can provide as many deﬁnes as you wish, and the ordering you specify them is preserved. The default

value assigned to each deﬁne is "1". To provide multiple deﬁnes, use the keyword multiple times, for example:

define MYVAR=something define MYVAR2=something_else ...

It is important to note that Gromacs supports a much larger array of bonded potentials than Amber does. Gromacs
supports several different bonded potentials (cubic, quartic, and Morse, just to name a few), while Amber supports
only the simple harmonic bond potential. Similarly, Amber only supports quadratic angle potentials, periodic
torsions, and the 12-6 Lennard-Jones potential. Through the chamber extensions (see Sec. 14.2.2.8), Amber can
also support Urey-Bradley angle potentials, quadratic improper potentials, and correction map (CMAP) potentials.
Other potential energy functions Gromacs supports—like the Buckingham nonbonded potential—cannot be
computed in Amber and so will result in an error. ParmEd also currently only supports the Lorentz-Berthelot
combining rules, although support for the geometric combining rules is planned.

14.2.2.24. HMassRepartition

Usage: HMassRepartition [<mass>] [dowater]
This action implements hydrogen mass repartitioning in which the mass of each hydrogen is changed to <mass>
(the default value is 3.024 daltons if no mass is provided). The mass of the heavy atom that the hydrogen is attached
to is adjusted so that the total mass remains the same. This allows longer time steps to be taken in dynamics (see
the relevant literature regarding this approach; e.g., [381]). By default, partitioning is only applied to the solute
since SHAKE on water is handled analytically (via the SETTLE algorithm). Water can be forcibly repartitioned
using the keyword dowater.

14.2.2.25. help

Usage: help [action]
This command does one of two things. If action is not speciﬁed, a list of available commands along with their
short usage statement is displayed in a nicely formatted table. If action is provided and that action exists, a usage

271

14. Reading and modifying Amber parameter ﬁles

statement along with a short description is printed. This is a useful reference for quick interactive sessions. You
can use a single “?” character instead of the word ‘help’.

14.2.2.26. history

Usage: history
This command prints a list of the previous commands that were run in ParmEd. This can be useful if you want

to turn your interactive ParmEd session into a script (much like the history command works in the shell).

14.2.2.27. interpolate

Usage: interpolate <nparm> [parm2 <other_parm>] [eleconly] [preﬁx <preﬁx>] [startnum<num>]
This command can be useful to create topology ﬁles that are a linear combination of two topology ﬁles, speciﬁed
by <other_parm> and the currently active parm (which can be set for this action using the parm keyword). If only
two parms are loaded (see listParms, below), <other_parm> defaults to the inactive parm for this action.

The options are described below:

<nparm> Number of topology ﬁles that will be generated in addition to the two end-state parms.

parm2 <other_parm> The other topology ﬁle to use when interpolating prmtops (in addition to the active parm).

The selection here works the same as the parm keyword for every other action.

eleconly If present, this only interpolates the charge vectors. This is currently the only supported mode, although

van der Waals interpolation is planned for future versions.

preﬁx <preﬁx> The preﬁx of the prmtop ﬁle names that will be written by this action. Generated topologies will
be written as <prefix>.#, where # starts from <num> (see below) and increases by 1 for each parm. Default
is the name of the active parm.

startnum <num> The number to use as a sufﬁx for the ﬁrst generated parm. Default value is 1.

14.2.2.28. listParms

Usage: listParms
This command will list all of the topology ﬁle names for the topology ﬁles that have been loaded into the main

list, highlighting the active one.

14.2.2.29. lmod

Usage: lmod
This action adjusts the Lennard Jones parameters to work with the LMOD code in Amber. It changes Lennard-
Jones A-coefﬁcients that are 0 to 1000 to improve numerical stability. This action replaces the lmodprmtop pro-
gram.

14.2.2.30. loadCoordinates

Usage: loadCoordinates <ﬁlename>
This reads a coordinate ﬁle and loads the ﬁrst ste of coordinates found into the active structure. File type is

auto-detected, with supported ﬁle formats currently including:

• Amber restart ﬁle

• Amber NetCDF restart ﬁle

• CHARMM coordinate ﬁle

• CHARMM restart ﬁle

272

14.2. ParmEd

• Amber mdcrd trajectory ﬁle

• Amber NetCDF trajectory ﬁle

• PDB ﬁle

• PDBx/mmCIF ﬁle

For trajectories and PDB or mmCIF ﬁles with multiple models, the coordinates are taken from the ﬁrst frame or
model. Note, this is a generalization of the loadRestrt command, below.

14.2.2.31. loadRestrt

Usage: loadRestrt <restart_ﬁlename>
This command takes an inpcrd or a restart ﬁle to assign coordinates to each of the atoms. This is needed for any

commands that require coordinates.

14.2.2.32. ls

This is supposed to emulate the Unix ‘ls’ program as closely as possible, and can be used inside ParmEd in the

same way.

14.2.2.33. minimize

Usage: minimize [cutoff <cut>] [[igb <IGB>] [saltcon <conc>]] [[restrain <mask>] [weight <k>]] [norun]
[script <script_ﬁle.py>] [platform <platform>] [precision <precision model>] [tol <tolerance>] [maxcyc <cy-
cles>]

Uses OpenMM to minimize a structure. After this action, the coordinates stored in the topology ﬁle are updated
with the minimized coordinates (and the minimized structure will be written if a coordinate ﬁle is provided in the
outparm or parmout commands).

General options The following options apply to all systems

cutoff <cut> This is the non-bonded cutoff in Angstroms to use for the minimization. For periodic systems, the

default value is 8 Angstroms. For non-periodic systems, no cutoff is applied.

restrain <mask> If provided, the given mask will have Cartesian positional restraints applied with the given force

constant (see weight below)

weight <k> The restraint weight used in the positional restraints according to (14.21). Note that this force constant

is not scaled by 1/2 as it is in Hooke’s Law (so it is half the value of the corresponding force constant).

Erestraint = k (r− req)2

(14.21)

norun Do not run the minimization—just write the script and quit. If no script is requested, an error is raised and

nothing is done.

script <script_ﬁle.py> The name of a ﬁle in which to write a Python script that will perform the desired energy

minimization using OpenMM.

tol <tolerance> The tolerance to use to determine when to stop the minimization. Default is 0.001.

maxcyc <cycles> The maximum number of minimization cycles to use. By default there is no limit—the mini-

mization will run until the tolerance is reached.

273

14. Reading and modifying Amber parameter ﬁles

Implicit Solvent Options The following options apply only to implicit solvent simulations

igb <IGB> GB model to use. Allowed values are 0, 1, 2, 5, 6, 7, and 8. The values 0 and 6 indicate vacuum
electrostatics. The other values match the options available in sander, pmemd, and NAB (see pages 69 and
826 for more details).

saltcon <conc> Salt concentration (in Molarity) to use when using GB implicit solvent. See page 71 for more

information.

OpenMM-speciﬁc options These options specify some computational details of the OpenMM calculation.

platform <platform> OpenMM compute platform to use. Options are CUDA, OpenCL, Reference, and CPU.
Consult the OpenMM manual for more details. If you are using positional restraints, the CPU and Reference
platforms will be even slower compared to the OpenCL and CUDA platforms than usual.

precision <precision model> OpenMM precision model to use. Options are single, double, and mixed. Refer-
ence is always double and CPU is always single. The mixed precision model (default) uses single precision
for calculations and double for accumulation.

14.2.2.34. netCharge

Usage: netCharge [mask]
This command will calculate the net charge of all atoms belonging to a speciﬁc mask. If no mask is provided, it

returns the net charge of all atoms in the topology ﬁle.

14.2.2.35. OpenMM

Usage: OpenMM [sander/pmemd options] [-platform <platform>] [-precision <precision model>] [dcd]

[progress] [script <script_ﬁle.py>] [norun]

This action use OpenMM to run a molecular dynamics simulation in a mode very similarly to how sander or
pmemd would run the same simulation. It recognizes all of the same command-line options as sander and pmemd
in addition to the ones listed above. It will read an mdin ﬁle (given by the -i ﬂag) and run an equivalent simulation
(or as close to equivalent as possible) using the OpenMM Python application layer. See the OpenMM website
(https://simtk.org/home/openmm) and manual for more details. If a simulation cannot be done, an error message
is emitted.

The computational platform to use (CUDA, OpenCL, CPU, or Reference) can be provided as <platform>. By
default, the fastest platform detected will be used. The precision model can be used to specify the precision of the
variables that will be used as <precision model>. Currently supported options are “mixed” (single precision for
calculations, double precision for accumulation), “single” (everything is done in pure single precision), and “dou-
ble” (everything is done in pure double precision). As of OpenMM 6.0, only the CUDA and OpenCL platforms
support multiple precision models. CPU is always single and Reference is always double.

The default prmtop that will be used is the active topology ﬁle, although either the parm or -p ﬂags can be used
to specify a different one. The progress keyword makes ParmEd print a message when it starts a new phase of the
simulation.

The script keyword allows you to specify the name of a ﬁle in which a Python script that runs an equivalent
calculation that ParmEd is running is printed to. This allows you to both inspect what ParmEd is doing behind-the-
scenes with the OpenMM Python application layer as well as implement functionality not supported by Amber (but
supported by OpenMM) without having to do the potentially laborious setup beforehand. The latter is particularly
useful with the norun keyword, which will prevent ParmEd from running any dynamics or minimization.

The dcd keyword can be used to make ParmEd print the trajectory in DCD format. This is useful if you do not
have a NetCDF Python package installed (any of scipy, ScientiﬁcPython, or netCDF4 will work), but still wish to
generate a binary trajectory ﬁle.

See Chapter 19 and Chapter 20 for a more thorough description of the sander/pmemd options.
Some caveats for this action are listed below.

274

14.2. ParmEd

• The OpenMM package and the Python application layer must be installed and importable from the Python

environment. ParmEd supports only OpenMM version 6.0 or higher.

• OpenMM itself requires Python 2.6 or later, which in turn passes on this requirement to this command in

ParmEd.

• A NetCDF package for Python must be installed (for the Python interpreter used during the AmberTools
conﬁgure step) and available to either read or write NetCDF trajectories and restarts. Supported NetCDF-
Python packages are netCDF4, ScientiﬁcPython, or scipy (provided that the NetCDF bindings of those
packages are included in the install). The scipy package is recommended.

• Trajectory ﬁle and restart ﬁle writing from the Python application layer are very slow, especially for ASCII
versions of the ﬁles. NetCDF and DCD ﬁles are notably faster to write, but still incur signiﬁcant overhead.
Increasing the intervals for data printouts (ntpr, ntwx, ntwv, ntwf, and ntwr in the mdin ﬁle, for instance) can
signiﬁcantly improve computational performance, particularly for the GPU-enabled platforms.

• Not all features in sander and pmemd are supported, and not all unsupported options may be caught currently.

14.2.2.36. outCIF

Usage: outCIF <ﬁle> [norenumber] [anisou]
This will write a PDBx/mmCIF ﬁle from the currently active system. This is the new ﬁle format used by the

Protein Data Bank in preference to the traditional PDB ﬁle format. The various options are described below:
<ﬁle> The name of the PDBx/mmCIF ﬁle to write

norenumber If this keyword is given, the original atom and residue numbering from the input structure are used
rather than using the internal ordering used by Amber programs. If you used addPDB previously to add this
information to the prmtop, this keyword will respect the numbering in the original PDB ﬁle. This will also
work if you loaded your parm ﬁle from a PSF, PDB, or CIF ﬁle that may contain non-sequential numbering.

anisou If anisotropic B-factors are present, print them to the PDBx/mmCIF ﬁle.

14.2.2.37. outparm

Usage: outparm <prmtop_name> [<restrt_name>]
This command is just like parmout, except it can occur as many times as you want it to, and that topology ﬁle
is written in the order in which that command is placed in the input ﬁle or read from STDIN (similar to outtraj in
cpptraj). If you provide a ﬁle name for restrt_name, parmed will also write a valid restart ﬁle from the provided
initial coordinates and velocities (if present) from the restart ﬁle added via the loadRestrt command. It will include
velocities if they were present in the initial restart ﬁle. Note this is most useful when used in conjunction with the
“strip” command. If all solvent is stripped, the box information will be discarded. If you do not strip all solvent
molecules, the box info will remain unchanged from the original (even if you strip a large number of solvent
molecules). If you removed a large number of solvent molecules, take care to re-equilibrate the density before
continuing with production dynamics.

14.2.2.38. outPDB

Usage: outPDB <ﬁle> [norenumber] [charmm] [anisou]
This will write a PDBx/mmCIF ﬁle from the currently active system. This is the new ﬁle format used by the

Protein Data Bank in preference to the traditional PDB ﬁle format. The various options are described below:
<ﬁle> The name of the PDBx/mmCIF ﬁle to write

norenumber If this keyword is given, the original atom and residue numbering from the input structure are used
rather than using the internal ordering used by Amber programs. If you used addPDB previously to add this
information to the prmtop, this keyword will respect the numbering in the original PDB ﬁle. This will also
work if you loaded your parm ﬁle from a PSF, PDB, or CIF ﬁle that may contain non-sequential numbering.

275

14. Reading and modifying Amber parameter ﬁles

charmm If a CHARMM SEGID identiﬁer is loaded (either from the CHARMM PSF ﬁle or a CHARMM-modiﬁed

PDB ﬁle), print that to the PDB ﬁle

anisou If anisotropic B-factors are present, print them to the PDB ﬁle as ANISOU records.

14.2.2.39. parm

Usage: parm <ﬁlename> | parm set <ﬁlename>|<index>
If used with the “set” keyword, the active topology is changed to the one with the given ﬁle name or the <in-
dex>+1’th topology ﬁle that was loaded. If used without the “set” keyword, it adds a new topology ﬁle to the list
of available topologies from the given ﬁle name and sets that as the active topology for all future actions. (All
previous actions were already applied to the previous ‘active’ topology).

14.2.2.40. parmout

Usage: parmout <prmtop_name> [<restrt_name>]
This command is similar to trajout in cpptraj and ptraj. It is ALWAYS the last command executed, and only
the last parmout command is executed. It writes a topology ﬁle with all of the modiﬁcations made to it during
the course of the whole ParmEd session. If you provide a ﬁle name for restrt_name, parmed will also write a
valid restart ﬁle from the provided initial coordinates and velocities (if present) from the restart ﬁle added via the
loadRestrt command. It will include velocities if they were present in the initial restart ﬁle. Note this is most
useful when used in conjunction with the “strip” command. If all solvent is stripped, the box information will be
discarded. If you do not strip all solvent molecules, the box info will remain unchanged from the original (even if
you strip a large number of solvent molecules). If you removed a large number of solvent molecules, take care to
re-equilibrate the density before continuing with production dynamics.

14.2.2.41. printAngles

Usage: printAngles <mask> [<mask> [<mask>] ]
This will print out every angle that involves at least one atom speciﬁed by <mask>. If additional masks are
given, only the angles in which the three atoms are speciﬁed in each of the given masks (with the central atom
required to be in the second mask) are printed.

14.2.2.42. printBonds

Usage: printBonds <mask> [<mask>]
This will print out every bond that involves at least one atom speciﬁed by <mask>. If a second mask is given,

only bonds in which one atom appears in each mask will be printed.

14.2.2.43. printDetails

Usage: printDetails <mask>
This command prints atomic details of every atom matching a given mask (atom number, residue number, residue
name, atom name, atom type, van der Waals radius, van der Waals well depth, mass, and charge) in standard Amber
units. This is a useful command to make sure that every atom you think belongs in a mask actually does belong
in the mask (and that no atoms were missed). The mask parser implemented in Python here is (mostly) a copy of
ptraj’s mask parser implemented in C, but some parts had to be rewritten slightly to adjust for different syntaxes of
the two languages. Note, distance-based criteria is not yet implemented in this parser.

14.2.2.44. printDihedrals

Usage: printDihedrals <mask> [<mask> [<mask> [<mask>] ] ]
This will print out every dihedral that involves at least one atom speciﬁed by <mask>. It labels dihedrals in
which end-group interactions are omitted (either because they are in a multiterm dihedral or a ring) with an M and

276

14.2. ParmEd

improper dihedrals with an I in the output. If multiple masks are given, only dihedrals that have one atom in each
mask are printed. Ordering is important here, so the ﬁrst atom must be in the ﬁrst mask, the second atom in the
second, etc. The order can be precisely reversed, but no other ordering is recognized.

14.2.2.45. printFlags

Usage: printFlags
This command prints every %FLAG present in the topology ﬁle (see http://ambermd.org/FileFormats.php for a

description of what each section labelled with these FLAGs means).

14.2.2.46. printInfo

Usage: printInfo <ﬂag>
This command just prints out all of the data in a given prmtop %FLAG (see http://ambermd.org/FileFormats.php

for details)

14.2.2.47. printLJMatrix

Usage: printLJMatrix <mask>
This function prints out how every atom type interacts with the atom type(s) in <mask>.

14.2.2.48. printLJTypes

Usage: printLJTypes [mask]
This command prints out each atom’s van der Waals, or Lennard-Jones type in the mask, as well as every other
atom that shares the same atom type as any type in the mask. If no mask is provided, it prints out that information
for every atom. This is particularly useful if you want to see if changing a particular pair interaction will affect
more atoms than you expect. If it turns out that you wish to treat some of the atoms that share the same VDW type
differently from one another, you will have to “separate” them by using the addLJType command before modifying
them.

14.2.2.49. printPointers

Usage: printPointers
This command will print every pointer along with its name and a short description in the topology ﬁle. Solvated

topology ﬁles will also have their SOLVENT_POINTERs printed in the same manner.

14.2.2.50. quit

Usage: quit
This command will halt parmed in its tracks. It is effectively the same as go except it will NOT execute any

parmout command (although any outparm command used prior to quitting has already been executed)

14.2.2.51. scale

Usage: scale <FLAG> <factor>
This action scales all numbers in the FLAG section of the topology ﬁle by multiplying it by the number <factor>.
This can be used, for instance, to scale all of the torsion force constants by a particular value in a Hamiltonian
replica exchange simulation. [382]

277

14. Reading and modifying Amber parameter ﬁles

14.2.2.52. scee

Usage: scee <value>
Allows the user to set/change the value of the electrostatic scaling constant that will be used to scale 1-4 elec-
trostatic interactions. This needs to be set in the prmtop since it was removed from the sander/pmemd input ﬁle in
Amber 11. This will apply <value> to all dihedral terms.

14.2.2.53. scnb

Usage: scnb <value>
Allows the user to set/change the value of the VDW scaling constant that will be used to scale 1-4 VDW
interactions. This needs to be set in the prmtop since it was removed from the sander/pmemd input ﬁle in Amber
11. This will apply <value> to all dihedral terms.

14.2.2.54. setAngle

Usage: setAngle <mask1> <mask2> <mask3> <k> <THETeq>
Changes (or adds a non-existent) angle in the topology ﬁle. Each mask must select the same number of atoms,
and an angle will be placed between the atoms in mask1, mask2, and mask3 (one angle between atom1 from mask1,
atom1 from mask2, and atom1 from mask3, another angle between atom2 from mask1, atom2 from mask2, and
atom2 from mask3, etc.)

14.2.2.55. setBond

Usage: setBond <mask1> <mask2> <k> <Req>
Changes (or adds a non-existent) bond in the topology ﬁle. Each mask must select the same number of atoms,
and a bond will be placed between the atoms in mask1 and mask2 (one bond between atom1 from mask1 and
atom1 from mask2 and another bond between atom2 from mask1 and atom2 from mask2, etc.)

14.2.2.56. setMolecules

Usage: setMolecules [solute_ions=True|False]
This command uses its own algorithm to determine system molecularity (which resets SOLVENT_POINTERS
and ATOMS_PER_MOLECULE to what they should have been set to by leap). It will also determine if there
are any errors in which molecules are not represented as consecutive atoms within a topology ﬁle (which won’t
happen unless you modify it yourself or there is a bug in tleap that prevents it from reordering atoms properly).
However, in some unusual systems, tleap has been known to set the molecularity incorrectly, leading to strange
segfaults and errors in sander and pmemd. Errors of this type can be caught with checkValidity and corrected using
this command. It will also allow you to choose whether free ions are treated as part of the solute or part of the
solvent.

14.2.2.57. setOverwrite

Usage: setOverwrite [True|False]
Allows the original topology ﬁle to be overwritten. By default, the original prmtop ﬁle is protected, and you
cannot overwrite it. If you provide no value on this line, then it defaults to True. Note that no check is made if you
are overwriting any other existing ﬁle (just the original topology).

14.2.2.58. source

Usage: source <ﬁle>
Loads a ﬁle with a list of ParmEd commands and executes them immediately.

278

14.2. ParmEd

14.2.2.59. strip

Usage: strip <mask> [nobox]
This will strip every atom that corresponds to the given atom mask out of the topology ﬁle altogether. Any bond,
angle, or dihedral that it is a part of will be deleted as well. The bond, angle, and dihedral types that are no longer
referenced after the atoms are stripped out are deleted from the topology ﬁle. All Lennard Jones parameters are
kept, however, even if they are no longer used. In this way, any LJ modiﬁcations you did before the strip command
will remain intact. The nobox keyword will make ParmEd delete the unit cell information from the topology ﬁle.
This is necessary if you intend to use the resulting topology ﬁle for aperiodic simulations (e.g., using GB implicit
solvent).

14.2.2.60. summary

Usage: summary
This command prints out a summary of topology ﬁle contents. If coordinates are present, more information is

given (like system density). An example of the output is shown below:

Pure water:

0
Amino Acid Residues:
Nucleic Acid Residues: 0
0
Number of cations:
Number of anions:
0
Num. of solvent mols: 4096
Num. of unknown atoms: 0
Total charge (e-):
Total mass (amu):
Number of atoms:
Number of residues:
System volume (ang^3): 122023.94
System density (g/mL): 1.004222

0.0000
73793.5360
12288
4096

Implicit solvent protein system:

108

Amino Acid Residues:
Nucleic Acid Residues: 0
Number of cations:
0
Number of anions:
0
Num. of solvent mols: 0
Num. of unknown atoms: 0
Total charge (e-):
Total mass (amu):
Number of atoms:
Number of residues:

-4.0000
11669.4360
1654
108

14.2.2.61. tiMerge

Usage: tiMerge <mol1mask> <mol2mask> <scmask1> <scmask2> [<scmask1N>] [<scmask2N>] [<tol>]
This will remove redundant bonding terms and atoms from prmtop ﬁles for use in thermodynamic integra-
tion calculations with PMEMD. The input topology should have two molecules corresponding to V0 and V1.
mol1mask/mol2mask are the atom masks for the molecules that should be merged (for V0 and V1 respectively).
scmask1/scmask2 are the atom masks that list the unique atoms within the molecules to be merged. These do not
necessarily have to be soft core atoms. For instance, removing the charges on a residue in a protein requires two
copies of that residue in the prmtop ﬁle. These masks can be set to that residue. All atoms not in scmask1/scmask2
but in mol1mask/mol2mask should be the same, as these are considered common atoms. Any bonding terms which
involve scmask atoms will be kept, but any extra terms will be removed. scmask1N/scmask2N are only used for

279

14. Reading and modifying Amber parameter ﬁles

atoms that will not be merged. These atoms will be included in the masks for output, so that additional soft core
molecules that should not be merged do not have to be manually renumbered. tol speciﬁes how close the coor-
dinates have to be for the atoms in V0 and V1 to be considered the same. See Subsection 23.1.8 for a complete
description of thermodynamic integration in PMEMD as well as an example of this command.

14.2.2.62. writeFrcmod

Usage: writeFrcmod <frcmod_name>
This command will dump a complete frcmod ﬁle containing every parameter in your topology ﬁle. (Note that
the effects of a changeLJPair command will NOT be reﬂected in the topology ﬁle unless the pair you choose
is between two atoms with the same VDW type, in which case it will alter all pair interactions with that atom
type). It assumes the canonical Amber combining rules for VDW terms (Lorentz-Berthelot), and uses each type’s
interaction with itself to extract the well depths and VDW radii.

14.2.2.63. writeOFF

Usage: writeOFF <OFF_File>
Writes an Amber OFF (library) ﬁle containing every residue, including terminal residues, found in a given

topology ﬁle. You must have loaded a coordinate ﬁle before running this command.

14.2.3. Examples

This section outlines a couple of example input ﬁles for parmed with comments describing what each command
does. You can try these examples on the test parameter ﬁles in $AMBERHOME/AmberTools/test/parmed (either
the normal_prmtop/trx.prmtop or the chamber_prmtop/dhfr_gas.prmtop).



Example 1



# This file generates a topology file with the new mbondi3 radii
# optimized for the igb = 8 GB model and changes the charge set
# of LYS 3 (trx.prmtop) to set up for a FEP-like calculation.
# In practice you would need more than just the protonated and
# deprotonated state (you would have to interpolate), but this
# is just a demonstration.

# Change to mbondi3
changeRadii mbondi3

# Output the first topology file
outparm trx_mbondi3_state0.parm7

# Change the charges of the LYS
change charge :3@N -0.3479
change charge :3@H 0.2747
change charge :3@CA -0.24
change charge :3@HA 0.1426
change charge :3@CB -0.10961
change charge :3@HB2,HB3 0.034
change charge :3@CG 0.06612
change charge :3@HG2,HG3 0.01041
change charge :3@CD -0.03768
change charge :3@HD2,HD3 0.01155
change charge :3@CE 0.32604
change charge :3@HE2,HE3 -0.03358
change charge :3@NZ -1.03581

280

14.2. ParmEd

change charge :3@HZ1 0
change charge :3@HZ2,HZ3 0.38604
change charge :3@C 0.7341
change charge :3@O -0.5894

# Output the second topology file
outparm trx_mbondi3_state1.parm7




Example 2

# This file generates a topology file in which the L-J
# interactions between atoms 10 and 28 have been removed,
# and the L-J interactions between atoms 40, 41, 42, and
# 57 with everybody else has been removed.

# Make atoms 10 and 28 new LJ types, but keep their original
# well depths and radii
addLJType @10
addLJType @28

# Zero the interaction between them
changeLJPair @10 @28 0.0 0.0

# Make atoms 40, 41, 42, and 57 a new LJ type with 0s for
# their parameters to remove all of their LJ interactions
# with every other atom
addLJType @40-42,57 radius 0.0 epsilon 0.0

# Write the final topology file. This statement could have
# been put anywhere
parmout altered_LJ.parm7



14.2.4. Converting Amber ﬁles to gromacs and CHARMM

Pengfei Li has prepared some simple python scripts that use ParmEd to convert Amber prmtop ﬁle to gromacs

and CHARMM formats:



amb2chm_psf_crd.py

Usage: amb2chm_psf_crd.py -p prmtop -c inpcrd -f psf

-d crd -b pdb [--dict dict_file]

Options:

-h, --help
-p PRMTOP
-c INPCRD
-f PSF
-d CRD
-b PDB
--dict=DICF Dictionary file name

show this help message and exit
Prmtop file
Inpcrd file
PSF file
CRD file
A PDB file to generate



The program will generate a new PDB ﬁle (the -b option). This ﬁle will have residue and atom names consistent

with the generated PSF and CRD ﬁles. This ﬁle is for user’s reference.

281


















14. Reading and modifying Amber parameter ﬁles



amb2chm_par.py

Usage: amb2chm_par.py -i input_file [-f input_file_option]

-o output_file [--nat use_new_attype]

Options:

-h, --help
-i INPUTF
-f FOPT

show this help message and exit
The input file
The input file is a parameter file (1) or just contains file
names (2) [default: 2]
The output file

-o OUTPUTF
--nat=NEWTYPE Whether to perform atom type transfer [0 means no, 1 means

yes, default: 1]



For the -f option, users can specify it as 1 or 2. 1 means there is only one AMBER dat/frcmod ﬁle to convert
to CHARMM PAR ﬁle and this ﬁle name follows the -f option. 2 means there are multiple AMBER dat and/or
frcmod ﬁles to convert to one single CHARMM PAR ﬁle and the ﬁle follows the -f option is the ﬁle containing the
dat and/or frcmod ﬁle names (with each dat/frcmod ﬁle name is in an independent line). This is the default setting.
For the --nat option, users can specify it as 0 or 1. 0 means atom type transfer will not be made. Which means
the PAR ﬁle will keep the AMBER atom types. 1 means atom type transfer will be made. Which means the PAR
ﬁle will have the atom types compatible with the CHARMM force ﬁeld. This is the default setting.



amb2gro_top_gro.py

Usage: amb2gro_top_gro.py -p prmtop -c inpcrd -t top

-g gro -b pdb

Options:

-h, --help
-p PRMTOP
-c INPCRD
-t TOP
-g GRO
-b PDB



show this help message and exit
Prmtop file
Inpcrd file

GROMACS top file
GROMACS gro file

A PDB file to generate

The program will generate a new PDB ﬁle (the -b option). This ﬁle will have residue and atom names consistent

with the generated top and gro ﬁles. This ﬁle is for user’s reference.

14.2.5. xparmed

To aid in simple tasks and make single- (or few-) prmtop ﬁle changes easier, a GUI version of ParmEd is
available. It uses the Tk/Python graphical toolkit interface (called Tkinter). Tkinter is part of the standard Python
library, but not all operating systems provide it with their system Python. The package names recognized by
different package managers (e.g. apt-get, port, and yum) vary from system to system, and are detailed in the
section below separated by common operating systems that have been tested by developers.

The GUI is very basic with a number of limitations. For instance, windows cannot be resized (but should ﬁt on
most standard terminals and should be sized appropriately). Furthermore, if an information window is present, the
application will not end with the “Exit xParmEd” button until all information windows are closed. For scripting
purposes, the text-based version, parmed, should be used instead.

14.2.5.1. Tkinter on Ubuntu (Debian)

To install Tkinter on Ubuntu (the package name on other Debians may differ), use the following command: sudo

apt-get install python-tk

282

14.2. ParmEd

14.2.5.2. Tkinter on Red Hat

To install Tkinter on Red Hat (and CentOS and Fedora, probably), use the following command: sudo yum install

tkinter

14.2.5.3. Tkinter on Mac OS X

The default Python installation on Mac OS X has Tkinter installed by default. In fact, it’s a much ’prettier’
version because it is built on top of Apple’s GUI toolkits, which makes it look like a native Mac application. You
can force Amber programs to use the Mac system Python by specifying /usr/bin/python as the default python to
conﬁgure. If you wish to use a Python installed via MacPorts, you will need to also install the corresponding
tkinter port. For instance, if you installed Python 2.7 from MacPorts and wish to use that, you will also need to
install py27-tkinter.

14.2.5.4. Tkinter on Everything Else

If your system does not already have Tkinter installed, and none of the above helps you, you should consult a

search engine or online forums. If it doesn’t exist, you may have to stick with parmed.

14.2.6. Advanced Options

This section describes some of the advanced options in parmed. Note these are not generally available in

xparmed

14.2.6.1. Interactive Python Shell

To increase ParmEd’s ﬂexibility, you can activate an limited, interactive Python interpreter to inject your own

custom Python code into parmed’s normal execution. This brings with it the risk that custom code can be
malicious if untrusted, so custom code evaluation is disallowed by default. To enable it, use the “-e” or
“–enable-interpreter” command-line ﬂag when executing parmed. To improve security, import statements are
disallowed, although the math module has been imported for basic mathematical operations. To execute a single
instruction, begin the command with a “!”. In this case, leading whitespace is eliminated (so leading tabs/spaces
are ignored here). For example,

bash $ parmed -e -n trx.prmtop
Loaded Amber topology file trx.prmtop

Reading input from STDIN...
> !print amber_prmtop.parm.parm_data[’ATOM_NAME’][0:10]
[’N’, ’H1’, ’H2’, ’H3’, ’CA’, ’HA’, ’CB’, ’HB2’, ’HB3’, ’OG’]

To execute a formatted block of code that requires more than one line, use “!!” to indicate to ParmEd that you
wish to drop to interpreter mode. Terminate that block of code with another “!!” line. The prompt in STDIN-mode
changes to “py >>>”. For example:





bash$ parmed -e -n trx.prmtop
Loaded Amber topology file trx.prmtop

Reading input from STDIN...
> !!
py >>> def formatted_print(items):
py >>>
py >>>
py >>>
py >>>
py >>>

print '%10.4f ' % item,
i += 1
if i % 5 == 0: print ''

i = 0
for item in items:

283

14. Reading and modifying Amber parameter ﬁles

print ''

py >>>
py >>>
py >>> formatted_print(amber_prmtop.parm.parm_data['CHARGE'][0:10])
py >>> !!

0.1849
0.0782

0.1898
0.2596

0.1898
0.0273

0.1898
0.0273

0.0567
-0.6714



> quit
Quitting.



The main topology class list being worked on is called amber_prmtop. The currently ‘active’ topology ﬁle is
the ‘parm’ attribute of the list. You can also access speciﬁc topology ﬁles using an integer index or the original
prmtop name. See the API documentation below if you are interested in making custom modiﬁcations. Note that
it is VERY easy to break a topology ﬁle with this approach, so consider this an advanced option. A description of
the topology ﬁle format can be found on http://ambermd.org/FileFormats.php.

WARNING: Variable declarations you make here drop onto the top-level namespace in ParmEd’s normal op-
erating environment. That is, any variable you declare here MIGHT override a critical one for ParmEd. Variable
names to avoid using include any of the Python built-in functions and types as well as line, code, debug, actions,
ParmError, LineToCmd, AmberParm, output_parm, and input.

14.2.6.2. Extending ParmEd

This section describes what is necessary to add a new action to ParmEd.
All actions are parsed from the actions.py ﬁle in $AMBERHOME/AmberTools/src/parmed/parmed/tools direc-
tory. Each action must be its own class that inherits from Action and takes an ArgumentList as its ﬁrst argument
in its init method. All arguments should be extracted from the ArgumentList using its get_next_<type>,
get_key_<type>, and has_key methods (the get_key_<type> and has_key methods should be called ﬁrst). See
existing methods as examples. You also need to take care to write the class doc-strings (the string immediately
following every class declaration) to be as helpful as possible, because they are used in the help function. You
must also add your command’s usage statement in the Usages dictionary found at the top of ParmedActions.py,
or it will be invisible to the help function and interpreter tab-autocompletion. The command name is taken as the
ﬁrst argument from that usage string.

No further action is necessary to add your functionality to ParmEd (and you should never have to edit parmed
directly – any class put in actions.py is immediately accessible by parmed as long as it inherits from the Action
base class). Existing actions provide helpful examples if you choose to expand ParmEd.

Extending xParmEd: Any action that is added to actions.py will be visible as buttons in xparmed, but
will be disabled by default unless you implement that action directly. There is no well-deﬁned standard for
implementing actions in the GUI version like there is in the text-based version. GUI actions are deﬁned in
$AMBERHOME/AmberTools/src/parmed/parmed/tools/gui/_guiactions.py, and all additional actions must
be deﬁned there. You should only have to modify _guiactions.py, since the GUI is automatically sized and
ﬁlled based on classes in actions.py. The best advice I can give if you want to expand xParmEd is to copy the
class that does a similar task and modify it for your class. The related examples are fairly consistent in their style
of implementation, so hopefully it is easy enough to add actions quickly.

14.2.6.3. ParmEd API

ParmEd is a rapidly changing program, and keeping comprehensive API documentation up-to-date is beyond
the scope of this manual. Please see https://parmed.github.io/ParmEd for project documentation if you wish to use
the ParmEd API in your own Python scripts. The documentation there is generated automatically from the source
code and is kept up-to-date with the latest version. That said, you may ﬁnd it useful to use some of the ParmEd
commands described previously in your own Python scripts. This is described in the following paragraphs.

The actions in this version of ParmEd have been generalized to make it easy to incorporate them into your own
Python scripts. To gain access to the actions, you must import them from the ParmedTools package. The Action
class names are identical to the names printed in Subsection 14.2.2. When cast to a string, the action instance will

284

14.2. ParmEd

output what it has done (or will do). The execute method bound to each Action instance will actually carry out the
action on the speciﬁed topology ﬁle.

You can instantiate a new action in one of two ways, but the ﬁrst argument must be an AmberParm (or ParmList)
instance in both cases. Then, you can either load a single string with all of the options and key words (the same
way as you would type it in parmed), or you can enter each argument independently with keywords being added
appropriately.

An example showing how to add a new Lennard-Jones atom type is shown below using both techniques described



above.

import os
import sys
from parmed.amber import AmberParm
from parmed.tools import addLJType

parm = AmberParm('trx.prmtop')

act = addLJType(parm, '@1 radius 0.0 epsilon 0.0')
act.execute()
print 'I just did:\n%s' % act

parm.writeParm('trx_modified.prmtop')

# The following code does the same thing
parm = AmberParm('trx.prmtop')

act = addLJType(parm, '@1', radius=0.0, epsilon=0.0)
act.execute()
print 'I just did:\n%s\n\t...again.' % act

parm.writeParm('trx_modified_2.prmtop')







285

15. Antechamber and GAFF

These are a set of tools to generate ﬁles for organic molecules and for some metal centers in proteins, which
can then be read into LEaP. The Antechamber suite was written by Junmei Wang, and is designed to be used in
conjunction with the general AMBER force ﬁeld (GAFF) (gaff.dat).[383] See Ref. [384] for an explanation of the
algorithms used to classify atom and bond types, to assign charges, and to estimate force ﬁeld parameters that may
be missing in gaff.dat. The python Metal Site Modeling Toolbox (pyMSMT) software package was developed by
Pengfei Li, and is described in Section17.

Like the traditional AMBER force ﬁelds, GAFF uses a simple harmonic function form for bonds and angles.
Unlike the traditional AMBER force ﬁelds, atom types in GAFF are more general and cover most of the organic
chemical space. In total there are 33 basic atom types and 22 special atom types. The charge methods used in
GAFF can be HF/6-31G* RESP or AM1-BCC.[385, 386] The force ﬁeld parametrization was performed entirely
with HF/6-31G* RESP charges. However, in most cases, AM1-BCC, which was parametrized to reproduce HF/6-
31G* RESP charges, is recommended in large-scale calculations because of its efﬁciency. (Note that in AM1-BCC,
the QM electrostatic potentials that were used as ﬁtting targets were created in a very slightly different manner and
then compared to RESP charges, using different scaling factors (i.e. 0.001/0.01 [386] versus 0.0005/0.001 [387].)
The van der Waals parameters are the same as those used by the traditional AMBER force ﬁelds. The equilibrium
bond lengths and bond angles came from ab initio calculations at the MP2/6-31G* level and statistics derived
from the Cambridge Structural Database. The force constants for bonds and angles were estimated using empirical
models, and the parameters in these models were trained using the force ﬁeld parameters in the traditional AMBER
force ﬁelds. General torsional angle parameters were extensively applied in order to reduce the huge number of
torsional angle parameters to be derived. The force constants and phase angles in the torsional angle parameters
were optimized using our PARMSCAN package,[388] with an aim to reproduce the rotational proﬁles depicted
by high-level ab initio calculations (geometry optimizations at the MP2/6-31G* level, followed by single point
calculations at MP4/6-311G(d,p)).

By design, GAFF is a complete force ﬁeld (so that missing parameters rarely occur); it covers almost all the
organic chemical space that is made up of C, N, O, S, P, H, F, Cl, Br and I. Moreover, GAFF is totally compatible
with the AMBER macromolecular force ﬁelds. It should be noted that GAFF atom types, except metal types,
are in lower case, while AMBER atom types are always in upper case. This feature makes it possible to load
both AMBER protein/nucleic acid force ﬁelds and GAFF without any conﬂict. One can even merge the two
kinds of force ﬁelds into one ﬁle. The combined force ﬁelds are capable of studying complicated systems that
include both proteins/nucleic acids and organic molecules. We believe that the combination of GAFF with AMBER
macromolecular force ﬁelds will provide a useful molecular mechanical tool for rational drug design, especially in
binding free energy calculations and molecular docking studies. Since its introduction, GAFF has been used for
a wide range of applications, including ligand docking,[389] bilayer simulations,[390, 391] and the study of pure
organic liquids [392].

15.1. Principal programs

The antechamber program itself is the main program of Antechamber. If your molecule falls into any of several
fairly broad categories, antechamber should be able to process your PDB ﬁle directly, generating output ﬁles
suitable for LEaP. Otherwise, you may provide an input ﬁle with connectivity information, i.e., in a format such
as Mol2 or SDF. If there are missing parameters after antechamber is ﬁnished, you may want to run parmchk2 to
generate a frcmod template that will assist you in generating the needed parameters.

286

15.1.1. antechamber

15.1. Principal programs

This is the most important program in the package. It can perform many ﬁle conversions, and can also assign
atomic charges and atom types. As required by the input, antechamber executes the following programs: sqm (or,
alternatively, mopac or divcon), atomtype, am1bcc, bondtype, espgen, respgen and prepgen. It typically produces
many intermediate ﬁles; these may be recognized by their names, in which all letters are upper-case.
If you
experience problems while running antechamber, you may want to run the individual programs that are described
below (to facilitate this run antechamber with the option ’-s 2’).



Antechamber options:



-help print these instructions
-i input file name
-fi input file format
-o output file name
-fo output file format
-c charge method
-cf charge file name
-nc net molecular charge (int)
-a additional file name
-fa additional file format
-ao additional file operation

crd : only read in coordinate
crg: only read in charge
radius: only read in radius
name : only read in atom name
type : only read in atom type
bond : only read in bond type

-m multiplicity (2S+1), default is 1
-rn residue name, if not available in the input file
-rf residue topology file name in prep input file, default is molecule.res
-ch check file name in gaussian input file, default is molecule
-ek QM program (mopac or sqm) keyword (in quotes); overwrites previous keywords.
-gk gaussian keyword in a pair of quotation marks
-gm gaussian assign memory, inside a pair of quotes, such as "%mem=1000MB"
-gn gaussian assign number of processor, inside a pair of quotes, such as "%nproc=8"
-gv add keyword to generate gesp file (for Gaussian 09 only) 1: yes; 0: no, the default
-ge gaussian esp file generated by iop(6/50=1), default is g09.gesp
-df use divcon flag,
-at atom type

0 - use mopac; 2 - use sqm (the default)

gaff : the default
gaff2: for GAFF, version 2
amber: for PARM94/99/99SB
bcc : for AM1-BCC
sybyl: for atom types used in sybyl

-du check atom name duplications, can be yes(y) or no(n), default is yes
-bk 4-character component Id, for ccif
-j atom type and bond type prediction index, default is 4

0 : no assignment
1 : atom type
2 : full bond types
3 : part bond types
4 : atom and full bond type
5 : atom and part bond type

-eq equalize atomic charge, default is 1 for '-c resp' and '-c bcc'

0 : no equalization
1 : by atomic paths

287

15. Antechamber and GAFF

2 : by atomic paths and geometry, such as E/Z configurations

-s status information, can be 0 (brief), 1 (the default) and 2 (verbose)
-pf remove the intermediate files: can be yes (y) and no (n, default)
-pl maximum path length to determin equivalence of atomic charges for resp and bcc.

The smaller the value, the faster the algorithm, default is -1 (use full length),
set this parameter to 10 to 30 if your molecule is big (# atoms >= 100)

-dr acdoctor mode: validate the input file a la acdoctor, yes(y, default) or no(n)

-i -o -fi and -fo must appear in command lines and the others are optional

Use 'antechamber -L' to list the supported file formats and charge methods




List of the File Formats:

mol2
mpdb
prepc

file format type abbre. index | file format type abbre. index
---------------------------------------------------------------
ac
Antechamber
pdb
PDB
AMBER PREP (int)
prepi
Gaussian Z-Matrix gzmat
Mopac Internal
Gaussian Output
Alchemy
MDL
AMBER Restart
Jaguar Z-Matrix
Divcon Input
SQM Input
Charmm
--------------------------------------------------------------

| Sybyl Mol2
| Modified PDB
| AMBER PREP (car)
| Gaussian Cartesian gcrt
| Mopac Cartesian
| Mopac Output
| CSD
| Hyper
| Jaguar Cartesian
| Jaguar Output
| Divcon Output
| SQM Output
| Gaussian ESP

1
3
5
7
9
mopint
11
gout
13
alc
15
mdl
17
rst
19
jzmat
21
divcrt
sqmcrt
23
charmm 25

2
4
6
8
mopcrt 10
mopout 12
14
csd
16
hin
18
jcrt
jout
20
divout 22
sqmout 24
gesp
26



AMBER restart ﬁle can only be read in as additional ﬁle



List of the Charge Methods:

abbre.

index | charge method

charge method
----------------------------------------------------------------
RESP
CM1
ESP (Kollman)
Gasteiger
Write out charge
----------------------------------------------------------------

AM1-BCC
CM2
Mulliken
Read in charge
Delete Charge

resp
cm1
esp
gas
wc

bcc
cm2
mul
rc
dc

2
4
6
8
10

1
3
5
7
9

|
|
|
|
|

abbre.



Examples:

The basic use of antechamber is to pick input and output ﬁles and formats (via the -i, -fi, -o, -fo ﬂags) ,

and choose various options for charge models, atom types, etc. A typical use would be:

antechamber -i my.pdb -fi pdb -o my.mol2 -fo mol2 -c bcc -nc 1

The only “tricky” part is in generating resp charges, which requires interacting with the Gaussian program, and
which varies depending on the version:

288










15.1. Principal programs

Using Gaussian 98 files as input:
(1) antechamber -i g98.out -fi gout -o sustiva_resp.mol2 -fo mol2 -c resp -eq 2
(2) antechamber -i g98.out -fi gout -o sustiva_cm2.mol2 -fo mol2 -c cm2

Using Gaussian03 files as input:
(11)antechamber -i g03.out -fi gout -o mtx.mol2 -fo mol2 -c resp

-a mtx.pdb -fa pdb -ao name

Using Gaussian09 (version b1 and beyond):
(12)antechamber -i ch3I.mol2 -fi mol2 -o gcrt.com -fo gcrt -gv 1 -ge ch3I.gesp

run Gaussian09 with gcrt.com as input
antechamber -i ch3I.gesp -fi gesp -o ch3I_resp.mol2 -fo mol2 -c resp -eq 2

The following is the detailed explanations of some ﬂags

-nc This ﬂag speciﬁes the net charge of the input molecule, otherwise, the net charge is read in from the input
directly (such as gout, mopout, sqmout, sqmcrt, gcrt, etc.) or calculated by summing the partial charges
(such as mol2, prepi, etc).

-a,-fa,-ao Sometimes, one wants to read additional information from another ﬁle other than the input, the ’-ao’
ﬂag informs the program to read in which information from the additional ﬁle speciﬁed with ’-a’ ﬂag. In
Example (11), a mol2 ﬁle is generated from a Gaussian output ﬁle with atom names read in from a pdb ﬁle.

-ch,-gk,-gm,-gn Those ﬂags specify the keywords and resource usage in Gaussian calculations

-ge,-gv The ’-ge’ ﬂag speciﬁes the ﬁle name of gesp ﬁle generated using iop(6/50=1) with Gaussian 09; the -gv
ﬂag speciﬁes the Gaussian version and the default is ’1’ for Gaussian 09. If one wants to generate Gaussian
input ﬁles (gcrt and gzmat) for older Gaussian versions, ’-gv’ must be set to ’0’.

-rn The ’-rn’ line speciﬁes the residue name to be used; thus, it must be one to three characters long.

-at This ﬂag is used to specify whether atom types are to be created for the GAFF force ﬁeld or for atom types
consistent with parm94.dat and parm99.dat (i.e., the AMBER force ﬁelds). If you are using antechamber
to create a modiﬁed residue for use with the standard AMBER parm94/parm99 force ﬁelds, you should set
this ﬂag to “amber”; if you are looking at a more arbitrary molecule, set it to “gaff”, even if the molecule is
intended for use as a ligand bound to a macromolecule described by the AMBER force ﬁelds.

-j This ﬂag instructs the program how to run ’bondtype’ and ’atom type’. ’-j 1’ assumes the bond types already
exists; ’-j 4’ ﬁrst predicts the connectivity table, then assigns bond and atom types sequentially; ’-j 5’ reads
in connectivity table from the input and then run ’bondtype’ and ’atomtype’ sequentially. In most situations,
’-j 4’, the default option, is recommended. However, ’-j 5’ should be used if the input structure is not good
enough and it includes the bond connectivity information (such as mol2, mdl, gzmat, etc.)

-eq This ﬂag speciﬁes how to do charge equilibration. With ’-eq 1’, atomic charge equilibration is predicted
only by atom paths, in another word, if two or more atoms have exactly same sets of atom paths, they are
equivalent and their charges are forced to be same. While ’-eq 2’ predicts charge equilibration using both
atom paths and some geometrical information (E/Z conﬁguration). With the ’-eq 2’ option, the charges
of two hydrogen atoms bonded to the No 2 carbon of chloroethene are different as they adopt different
conﬁgurations to chlorine (one is cis and the other is trans). Similarly, the two amide hydrogen atoms of
acetamide do not share the same partial charge as the amide bond cannot rotate freely. To back-compatible
to the older versions, the default is set to ’1’

In Example (12), a gcrt ﬁle of iodine methane is generated and a gesp ﬁle named ch3I.gesp is produced when
running Gaussian 09 with the default keyword. In Examples (13-15), RESP charges are generated for acetamide
using different charge equilibration options. In the following table, the charges are listed for comparison purposes.

289

15. Antechamber and GAFF



atom names

eq

|
|no equalization

=

0

eq

|
1
|atomic paths

=

eq = 2

| + geometry

--------------------------------------------------------------------------
methyl carbon
methyl hydrogen
carbonyl carbon
oxygen
nitrogen
amide hydrogen
--------------------------------------------------------------------------

| -0.5516
|-0.5190
0.1470
| 0.1412/0.1380/0.1396 |
|
| 0.9673
0.9786
| -0.6463
|-0.6468
| -1.1219
|-1.1189
| 0.4556/0.4429
|
0.4501

| -0.5193
|
0.1397
|
0.9673
| -0.6468
| -1.1189
| 0.4556/0.4429



15.1.2. parmchk2





parmchk2 reads in an ac/mol2/prepi/prepc ﬁle, an atomtype similarity index ﬁle (the default is $AMBERHOME-
/dat/antechamber/PARMCHK.DAT) as well as a force ﬁeld ﬁle (the default is $AMBERHOME/dat/leap/parm/-
gaff.dat). It writes out a force ﬁeld modiﬁcation (frcmod) ﬁle containing any force ﬁeld parameters that are needed
for the molecule but not supplied by the force ﬁeld (*.dat) ﬁle. Problematic parameters, if any, are indicated in
the frcmod ﬁle with the note, “ATTN, need revision”, and are typically given values of zero. This can cause fatal
terminations of programs that later use a resulting prmtop ﬁle; for example, a zero value for the periodicity of the
torsional barrier of a dihedral parameter will be fatal in many cases. For each atom type, an atom type correspond-
ing ﬁle (ATCOR.DAT) lists its replaceable general atom types. By default, only the missing parameters are written
to the frcmod ﬁle. When the “-a” switch is given the value “Y”, parmchk2 prints out all force ﬁeld parameters used
by the input molecule, whether they are already in the parm ﬁle or not. This ﬁle can be used to prepare the frcmod
ﬁle used by thermodynamic integration calculations using sander.

Unlike parmchk which only checks several substitutions for a missing force ﬁeld parameter, parmchk2

enumerates all the possible substitutions and select the one with the best similarity score as the ﬁnal substitute.
Moreover, a penalty score, which measures the similarity between the missing force ﬁeld parameter and the
substitute is provided. The similarity socres are calculated using the similarity indexes deﬁned in the atom type
similarity index ﬁle (PARMCHK.DAT). A similarity index of a pair of atom types (’A/B’) for a speciﬁc force
ﬁeld parameter type was generated by calculating the average percent absolute error of two set of force ﬁeld
parameters in gaff. The two set of force ﬁeld parameters are identical except that one set has atom type ’A’ and
the other has ’B’. Each atom type pair (’A/B’) has nine similarity indexes for nine different types of force ﬁeld
parameters, which are bond equilibrium length, bond stretching force constant, bond equilibrium angle (’A’ and
’B’ are central atoms), bond angle bending force constant (’A’ and ’B’ are central atoms), bond equilibrium angle
(’A’ and ’B’ are non-central atoms), bond angle bending force constant (’A’ and ’B’ are non-central atoms),
torsional angle twisting force constant (’A’ and ’B’ are inner side atoms), torsional angle twisting force constant
(’A’ and ’B’ are outter side atoms), and improper dihedral angle.

parmchk2 -i

input file name

-o frcmod file name
-f input file format (prepi, prepc, ac, mol2)
-s ff parm set, it is suppressed by "-p" option

1: gaff (the default)
2: gaff2
-p ff parmfile
-pf parmfile format,

1: for amber FF data file (the default)
2: for additional force field parameter file

-c atom type corresponding score file, default is PARMCHK.DAT
-a print out all force field parameters including those in the parmfile

can be ’Y’ (yes) or ’N’ (no) default is ’N’

-w print out parameters that matching improper dihedral parameters

that contain ’X’ in the force field parameter file, can be ’Y’ (yes)

290

15.2. A simple example for antechamber

or ’N’ (no), default is ’Y’

Example:

parmchk2 -i sustiva.prep -f prepi -o frcmod

This command reads in sustiva.prep and ﬁnds the missing force ﬁeld parameters listed in frcmod.

15.2. A simple example for antechamber

The most common use of the antechamber program suite is to prepare input ﬁles for LEaP, starting from a
three-dimensional structure, as found in a PDB ﬁle. The antechamber suite automates the process of developing
a charge model and assigning atom types, and partially automates the process of developing parameters for the
various combinations of atom types found in the molecule.

As with any automated procedure, the output should be carefully examined, and users should be on the lookout

for any unusual or incorrect program behavior.

Suppose you have a PDB-format ﬁle for your ligand, say thiophenol, which looks like this:

ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM
ATOM

1 CG TP
2 CD1 TP
3 CD2 TP
4 CE1 TP
5 C6 TP
6 CZ TP
7 HE2 TP
8 S15 TP
9 H19 TP
10 H29 TP
11 H30 TP
12 H31 TP
13 H32 TP

1
1
1
1
1
1
1
1
1
1
1
1
1

-1.959
-1.249
-2.071
-0.646
-1.472
-0.759
-1.558
-2.782
-3.541
-0.787
0.373
-0.092
-2.379

0.102
0.795
0.602 -0.303
0.865
1.963
1.863 -0.234
2.129
2.031
0.934
2.627
2.931
2.719
3.060
0.365
0.979
3.274
-0.043 -0.938
2.045 -0.784
0.781
3.578
-0.916
0.901

(This ﬁle may be found at $AMBERHOME/AmberTools/test/antechamber/tp/tp.pdb). The basic command to
create a mol2 ﬁle for LEaP is just:

antechamber -i tp.pdb -fi pdb -o tp.mol2 -fo mol2 -c bcc

The output ﬁle will look like this:

@<TRIPOS>MOLECULE
TP

1

0

0

13

13
SMALL
bcc
@<TRIPOS>ATOM

1 CG
2 CD1
3 CD2
4 CE1
5 C6
6 CZ
7 HE2
8 S15
9 H19
10 H29

-1.9590
-1.2490
-2.0710
-0.6460
-1.4720
-0.7590
-1.5580
-2.7820
-3.5410
-0.7870

0.1020
0.6020
0.8650
1.8630
2.1290
2.6270
2.7190
0.3650
0.9790
-0.0430

0.7950 ca
-0.3030 ca
1.9630 ca
-0.2340 ca
2.0310 ca
0.9340 ca
2.9310 ha
3.0600 sh
3.2740 hs
-0.9380 ha

1 TP
1 TP
1 TP
1 TP
1 TP
1 TP
1 TP
1 TP
1 TP
1 TP

-0.132000
-0.113000
0.015900
-0.137000
-0.132000
-0.113000
0.136500
-0.254700
0.190800
0.133500

291

15. Antechamber and GAFF

11 H30
12 H31
13 H32

0.3730
-0.0920
-2.3790

2.0450
3.5780
-0.9160

-0.7840 ha
0.7810 ha
0.9010 ha

1 TP
1 TP
1 TP

0.134000
0.133500
0.136500

@<TRIPOS>BOND

1
2
3
4
5
6
7
8
9
10
11
12
13

1
1
1
2
2
3
3
4
4
5
5
6
8

2 ar
3 ar

13 1

4 ar

10 1

5 ar
8 1
6 ar

11 1

6 ar
7 1
12 1
9 1

@<TRIPOS>SUBSTRUCTURE

1 TP

1 TEMP

0 ****

****

0 ROOT

This command says that the input format is pdb, output format is Sybyl mol2, and the BCC charge model is to be
used. The output ﬁle is shown in the box titled .mol2. The format of this ﬁle is a common one understood by many
programs. However, to display molecules properly in software packages other than LEaP and gleap, one needs to
assign atom types using the ’-at sybyl’ ﬂag rather than using the default gaff atom types.

You can now run parmchk2 to see if all of the needed force ﬁeld parameters are available:

parmchk2 -i tp.mol2 -f mol2 -o frcmod

This yields the frcmod ﬁle:

remark goes here
MASS
BOND
ANGLE
DIHE
IMPROPER
ca-ca-ca-ha

ca-ca-ca-sh
NONBON

1.1

1.1

180.0

180.0

2.0

General improper \\

torsional angle (2 general atom types)

2.0

Using default value

In this case, there were two missing dihedral parameters from the gaff.dat ﬁle, which were assigned a default
value. (As gaff.dat continues to be developed, there should be fewer and fewer missing parameters to be estimated
by parmchk2.) In rare cases, parmchk2 may be unable to make a good estimate; it will then insert a placeholder
(with zeros everywhere) into the frcmod ﬁle, with the comment "ATTN: needs revision". After manually editing
this to take care of the elements that "need revision", you are ready to read this residue into LEaP, either as a
residue on its own, or as part of a larger system. The following LEaP input ﬁle (leap.in) will just create a system
with thiophenol in it:

source leaprc.gaff
mods = loadAmberParams frcmod
TP = loadMol2 tp.mol2
saveAmberParm TP prmtop inpcrd
quit

292

You can read this into LEaP as follows:

tleap -s -f leap.in

15.2. A simple example for antechamber

This will yield a prmtop and inpcrd ﬁle. If you want to use this residue in the context of a larger system, you can
insert commands after the loadAmberPrep step to construct the system you want, using standard LEaP commands.
In this respect, it is worth noting that the atom types in gaff.dat are all lower-case, whereas the atom types in the
standard AMBER force ﬁelds are all upper-case. This means that you can load both gaff.dat and (say) parm99.dat
into LEaP at the same time, and there won’t be any conﬂicts. Hence, it is generally expected that you will use one
of the AMBER force ﬁelds to describe your protein or nucleic acid, and the gaff.dat parameters to describe your
ligand; as mentioned above, gaff.dat has been designed with this in mind, i.e., to produce molecular mechanics
descriptions that are generally compatible with the AMBER macromolecular force ﬁelds.

The procedure above only works as it stands for neutral molecules. If your molecule is charged, you need to
set the -nc ﬂag in the initial antechamber run. Also note that this procedure depends heavily upon the initial 3D
structure: it must have all hydrogens present, and the charges computed are those for the conformation you provide,
after minimization in the AM1 Hamiltonian. In fact, this means that you must have an reasonable all-atom initial
model of your molecule (so that it can be minimized with the AM1 Hamiltonian), and you may need to specify
what its net charge is, especially for those molecular formats that have no net charge information, and no partial
charges or the partial charges in the input are not correct. The system should really be a closed-shell molecule,
since all of the atom-typing rules assume this implicitly.

Further examples of using antechamber to create force ﬁeld parameters can be found in the $AMBERHOME-

/test/antechamber directory. Here are some practical tips from Junmei Wang:

1. For the input molecules, make sure there are no open valences and the structures are reasonable. All hy-
drogen atoms must be present. Antechamber doesn’t know what to do with metal ions (see the MCPB.py
program for that), or for other non-organic elements such as Boron. Look at the $AMBERHOME/dat/leap/-
parm/gaff.dat ﬁle to see what sorts of atomic environments are supported.

2. The Antechamber package produces two kinds of messages: error messages and informative messages. In-
formative messages begin with "Info:" and may be safely ignored, but they may be helpful for understanding
and troubleshooting antechamber. For example: "Info: Bond types are assigned for valence state 1 with
penalty of 1". Messages beginning with "Fatal Error!" or "Error:" indicate a problem. Some such messages
may mention likely causes or contain suggested workarounds, but all such messages provide clues. Apply
common sense and the scientiﬁc method to troubleshoot. Typical ﬁrst steps are to verify input ﬁles and to
search the AMBER Mail Reﬂector for similar reported problems. Additional steps are described below.

3. Failures are most often produced when antechamber infers an incorrect connectivity. In such cases, you can
revise by hand the connectivity information in "ac" or "mol2" ﬁles. Systematic errors could be corrected by
revising the parameters in $AMBERHOME/dat/antechamber/CONNECT.TPL.

4. It is a good idea to check the intermediate ﬁles in case of a program failure, and you can run separate

programs one by one. Use the "-s 2" ﬂag to antechamber to see details of what it is doing.

5. acdoctor can diagnose many possible problems with input molecules. If you encounter failures when running
antechamber programs, it is highly recommended to let acdoctor perform a diagnosis. Run the acdoctor
program or use the acdoctor mode in program antechamber; the latter is controlled by option ’-dr’ and is on
by default.

6. By default, the AM1 Mulliken charges that are required for the AM1-BCC procedure are computed using

the sqm program, with the following keyword (which is placed inside the &qmmm namelist):

qm_theory="AM1", grms_tol=0.0005, scfconv=1.d-10,

For some molecules, especially if they have bad starting geometries, convergence to these tight criteria may
not be obtained. If you have trouble, examine the sqm.out ﬁle, and try changing scfconv to 1.d-8 and/or
increase the value of grms_tol. If you see failures in scf convergence that are not ﬁxed by changing scfconv,
try adding setting ndiis_attempts=700. You can use the -ek ﬂag to antechamber to change these: for example

293

15. Antechamber and GAFF


.....

antechamber ....

-ek "qm_theory='AM1', grms_tol=0.0005, scfconv=1.d-8, ndiis_attempts=700,"




But be aware that there may be something “wrong” with your molecule if these problems arise; acdoctor
may help (see the previous tip).

7. The standard procedure for obtaining AM1-BCC charges calls for a geometry optimization ﬁrst. [385, 386]
For some molecules (especially anions like phosphates) such a vacuum minimization may be inappropriate,
since it can lead to formation of intramolecular hydrogen bonds that are not representative of the expected
conformations in solution. If you trust your initial geometries, you can add maxcyc=0 to the -ek ﬂag to skip
the geometry minimization. You might also want to turn off geometry optimization in order try out several
conformations in order to assess the sensitivity of the AM1-BCC charges to input geometry.

15.3. Programs called by antechamber

The following programs are automatically called by antechamber when needed. Generally, you should not need

to run them yourself, unless problems arise and/or you want to ﬁne-tune what antechamber does.

15.3.1. atomtype

Atomtype reads in an ac ﬁle and assigns the atom types. You may ﬁnd the default deﬁnition ﬁles in

$AMBERHOME/dat/antechamber: ATOMTYPE_AMBER.DEF (AMBER), ATOMTYPE_GFF.DEF (general
AMBER force ﬁeld). ATOMTYPE_GFF.DEF is the default deﬁnition ﬁle. It is pointed out that the usage of
atomtype is not limited to assign force ﬁeld atom types, it can also be used to assign atom types in other
applications, such as QSAR and QSPR studies. The users can deﬁne their own atom type deﬁnition ﬁles
according to certain rules described in the above mentioned ﬁles.

atomtype -i input file name

-o output file name (ac)
-f input file format(ac (the default) or mol2)
-p atom type set, supressed by "-d" option

gaff : the default
amber : for PARM94/99/99SB
bcc
gas
sybyl : for atom types used in sybyl

: for AM1-BCC
: for Gasteiger charge

-d atom type definition file, optional
-a do post atom type adjustment (it is applied with "-d" option)

1: yes, 0: no (the default)

Example:

atomtype -i sustiva_resp.ac -o sustiva_resp_at.ac -f ac -p amber

This command assigns atom types for sustiva_resp.ac with amber atom type deﬁnitions. The output ﬁle name is
sustiva_resp_at.ac

15.3.2. am1bcc

Am1bcc ﬁrst reads in an ac or mol2 ﬁle with or without assigned AM1-BCC atom types and bond types. Then
the bcc parameter ﬁle (the default, BCCPARM.DAT is in $AMBERHOME/dat/antechamber) is read in. An ac ﬁle
with AM1-BCC charges [385, 386] is written out. Be sure the charges in the input ac ﬁle are AM1-Mulliken
charges.

294

15.3. Programs called by antechamber

am1bcc -i input file name in ac format

-o output file name
-f output file format(pdb or ac, optional, default is ac)
-p bcc parm file name (optional))
-j atom and bond type judge option, default is 0)

0: No judgement
1: Atom type
2: Full bond type
3: Partial bond type
4: Atom and full bond type
5: Atom and partial bond type

Example:

am1bcc -i comp1.ac -o comp1_bcc.ac -f ac -j 4

This command reads in comp1.ac, assigns both atom types and bond types and ﬁnally performs bond charge
correction to get AM1-BCC charges. The ’-j’ option of 4, which is the default, means that both the atom and bond
type information in the input ﬁle is ignored and a full atom and bond type assignments are performed. The ’-j’
option of 3 and 5 implies that bond type information (single bond, double bond, triple bond and aromatic bond)
is read in and only a bond type adjustment is performed. If the input ﬁle is in mol2 format that contains the basic
bond type information, option of 5 is highly recommended. comp1_bcc.ac is an ac ﬁle with the ﬁnal AM1-BCC
charges.

15.3.3. bondtype

bondtype is a program to assign six bond types based upon the read in simple bond types from an ac or mol2
format with a ﬂag of “-j part” or purely connectivity table using a ﬂag of “-j full”. The six bond types as deﬁned
in AM1-BCC [385, 386] are single bond, double bond, triple bond, aromatic single, aromatic double bonds and
delocalized bond. This program takes an ac ﬁle or mol2 ﬁle as input and write out an ac ﬁle with the predicted bond
types. After the continually improved algorithm and code, the current version of bondtype can correctly assign
bond types for most organic molecules (>99% overall and >95% for charged molecules) in our tests.

Starting with Amber 10, bond type assignment is proceeded based upon residues. The bonds that link two

residues are assumed to be single bonded. This feature allows antechamber to handle residue-based molecules,
even proteins are possible. It also provides a remedy for some molecules that would otherwise fail: it can be
helpful to dissect the whole molecule into residues. Some molecules have more than one way to assign bond
types; for example, there are two ways to alternate single and double bonds for benzene. The assignment adopted
by bondtype is purely affected by the atom sequence order. To get assignments for other resonant structures, one
may freeze some bond types in an ac or mol2 input ﬁle (appending ’F’ or ’f’ to the corresponding bond types).
Those frozen bond types are ignored in the bond type assignment procedure. If the input molecules contain some
unusual elements, such as metals, the involved bonds are automatically frozen. This frozen bond feature enables
bondtype to handle unusual molecules in a practical way without simply producing an error message.

bondtype -i input file name

-o output file name
-f input file format (ac or mol2)
-j judge bond type level option, default is part

full full judgment
part partial judgment, only do reassignment according
to known bond type information in the input file

Examples can be found in $AMBERHOME/test/antechamber/bondtype and $AMBERHOME/test/antecham-
ber/chemokine.

295

15. Antechamber and GAFF

15.3.4. prepgen

Prepgen generates the prep input ﬁle from an ac ﬁle. By default, the program generates a mainchain itself.

However, you may also specify the main-chain atoms in the main chain ﬁle. From this ﬁle, you can also specify
which atoms will be deleted, and whether to do charge correction or not. In order to generate the amino-acid-like
residue (this kind of residue has one head atom and one tail atom to be connected to other residues), you need a
main chain ﬁle. Sample main chain ﬁles are in $AMBERHOME/dat/antechamber.

prepgen -i input file name(ac)

-o output file name
-f output file format (car or int, default: int)
-m mainchain file name
-rn residue name (default: MOL)
-rf residue file name (default: molecule.res)

-f -m -rn -rf are optional

Examples:

prepgen -i sustiva.ac -o sustiva_int.prep -f int -rn SUS -rf SUS.res
prepgen -i sustiva.ac -o sustiva_car.prep -f car -rn SUS -rf SUS.res
prepgen -i sustiva.ac -o sustiva_int_main.prep -f int -rn SUS

-rf SUS.res -m mainchain_sus.dat

prepgen -i ala_cm2_at.ac -o ala_cm2_int_main.prep -f int -rn ALA

-rf ala.res -m mainchain_ala.dat

The above commands generate different kinds of prep input ﬁles with and without specifying a main chain ﬁle.

15.3.5. espgen

Espgen reads in a gaussian (92,94,98,03) output ﬁle and extracts the ESP information. An esp ﬁle for the resp

program is generated.

espgen -i
-o

input file name
output file name

Example:

(1) espgen -i sustiva_g98.out -o sustiva.esp
(2) espgen -i ch3I.gesp -o ch3I.esp

Command (1) reads in sustiva_g98.out and writes out sustiva.esp, which can be used by the resp program. Com-
mand (2) reads in a gesp ﬁle generated by Gaussian 09 and outputs the esp ﬁle. Note that this program replaces
shell scripts formerly found on the AMBER web site that perform equivalent tasks.

15.3.6. respgen

Respgen generates the input ﬁles for two-stage resp ﬁtting. Starting with Amber 10, the program supports a

single molecule with one or multiple conformations RESP ﬁttings. Atom equivalence is recognized automatically.
Frozen charges and charge groups are read in with ’-a’ ﬂag. If there are some frozen charges in the additional
input data ﬁle, a RESP charge ﬁle, QIN is generated as well. Here are ﬂags to respgen:

-i input file name(ac)
-o output file name
-l maximum path length (default is -1, i.e. the path can be any long)
-f output file format

resp1 - first stage resp fitting
resp2 - second stage resp fitting

296



15.4. Miscellaneous programs

iresp1 - first stage i_resp fitting
iresp2 - second stage i_resp fitting
resp3 - one-stage resp fitting
resp4 - calculating ESP from point charges
resp5 - no-equalization

-e equalizing atomic charge (default is 1)

0 not use
1 by atomic paths
2 by atomic paths and geometry (such as E/Z configuration)

-a additional input data (predefined charges, atom groups etc)
-n number of conformations (default is 1)
-w weight of charge constraint

the default values are 0.0005 for resp1/iresp1 and 0.001 for
resp2/iresp2

The following is a sample of additional respgen input ﬁle

//predefined charges in a format of (CHARGE partial_charge atom_ID atom_name)
CHARGE -0.417500 7 N1
CHARGE 0.271900 8 H4
CHARGE 0.597300 15 C5
CHARGE -0.567900 16 O2
//charge groups in a format of (GROUP num_atom net_charge),
//more than one group may be defined.
GROUP 10 0.00000
//atoms in the group in a format of (ATOM atom_ID atom_name)
ATOM 7 N1
ATOM 8 H4
ATOM 9 C3
ATOM 10 H5
ATOM 11 C4
ATOM 12 H6
ATOM 13 H7
ATOM 14 H8
ATOM 15 C5
ATOM 16 O2



Example:

respgen -i sustiva.ac -o sustiva.respin1 -f resp1
respgen -i sustiva.ac -o sustiva.respin2 -f resp2
resp -O -i sustiva.respin1 -o sustiva.respout1 -e sustiva.esp -t qout_stage1
resp -O -i sustiva.respin2 -o sustiva.respout2 -e sustiva.esp

-q qout_stage1 -t qout_stage2

antechamber -i sustiva.ac -fi ac -o sustiva_resp.ac -fo ac -c rc -cf qout_stage2
respgen -i acetamide.ac -o acetamide.respin1 -f resp1 -e 2
respgen -i acetamide.ac -o acetamide.respin2 -f resp2 -e 2

The above commands ﬁrst generate the input ﬁles (sustiva.respin1 and sustiva.respin2) for resp ﬁtting, then do two-
stage resp ﬁtting and ﬁnally use antechamber to read in the resp charges and write out an ac ﬁle, sustiva_resp.ac.
A more complicated example has been provided in $AMBERHOME/test/antechamber/residuegen. The last two
’respgen’ commands generate resp input ﬁles for acetamide discriminating the two amide hydrogen atoms.

15.4. Miscellaneous programs

The Antechamber suite also contains some utility programs that perform various tasks in molecular mechanical

calculations. They are listed in alphabetical order.

297





15. Antechamber and GAFF

15.4.1. acdoctor

acdoctor reads the same input ﬁle formats used by theantechamber program and ’diagnoses’ potential issues
that can cause antechamber to fail. In AmberTools version 17 the acdoctor functionality was added to program
antechamber; it is controlled by option ’-dr’ and is on by default. The ﬁrst step is to validate some
commonly-used molecular formats, such as pdb, mol2, mdl (sdf), etc. Then the presence of any unusual elements
(elements other than C, O, N, S, P, H, F, Cl, Br and I) is reported; in AmberTools version 19 the unusual elements
check was changed from a warning to a fatal error; please contact the Amber Mail Reﬂector specifying the
unusual element(s) to register your interest in using antechamber on those element(s). Unﬁlled valences are
reported and additional checks are performed when atom types and/or bond types are read for ﬁle formats ac,
mol2, sdf, prepi, prepc, mdl, alc and hin. The geometry is quantiﬁed by a distance matrix and atomic clashes are
reported. acdoctor also applies a more stringent criterion than that utilized by antechamber to determine whether
a bond is formed or not. A warning message is printed for those bonds that fail to meet the standard as well as for
weird bonds. Nextacdoctor determines whether all atoms are linked together through atomic paths. If not, an
error message is printed. This kind of error typically implies that the input molecule has one or several bonds
missing. Finally, acdoctor tries to assign bond types and atom types for the input molecule. If no error occurs
during running bondtype and atomtype, presumably the input molecule should be free from problems when
running the other Antechamber programs. It is recommended to diagnose your molecules with acdoctor when
you encounter Antechamber program suite failures.

Usage: acdoctor -i input file name

-f input file format

Example:

acdoctor -i test.mol2 -f mol2

The program reads test.mol2 and checks for potential problems when running the Antechamber programs. Errors
and warning messages are printed. (Possible ﬁle formats are listed above in Section 15.1.1.

15.4.2. parmcal

parmcal is an interactive program to calculate the bond length and bond angle parameters, according to the

rules outlined in Ref. [383].

Please select:
1. calculate the bond length parameter: A-B
2. calculate the bond angle parameter: A-B-C
3. exit

15.4.3. residuegen

It can be painful to prepare a modiﬁed amino acid or nucleotide; the complication is that a residue is not a free
standing molecule, and needs to be capped with extra atoms, usually at both termini. For “simple” systems, where
a single conformation can be used to estimate partial charges, the prepgen program described above with the “-m”
ﬂag to specify which atoms to keep in the ﬁnal residue. For more complex circumstances, the residuegen
facilitates residue topology generation. residuegen reads in an input ﬁle and applies a set of antechamber
programs to generate residue topologies in prepi format. The program can be applied to generate amino-acid-like
topologies for amino acids, nucleic acids and other polymers as well. An example is provided below and the ﬁle
format of the input ﬁle is also explained.

Usage: residuegen input_file

Example:

residuegen ala.input

298



This command reads in ala.input and generate residue topology for alanine. The ﬁle format of ala.input is explained
below.

15.4. Miscellaneous programs

#INPUT_FILE:
INPUT_FILE
#CONF_NUM:
CONF_NUM
#ESP_FILE:
#
ESP_FILE
#SEP_BOND:
#
#
SEP_BOND
SEP_BOND
#NET_CHARGE:
NET_CHARGE
#ATOM_CHARGE:
#
ATOM_CHARGE
ATOM_CHARGE
ATOM_CHARGE
ATOM_CHARGE
#PREP_FILE:
PREP_FILE:
#RESIDUE_FILE_NAME:
RESIDUE_FILE_NAME:
#RESIDUE_SYMBOL:
RESIDUE_SYMBOL:



structure file in ac format, generated from a Gaussian output
ala.ac
Number of conformations utilized
2
esp file generated from gaussian output with 'espgen'
for multiple conformations, cat all CONF_NUM esp files onto ESP_FILE
ala.esp
bonds that separate residue and caps, input in a format of
(Atom_Name1 Atom_Name2), where Atom_Name1 belongs to residue and
Atom_Name2 belongs to a cap; must show up no more than two times
N1 C2
C5 N2
net charge of the residue
0
predefined atom charge, input in a format of

(Atom_Name Partial_Charge); can show up multiple times.

N1 -0.4175
H4 0.2719
C5 0.5973
O2 -0.5679
prep file name
ala.prep

residue file name in PREP_FILE
ala.res
residue symbol in PREP_FILE
ALA





15.4.4. match

The match program was developed to conduct least-square ﬁttings for two molecules (one input and one

reference) which are not necessarily the same in structure. Users can specify which atom or residue in the input
corresponds to which in the reference in the deﬁnition ﬁle (-df). The users can also specify which atoms
participating the ﬁtting (-ds). The match matrix can be saved for translating and roating those atoms not
participating the ﬁtting procedure in separate step using ’-j 2’.

Usage: match -i input file name

-r reference file name
-f format: 1-pdb (the default), 2-ac, 3-mol2, 4-sdf, 5-crd/rst
-o output file name
-l run log file name, default is "match.log"
-s selection mode

0: use all atoms (the default)
1: specify atom names
2: use atom definition file
3: use residue definition file - original residue IDs
4: use residue definition file - renumbered residue IDs

-ds definition string if selection modes of ’1’ or ’3’ or ’4’

e.g. ’C,N,O,CA’, or ’HET’ which stands for heavy atoms for ’-ds 1’)

-df definition file if selection mode of ’2’ or ’3’ or ’4’

records take a form of ’ATOM atom_id_input atom_id_reference’
or ’RES res_id_input res_id_reference’

-n number of atoms participating ls-fitting,

299

15. Antechamber and GAFF

default is -1, which implies to use all the selected atoms

-m matrix file, default is "match.matrix"
-t job type:

0: calculate rms only, need -i and -r
1: lsfit, need -i, -r and -o the default
2: translation/rotation, need -i, -o and -m

Example:

match -f pdb -r 1be9.pdb -i 3pdz.pdb -o 3pdz_aligned.pdb -s 4 -ds "CA,C,N,O" -df 3pdz_1be9.corr

The program runs least-square ﬁtting for the non-hydrogen main chain atoms of residues deﬁned in the
3pdz_1be9.corr. A part of the 3pdz_1be9.corr is shown below:

RES 34 35 G G
RES 35 36 I I
RES 36 37 Y F
...
RES 87 88 L I
RES 88 89 L I

15.4.5. match_atomname

One limitation of the Antechamber package is that the atom name information is lost after running Gaussian
calculations. And a residue topology ﬁle in prepi or prepc or a mol2 ﬁle generated from the Gaussian output has
atom names not matching those from the original ﬁle (usually a pdb ﬁle). Because of this glitch, one can not
simply load the residue topology ﬁle to tleap, read in the pdb ﬁle and then to save the topolgoy. We developed
match_atomname to address this problem. The match_atomname program takes an input ﬁle and a reference ﬁle
in pdb, ac, prepi, prepc and mol2 format, automatically detects the corresponding atom name in the reference for
each atom name in the input. An output ﬁle in the same format as that of the input is generated using the matched
atom names.

Usage: match_atomname -i input file name

-fi input format (pdb, ac, prepi, prepc, mol2
-r ref file name
-fr ref format (pdb, ac, prepi, prepc, mol2)
-o output file name
-h include hydrogen atoms or not

0 not, the default
1 yes

-g geometric info (such as E/Z configuration) is considered to describe chemical environment

0 no, the default
1 yes

-l maximum path length, default is -1 (full length)

if it takes very long time and/or core dump occur, a value between 8 to 10 is recommended

Example:

match_atomname -i SAH.prepi -fi prepi -o SAH_matched.prepi -r SAH_XRAY.pdb -fr pdb

The output, SAH_matched.prepi and SAH_XRAY.pdb can be loaded to tleap directly to generate a topology for
minimization or MD simulations.

300

16. Molecular Mechanics Parameter Fitting in

mdgx

The mdgx program has been distributed with Amber since 2012. At ﬁrst, it was intended as a platform for
radical redesign of the molecular dynamics algorithm, implementing a proof-of-concept multigrid technique for
the particle-mesh Ewald electrostatic sum as well as a rare strategy for pair list decomposition. All of these
features remain in mdgx, and the code retains a modest parallel CPU capability for running basic simulations. This
molecular dynamics facility is critical to “IPolQ” charge development method unique to the program.

However, it soon became obvious that the needs for a simulation engine as well as an algorithmic development
platform would be served by pmemd and its GPU extensions. The role of mdgx then shifted to parameter develop-
ment, for which the simple C coding, the facility for reading multiple topologies, and modular extensibility have
proved well suited.

Repurposed as a parameter development too, mdgx is a worthy addition to the AmberTools family of programs,
and one of the most powerful package-distributed tools available for this purpose. There is one exceptional func-
tionality in the program, new to Amber20: the ability to run large numbers of simulations on small systems with
the Generalized Born solvent model. At present, only standard molecular dynamics for these systems is enabled,
but the standard igb settings present in sander and pmemd are possible (surface area terms are not yet computed).
This capability enables validation runs on vast numbers of small systems with unprecedented throughput, which
makes it a sensible feature to include under the theme of parameter development.

16.1. Input and Output

Input command ﬁles for mdgx may be similar to the mdin format used by sander and pmemd. One requirement
of mdgx that is not found in sander is that each of the namelist segments of the input ﬁle must begin with the
identiﬁer of the namelist on its own line and end with the keyword &end on its own separate line. However, the
namelist format is not strictly enforced in mdgx, not all sander input variables are available in mdgx, and some new
input variables have been added. All mdgx input variables can also be identiﬁed by aliases that may be lengthier
than their sander counterparts but may make the input easier for a human to parse.

All mdgx namelists and their associated variables may be browsed by running the mdgx program itself; running
the program with no command line arguments will produce basic instructions for usage and a list of command-line
arguments to display each namelist. For example, on the command line: “>>mdgx -PARAM” will show a lengthy
description of all features in the mdgx &param namelist, the parameter sampling module.

Certain directives to mdgx may be supplied as either part of the input ﬁle or on the command line; in particular,
the names of the topology, input coordinates, and output ﬁles may be speciﬁed in either manner. Also, the random
number generator seed may be speciﬁed on the command line. However, if the same variable is declared both on
the command line and in the input ﬁle, the command-line input will take precedence. This predominance makes
it possible to execute multiple related mdgx runs based on a single input ﬁle. Units of input variables follow the
sander and pmemd conventions.

The mdgx program will read standard AMBER prmtop ﬁles using its own routines and, in some run modes, will
perform basic tests of the topology to identify common problems such as omitted disulﬁde bonds or “D” to “L”
chirality ﬂips in the standard amino acids; any potential problems are reported in the mdout output diagnostics
ﬁles, but do not immediately lead the program to halt.

Output ﬁles produced by mdgx follow the AMBER .crd and NetCDF formats for coordinates and velocities.
While there is an elaborate scheme available for output ﬁle organization in traditional MD, this is not used very
often and anyone interested should contact the authors. For most purposes, the standard output ﬁle types and

301

16. Molecular Mechanics Parameter Fitting in mdgx

descriptions apply. For parameter ﬁtting, the equivalent mdout contains a great deal of diagnostic information on
the breadth of the training data and the improvement accomplished in the ﬁt to the quantum energy surface.

The mdgx program also provides its own output format for force diagnostics. In sander, information relating the
bond, angle, torsion, and nonbonded direct and reciprocal space forces is only available by running in “debugging”
mode as speciﬁed by the &debugf namelist block. In mdgx, such output is available by setting the sander-related
imin variable to 2; the output is produced in ASCII format with numerous comments to make the results compre-
hensible to a human, and in some cases can be convenient for analyzing forces on boxes full of atoms.

16.2. Installation

mdgx is installed as part of the AmberTools package. The program relies on the FFTW 3.3 and NetCDF libraries

already distributed as part of AmberTools.

16.3. Partial Charge Development

The ﬁrst parameter sets that utilized the mdgx apparatus were charge sets for protein force ﬁelds, namely ff14ipq
and its successor ff15ipq. Before we delve into the derivation for IPolQ, which is somewhat involved, it is important
to note that mdgx can perform electrostatic potential ﬁtting using any quantum method which generates a Gaussian
cubegen format ﬁle or can be converted into such a format. Once mdgx has data on electrostatic potentials, mdgx
automates the tedious task of synthesizing that data into a set of partial charges.

The Restrained Electrostatic Potential (RESP) methodology is the basis for charge assignment based on
quantum-mechanical electrostatic potential data, but the details differ somewhat from the implementation in an-
techamber. The basic concept of ﬁtting charges to reproduce the electrostatic potential of a molecule, by ﬁnding
the solution with least squared error in the presence of restraints, is carried over from the original Kollmann RESP.
However, instead of Langrangian constraints, equivalent charges are uniﬁed as single variables in the ﬁt, and
penalty functions are added to the ﬁtting matrix to enforce total charge constraints. Where mdgx excels is in the
control it gives the user over what ﬁtting data will be used. Rather than relying on a quantum-chemistry package
to select a particular surface around a molecule, mdgx will read the electrostatic potential due to that molecule
on a regular grid and select points from that grid based on a solvent-accessible region determined by the actual
Lennard- Jones parameters of the model. Because most solvent models make use of hydrogen atoms with modest
or nonexistent steric properties, mdgx also considers points which may not be accessible to the solvent probe but
might be accessible to a hydrogen atom connected to that probe. mdgx will read a prmtop describing the system
and also, if required, a Virtual Sites rule ﬁle, so that partial charges may be ﬁtted for any virtual sites that the user
wishes to add. Once ﬁtting is complete, mdgx can return a new Virtual Sites rule ﬁle that will apply the ﬁtted
charges to the original prmtop in future simulations.

Fitting is called by its own separate &ﬁtq namelist, and triggers a distinct run mode in the sense that the program
will terminate after the ﬁt is complete. The options available in the &ﬁtq namelist include (shorthand aliases in
parentheses):

• RespPhi (resp): File names and numerical weight of an electrostatic potential to use in ﬁtting. The format
is <string1> <string2> <real1>, where string1 is a Gaussian cubegen format ﬁle specifying the electrostatic
potential and molecular coordinates and Z-numbers appropriate to the topology speciﬁed by string2 and
real1 is the numerical weight to be given to this conformation in the ﬁt.

• IPolQPhi (ipolq): File names and numerical weight of a pair of electrostatic potentials to use in IPolQ ﬁt-
ting. The format is <string1> <string2> <string3> <real1>, where string1 and string2 are Gaussian cubegen
format ﬁles relating to the system in vacuum and in a condensed-phase environment (see also the section on
Implicitly Polarized Charge creation). Note that the molecular coordinates in both cubegen ﬁles must match.
As in the resp variable format, string3 is the topology, and real1 is the numerical weight of this conformation.
• EPRules (eprules): If speciﬁed, mdgx will output all ﬁtted charges in the form of a Virtual Sites rule ﬁle,
which can be given as input to subsequent simulations to modify the original prmtop and apply the ﬁtted
charge model.

302

16.3. Partial Charge Development

• ConfFile (conf): If speciﬁed, mdgx will output the ﬁrst molecular conformation, complete with any added
virtual sites, in PDB format for inspection. This is useful for understanding exactly what model is being
ﬁtted.

• TotalQ (qtot): The total charge constraint in units of the proton charge; the sum of all ﬁtted charges is

required to equal this value. Default 0.0.

• MinimizeQ (minq): Restrain the charges of a group of atoms to zero by the weight given in minqwt. The

groups are speciﬁed in ambmask format.

• EqualizeQ (equalq): Restrain the charges of a group of atoms to have the same values. Groups are speciﬁed

in ambmask format.

• MinQWeight (minqwt): Weight used for restraining values of charges to zero; as more and more ﬁtting
data is included (either through a higher sampling density of the electrostatic potential due to each molecular
conformation or additional molecular conformations) higher values of minqwt may be needed to keep the
ﬁtted charges small. However, with more data the need to restrain charges may diminish as well.

• FitPoints (nfpt): The number of ﬁtting points to select from each electrostatic potential grid. The points
nearest the molecule, which satisfy the limits set by the solvent probe and point-to-point distances as deﬁned
below, will be selected for the ﬁt. Default 1000.

• ProbeSig (psig): The Lennard-Jones σ parameter of the solvent probe. Default 3.16435 (TIP4P oxygen).

• ProbeEps (peps): The Lennard-Jones ε parameter of the solvent probe. Default 0.16275 (TIP4P oxygen).

• ProbeArm (parm): The probe arm; points on the electrostatic potential grid that would be inaccessible to
the solvent probe may still be included in the ﬁt if they are within the probe arm’s reach. Default 0.9572Å
(TIP oxygen-hydrogen bond distance).

• StericLimit (pnrg): The maximum Lennard-Jones energy of the solvent probe at which a point will qualify

for inclusion in the ﬁt. Default 3.0 kcal/mol.

• Proximity (ﬂim): The minimum proximity of any two points to be included in the ﬁt. Default 0.4Å.

• HistogramBin (hbin): If hist is speciﬁed, mdgx will print a histogram reporting the number of ﬁtting points
falling within any particular distance of some atom of the molecule. This parameter controls the discretiza-
tion of the histogram.

• MaxMemory (maxmem): Because ﬁtting matrices can become very large in some cases (in particular, those
involving multiple systems with correlated partial charges), mdgx offers this parameter as a safeguard against
creating a matrix that may inadvertently take up too much memory. Values for this argument may be integers,
or integers followed immediately (no spaces) with terms such as “GB,” “Mb,” or “kB” (case-insensitive) for
giga/mega/kilo bytes. Default 1GB.

• Verbose (verbose): Unless set to zero by the user, mdgx will print periodic updates and record milestones

from the ﬁtting run in terminal output.

An example of a &ﬁtq namelist is given below. In this particular problem, ECl2 and ECl3 were the names of
virtual sites not in the original topology ﬁle but speciﬁed by a Virtual Sites rule ﬁle.

&fitq

Conf12/pcm12.cube,
Conf13/pcm13.cube,
Conf14/pcm14.cube,

RespPhi
RespPhi
RespPhi
2.0,
pnrg
nfpt
15000,
minqwt 175.0,

303

16. Molecular Mechanics Parameter Fitting in mdgx

EqualizeQ ’@H1,H2’
EqualizeQ ’@Cl2,Cl3’
EqualizeQ ’@ECl2,ECl3’
MinimizeQ = ’@E*’
EPRules
ConfFile

frag.xpt
f6xp.pdb

&end

Virtual site constructions have strong support in mdgx to rapidly translate between an imagined model and a
practical simulation.

16.4. Implicitly Polarized Charge Development

The mdgx package is the workhorse used to create ff14ipq and its successor ff15ipq. At the heart of each of

these protein force ﬁelds is the Implicitly Polarized Charge model (IPolQ), which mdgx automates.

The purpose of IPolQ is to derive an appropriate set of ﬁxed partial charges on a molecule which account for
the mean-ﬁeld polarization it displays in solvent (water) while also accounting for the energetic cost of perturbing
the gas phase wave function. This is handled by two separate quantum calculations on the same set of molecular
coordinates: the ﬁrst is performed in vacuum, the second in the presence of a time-averaged solvent charge density.
Taking a page from linear response theory, the average of the two calculations provides the target electrostatic
potential that the ﬁxed partial charges should project. Collecting that charge density, particularly if the solvent
contains counterions and there are inﬁnite electrostatics in play, takes a fair amount of code, but this is why mdgx
has a special module. It currently interfaces with two quantum packages, ORCA and Gaussian, to drive the QM
calculations, and additional code in this module will write inputs and post-process the outputs of each program into
material suitable for the mdgx electrostatic potential ﬁtting tools. The variables available in the &ipolq namelist
are as follows (shorthand aliases in parentheses):

• SoluteMol (solute): The solute molecule, speciﬁed by an ambmask string. This is the molecule of interest

for charge ﬁtting, and will be immobilized during the simulation. This must be speciﬁed by the user.

• FrameRate (ntqs): The rate of charge density sampling; the number of steps between successive snapshots
to determine the solvent reaction ﬁeld potential (SRFP). Default 1000 (the time step set in the &cntrl or
&ipolq namelists should factor into the ntqs setting).

• FrameCount (nqframe): The number of frames used to compose the SRFP. Default 10 (this is too low for

most solvent environments).

• EqStepCount (nsteqlim): The number of steps used to equilibrate the system before charge density collec-
tion begins. Use this part of the simulation to buffer against any artifacts that might arise from suddenly
freezing the solute in place. Default 10000.

• Blocks (nblock): The number of blocks into which the simulation shall be divided for the purpose of esti-

mating the convergence of the electrostatic potential. Default 4.

• Verbose (verbose): Default 0; set to 1 to activate step-by-step progress updates printed to the terminal win-
dow. Useful for monitoring short runs to ensure that the input successfully completes the SRFP calculation.

• EConverge (econv): Convergence tolerance for the SRFP (convergence checking is not yet implemented).

• QShellCount (nqshell): The number of additional shells of charge to place around the system in order to
approximate the SRFP due to inﬁnite electrostatics in the conﬁnes of an isolated system. Maximum (and
default) is 3, minimum is 1.

• VShellCount (nvshell): The number of shells around each atom on which the exact SRFP due to inﬁnite

electrostatics shall be calculated. Maximum (and default) is 3, minimum is 1.

304

16.4. Implicitly Polarized Charge Development

• QSpherePts (nqphpt): In order to generate the surface charges that will help in approximating the SRFP,
this number of points is placed equidistant on a sphere. The sphere is then rotated randomly and expanded to
the radii indicated by qshell[1,2,3,x]. All points that are on the sphere due to one atom but within the sphere
projected by another atom are deleted, until only points on the proper surface remain. Default 100.

• VSpherePts (nvphpt): Similar to nqphpt above, but for the shells of SRFP evaluation points. Default 20.

• ExpQBoundary (qshell1): The distance at which to locate the ﬁrst surface charges, and to stop collecting

charges explicitly from the simulation’s non-solute (that is, solvent) atoms. Default 5.0.

• QShell[2,3] (qshell2, qshell3): The distance at which to locate the second and third shells of boundary
charges. If engaged, each shell must be located successively further from the solute than the previous one.

• VShell[1,2,3] (vshell1, ...): The distances at which to locate additional shells of exact SRFP evaluation

points. The SRFP is always evaluated, exactly, at the solute atom sites.

• TimeStep (dt): The simulation time step. This is read in the &ipolq namelist just as if it were present in
the &cntrl namelist, but a value speciﬁed in &ipolq overrides the &cntrl setting. Default is 0.001ps, set in
&cntrl.

• MinQWeight (minqwt): The stiffness of harmonic restraint by which to restrain ﬁtted shell charges to zero.

Default 0.01.

• ModifyQ (modq): When IPolQ is applied, it is appropriate to hyper-polarize certain molecules in the SRFP
calculation. This variable may be speciﬁed as many times as necessary, followed by an ambmask string and
a real number indicating the new charges to be assigned to all atoms in the mask. For example, ﬁxed-charge
water models should have their dipoles increased by an amount equal to the original model’s dipole less 1.85
(the dipole of water in vacuum).

• QuantumPrep (prepqm): Preparatory call for QM calculations. This variable may be speciﬁed as many
times as necessary. Each of these calls will be issued, in the order speciﬁed, before executing quantum
calculations.

• QuantumClean (postqm): Post-processing calls for QM calculations. Similar to prepqm directives, called

after QM calculations have been completed.

• QMPackage (qmprog): The quantum package to use. Supported packages are "gaussian" and "orca".

• QMPath (qmpath): Path to the primary QM executable. This path will be tested, taking into account prepqm

calls, to be sure that the executable exists prior to running the SRFP calculation.

• QMInputFile (qmcomm): The base name of the QM input ﬁle. Vacuum and condensed-phase versions will

be written with extensions ’vacu’ and ’solv’, respectively. Default ’IPolQinp’.

• Maxmemory (maxcore): The maximum memory that can be allocated to arrays for quantum calculations

with Orca, or the maximum total memory that can be allocated for calculations with Gaussian.

• QMOutputFile (qmresult): The base name of the QM output ﬁle, which is given similar extensions to the

input ﬁle. Default ’IPolQout’.

• PointQFile (ptqﬁ): The name of the point charges ﬁle referenced by orca for including the SRFP into the

condensed-phase calculation.

• QMSignal (qmﬂag): The name of the ﬁle used to signal slave processes that the QM calculations launched

by the master are complete. Default ’.mdgx.ﬁnqm’.

• QMTheory (qmlev): The level of QM theory to use. Default MP2.

• QMBasis (basis): The QM basis set to use. Default cc-pvTZ.

305

16. Molecular Mechanics Parameter Fitting in mdgx

• WorkDirectory (scrdir): The scratch directory to use during QM calculations. Useful to reduce NFS load.
If the directory exists, it will be used but not destroyed following each QM calculation. If the directory does
not exist at the start of the run, it will be created and later destroyed.

• KeepQMInput (rqminp): Directive to retain QM input ﬁles after the run. Default 0 (OFF).

• KeepQMCheckPt (rqmchk): Directive to retain QM checkpoint ﬁle(s) after the run. Default 0 (OFF).

• KeepQCloud (rcloud): Directive to retain the solvent charge density cloud ﬁle after the run. Default 0

(OFF).

• CheckExist (checkex): Activates safety checks for the existence of QM executables (including electrostatic
potential calculators) called at the start of the run. These checks attempt to take into account user-speciﬁed
preparatory directives (see prepqm above). Default 1 (ON). Set to zero to disable this safeguard, for instance
if the checks cannot ﬁnd the executables but the preparatory directives, when fully implemented, are known
to result in success.

• UElec[X,Y,Z]Bin (un[x,y,z]): The number of grid points on which to evaluate the electrostatic potential, in

the X direction. Grid dimensions in Y and Z are set by similar variables.

• UElec[X,Y,Z]Spc (uh[x,y,z]): The grid spacing of the electrostatic potential grid in the X direction. The

grid is always rectilinear. Spacings in Y and Z are set by similar variables.

• CenterGrid (cengrid): Directive to center the electrostatic potential grid on the location of the molecule
stored in mdgx. The default behavior varies with each quantum package: ’orca’ activates centering on the
molecule whereas ’gaussian’ calls for centering on the origin, as Orca does not reposition the molecule in its
output but Gaussian will place the molecule in a ’Standard Orientation’ and leave it there in the output and
checkpoint ﬁles used for electrostatic potential calculations.

• FormChkPath (fmpath): Path to the program called for converting binary checkpoint ﬁles into formatted

checkpoint ﬁles. Needed only if the QM program is ’gaussian’.

• UEvalPath (uvpath): Path to the program called for evaluating the electrostatic potential grid.

• GridFile (grid): Base name of the electrostatic potential grid to be written. As with QM input and output,

this base name is appended ’vacu’ or ’solv’ for vacuum and condensed-phase calculations.

16.5. Customizable Virtual Site Support

It is not completely feasible to perform molecular dynamics with massless particles. However, for many useful
cases in which the locations of massless particles are determined by the locations of two or more atoms with mass,
it is possible to perform dynamics by using the chain rule to transfer forces from the “virtual sites” to the massive
particles. These constructions, enumerated below, provide a means for breaking out of the “one atom, one site”
paradigm that has dominated classical molecular dynamics. The prmtop format utilized by the sander and pmemd
programs does not always provide a straightforward means of expressing the relationships between virtual sites
and their parent (or “frame”) atoms. In Amber20, the sander and pmemd programs only support the most widely
used cases of virtual sites (e.g. TIP4P and TIP5P water), but efforts are underway to support a broader variety of
these virtual sites.

The mdgx program provides a means for adding any number of virtual sites to an existing force ﬁeld, with
custom charges and even Lennard-Jones properties. The only limitations with the virtual sites are that no new
bonded terms may be added, that the virtual sites carry zero mass, and that each virtual site location be determined
by two or three frame atoms on the same residue which do have mass. The constructions below follow those
outlined in the GROMACS manual; a four-point frame construction devised by the GROMACS team is not yet
implemented, but a “zeroth” frame type is available in mdgx which allows, without changing the prmtop, run-time
modiﬁcation of existing atomic non-bonded parameters.

306

16.5. Customizable Virtual Site Support

Figure 16.1.: Frame styles in mdgx.

In the Fig. Figure 16.1 on page 307, the &rule namelist variables for specifying each virtual site constructor are
superimposed on atoms, vectors, and angles. In Style 1, the virtual site lies along the line determined by two atoms;
v12 denotes the fraction of the distance between the two atoms at which to place the virtual site. In Style 2, the
virtual site lies in the plane determined by three atoms at a point determined by a combination of the displacements
between atoms 1 and 2 and atoms 2 and 3. Virtual sites of Styles 1 and 2 are located by linear combinations of the
positions of their frame atoms. In Style 3, the virtual site is located along the line described by frame atom 1 and a
point between frame atoms 2 and 3 (v23 denoting the fraction of this distance), at a ﬁxed distance v1e from frame
atom 1. Style 4, perhaps the most mathematically challenging frame type to deﬁne but very useful and intuitively
comprehensible, places a virtual site at a ﬁxed distance v1e from frame atom 1 such that the angle illustrated has
the value theta (speciﬁed in radians in the &rule namelist). The virtual site remains in the plane of the frame atoms,
and frame atom 3, which must not be colinear with the other frame atoms, orients the sign of theta. Virtual sites of
Style 5 are deﬁned as sites of Style 2, but projected normal to the plane according to a multiple v12x13 of the cross
product of the vectors between frame atoms 1 and 2 and frame atoms 1 and 3. Note that virtual sites of Styles 1,
2, and 5 will stretch with their frames, whereas 3 and 4 will not. The stretching will be minor if the frame atoms
are bonded as shown in the ﬁgure. Due to the manner in which virtual sites are positioned in mdgx, frame atoms 2
and 3, and the virtual site when placed, must lie within half the van-der Waals non-bonded cutoff of frame atom 1.
This should seldom if ever be a problem. A complete list of &rule namelist variables follows (shorthand aliases in
parentheses):

• FrameAtom[1,2,3] (frame[1,2,3]): speciﬁes the frame atoms needed for virtual site construction

• ExtraPoint (epname): The name of the virtual site

• AtomName (atom): The name of the virtual site (alternate speciﬁcations)

• FrameStyle (style): The frame style to use (see descriptions in the preceding ﬁgure); acceptable values are

0 through 5

• Exclude[2,3] (excl[2,3]): The virtual site is deﬁnitively 1:1 bound to frame atom 1 and thereby inherits all
1:2, 1:3, and 1:4 neighbors of frame atom 1, but if ? is 2 or 3 then the virtual site will also be considered 1:1
to frame atoms 2 or 3 and inherit their bonded neighbors as well. This will not affect the 1:2, 1:3, and 1:4
neighbor lists of the frame atoms themselves.

307

16. Molecular Mechanics Parameter Fitting in mdgx

• Vector12 (v12): Deﬁned according to frame type; see preceding paragraph and illustration.

• Vector1E (v1e): Deﬁned according to frame type; see preceding paragraph and illustration.

• Vector13 (v13): Deﬁned according to frame type; see preceding paragraph and illustration.

• Theta (theta): Deﬁned according to frame type; see preceding paragraph and illustration.

• Vector23 (v23): Deﬁned according to frame type; see preceding paragraph and illustration.

• Vector12x13 (v12x13): Deﬁned according to frame type; see preceding paragraph and illustration.

• Charge (q): Charge of the virtual site

• Sigma (sig): Lennard-Jonesσ parameter for the virtual site

• Epsilon (eps): Lennard-Jones ε parameter for the virtual site

• ResidueName (residue): The residue to which extra points will be added. Because it is speciﬁed according
to the four-character name, there is some possibility for ambiguity as terminal residues often have the same
names as residues in the middle of a chain. Therefore, in order to add a virtual site to an the amino terminus
of N-terminal alanine but skip over alanines within a polypeptide, the N-terminal alanine would have to be
given a new name within the prmtop.

Through the &rule namelist, mdgx can ﬁt partial charges for virtual sites. Ultimately, the prmtop format will be
extended and pmemd will be able to read the mdgx palette of virtual sites in addition to its own, but without a
means for generating parameters the sites would not be useful. For now, mdgx permits users to test the beneﬁts
of virtual sites for reproducing molecular electrostatics through a more elaborate distribution of monopoles. It is
possible in mdgx (noting that the rigid geometry of the massive atoms is the same throughout all TIP water models)
to simulate TIP4P or TIP5P water starting from a prmtop containing TIP3P water, although it is more convenient
and perhaps marginally faster to simulate beginning with a prmtop specifying the more complex water model.

Virtual sites added in this manner follow the neighbor conventions that virtual sites are counted as “1:1” neigh-
bors of their ﬁrst parent atoms and then inherit all 1:2 (bond), 1:3 (angle), and 1:4 nonbonded neighbors of the ﬁrst
parent atom. It is also possible to endow virtual sites with neighbors of other parent atoms, effectively declaring
the virtual sites to be 1:1 neighbors of more than one atom. The neighbor list updates implied by adding virtual
sites do not get applied retroactively, however, so multiple frame atoms do not become 1:1 neighbors of each other.
Because of the exclusions implied by different frame constructions, care should be taken when deﬁning parent
atoms. For instance, in the chlorinated ethane derivative below virtual sites of frame type 1 (v12 = −0.3, with
chlorines being frame atom 1 and the bonded carbons being frame atom 2) can be shown to signiﬁcantly improve
the electrostatic ﬁt to quantum-mechanical MP2 calculations.

308

16.6. Bonded Term Fitting in mdgx

In principle, the frame atom 1 may be deﬁned as the carbon, with the chlorine (which is actually closest to
the virtual site) merely deﬁning the direction of the virtual site projection. However, this construction omits
interactions between virtual sites on opposite ends of the molecule, and as a result the torsional conformations
of the molecule are drastically altered (so much so that the hydration free energy in explicit solvent simulations
changes by more than 3 kcal/mol). If the chlorines themselves are made frame atom 1 in each virtual site frame,
the virtual sites become 1:4 neighbors to one another and interact by a slightly screened electrostatic potential.

The effects on the torsional distribution and resulting hydration free energy are then much more modest. This
trichloroethane represents an extreme case, but more subtle examples abound. In general, virtual sites can change
the charge distribution of a molecule to roughly the same degree that reﬁtting an atom-centered charge model
to new quantum data does. Ideally, torsional parameters would be reﬁtted in all cases to accommodate the new
electrostatic model.

16.6. Bonded Term Fitting in mdgx

Having the capabilities to read multiple topologies and coordinate sets, compute energies, and to optimize pa-
rameter sets made a bonded parameter ﬁtting module a natural extension of mdgx. Like the RESP ﬁtting module,
the bond parameter ﬁtting routines can read multiple systems and conformations and determine the best overall
values for harmonic bond, harmonic angle, and torsion Fourier series appearing in multiple contexts. The while
the RESP module is limited to 512 systems and conformations and makes its ﬁtting matrices based on thousands
of data points from each one, there is no practical limit to the number of systems and conformations that the bond
parameter ﬁtting module can muster, although it seeks only to make the total internal energy of each conformation
match a single target value (presumably obtained from quantum mechanics). This duplicates some functionality in
the paramﬁt program described in Chapter 3, but with improved capabilities for large data ﬁtting problems. Results
are written to several different ﬁles: the forcedump ﬁle (-d option on the command line or in the &ﬁles namelist)
stores ﬁtted parameters in the standard Amber parameter ﬁle or frcmod formats (i.e. parm99.dat, frcmod.ff14SB),
mdout provides extensive analysis of the ﬁt and sampling of each ﬁtted parameter in the data set, and the accrep
option described in the table below creates a complete report of the correlations, system by system, if requested.

Bonded term ﬁtting is called by including the &param namelist in an inpue ﬁle. If detected, this namelist will
send mdgx into a distinct run mode for parameter optimization. The goal is to take in parameter ﬁles, topologies,
coordinates, and quantum single point energies, then organize this data. The ﬁrst thing mdgx does is trace all
parameters back to their sources in the parameter ﬁles (i.e. parm10.dat) and then determine which parameters
are open for optimization. Then, mdgx computes molecular mechanics energies of all the molecular systems and
conformations (as if they were isolated in the gas phase) and subtracts off the portion due to non-optimizable
sources. The goal is to make the relative potential energy surfaces of the systems as close as possible to the
corresponding quantum energy surfaces.

New in AmberTools20, the mdgx program offers the ability to ﬁt CMAP surfaces alongside bond, bond angle,
and torsion parameters. This unique capability treats every grid point on the CMAP surface as an independent,
optimizable variable. Instead of four cosine terms in each of two dihedrals, a CMAP can contain up to 576 unique
parameters–a seventy-fold increase in the amount of detail. The &param namelist is designed to accept trajectories
and ﬁles of energy values for each frame, simplifying inputs of tens of thousands to hundreds of thousands of data
points. The related &conﬁgs namelist can generate conformations and automate the QM calculations to construct
such a large data set. These features can address a vast new parameter space such as that afforded by CMAPs.
However, the explosion in parameter space can also be mitigated by ﬁtting lower-resolution maps (i.e. 8 or 12
points on a side, rather than the full 24), which are then promoted (by interpolating) to the full 24-by-24 map that
sander and pmemd expect.

The options available in the &param namelist include (shorthand aliases in parentheses):

• System (sys): A ﬁtting data point. This keyword must be followed by three items: the name of a topology

ﬁle, the name of a corresponding coordinate ﬁle, and the energy of this system in the stated conformation.

• FitBonds (bonds): Requests a linear least-squares ﬁt for bond stiffnesses in the system.

• FitAngles (angles): Requests a linear least-squares ﬁt for angle stiffnesses in the system.

309

16. Molecular Mechanics Parameter Fitting in mdgx

• FitTorsions (torsions): Requests a linear least-squares ﬁt for torsion stiffnesses in the system.

• FitCmaps (cmaps): Requests a linear least-squares ﬁt for CMAP surfaces in the system.

• FitB (ﬁtb): Request that a speciﬁc bond parameter be included in the linear least-squares ﬁtting.

• FitA (ﬁta): Request that a speciﬁc angle parameter be included in the linear least-squares ﬁtting.

• FitH (ﬁth): Request that a speciﬁc torsion parameter be included in linear least-squares ﬁtting.

• FitBondEq (bondeq): Requests that bond equilibrium constants be ﬁtted alongside their spring constants.

• FitAnglEq (angleq): Requests that angle equilibrium constants be ﬁtted alongside their spring constants.

• FitLJ14 (ﬁtscnb): Requests a linear least-squares ﬁt for Lennard-Jones 1:4 scaling factors.

• FitEE14 (ﬁtscee): Requests a linear least-squares ﬁt for electrostatic 1:4 scaling factors.

• ReportAll (repall): Flag to activate output of all parameters encountered during the ﬁtting procedure, includ-
ing those that were not adjusted by the ﬁt but nonetheless contributed to the molecular mechanics energies.
Default is 1 (write all parameters to the Amber parameter ﬁle), appropriate for creating a parm##.dat ﬁle to
specify a new force ﬁeld. Set to 0 to create ﬁles more akin to frcmod ﬁles.

• ShowProgress (verbose): Alert the user as to the progress of the ﬁtting procedure. Runs involving thou-
sands of molecular conformations and hundreds of parameters can generally be completed in a few minutes.
Default is 1 (ON). Set to zero to suppress output.

• ElimOutliers (elimsig): Flag to activate removal of molecular conformations whose energies are far outside

the norm for other conformations of the same system. Default 0 (do not remove outliers).

• ConfTol (ctol): Tolerance for deviation from the mean energy value, speciﬁed as a function of the standard
deviation for all conformations of the same system. Conformations of a system which exceed this threshold
will be reported if verbose is set to 1, and removed from consideration if elimsig is set to 1. Default 5.0
sigmas.

• EnergyUnits (eunits): Units of the target energy values. Default Hartrees. Acceptable values include

Hartree/Atomic, kJ/kilojoules, and j/joules. Case insensitive.

• AccReport (accrep): Accuracy report on the ﬁt. Contains extensive analysis on the resulting parameters, in

MatLab format.

• ParmTitle (title): Parameter ﬁle title. This is not a ﬁle name, but rathr the title appearing on the ﬁrst line of

the printed ﬁle named by the -d command line / &ﬁles namelist argument.

• Vdw14Fac (scnb): Sets a universal 1:4 scaling factor for van-der Waals interactions. Use this input to change

the scaling on all systems simultaneously.

• Elec14Fac (scee): Sets a universal 1:4 scaling factor for electrostatic interactions. Use this input to change

the scaling on all systems simultaneously.

• BondRest (brst): General value for harmonic restraints on bond stiffness constants.

• AngleRest (arst): General value for harmonic restraints on angle stiffness constants.

• DihedralRest (hrst): General value for harmonic restraints on dihedral cosine amplitude constants.

• CmapRest (mrst): General value for harmonic restraints on CMAP surfaces, coupling adjacent points to

have similar values. This will push the surface towards ﬂatness.

310

16.6. Bonded Term Fitting in mdgx

• CMAPDensity (cmapdens): Density of CMAP surfaces to use in ﬁtting. CMAP surfaces will always be
printed to the parameter ﬁle outputs as 24 x 24 objects. If CMAPDensity is a factor of 24, the outputs will
have perfect ﬁdelity to the original ﬁtted surfaces. Otherwise, the output CMAPs will bear close resemblance
to the original ﬁtted results.

• RestrainB (sbrst): Applies a speciﬁc restraint stiffness to the value of a ﬁtted bond, equivalent to changing
brst for that bond alone. This command takes subdirectives of atom type names, plus ’Keq’ and ’Leq’ (each
followed by a positive real number to denote the target stiffness and equilibrium bond length, respectively).
These subdirectives may be given in free format.

• RestrainA (sarst): Applies a speciﬁc restraint stiffness to the value of a ﬁtted angle, equivalent to changing
arst for that angle alone. This command takes subdirectives similar to sbrst, although ’Leq’ corresponds to
the equilibrium angle rather than length.

• RestrainH (shrst): Applies a speciﬁc restraint stiffness to the value of a ﬁtted torsion amplitude, equivalent
to changing hrst for that torsion alone. This command takes subdirectives (in free format) of atom types,
’period’ or ’per’ followed by a real number for the periodicity, ’weight’ or ’rwt’ followed by a real number
for the restraint strength (which scales just like hrst), and ’target’ or ’trg’ followed by a real number if the
target value of the restraint is non-zero.

• BondCoupling (brstcpl): General value for pricing 1A changes in the ﬁtted equilibrium constant with
kcal/mol-A^2 changes in bond spring constants. The default is 5000.0, which penalizes 50 kcal/mol changes
in the stiffness at the same rate as 0.01A changes in the equilibrium value. Only relevant with FitBondEq =
1.

• AngleCoupling (arstcpl): General value for pricing 1-degree changes in the ﬁtted equilibrium constant with
kcal/mol-rad^2 changes in angle spring constants. The default is 114.59, which penalizes 2 kcal/mol changes
in the stiffness at the same rate as 1 degree changes in the equilibrium value. Only relevant with FitAnglEq
= 1.

• BondBasisSep (lpost): Distance form the original bond equilibrium length to place the equilibrium values

of either of two basis functions for ﬁtting a new bond term.

• AngleBasisSep (thpost): Distance from the original angle equilibrium length to place the equilibrium values

of either of two basis functions for ﬁtting a new angle term.

• Spectrum (spectrum): Request that a particular bond, angle, or dihedral from among the adjustable parame-
ters be sampled near various values along a speciﬁed range, or otherwise included as a reoptimizable variable
while others are resampled. This keyword invokes its own sort of namelist: the sub-directives can be given in
any order, but they must all be given on the same line. Words that are not explicitly sub-directives or values
following them may be counted as atom types, so long as they have fewer than four characters, until four
such types are catalogged. Sub-directives include retain (parameters matching this request are reoptimized
but not resampled), sample (parameters matching this request are resampled), order (followed by a value, 2
= bonds, 3 = angles, 4 = torsions), min and max (followed by values, the resampling range limits), spc (the
resampling discretization), and break (stop adding new sub-directives to this spectrum command). This is an
experimental feature, but may be useful for generating multiple force ﬁeld candidates with subtly different
behavior around the optimal data ﬁt.

The data ﬁtting capabilities in mdgx focus on a single linear least-squares problem, unless the experimental “spec-
trum” option is invoked, in which case a series of linear least squares problems are solved. This is a very active
area of development in mdgx, and will continue to gain new features and capabilities in future patches, with the
goal of leveraging high-performance computing to deliver robust parameter development to novice users.

311

16. Molecular Mechanics Parameter Fitting in mdgx

16.7. Conﬁguration Sampling

While mdgx provides lots of options for its force ﬁeld applications, the charge and bonded parameter devel-
opment are little more than big data ﬁtting problems. They rely on a ﬁnely sampled and complex data set, and
generating such a thing is at tedious process, prone to fatigue and human error. The &conﬁgs namelist in mdgx is
designed to streamline this process by energy-minimizing hundreds to thousands of instances of a single structure,
subject to different constraints, en masse. In principle, everything that this module does could be accomplished
with a shell script executing sander or pmemd, but the execution would take tens to hundreds of times longer
and things that are easily done with mdgx &conﬁgs would take complex shell scripts. Even then mdgx performs
analyses on the data set as a whole that help users to understand whether the data set is suitable for quantum
calculations, and if not, how to improve it. With a sander script, creating 500 energy-minimized conformations
of a drug molecule that sample rotation around three critical dihedrals might take an hour, and the process may
have to be repeated several times to ensure that the restraints are sufﬁciently stiff or that other desgrees of freedom
are properly relaxed or randomized. With mdgx &conﬁgs, the same process will take about a minute, making it
possible to set up higher quality data sets in a single sitting.

To support the operations of conﬁguration sampling, several mdgx inputs have been ungraded to support direc-
tories and regular expressions rather than simply the names of individual ﬁles. A single structure can serve as
input to the conﬁgurations module to make hundreds of copies, but a trajectory, list of trajectories, or directory
containing any number of single-frame ﬁles can also serve. In this manner, one structure can become a thousand,
or the same minimization protocol can be applied to a thousand conformations of the same structure.

Available options for the &conﬁgs module fall into several categories. The minimization protocol itself is guided
by parameters similar to sander inputs. Additionally, mdgx provides a feature for “shufﬂing” results and attempting
additional minimizations. This helps solve the problem of escaping local minima without resorting to much more
costly simulations with temperature to jostle small molecules around.

• Verbose (verbose): Sets the verbosity level (0 is silent, 1 will give frequent updates on the command line.

• Replicas (count): The number of conﬁgurations to generate, if starting from a single conﬁguration in inpcrd

or restart format.

• MaxCycles (maxcyc): The maximum number of line minimization steps to attempt in any one round of

energy minimization.

• SDSteps (ncyc) The number of steepest descent line minimization steps to perform before switching to a
conjugate gradient method. As with the eponymous keywords in sander, ncyc must be less than or equal to
maxcyc.

• ExclTableSize (exclmax): The maximum number of atoms for which a table of non-bonded scaling factors
will be kept. For small systems, it is faster to pre-calculate whether non-bonded interactions will be excluded
or attenuated and store these values in a matrix. However, this is memory-intensive and will trash the cache
for larger systems.
In those cases it is better to store a different sort of data structure that will quickly
determine whether two atoms constitute an exclusion.

• ForceConverge (frctol): Convergence criterion for the optimization. This is a quantity of force--if forces
on all particles have lower magnitude than this value, the energy optimization for that conﬁguration will be
deemed converged.

• StepConverge (steptol): Convergence criterion for the optimization. This is a quantity of distance--if the
movement of all particles along the current force vector is driven lower than this value, the energy optimiza-
tion for that conﬁguration will be deemed converged.

• InitialStep (step0): Initial step size for the energy optimization. This is a quantity of distance: the total
magnitude of the initial step along the ﬁrst computed force vector, that is the square root of the sums of
squares of the displacements of all particles from their original positions, will be equal to this number
(default 0.01A). The step size will be iteratively changed throughout optimization and will be tailored to
each conﬁguration.

312

16.7. Conﬁguration Sampling

• ShufﬂeCount (nshufﬂe): The number of times to restart energy minimizations towards the speciﬁed restraint

targets using different initial states.

• ShufﬂeStyle (shufﬂe): The type of shufﬂing to perform if nshufﬂe > 0. Available methods include "boot-
strap" (new initial states will be assigned randomly from existing solutions, with replacement--one solution
can serve as the initial state for more than one conﬁguration), "jackknife" (the default--each existing solution
will be assigned as the initial state for energy reoptimization to one and only one conﬁguration), and "prox-
imity" (every solved conﬁguration will be evaluated in terms of the restraint targets of every other, and new
initial states will be randomly chosen from among solutions whose restraint energies are within a certain
threshold of the MINIMUM energy found for any existing solution with respect to the particular restraint
targets of a given conﬁguration.

• ProximateNrg (eprox): Threshold energy for taking existing solutions as the intial states for new attempts

at energy minimization if using "proximity" reshufﬂing (default 5.0 kcal/mol).

• ReplacementTol (erep): Threshold for accepting a new solution based on a different initial state. The new

solution must supplant the energy of the existing one by at least this amount. Default 1.0e-4 kcal/mol.

• Direction (shfdir): The direction to replace energies when reshufﬂing energy optimizations. Choices are
"up" and "down". Default is "down," but replacement can be made to move the energies upwards, ﬁnding
new local minima with higher overall energies.

The &conﬁgs module performs energy minimization subject to NMR-like restraints and supports multiple sam-
pling strategies for each of them. Each restraint and sampling strategy commands contains its own vocabulary and
multiple descriptors.

• RandomSample (random): Perform random sampling within a range. This keyword must be followed by
a series of commands, all on the same line of the input ﬁle, but the order of the sub-commands is ﬂexible.
After seeing this keyword, mdgx will search the remainder of the line until it hits another keyword from the
&conﬁgs namelist; until then it will associate any input it ﬁnds with the previous "random" or "Random-
Sample" keyword. The range of sampling in this case is absolute: a ﬂat-bottom harmonic potential will be
constructed, centered on the spot randomly chosen between the limits "min" and "max", or given between
two { } braces. To specify that all conﬁgurations be restrained towards a single target value, the keyword
"center" may be used in place of "min", "max", or { }. The potential shall be ﬂat up to a distance "fbhw"
(ﬂat bottom half width) from the center, and thereafter rise quadratically with a coefﬁcient "Krst" (stiffness
constant K of the restraint) over a length speciﬁed by the "quadratic" keyword, or up to a point at which the
restraint force would reach a limit given by the "Ftop" keyword. Beyond this limit, the force will be clamped
and the restraint potential will be effectively linear, which helps to ensure that restraints to positions far from
the initial conﬁguration do not break things like chirality. Because it is more intuitive to specify a maximum
restraint force than a quadratic window, "Ftop" will take priority over "quadratic" if both keywords are given.
The defaults are to have 64 kcal/mol restraints applied after a 0.5A ﬂat bottom half width, topping out at 32
kcal/mol-A applied force.

• GridSample (uniform): Perform sampling on regular intervals within a range. All of the keywords from

RandomSample apply here as well.

• RandomPerturb (rpert): Perform sampling on regular intervals within a range based on the arrangement of
atoms in each initial structure. All of the keywords from RandomSample apply here as well, except that the
range now speciﬁes minimum and maximum values relative to the initial arrangement of atoms. If multiple
initial structures are read in, this will perturb each of them by similar random amounts.

• GridPerturb (gpert): Perform sampling on regular intervals within a range based on the initial arrangement

of atoms. This is to RandomPerturb as GridSample is to RandomSample.

• LinkOperationsCombine (combine): Combine two operations involving grid-based, interval sampling.
Without any such combinations, the interval sampling restraints in each conﬁguration will march from one

313

16. Molecular Mechanics Parameter Fitting in mdgx

end of their respective ranges to the other, in unison--this will generate a line of conﬁgurations in the multi-
dimensional space deﬁned by each restrained coordinate. To sample two or three dimensions of the space
simultaneously at regular intervals, combine the operations. Up to three operations may be combined. For N
combined operations, mdgx will take the Nth root of the total number of conﬁgurations and take this many
samples along each of the combined restraint dimensions.

• MovingAtoms (belly): Make only the atoms in the given ambmask string movable during geometry opti-

mization.

The &conﬁgs module supports multiple output formats for the minimized structures, including the well known
PDB format and outputs that can serve as input ﬁles for some popular quantum packages.

• ShowOrigins (showorig): Flag to have mdgx show the original ﬁles for each conﬁguration that it solves. If
all conﬁgurations start from a single state in a single ﬁle, the default behavior is to withhold this reporting.
However, if there are many ﬁles, the origin of each conﬁguration may not be so obvious, and while mdgx
does attempt to alphabetize and organize long lists of ﬁles arising from directory searches or regular expres-
sions the evolution of molecular conﬁgurations may be of interest. In these cases the default behavior is to
report the origins of each conﬁguration.

• OutputBase (outbase): The bases of the output ﬁle names for conﬁgurations. The format will be
<base><number>.<sufﬁx>. Multiple strings may follow this keyword, so long as they are all on the same
line. Each string provided will be matched with a sufﬁx and a style provided, in the order each is given.

• OutputSufﬁx (outsuff): Sufﬁxes of the output ﬁle names for printed conﬁgurations.

• OutputType (write): The type of output to write, options being "CRD" (old Amber .crd format trajec-
tory), "CDF" (Amber netCDF trajectory), "INPCRD" (Amber ascii 7-decimal place inpcrd ﬁle for individual
conﬁgurations), "PDB" (PDB format, with descriptions of the way the conﬁguration was generated in the
REMARK section), and "ORCA", "GAUSSIAN", "MOLPRO", and "GAMESS" for input ﬁles to various
quantum packages. If trajectories are being written, all conﬁgurations that pass sanity checks will be printed
to the ﬁle. For the other formats, individual conﬁgurations will be printed to separate ﬁles. More than one
type of output may be written after creating a set of conﬁgurations.

Sanity checking is an essential part of data set creation. Because all mdgx outptus are already energy minimized
with respect to an input force ﬁeld, they are already mostly “sane.” However, with any minimization there can be
traps, local minima, and residual strain that should be considered before submitting the conﬁguration to quantum
methods or using it as input data for making a force ﬁeld. mdgx will automatically check for some common
problems, decline to print structures that have them, and report what went wrong so that the conﬁguration sampling
can be repeated for better results.

• BondStrain (bstrain): The maximum bond strain (according to the input force ﬁeld, as given in the topology

ﬁle) that will be tolerated in any conﬁguration that is to be printed.

• AngleStrain (astrain): The maximum bond angle strain (according to the input force ﬁeld, as given in the

topology ﬁle) that will be tolerated in any conﬁguration that is to be printed.

• StrainLimit (strainlim): The maximum restraint penalty that will be tolerated in any conﬁguration. Note
that, for any of these sanity checks, convergence of the energy minimization is NOT an automatic fail--it
will simply be noted in the report ﬁle summarizing the process. Rather, the sanity checks pertain to features
of the structures that appear well outside the applicable range of molecular mechanics functions.

When the output structures are given as inputs for quantum calculations, there are other considerations for running
the QM program itself. While advanced use of the quantum programs may require post-processing the ﬁles with a
shell script, mdgx does interpret some basic run parameters and incorporate them into its results.

• MaxMemory (maxcore): When ordering mdgx to print conﬁgurations as input ﬁles to quantum packages,

this states how much memory should be available for QM calculations.

314

16.8. Parallel Generalized Born Problems on the GPU

• CPUCount (ncpu): The number of CPUs to apply in each QM calculation.

• Multiplicity (spin): The multiplicity to assign to this system (in all its conﬁgurations) for quantum calcula-

tions. mdgx is not able to calculate this on its own.

• QMTheory (qmlev): The level of theory to apply in quantum calculations.

• QMBasis (basis): The basis set to apply in quantum calculations.

• Checkpoint (chk): The checkpoint ﬁle to write if using Gaussian for QM calculations.

16.8. Parallel Generalized Born Problems on the GPU

The mdgx program’s ability to read multiple topologies enabled a new strategy for conducting simulations of
small, implicit solvent systems on the GPU. The benchmarks on the Amber website show how a 305 atom Trp
Cage system runs at greater speed than a much larger, 2400 atom myoglobin system, but not nearly the 64-fold
increase that would be expected from the system’s size and the scaling of the non-bonded interaction calculation
which dominates the effort. Not even the myoglobin system compares favorably to the very large nucleosome
simulation, which ﬁnally tops out the GPU’s bandwidth for generalized Born calculations.

The mdgx peptide multi-simulator is the program’s ﬁrst CUDA extension for implicit solvent GB and gas-phase
molecular dynamics. It treats a GPU as miniature Beowulf cluster of streaming multiprocessors (SMPs) and uses
the device’s block scheduler as a queueing system of sorts. This paradigm shift in GPU utilization can backﬁll
idle SMPs to reap enormous gains in total throughput on small systems (928 atoms maximum) and may even
exceed the simulation rate of pmemd.cuda for very small systems (less than 225 atoms). While it offers RATTLE,
the equivalent of SHAKE for mdgx’s velocity-Verlet integrator, the module also offers a velocity-Verlet I/r-RESPA
multi-time stepping scheme which performs at least as well as SHAKE in most cases, and often considerably better
in terms of speed and energy conservation.

The sizes of systems served by this module cover a range ideal for Generalized Born calculations. Systems
with more than 928 atoms will engage the pmemd.cuda GB engine with reasonable efﬁciency. The mdgx engine is
instead designed for maximum throughput on one or more systems by simulating independent copies on all of the
GPU’s SMPs.

A reliable approach for getting the best throughput on a single system is to call for a number copies of the system
equal to number of SMPs on the GPU SMP, or twice that number if the system has 512 or fewer atoms, or four
times that number if the system has 256 or fewer atoms. The number of SMPs will be displayed in mdgx output
(Section 5,’GPU Utilization’), as will the thread block and block grid sizes.

For the best throughput on an array of systems with varying sizes, the ﬁrst thing to understand is that simulation
time will scale as the square of the system size and cause each system to ﬁnish at a different rate. If the spread
of sizes is great, this will create a lot of idle SMPs as the GPU works to ﬁnish the largest simulation. However, if
mdgx has additional systems to run, it can backﬁll the idle SMPs with more work. The program will automatically
arrange the systems internally in decreasing order of size, to run the largest ﬁrst and the smallest last. It is therefore
advantageous, if trying to simulate many systems of disparate sizes, to queue up many more systems than the size
of the block grid (which will be determined by the number of SMPs and the size of the largest sytem). By queueing
three to four times as many systems as the size of the mdgx block grid, the entire GPU can keep busy.

The main input for this section is the Peptide / oligomer keyword, followed by a list of subdirectives reminiscent
of sander command line input. Many directives will be carried down from the &ﬁles and &cntrl namelists, such
as DoRATTLE / rigidbonds, thermostat controls, and the time step. The &pptd namelist can override some of
these directives for speciﬁc oligomers. Other parameters that can inﬂuence the dynamics, such as the GB style, are
native to the &pptd namelist as this is the only context in which they can be used.

• Peptide (oligomer): A system to simulate in non-periodic conditions (implicit solvent or vacuum). After
seeing this keyword, mdgx will search the remainder of the line until it hits another keyword from the
&pptd namelist; until then it will associate any input it ﬁnds with the previous "oligomer" or "Peptide"
keyword. Each oligomer requires its own topology and input coordinates, speciﬁed by the -p and -c ﬂags
to mirror sander command line input. Files for mdout, mdcrd, and mdrst can be supplied with ﬂags -o, -x,

315

16. Molecular Mechanics Parameter Fitting in mdgx

and -r, respectively, again like sander command line input. Multiple copies of the system can be speciﬁed
by including the N-rep ﬂag followed by the number. It is also possible to simulate replicas at a range of
temperatures by providing the T-rep ﬂag followed by an integer as well as a temperature range with the ﬂags
Tmin and Tmax (each followed by a real number). Replicas will be simulated at evenly spaced intervals of
the temperature, inclusive of the two end points (i.e. Tmin 100.0 Tmax 200.0 T-rep 11 would create replicas
at 100.0, 110.0, 120.0, ..., 200.0K). To simulate all replicas at one particular temperature which differs from
temp0 in &cntrl, temp0 may also be supplied as a ﬂag for a speciﬁc oligomer. Also, the -p ﬂag may be
replaced by -pi and -pf, each followed by a topology ﬁle, to create replicas based on interpolated topologies.
The two topologies must have similar atom counts, names, and bonding patterns, but otherwise are just two
endpoints. With two topologies, the P-rep ﬂag followed by an integer will specify the number of copies
to make at regular intervals along a linear interpolation between the topologies, again inclusive of the end
points.

• GBStyle (igb): Type of Generalized Born solvent to use. All standard sander settings, including 7 and 8

(neck GB) and 6 (vacuum conditions) are available.

• GBOffset (offset): The offset for GB radii calculations. For igb=8 (Neck GB II), this is 0.195141. For all

other models it is 0.09.

• MinorSteps (bondstep): The number of minor steps to use in a velocity Verlet I/r-RESPA multiple time-
stepping scheme. To say "bond steps" is a bit of a misnomer: bond, angle, and 1-4 non-bonded interactions
are all recalculated on each minor step in between major steps where general non-bonded and dihedral
interactions are calculated.

• Dielectric (diel): Dielectric constant for the solvent, whether GB or some continuum homogeneous envi-

ronment.

316

17. Python Metal Site Modeling Toolbox (pyMSMT)

17.1. Introduction

The Python Metal Site Modeling Toolbox (pyMSMT) is a python package for metal site modeling of mixed
systems (especially protein systems) for ultimate use in molecular dynamics simulations. It could facilitate pa-
rameterization of both the bonded and nonbonded models. This toolbox was developed by Pengfei Li in Prof.
Kenneth M. Merz, Jr.’s research group at Michigan State University and now who is a postdoc in Prof. Sharon
Hammes-Schiffer’s research group at Yale. Li and Merz have written a comprehensive review about metal ion
modeling, which covers a wide spectrum of models including quantum mechanics models, classical force ﬁeld
models, polarizable force ﬁeld models, reactive force ﬁelds, and some other types of models.[393] People who are
interested can check the review article for more details. Users are welcome to send suggestions and bug reports to
AMBER Mailing List (amber@ambermd.org).

In the current version, six applications are supported by the pyMSMT package:

1. MCPB.py: a Python version for the Metal Center Parameter Builder (MCPB). MCPB.py supports various
metal ions (more than 80 metal ions with partial charges/oxidation-states from +1 to +8, literally), different
AMBER force ﬁelds (ff94, ff99, ff99SB, ff03, ff03.r1, ff10, ff14ipq, ff14SB, ff14SB.redq, ff14SBonlysc,
ff19SB, ff15ipq, ff15ipq-vac, fb15, GAFF, and GAFF2 in the current version), different parameterization
methods (Seminario, Z-matrix and empirical), and different models (bonded model and nonbonded models
for metal ions). It could facilitate parameterization of both metalloproteins and organometallic compounds.
The workﬂow is more efﬁcient and many of the modeling processes in previous MCPB versions are auto-
matically implemented into MCPB.py (MCPB.py uses about 10 fewer steps and many fewer scripts than
MCPB). An application note of the program is published by Li and Merz.[394] The main scheme and pa-
rameters are based on previous papers published by Merz et al.[116–119, 395]

2. IPMach.py: the Python ion parameterization machine. IPMach.py could largely facilitate the parameteriza-
tion for the 12-6 LJ model and 12-6-4 LJ-type model of ions. It could automatically parameterize the 12-6
LJ model for a given hydration free energy or ion-oxygen distance, and the 12-6-4 LJ-type model for given
hydration free energy and ion-oxygen distance.

3. PdbSearcher.py: the Python version of Pdbsearcher. PdbSearcher.py better supports the automatic recog-
nition of the metal centers in a PDB ﬁle due to better compatibility with the PDB naming scheme of metal
ions.

4. OptC4.py: a program to optimize theC4 terms of the 12-6-4 potential using the AMBER topology and coor-
dinate ﬁles. It can automatically optimize the metal-site-relatedC4 terms to better reproduce the experimental
structure. It uses the sum of unsigned error of metal site bond lengths, angles and dihedrals as the criterion
(in which the bond, angle and dihedral have different weights). For each optimization cycle, the structure
will be minimized by OpenMM[396, 397] and then have the sum of unsigned error calculated. It requires
OpenMM version 6.3 and an installed SciPy package in current version.

5. CartHess2FC.py: the program to calculate the force constants using Cartesian Hessian matrix based on
Seminario method. It could calculate all the bond and angle force constants of a system based on a Gaussian
fchk ﬁle or GAMESS log ﬁle that contains the Cartesian Hessian matrix.

6. espgen.py:

the Python version of espgen in the antechamber package.

It could extract the electrostatic
potential information from a Gaussian output ﬁle or GAMESS log ﬁle that contains this information. It
supports Gaussian03, Gaussian09 and GAMESS.

317

17. Python Metal Site Modeling Toolbox (pyMSMT)

7. ProScrs.py: the "Protein Scissors" program for cutting and capping the protein segment into clusters.

8. car_to_ﬁles.py:

the program to generate the mol2 and PDB ﬁles based on the car ﬁle. This func-
tion is designed for users of the INTERFACE force ﬁeld in AMBER, which can be checked at
https://bionanostructures.com/interface-md/.

9. amb2chm_psf_crd.py: the program to generate the CHARMM PSF and CRD ﬁles based on the AMBER

prmtop and inpcrd ﬁles. This function is designed for users of the AMBER force ﬁeld in CHARMM.

10. amb2chm_par.py: the program to generate the CHARMM PAR ﬁle based on the AMBER dat/frcmod ﬁle.
It can combine several AMBER dat and/or frcmod ﬁles into one CHARMM par ﬁle in one single step. This
function is designed for users of the AMBER force ﬁeld in CHARMM.

11. mol2rtf.py:

the program to generate the CHARMM RTF ﬁle based on the mol2 ﬁle. This function is

designed for users of the AMBER force ﬁeld in CHARMM.

12. amb2gro_top_gro.py: the program to generate the GROMACS top and gro ﬁles based on the AMBER

prmtop and inpcrd ﬁles. This function is designed for users of the AMBER force ﬁeld in GROMACS.

13. metalpdb2mol2.py: the program to convert PDB ﬁles of metal ions to mol2 ﬁles. This function is designed

for users of the MCPB.py program.

17.2. Usage

The following is a summary of the usage and options for the three applications:

17.2.1. MCPB.py

Usage: MCPB.py -i input_file -s/--step step_number

[--logf Gaussian/GAMESS-US output logfile]
[--fchk Gaussian fchk file]

Options:

-h, --help
-i INPUTFILE
-s STEP, --step=STEP
--logf
--fchk

show this help message and exit
Input file name
Step number
Gaussian/GAMESS-US output logfile
Gaussian fchk file

The following is an introduction of the variables in the input_ﬁle:

(Reminder: there should be no blank lines in the input_ﬁle. The values or parameters should follow the variables

separated by a space.)
Required variables:

ion_ids The PDB atom ID(s) of the complex’s central metal ion(s). If there is only one metal ion in the metal
site, you need to put its PDB atom ID after the variable. If there are multiple metal ions in the metal site,
you need to put the PDB atom IDs of all these metal ions (with these IDs are separated by space) after the
variable. Each PDB atom ID should be an integer value.

ion_info This variable is only required for the nonbonded model without reﬁtting the residue charges (step number
4n2). In all, there are four data points required for each metal ion: 1) the residue name of the metal ion in
the PDB ﬁle; 2) the atom name of the metal ion in the PDB ﬁle; 3) the element symbol of the metal ion; 4)
the charge (or oxidation state, which needs to be an integer) of the metal ion. For example: ZN ZN Zn 2 (the
ﬁrst two are the residue and atom name of the Zn2+ ion in the PDB ﬁle, the third is its element symbol and
the last one is its charge).

318

17.2. Usage

ion_mol2ﬁles The name(s) of the ion(s) in the mol2 ﬁle(s) contained in the metal center. This can be one or
several name(s), depending on how many kinds of ions are included in the metal center. The user can use
antechamber to transfer the single ion PDB ﬁle to a mol2 ﬁle and then manually modify the atom type and
the atomic charge of the metal ion in the mol2 ﬁle.

original_pdb This is the ﬁle name of the original PDB ﬁle, which should have only one chain. The PDB ﬁle
should have hydrogen atoms and metal ions in it. Users are advised to use an application like pdb4amber to
clean up the PDB ﬁle ﬁrst. They are also advised to add the hydrogen atoms by using a webserver such as
H++ before performing the modeling in MCPB.py.

Optional variables:

add_bonded_pairs Specify the bonded atom pair(s) you want to add in the model building by MCPB.py. In
default MCPB.py only detect the Metal-N/O/S/F/Cl/Br/I bond, if you have a other kind of metal ligating
bond in the metal site (e.g. Metal-C bond), you need to specify the atom numbers of metal and the ligating
atom in the input ﬁle. There should be dash between the numbers of two atoms bonded together. For
example, if you have two Metal-C bond in the metal site, and the metal has atomic number as 1001, while
the two carbon atoms have atomic numbers as 1320 and 1380 respectively, you can use add following line
in the input ﬁle: "add_bonded_pairs 1001-1320 1001-1380" or use two separate lines as "add_bonded_pairs
1001-1320" and "add_bonded_pairs 1001-1380". [The default value of this variable is the null list.]

add_redcrd Specify whether additional redundant coordinates added to the Gaussian calculations for the small
model. This option is designed for the Z-matrix method. If you are using Seminario method, this option can
be ignored. In default Gaussian performed the geometry optimization using redundant internal coordinates,
the default internal coordinates may not have the metal-ligand coordination bonds and angles (means the
angles which including metal) included.
If these bonds and angles are not included, it will cause users
could not generate related force constants when using the Z-matrix method. 0 means do not add redundant
coordinates for metal-ligand coordination bonds and angles. 1 means add redundant coordinates for metal-
ligand coordinate bonds and angles to the optimization of the small model.
In this way, the afterwards
force constant calculation will use the same redundant internal coordinates as the optimization procedure
when it reads the formerly generated chk ﬁle. Care should be taken that chosing 1 may cause convergence
failure for geometry optimization, when chosing 2 is suggested. 2 means only do that for the force constant
calculation of the small model. This option is suggested to use when user use option 1 but could not get a
converged results for the geometry optimization procedure. In this way, Gaussian will perform the geometry
optimization in a default manner, but the force constants for the Z-matrix will be based on the updated
redundant coordinates. [The default is 0.]

additional_resids Specify the residues’ IDs for which you want to add to the models built by MCPB.py. For
example, it may be a residue in the second layer which coordinates a metal bonded residue. It will increase
the computational cost for QM calculations. [The default value of this variable is the null list.]

anglefc_avg A variable used to indicate whether to make an average of angle force constants derived based on
different manners of chosing the sub-matrices in Seminario method. There are A-B and B-A two ways
of chosing the sub-matrix for two atoms in the parameter derivation process based on Seminario method.
The angle force constant obtained based on different manners of chosing the sub-matrices may not have
big differences. Two options are available: 0 or 1. 0 means not making average, using the default manner
to chose the sub-matrices. 1 means making average of different manners to chose the sub-matrices. [The
default is 0.]

bondfc_avg A variable used to indicate whether to make an average of bond force constants derived based on
different manners of chosing the sub-matrix in Seminario method. There are A-B and B-A two ways of
chosing the sub-matrix for two atoms in the parameter derivation process based on Seminario method. The
bond force constant obtained based on different manners of chosing the sub-matrix would not have big
differences. Two options are available: 0 or 1. 0 means not making average, using the default manner to
chose the sub-matrix. 1 means making average of different manners to chose the sub-matrix. [The default is
0.]

319

17. Python Metal Site Modeling Toolbox (pyMSMT)

chgﬁx_resids Specify the residues’ IDs whose charges are going to be ﬁxed during the charge ﬁtting. The ﬁxed
charge values are referenced from the mol2 ﬁles used during the modeling. [The default value of this variable
is the null list.]

cut_off The cutoff value is used to indicate there is a bond between the metal ion and the surrounding atoms. The

unit is Angstroms. [The default is 2.8.]

force_ﬁeld The user-designated name of the force ﬁeld. The current version supports ff94, ff99, ff99SB, ff03,
ff03.r1, ff10, ff14ipq, ff14SB, ff14SB.redq, ff14SBonlysc, ff19SB, ff15ipq, ff15ipq-vac, and fb15. [The
default is ff19SB.]

frcmod_ﬁles The variable used to indicate the parameter modiﬁcation ﬁle(s) for the nonstandard residue(s) (e.g.
frcmod ﬁle generated by parmchk for a ligand molecule) in the metal complex. It can be one name or several
names separated by space. [The default value of this variable is the null list.]

gaff A variable used to indicate the use of a GAFF force ﬁeld during the modeling. 0 means no, 1 means using

GAFF, 2 means using GAFF2. [The default is 1.]

group_name The group name the user has speciﬁed. The group name is the preﬁx for different kinds of modeling

ﬁles e.g. PDB, ﬁngerprint and Gaussian input ﬁles for different models. [The default is MOL.]

ion_paraset The user-designated ion parameter set to be used in the nonbonded model.

(This option has no
inﬂuence on the metal ion VDW parameters in the bonded model, in which the author has chosen certain
VDW parameter sets for different ions.) There are four options for this variable: HFE, CM, IOD and 12_6_4
(reminder: there are underlines between the numbers). If you use the 12-6 Lennard-Jones nonbonded model,
the recommended settings are the HFE set for the +1 and -1 ions, the CM set for the +2 ions, and the IOD
set for the +3 and +4 ions. They are also the default settings for these metal ions.

large_opt A variable used to indicate whether to do an geometry optimization in the Gaussian input ﬁle. Three
options are available: 0, 1, or 2. 0 means no optimization, 1 means only optimizing the hydrogen positions,
2 means full geometry optimization. [The default is 0.]

lgmodel_chg Specify the total charge of the large model.

[The default value of the charge will be assigned
automatically by the program, which is not guaranteed to be right. Careful check is suggested from running
the Gaussian/GAMESS-US program. If it is not right, you can add this option with right charge into the
MCPB.py input ﬁle and regenerate the modeling ﬁles.]

lgmodel_spin Specify the spin of the large model. [The default value of the spin will be assigned automatically
by the program as 1 or 2, based on the number of electrons. This is not guaranteed to be right. Careful check
is suggested from running the Gaussian/GAMESS-US program. If it is not right, you can add this option
with right spin into the MCPB.py input ﬁle and regenerate the modeling ﬁles.]

naa_mol2ﬁles The variable used to indicate non-amino acid mol2 ﬁle(s) in the metal complex if there are any
nonstandard residue(s) in the metal complex. Examples of nonstandard residues include hydroxyl group and
ligand molecules. For these residues, the user can use antechamber to generate the mol2 ﬁle(s) by ﬁrst doing
an AM1-BCC or HF/6-31G* RESP charge ﬁt and then assigning an AMBER atom type (recommended for
water or hydroxyl group) or a GAFF atom type (recommended for ligand). [The default value of this variable
is the null list.]

scale_factor Specify the frequency scale factor for force constant derivation based on QM methods. This scale
factor will scale all the bond and angle force constants determined from the QM calculations.Reminder: The
force constant scale factor is usually equals the sqaure of frequency scale factor. For example, if you are
using HF/6-31G* level of theory to do calculation and its frequency scale factor is 0.9, the force constant
scale factor you need to use is 0.9^2=0.81. [The default value is 1.0 (no scaling performed).]

320

17.2. Usage

smmodel_chg Specify the total charge of the small model. [The default value of the charge will be assigned
automatically by the program, which is not guaranteed to be right. Careful check is suggested from running
the Gaussian/GAMESS-US program. If it is not right, you can add this option with right charge into the
MCPB.py input ﬁle and regenerate the modeling ﬁles.]

smmodel_spin Specify the spin of the small model. [The default value of the spin will be assigned automatically
by the program as 1 or 2, based on the number of electrons. This is not guaranteed to be right. Careful check
is suggested from running the Gaussian/GAMESS-US program. If it is not right, you can add this option
with right spin into the MCPB.py input ﬁle and regenerate the modeling ﬁles.]

software_version The version of software the user used to perform the QM calculations. Five options are avail-
able, g03 (which represents Gaussian03), g09 (which represents Gaussian09), g16 (which represents Gaus-
sian16), gau (which represents Gaussian), and gms (which represents GAMESS-US). In the current version
of MCPB.py, all the three Gaussian versions (g03, g09, and g16) are equally supported, all of them are equal
to option gau, with they are kept for backward compatibility. [The default is gau.]

sqm_opt A variable used to indicate the use of SQM in AmberTools to do a simulation of the sidechain and/or
large model before using Gaussian to perform the calculation. Please note: if 1, 2 or 3 are chosen, the ﬁrst
step of the modeling process will take additional time (minutes for the sidechain model and hours for the
large model). [The default is 0.]

• 0 – means no use of SQM.

• 1 – means the optimization is done only for the sidechain model.

• 2 – means the optimization is done only for the large model.

• 3 – means the optimization is done for both the sidechain and large models.

water_model The user-designated water model to be used in the molecular modeling. Options are TIP3P, SPCE

and TIP4PEW. [The default is TIP3P.]

xstru Specify whether the structure in the original PDB ﬁle is used to generate the equilibrium bond distances and
angle values in the frcmod ﬁle. 0 means not using, but use the QM optimized structure. 1 means using. [The
default is 0.]

The following is an explanation of the step number variables:

Here are the options for the step_number:
For step1 there are three options: 1a (default, same as specifying 1), 1m and 1n.
For step2 there are four options: 2b, 2e, 2s (default, same as specifying 2) and 2z.
For step3 there are four options: 3a, 3b (default, same as specifying 3), 3c and 3d.
For step4 there are three options: 4b (default, same as specifying 4), 4n1 and 4n2.
The following is the detailed explanation of the steps used in the modeling procedure:

Step1. Used to generate the modeling ﬁles (e.g. PDB, ﬁngerprint and Gaussian input ﬁles) for different models
(e.g. sidechain, standard and large models). Three options are available and their explanation is shown
below. Default is 1a.

• 1a – Used to automatically rename the atom types of the center metal ions and the surrounding bonded atoms

in the standard ﬁngerprint ﬁle.

• 1m – Used to automatically rename only the atom type(s) of the center metal ion(s) to the AMBER atomic

ion atom type style in the standard ﬁngerprint ﬁle.

• 1n – Used to generate the standard ﬁngerprint ﬁle without renaming the atom types. Users can rename the

atom type of the metal ion(s) and its ligating atoms manually in the standard ﬁngerprint ﬁle.

321

17. Python Metal Site Modeling Toolbox (pyMSMT)

Please note: Between using Step1 and Step2, the Gaussian calculations (if needed), should be done for the
sidechain model (to calculate the force constants) and the large model (to do the RESP charge calculation) us-
ing Gaussian input ﬁles. Prior to the calculation, users can change the parameters (such as the calculation method,
basis set, etc.) in the Gaussian input ﬁles according to their own preferences. After ﬁnishing this procedure, the
user can move on to Step2.

Step2. Used to generate the frcmod ﬁle for the modeling. In this step, a frcmod ﬁle (with pre.frcmod name at
the end of the ﬁle name), will be pre-generated. This ﬁle includes all the parameters, except the bond and
angle parameters related to the metal ions. Later, the ﬁnal frcmod ﬁle will be generated which will include
all the parameters. There are three methods to choose from: Empirical, Seminario and Z-matrix. Each of
these methods generates the metal ion-related bond and angle parameters. If you don’t have a QM optimized
structure, you can also generate a frcmod ﬁle with metal related bond and angle parameters as zero (as step
2b) and then manually modify it later for further usage. Default is the 2s (Seminario method).

• 2b - The "blank" methodGenerate a frcmod ﬁles with metal related bonds and angles have zero as the
equilibrium values and force constants.
If use with option "xstru 1" in the MCPB.py input ﬁle, it will
generate the equilibrium values based on the orignal PDB structure and force constants as zero. User can
modify the generated frcmod ﬁle by manually assigned bond and angle parameters for further usage.

• 2e – The Empirical method,[398]can generate the metal ion-related bond and angle parameters efﬁciently

without doing Gaussian calculations. It only supports Zn2+ ion in the current version.

• 2s – The Seminario method[399] generates the force ﬁeld parameters based on sub-matrices of the Cartesian
Hessian matrix obtained from quantum calculations. This method requires a Gaussian fchk ﬁle (which can
be generated from a chk ﬁle by using the formchk command in Gaussian).Reminder: both the geometry op-
timization and force constant calculation procedures are needed to generate the ﬁnal chk ﬁle and subsequent
fchk ﬁle for the force constant calculations done by the Seminario method.

• 2z – The Z-matrix method generates the force ﬁeld parameters by using the Cartesian Hessian matrix ob-
tained from the quantum calculations. This method requires the force constant Gaussian output ﬁle (usually
named as a log ﬁle) after the geometry optimization and force constant calculations.

Step3. Used to perform the RESP charge ﬁtting and to generate the mol2 ﬁles for the residues within the metal
ion complex. There are several ﬁtting schemes available in this step. The four options are shown below.
The default is 3b since Seminario/ChgModB was identiﬁed as the best combination in the work of Peters
et al.[395]Reminder: the chgﬁx_resids variable is effective in this procedure, if the variable is speciﬁed, the
charge restriction will be used as well as one of the following choices.

• 3a – Allows all the charges of the atoms in the ligating residues to change without any restrictions.

• 3b – Restrains the charges of the heavy backbone atoms in the ligating residues according to the user-chosen

force ﬁeld.

• 3c – Restrains the charges of the backbone atoms (both heavy and hydrogen atoms) in the ligating residues

according to the user-chosenforce ﬁeld.

• 3d – Restrains the charges of the backbone atoms (both heavy and hydrogen atoms) and C beta atoms in the

ligating residues according to the user-chosen force ﬁeld.

Step4. Generates the leap input ﬁle. The default is 4b.

• 4b – Generates the leap input ﬁle for the bonded model.

• 4n1 – Generates the leap input ﬁle for the nonbonded model and reﬁts the charge of the ligating residues.

• 4n2 – Generates the leap input ﬁle for the nonbonded model without reﬁtting the charge of the ligating

residues.

322

17.2. Usage

the following steps are usually needed (4 steps):

1) For

the modeling of

Here are some suggestions for the parameterization procedure:
1a/1n→2e/2s/2z→3a/3b/3c/3d→4b
1m→3a/3b/3c/3d→4n1

the bonded model,

2) For the modeling of a non-bonded model with a reﬁtted charge, users can follow the workﬂow (3 steps):

3) For modeling with a normal nonbonded model (without ﬁtting any charges), users usually only need one step

to perform the modeling (1 step): 4n2.

The following is an explanation of the logf and fchk variables:
These variables are optional. If provided, they are only active in step2 and/or step3. The default log ﬁle name
is group_name + ’_sidechain_fc.log’ for step2 and group_name + ’_large_mk.log’ for step3. The default fchk ﬁle
name is group_name + ’_sidechain_opt.fchk’ and it is only active for step2 when using Gaussian software and
Seminario method to obtain the force constant parameters.

If you are using Gaussian software and Seminario method to generate force constant parameters, it uses the fchk
ﬁle of sidechain model to store the Cartesian Hessian matrix. If you are using Gaussian software and Z-matrix
method to generate force constant parameters, it uses the log ﬁle of sidechain model to store the force constant
parameters. While if you are using GAMESS-US software and Seminario method to generate the force constants,
it uses the log ﬁle of sidechain model to store the Cartesian Hessian matrix. In current version the software doesn’t
support GAMESS-US with Z-matrix method to generate the force constants.

Both the Gaussian and GAMESS-US software use the log ﬁle of large model to store the ESP charges.

17.2.2. IPMach.py

Usage: IPMach.py -i inputfile
Options:

-h, --help
-i INPUTF

show this help message and exit

Input file name

The following is an introduction of the variables in the input_ﬁle:

(Reminder: there should be no blank lines in the input_ﬁle. The values or parameters should follow the variables

separated by a space.)
Required variables:

resname Residue name of the ion for parameterization (e.g. NA).

atname Atom name of the ion for parameterization (e.g. NA).

element Element of the ion for parameterization (e.g. Na).

attype Atom type of the ion for parameterization (e.g. Na+).

attype Charge of the ion for parameterization (e.g. 1).

Optional variables:

cpus Number of cpus to be used during the parameterization (e.g. 2). There are at least 2 cpus needed to perform
TI simulation using sander program. While 1 cpu could also be used to perform TI simulation using pmemd
program. [The default is 2.]

gpus Number of gpus to be used during the parameterization. It should be 0 or 1. If it equals 1, the pmemd.cuda

program will be used. [The default is 0.]

tisteps Number of steps used during the thermodynamic integration simulation. Two options are available: 1 or
2. 1 means use the "one-step" method while 2 means use the "two-step" method. The "two-step" method
generally needs longer simulation time but gives better accuracy. [The default is 2.]

ti_windows Number of windows used for the "one-step" TI simulation. Which is not effective when using the

"two-step" TI simulation method. [The default is 7.]

323

17. Python Metal Site Modeling Toolbox (pyMSMT)

vdw_windows Number of windows used for the VDW scaling step in the "two-step" simulation method. Which

is not effective when using the "one-step" TI simulation method. [The default is 3.]

chg_windows Number of windows used for the charge scaling step in the "two-step" simulation method. Which

is not effective when using the "one-step" TI simulation method. [The default is 7.]

rev Whether reverse TI simulation performed. There are two options available: 0 or 1. 0 means no, 1 means yes.
Performing reverse TI simulation could double the simulation time but offer more valid results. [The default
is 1.]

rmin VDW radius parameter (unit is Angstrom) used for the initial guessing. [The default is 1.5.]

hfe Target hydration free energy value (unit is kcal/mol) used for the parameterization. [The default is -100.0.]

hfe_tol Tolerance of target hydration free energy value (unit is kcal/mol) during the parameterization. [The default

is 1.0]

iod Target ion-oxygen distance of ﬁrst solvation shell (unit is Angstrom) used for the parameterization. [The

default is 2.0.]

iod_tol Tolerance of target ion-oxygen distance of ﬁrst solvation shell (unit is Angstrom) during the parameteri-

zation. [The default is 0.01.]

cal_type Type of the calculation: whether it is a optimization (OPT), or single point calculation (SP). [The default

is OPT.]

set Parameter set to generate. Three options are available: HFE, IOD, or 1264. The HFE parameter set will treat
hydration free energy as target during the parameterization. The IOD parameter set will treat ion-oxygen
distance of ﬁrst solvation shell as target during the parameterization. The variable should be set to 1264 for
the 12-6-4 calculations. Otherwise it will be set to 1264 automatically if the c4v variable is not equal to 0.0.
[The default is HFE.]

maxiter Maximum iteration steps during the parameter optimization. [The default is 100.]

mode There are three modes available for running the program:

test, scan, normal. These three modes will

increase the simulation time one-by-one. [The default is normal]

program The MD program used during the parameterization. Two options: sander or pmemd. Reminder:
pmemd.cuda can perform TI simulations for the 12-6-4 LJ-type model starting from Amber18. However,
in the current version of release, IPMach.py does not support TI simulations with the 12-6-4 LJ-type model
using the pmemd program (neither pmemd, pmemd.MPI, nor pmemd.cuda). [The default is sander.]

watermodel Water model used during the parameterization. The ion parameters may vary for different water
models. It is suggested to parameterize a ion model for a speciﬁc water model. Ten options: tip3p, tip4p,
tip4pew, tip5p, spc, spce, opc3, opc, fb3, and fb4. [The default is tip3p.]

c4 Initial C4 values between ion and oxygen in water for parameterization of the 12-6-4 model for ions. Unit is
kcal/mol * Angstrom^4. The input value will be kept to 1 decimal place. [The default is 0.0, means only
12-6 parameters with no C4 parameters applied.]

distance The distance variable for the solvateBox command in LEaP when creating the periodic solvent box
around the metal ion. Unit is Angstrom. The input value will be kept to 1 decimal place. [The default is
13.0.]

324

17.2.3. PdbSearcher.py

Usage: PdbSearcher.py -i/--ion ionname -l/--list input_file

-e/--env environment_file -s/--sum summary_file
[-c/--cut cutoff]

Options:

17.2. Usage

-h, --help
-i IONNAME, --ion=IONNAME Element symbol of ion, e.g. Zn
-l INPUTF, --list=INPUTF

show this help message and exit

List file name, list file contains one
PDB file name per line

-e ENVRMTF, --env=ENVRMTF Environment file name. An environment file is used

-s SUMF, --sum=SUMF

-c CUTOFF, --cut=CUTOFF

to store the metal center environment information
such as ligating atoms, distance, geometry etc.
For each bond, there is a record.
Summary file name. A summary file is used to store
the metal center summary information such as metal
center geometry, ligating residues etc. For each
metal center there is a record.
Optional. The cut off value used to detect the
bond between metal ion and ligating atoms.
The unit is Angstroms. If there is no value
specified, the default algorithm will be used.
The default algorithm recognizes the bond when
its distance is no less than 0.1 (smaller than 0.1
usually indicates a low quality structure) and no
bigger than the covalent radius sum of the two
atoms with a tolerance of 0.4.

17.2.4. OptC4.py

Usage: OptC4.py -m amber_mask -p topology_file -c coordinate_file -r restart_file

[--maxsteps maxsteps] [--phase simulation_phase]
[--size optimization_step_size] [--method optimization_method]
[--platform device_platform] [--model metal_complex_model]

Options:

-h, --help
-m ION_MASK
-p PFILE
-c CFILE
-r RFILE
--maxsteps=MAXSTEPS

--phase=SIMUPHA

--size=STEPSIZE

--method=MINM

show this help message and exit
Amber mask of the center metal ion
Topology file
Coordinate file
Restart file
Maximum minimization steps performed by OpenMM
in each parameter optimization cycle.
[Default: 1000]
Simulation phase, either gas or liquid.
[Default: gas]
Step size chosen by the user for the C4 value
during parameter searching. [Default: 10.0]
Optimization method of the C4 terms, The options
are: powell, cg, bfgs or slsqp.[Default: bfgs]
Please check the website:
http://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize
for more information if interested.

325

17. Python Metal Site Modeling Toolbox (pyMSMT)

--platform=PLATF

--presn=PRESN

--model=MODEL

Platform used. The options are: reference, cpu,
gpu or opencl. [Default: cpu] Here we use the
OpenMM software to perform the structure
minimization. Please check OpenMM user guide for
more information if interested.
Precision used. The options are: single, mixed, or
double. This option is only valid when using the CUDA
or OpenCL platform. [Default: single]
The metal ion complex model chosen to calculate the sum
of unsigned average errors of bond lengths, angles, and
dihedrals (the units of them are angstrom, degree and
degree respectively while the weights of them are
1/100, 1/2 and 1 respectively). This sum is the
criterion for the optimization (with a smaller value,
the better the parameters). The options are: 1 or 2.
1 means a small model (only contains the metal ion
and binding heavy atoms) while 2 means a big model
(contains the metal ion and heavy atoms in the
ligating residues). [Default: 1]

17.2.5. CartHess2FC.py

Usage: CartHess2FC.py -p PDB_file -f QM_output_file [-v software] [-m method]

[--scalef freq_scale_factor] [--nstpdb]
[--bavg] [--avg13] [--aavg]

Options:

-h, --help
-i INPUTFILE
-f HESSF

-v SOFTV

-m METHOD

show this help message and exit
Input PDB file name
Quantum output file name (a fchk/log file for Gaussian or a file for
log file for GAMESS-US).
Software version [Default is gau (means Gaussian). Other
options are g03 (means Gaussian03), g09 (means Gaussian09),
g16 (means Gaussian16), and gms (means GAMESS-US)]. The
options g03, g09, and g16 are all equal to gau but kept for
backward compatibility.
Method used. [Default is sem (means Seminario, applicable
to g03, g09, g16, gau, and gms) other option is zmx (means
Z-matrix, only applicable to g03, g09, g16, and gau.)]

--scalef=SCALEF Scale factor (ATTENTION: This is the scale factor of

--nstdpdb

--bavg

--avg13

--aavg

frequency. The force constants will be scaled by
multiplying the square of scale_factor).
Non standard PDB file used. It is the PDB file which have
all the atom names as element followed by interger number.
It could be a PDB file generated by software such as
antechamber based on the Gaussian output file.
Make average of bond force constants based on different ways
of chosing sub Hessian matrices using Seminario method.
Make average of Urey-Bradley force constants based on
different ways of chosing sub Hessian matrices using
Seminario method.
Make average of angle force constants based on different ways
of chosing sub Hessian matrices using Seminario method.

326

CartHess2FF.py is designed to generate force ﬁeld parameters for bond, angle, Urey-Bradley (1-3 interaction),
dihedral, and improper torsion terms based on quantum calculated Cartesian Hessian matrix. These terms could be
used separately in force ﬁelds such as AMBER, CHARMM, CNS (Crystallography and NMR System), etc. while
limits may be applicable for the dihedral and improper terms (see below).

17.2. Usage

kb(r− r0)2
kθ (θ − θ0)2

bonds

Etotal = ∑
+ ∑
+ ∑

angles

dihedrals

kφ (φ − φ0)2

(17.1)

CartHess2FF.py could generate the force ﬁeld parameters for the potential shown in Eq17.1 based on the log ﬁle
of force constant calculation using Gaussian software and Z-matrix method. Here the dihedral term uses a harmonic
potential other than a Fourier expansion. Users may try to transfer the parameters to a Fourier term based on the
relationship: Vn = 2kφ /n2 (whileVn andn are from Eq14.1 ) while there is no guarantee for working. This is due
to 1-4 nonbonded interaction is usually coupled to dihedral potential in AMBER while it is not considered current
potential formulation. Meanwhile, there is also other issues (such as the connectivities of the central two atoms)
available which limits the transferability of these dihedral parameters. Therefore only qualitatively comparison
between different dihedral angles (while the QM calculations should be carried out under same level of theory)
are suggested by the author. The Gaussian calculation could be performed with iop(7/33=1), before which the
structural optimization at the same level of theory is needed.

Etotal = ∑

kb(r− r0)2

bonds

+ ∑
Urey−Bradley

ku (u− u0)2

kθ (θ − θ0)2

kφ (φ − φ0)2
kAN(rAN − rAN,0)2

angles

+ ∑
+ ∑
∑

+

dihedrals

impropers

(17.2)

Moreover, CartHess2FF.py could generate the force ﬁeld parameters for the potential shown in Eq17.2 based
on the Cartesian Hessian matrix obtained by using Gaussian or GAMESS-US. Comparing to Eq17.1 it has an
additional Urey-Bradley (1-3 harmonic interaction) term and a harmonic improper torsion term (instead of a Fourier
term). In the harmonic improper term A and N represent the central atom and its projection into the plane of the
other three atoms in the improper torsion. Herein kAN , rAN , and rAN,0 represent the force constant, distance and
equilibrium distance between A and N respectively. Similarly, parameters of the dihedral and improper torsion
terms have limited transferability and are only suggested to be used for qualitative comparison. A fchk ﬁle is
needed for Gaussian, and it could be obtained by using the "formchk" command on the chk ﬁle after the force
constant calculation (again, before which a structural optimization at the same level of theory is needed). A log
ﬁle is needed for GAMESS-US force constant calculation (same as Gaussian, a structural optimization at the same
level of theory is needed before the calculation).

17.2.6. espgen.py

Usage: espgen.py -i input_file -o output_file [-v software]

327

17. Python Metal Site Modeling Toolbox (pyMSMT)

Options:

-h, --help
-i INPUTFILE
-o OUTPUTFILE
-v SOFTVERSION Software version [Default is gau (means Gaussian),

show this help message and exit
Input file name
Output file name

other option is gms (means GAMESS-US)]

17.2.7. ProScrs.py

Usage: ProScrs.py -i input_file -p PDB_file
Options:

-h, --help
-i INPUTFILE
-p PDBFILE
-s PRE
-c CHG
--symcrd=SYMCRD Use symbolic Cartesian coordinates (default: 0)
--fix=FIX

show this help message and exit
Input file name
PDB file name
File name prefix (default: MOL)
Charge (default: 0)

Fix heavy atoms or not (default: 0): 0 means no, 1 means
only backbone N, CA, C, and O atoms, 2 means backbone N,
CA, C, O, and sidechain beta atoms, 3 means all heavy
atoms.
Reassign the coordinates with first atom as 0 (default: 0)

--crd0=CRD0

Reminder: For the following functions, some X-H distances will be adjusted based on the normal X-H distances
for the generated Gaussian input ﬁles (here X represents a heavy atom).

ace Specify the residue number for which residue you want to treat as ACE (CH3CO). ProScrs.py will keep the
backbone CA, HA, C, O atoms, and change beta atom in the sidechain and backbone N atoms into hydrogen
atoms while omit all the atoms in the residue.

act Specify the residue number for which residue you want to treat as the CH3CO2- group. This is speciﬁc for the
C-terminal residue which has backbone O atom coordinated to another atom (e.g. a metal ion). ProScrs.py
will keep the backbone CA, HA, C, O, OXT atoms, and change beta atom in the sidechain and backbone N
atoms into hydrogen atoms while omit all the atoms in the residue.

nme Specify the residue number for which residue you want to treat as NME (CH3NH). ProScrs.py will keep the
backbone CA, HA, N, H atoms, and change beta atom in the sidechain and backbone C atoms into hydrogen
atoms while omit all the atoms in the residue.

ant Similar to nme variable except keep all the backbone N atom and H atoms connected to it. This can be a
N-terminal residue which has backbone N atom coordinated to another atom (e.g. a metal ion). ProScrs.py
will keep the backbone CA, HA, N, H1, H2, H3 atoms, and change beta atom in the sidechain and backbone
N atoms into hydrogen atoms while omit all the atoms in the residue.

gly Specify the residue number for which residue you want to treat as the GLY residue. This can be used for the
situation that backbone atoms of the residue matters most while sidechain doesn’t involve a lot. ProScrs.py
will keep the backbone N, H, CA, HA, C, O atoms and change beta atom in the sidechain into a hydrogen
atom while omit all the atoms in the residue.

keep Specify the residue number for which residue you want to keep entirely. This can be any residue (such as a

metal, water, ligand, or amino acid).

sc Specify the residue number for which residue you only want to keep the sidechain. ProScrs.py will keep the
sidechain and backbone CA, HA atoms and change the backbone N and C atoms into hydrogen atoms while
omitting all the other backbone atoms.

328

17.2. Usage

sc_knh Specify the residue number for which residue you want to keep the sidechain and backbone NH group.
ProScrs.py will keep the sidechain and backbone CA, HA, N, H atoms and change the backbone C atom into
a hydrogen atom while omitting the O backbone atom.

sc_kco Specify the residue number for which residue you want to keep the sidechain and backbone CO group.
ProScrs.py will keep the sidechain and backbone CA, HA, C, O atoms and change the backbone N atom into
a hydrogen atom while omitting the H backbone atom.

c2h Specify the residue number for which residue you only want to keep the backbone C atom and change it to a

hydrogen atom. This is used to have a hydrogen cap for next residue connecting to it.

n2h Specify the residue number for which residue you only want to keep the backbone N atom and change it to a

hydrogen atom. This is used to have a hydrogen cap for former residue connecting to it.

17.2.8. car_to_ﬁles.py

Usage: car_to_files.py -i input_file -m mol2_file -p pdb_file -r residue_name
Options:

show this help message and exit

-h, --help
-i INPUT_FILE Input file name
-m MOL2_FILE
-p PDB_FILE
-r RESNAME

Output mol2 file name
Output PDB file name
Residue name

17.2.9. mol2rtf.py

Usage: mol2rtf.py -i mol2_file -o rtf_file -r residue_name

-n new_resname [--ref reference_rtf_file]

Options:

show this help message and exit
-h, --help
-i INPUT_FILE
Input mol2 file
-o OUTPUT_FILE Output RTF file
-r RESNAME
-n NEW_RESNAME New residue name
--ref=REF_RTF

Original residue name

Reference RTF file

The --ref option is only needed when one wants to create a RTF ﬁle for an amino acid residue which has the
residue name different from the standard residue name used in the CHARMM force ﬁeld. For this case, one needs
to specify the reference RTF ﬁle as the RTF ﬁle for the ff14SB force ﬁeld in the CHARMM software package.
Which can be found as "/toppar/non_charmm/parm14sb_all.rtf" in the CHARMM software package. The metal
site residues are renamed to different names in the workﬂow of MCPB.py (e.g. HID->HD1). For example, for the
situation of HID->HD1, mol2rtf.py will generate a RTF ﬁle for HD1 based on the HID residue in the reference
ﬁle. During this procedure, the -r option should be set as HID, while the -n option should be set as HD1.

17.2.10. metalpdb2mol2.py

Usage: metalpdb2mol2.py -i pdb_file -o mol2_file -c charge
Options:

show this help message and exit

-h, --help
-i INPUT_FILE
-o OUTPUT_FILE Output mol2 file
-c CHARGE

Input PDB file

Charge of the metal ion

329

17. Python Metal Site Modeling Toolbox (pyMSMT)

The program will convert a PDB ﬁle which contains an metal ion to a mol2 ﬁle. The PDB ﬁle should only have
one single metal ion in it. Users need to specify the charge of the metal ion using the -c option. This program was
developed speciﬁcally for the MCPB.py users to convert the metal ion PDB ﬁle to a mol2 ﬁle.

330

18. Setting up crystal simulations

David S. Cerutti

Simulations of biomolecular crystals are in principle no different than any of the simulations that AMBER
does in periodic boundary conditions. However, the setup of these systems is not trivial and probably cannot
be accomplished with the LEaP software. Of principal importance are the construction of the solvent conditions
(packing precise amounts of multiple solvent species into the simulation cell), and tailoring the unit cell dimensions
to accommodate the inherently periodic nature of the system. The LEaP software, designed to construct simulations
of molecules in solution, will overlay a pre-equilibrated solvent mask over the (biomolecular) solute, tile that mask
throughout the simulation cell, and then prune solvent residues which clash with the solute. The result of this
procedure is a system which will likely contract under constant pressure dynamics as the pruning process has left
vacuum bubbles at the solute:solvent interface. Simulations of biomolecular crystals require that the simulation cell
begin at a size corresponding to the crystallographic unit cell, and deviate very little from that size over the course
of equilibration and onset of constant pressure dynamics. This demands a different strategy for placing solvent
in the simulation cell. Four programs in the AmberTools release are designed to accomplish this. An example of
their use in given in a web-based tutorial at http://ambermd.org/tutorials/advanced/tutorial13/XtalTutor1.html . A
recent (2018) review of crystal simulations is also worth consulting.[400]

For brevity, only basic descriptions of the programs are given in this manual. All of the programs may be
run with command line input; the input options to each program may be listed by running each program with no
arguments.

18.1. UnitCell

A macromolecular crystal contains many repeating unit cells which stack like blocks in three dimensional space
just as simulation cells do in periodic boundary conditions. Each unit cell, in turn, may contain multiple symmetry-
related clusters of atoms. A PDB ﬁle contains one set of coordinates for the irreducible unit of the crystal, the
“asymmetric unit,” and also information about the crystal space group and unit cell dimensions. The UnitCell pro-
gram reads PDB ﬁles, seeking the SMTRY records within the REMARKs to enumerate the rotation and translation
operations which may be applied to the coordinates given in the PDB ﬁle to reconstuct one complete unit cell.

Usage of the UnitCell program is as follows. The simple command rests on a critical assumption, that the PDB

ﬁle contains an accurate CRYST1 record and that the REMARK 290 SMTRY records provide its space group
symmetry operations.

UnitCell -p MyProtein.pdb -o UnitCell.pdb

18.2. PropPDB

Simulations in periodic boundary conditions require a minimum unit cell size: the simulation cell must be able
to enclose a sphere of at least the nonbonded direct space cutoff radius plus a small buffer region for nonbonded
pairlist updates. Many biomolecular crystal unit cells come in “shoebox” dimensions that may have one very
short side; many unit cells are also not rectangular but triclinic, meaning that the size of the largest sphere they
can enclose is further reduced. The workhorse simulation engine, pmemd.cuda, even requires that the simulation
cell be at least three times as thick as the cutoff plus some buffer margin in order to run safely: for typical sun
conditions this thickness is about 30Å. For these reasons, and perhaps to ensure that the rigid symmetry imposed
by periodic boundary conditions does not create artifacts (crystallographic unit cells are equivalent when averaged
over all time and space, but are not necessarily identical at any given moment), it may be necessary to include

331

18. Setting up crystal simulations

multiple unit cells within the simulation cell. This is the purpose of the PropPDB program: to propagate a unit cell
in one or more directions so that the complete simulation cell meets minimum size requirements.

Drawing on the hypothetical example above, if the unit cell is too small we can extend it in the x and z

dimensions:

PropPDB -p UnitCell -o ExpandedCell.pdb -ix 2 -iy 1 -iz 2

18.3. AddToBox

The AddToBox program handles placement of solvent within a crystal unit cell or supercell (as may be created
by PropPDB). As described in the introduction, the basic strategy is to place solvent such that added solvent
molecules do not clash with biomolecule solutes, but may clash with one another initially. This compromise is
necessary because enough solvent must be added to the system to ensure that the correct unit cell dimensions are
maintained in the long run, but it is not acceptable to place solvent within the interior of a biomolecule where it
might not belong and never escape.

The AddToBox program takes a PDB ﬁle providing the coordinates of a complete biomolecular unit cell or
supercell (argument -c), the dimensions by which that supercell repeats in space (the unit cell dimensions are
taken from the CRYST1 record of this ﬁle), a PDB ﬁle describing the solvent residue to add (argument -a), and
the number of copies of that solvent molecule to add (argument -na). AddToBox inherently assumes that the
biomolecular unit cell it is initially presented may contain some amount of solvent already, and according to the
AMBER convention of listing macromolecular solute atoms ﬁrst and solvent last assumes that the ﬁrst -P atoms
in the ﬁle are the protein (or biomolecule). AddToBox will then color a very ﬁne grid “black” if the grid point is
within a certain distance of a biomolecular atom (argument -RP, default 5.0Å) or other solvent atom (argument
-RW, default 1.0Å); the grid is “white” otherwise (the grid is stored in binary for memory efﬁciency). AddToBox
will the make a copy of the solvent residue and randomly rotate and translate it somewhere within the unit cell. If all
atoms of the solvent residue land on “white” grid voxels, the solvent molecule will become part of the system and
the grid around the newly added solvent will be blacked out accordingly. If the solvent molecule cannot be placed,
this process will be repeated until a million consecutive failures are encountered, at which point the program will
terminate. If AddToBox has not placed the requested number of solvent molecules by the time it terminates, the -V
option can be used to order the program to recursively call itself with progressively smaller solvent buffer distances
until all the requested solvent can be placed. The output of the AddToBox program is another PDB named by the
-o option.

Successful operation of AddToBox may take practice. If multiple solvent species are required, as is the case
with heterogenous crystallization solutions, AddToBox may be called repeatedly with each input molecular cell
being the previous call’s output. When considering crystal solvation, the order of addition is important!
It is
recommended that rare species, such as trace buffer reagents, be added ﬁrst, with large -RW argument to ensure that
they are dispersed throughout the available crystal void zones. Large solvent species such as MPD (an isohexane
diol commonly used in crystallization conditions) or should be added second, and with a sufﬁciently large -RW
argument that methyl groups and ring systems cannot become interlocked (which will likely lead to SHAKE /
vlimit errors). Small and abundant species such as water should be added last, as they can go anywhere that space
remains.

Below is an example of the usage for a hypothetical protein with 5431 atoms and a net charge of +6 that is to be

neutralized with ammonium sulfate:

AddToBox -c ExpandedCell.pdb -a Sulfate.pdb -na 18 -RP 3.0 -P 5431 -o System.pdb
AddToBox -c System.pdb -a Ammonium.pdb -na 30 -RP 3.0 -P 5431 -o System.pdb
AddToBox -c System.pdb -a Water.pdb -na 1089 -RP 3.0 -P 5431 -o System.pdb

The use of the -V ﬂag ensures that the desired amounts of each species are included. The protein clipping radius
of 3Å is lower than the default, but safe (remember, this radius stipulates that no solvent atom, regardless of the
size of the solvent molecule, come within 3Å of the protein). Note how the original protein PDB ﬁle serves as
the base for system, but thereafter we work with the System.pdb to accumulate more solvent particles. Here, the

332

18.4. ChBox

ammonium sulfate serves both to neutralize the system and replicate a salty bath, perhaps from a crystallization
mother liquor, hence the break from the usual 2:1 stoichiometry of ammonium sulfate ions.

It is likely that the unobservable “void” regions between biomolecules in most crystals do not contain solvent
species in proportion to their abundance in the crystallization solution–the vast majority of these regions are within
a few Ångstroms of some biomolecular surface, and different biomolecular functional groups will preferentially
interact with some types of solvent over others. Also, in many crystals some solvent molecules are observed; in
many of these, the amount of solvent observed is such that it would be impossible to pack other species into the
unit cell in proportion to their abundances in the crystallization ﬂuid. In these cases, we recommend estimating
the amount of volume that must be ﬁlled with solvent apart from solvent which has already been observed in the
crystal, and ﬁlling this void with solvent in proportion to the composition of the crystallization ﬂuid. For example,
if a crystal were grown in a 1:1 mole-to-mole water/ethanol mixture, and the crystal coordinates as deposited in the
PDB contained 500 water molecules and 3 ethanol molecules, we would use AddToBox to add water and ethanol in
a 1:1 ratio until the system contained enough solvent to maintain the correct volume during equilibrium dynamics
at constant pressure.

Finally, it is difﬁcult to estimate exactly how much solvent will be needed to maintain the correct equilibrium
volume; the advisable approach is simply to make an initial guess and script the setup so that, over multiple runs and
reconstructions, the correct system composition can be found. We recommend matching the equilibrium unit cell
volume to within 0.3% to keep this simulation parameter within the error of most crystallographic measurements.
While errors of 0.5-1% will show up quickly after constant pressure dynamics begin, a 10 to 20ns simulation may
be needed to ensure that the correct equilibrium volume has been achieved.

18.4. ChBox

After the complex process of adding solvent, the LEaP program may be used to produce a topology and initial
set of coordinates based on the PDB ﬁle produced by AddToBox. By using the SetBox command, LEaP will create
a periodic system without adding any more solvent on its own. The only problem with using LEaP at this point
is that the program will fail to realize that the system does tile in three dimensions if only the box dimensions are
set properly. If visualized, the output of UnitCell / PropPDB will likely look jagged, but the output of AddToBox,
containing lots of added water, will make it obvious how parts of biomolecules jutting out one face of the box ﬁt
neatly into open spaces on an opposite face. The topology produced by LEaP needs no editing; only the last line of
the coordinates does. This can be done manually, but the ChBox program automates the process, taking the same
coordinates supplied to AddToBox and grafting them into the input coordinates ﬁle.

The program is even unnecessary in the case of orthorhombic (rectangular) unit cells, as this the tleap

command will substitute:

set [unit] box { <x> <y> <z> }

For cells that do not have only 90-degree box angles, ChBox will do the trick.

333

Part IV.

Running simulations

334

19. sander

19.1. Introduction

This is a guide to sander, an Amber module which carries out energy minimization, molecular dynamics, and
NMR reﬁnements. The acronym stands for Simulated Annealing with NMR-Derived Energy Restraints, but this
module is used for a variety of simulations that have nothing to do with NMR reﬁnement. Some of the functionality
of sander is available with better computational performance in the pmemd module. In general, sander and pmemd
are input compatible. sander inputs for features not supported by pmemd should be properly parsed by pmemd
and pmemd should report that the requested feature is not supported. There are a few features available in pmemd
that are not supported by sander, see Sections20.3 and 20.4 Some general features are outlined in the following
paragraphs:

1. Sander provides direct support for several force ﬁelds for proteins and nucleic acids, and for several water
models and other organic solvents. The basic force ﬁeld implemented here has the following form, which is
about the simplest functional form that preserves the essential nature of molecules in condensed phases:

V (r) = ∑

bonds

Kb(b− b0)2 + ∑

Kθ (θ − θo)2

angles

(Vn/2)(1 + cos[nφ − δ ]

(Ai j/r12

i j )− (Bi j/r6

i j) + (qiq j/ri j)

dihedrals

+ ∑
+ ∑

nonbi j

"Non-additive" force ﬁelds based on atom-centered dipole polarizabilities can also be used. These add a
"polarization" term to what was given above:

Epol = −2∑

i

µi · Eio

where µi is an induced atomic dipole. In addition, charges that are not centered on atoms, but are off-center
(as for lone-pairs or "extra points") can be included in the force ﬁeld.

2. The particle-mesh Ewald (PME) procedure (or, optionally, a "true" Ewald sum) is used to handle long-
range electrostatic interactions. Long-range van der Waals interactions are estimated by a continuum model.
Biomolecular simulations in the NVE ensemble (i.e. with Newtonian dynamics) conserve energy well over
multi-nanosecond runs without modiﬁcation of the equations of motion.

3. Two periodic imaging geometries are included: rectangular parallelepiped and truncated octahedron (box
with corners chopped off). (Sander itself can handle many other periodically-replicating boxes, but input
and output support in LEaP and ptraj is only available right now for these two.) The size of the repeating unit
can be coupled to a given external pressure, and velocities can be coupled to a given external temperature
by several schemes. The external conditions and coupling constants can be varied over time, so various
simulated annealing protocols can be speciﬁed in a simple and ﬂexible manner.

4. It is also possible to carry out non-periodic simulations in which aqueous solvation effects are represented
implicitly by a generalized Born/ surface area model by adding the following two terms to the "vacuum"
potential function:

336

∆Gsol = ∑

i j

(1− 1

ε )(qiq j/ fGB(ri j) + A∑

i

19.2. File usage

σi

The ﬁrst term accounts for the polar part of solvation (free) energy, designed to provide an approximation
for the reaction ﬁeld potential, and the second represents the non-polar contribution which is taken to be
proportional to the surface area of the molecule.

5. Users can deﬁne internal restraints on bonds, valence angles, and torsions, and the force constants and target
values for the restraints can vary during the simulation. The relative weights of various terms in the force
ﬁeld can be varied over time, allowing one to implement a variety of simulated annealing protocols in a
single run.

6. Internal restraints can be deﬁned to be "time-averaged", that is, restraint forces are applied based on the aver-
aged value of an internal coordinate over the course of the dynamics trajectory, not only on its current value.
Alternatively, restraints can be "ensemble-averaged" using the locally-enhanced-sampling (LES) option.

7. Restraints can be directly deﬁned in terms of NOESY intensities (calculated with a relaxation matrix tech-
nique), residual dipolar couplings, scalar coupling constants and proton chemical shifts. There are provi-
sions for handling overlapping peaks or ambiguous assignments. In conjunction with distance and angle
constraints, this provides a powerful and ﬂexible approach to NMR structural reﬁnements.

8. Replica exchange calculations can allow simultaneous sampling at a variety of conditions (such as tempera-
ture), and allow the user to construct Boltzmann samples in ways that converge more quickly than standard
MD simulations. Other variants of biased MD simulations can also be used to improve sampling.

9. Restraints can also be deﬁned in terms of the root-mean-square coordinate distance from some reference
structure. This allows one to bias trajectories either towards or away from some target. Free energies can be
estimated from non-equilibrium simulations based on targetting restraints.

10. Free energy calculations, using thermodynamic integration (TI) with a linear or non-linear mixing of the
"unperturbed" and "perturbed" Hamiltonian, can be carried out. Alternatively, potentials of mean force can
be computed using umbrella sampling.

11. The empirical valence bond (EVB) scheme can be used to mix "diabatic" states into a potential that can

represent many types of chemical reactions that take place in enzymes.

12. QMMM Calculations where part of the system can be treated quantum mechanically allowing bond breaking
and formation during a simulation. Semi-empirical and DFTB Hamiltonians are provided directly within
sander. More advanced ab initio and DFT Hamiltonians are available via an interface to external QM
software packages.

13. Nuclear quantum effects can be included through path-integral molecular dynamics (PIMD) simulations,

and estimates of quantum time-correlation functions can be computed.

19.2. File usage

sander [-help] [-O] [-A] -i mdin -o mdout -p prmtop -c inpcrd -r restrt
-ref refc -mtmd mtmd -x mdcrd -y inptraj -v mdvel -frc mdfrc -e mden
-inf mdinfo -radii radii -cpin cpin -cpout cpout -cprestrt cprestrt

-cein cein -ceout ceout -cerestrt cerestrt -evbin evbin -suffix suffix

-O Overwrite output files if they exist.
-A Append output files if they exist (used mainly for replica exchange).

Here is a brief description of the ﬁles referred to above; the ﬁrst ﬁve ﬁles are used for every run, whereas the
remainder are only used when certain options are chosen.

337

19. sander

mdin input control data for the min/md run

mdout output user readable state info and diagnostics -o stdout will send output to stdout (to the terminal) instead

of to a ﬁle.

mdinfo output latest mdout-format energy info

prmtop input molecular topology, force ﬁeld, periodic box type, atom and residue names

inpcrd input initial coordinates and (optionally) velocities and periodic box size

refc input (optional) reference coords for position restraints; also used for targeted MD

mtmd input (optional) containing list of ﬁles and parameters for targeted MD to multiple targets

mdcrd output coordinate sets saved over trajectory

inptraj input coordinate sets in trajectory format, when imin=5

mdvel output velocity sets saved over trajectory

mdfrc output force sets saved over trajectory

mden output extensive energy data over trajectory (not synchronized with mdcrd or mdvel)

restrt output ﬁnal coordinates, velocity, and box dimensions if any - for restarting run

inpdip input polarizable dipole ﬁle, when indmeth=3

rstdip output polarizable dipole ﬁle, when indmeth=3

cpin input protonation state deﬁnitions

cprestrt protonation state deﬁnitions, ﬁnal protonation states for restart (same format as cpin)

cpout output protonation state data saved over trajectory

cein input redox state deﬁnitions

cerestrt redox state deﬁnitions, ﬁnal redox states for restart (same format as cein)

ceout output redox state data saved over trajectory

evbin input input for EVB potentials

sufﬁx output this string will be added to all unspeciﬁed output ﬁles that are printed (for multisander runs, it will

append this sufﬁx to all output ﬁles)

19.3. Example input ﬁles

Here are a couple of sample ﬁles, just to establish a basic syntax and appearance. There are more examples of

NMR-related ﬁles later in this chapter.

338



1. Simple restrained minimization

Minimization with Cartesian restraints
&cntrl
imin=1, maxcyc=200, (invoke minimization)
ntpr=5, (print frequency)
ntr=1, (turn on Cartesian restraints)
restraint_wt=1.0, (force constant for restraint)
restraintmask=':1-58', (atoms in residues 1-58 restrained)

/

19.4. Namelist Input Syntax





2. "Plain" molecular dynamics run

molecular dynamics run
&cntrl
imin=0, irest=1, ntx=5, (restart MD)
ntt=3, temp0=300.0, gamma_ln=5.0, (temperature control)
ntp=1, taup=2.0, (pressure control)
ntb=2, ntc=2, ntf=2, (SHAKE, periodic bc.)
nstlim=500000, (run for 0.5 nsec)
ntwx=1000, ntpr=200, (output frequency)
/

3. Self-guided Langevin dynamics run

Self-guided Langevin dynamics run
&cntrl
imin=0, irest=0, ntx=1, (start LD)
ntt=3, temp0=300.0,gamma_ln=1.0, (temperature control)
ntc=3, ntf=3, (SHAKE)
nstlim=500000, (run for 0.5 nsec)
ntwx=1000, ntpr=200, (output frequency)
isgld=1, tsgavg=0.2,tempsg=400.0, (SGLD)
/

19.4. Namelist Input Syntax

Namelist provides list-directed input, and convenient speciﬁcation of default values. It dates back to the early
1960’s on the IBM 709, but was regrettably not part of Fortran 77. It is a part of the Fortran 90 standard, and is
supported as well by most Fortran 77 compilers (including g77).

Namelist input groups take the form:

&name
var1=value, var2=value, var3(sub)=value,
var4(sub,sub,sub)=value,value,
var5=repeat*value,value,
/

The variables must be names in the Namelist variable list. The order of the variables in the input list is of no
signiﬁcance, except that if a variable is speciﬁed more than once, later assignments may overwrite earlier ones.

339

19. sander

Blanks may occur anywhere in the input, except embedded in constants (other than string constants, where they
count as ordinary characters).

It is common in older inputs for the ending "/" to be replaced by "&end"; this is non-standard-conforming.
Letter case is ignored in all character comparisons, but case is preserved in string constants. String constants
must be enclosed by single quotes (’). If the text string itself contains single quotes, indicate them by two consec-
utive single quotes, e.g. C1’ becomes ’C1”’ as a character string constant.

Array variables may be subscripted or unsubscripted. An unsubscripted array variable is the same as if the
subscript (1) had been speciﬁed. If a subscript list is given, it must have either one constant, or exactly as many
as the number in the declared dimension of the array. Bounds checking is performed for ALL subscript positions,
although if only one is given for a multi-dimension array, the check is against the entire array size, not against
the ﬁrst dimension. If more than one constant appears after an array assignment, the values go into successive
locations of the array. It is NOT necessary to input all elements of an array.

Any constant may optionally be preceded by a positive (1,2,3,..) integer repeat factor, so that, for example,
25*3.1415 is equivalent to twenty-ﬁve successive values 3.1415. The repeat count separator, *, may be preceded
and followed by 0 or more blanks. Valid LOGICAL constants are 0, F, .F., .FALSE., 1, T, .T., and .TRUE.; lower
case versions of these also work.

19.5. Overview of the information in the input ﬁle

General minimization and dynamics input One or more title lines, followed by the (required) &cntrl and (op-
tional) &pb, &ewald, &qmmm, &amoeba or &debugf namelist blocks. Described in Sections 19.6 and
19.7.

Varying conditions Parameters for changing temperature, restraint weights, etc., during the MD run. Each pa-
rameter is speciﬁed by a separate &wt namelist block, ending with &wt type="END", /. Described in Section
19.8.

File redirection TYPE=ﬁlename lines. Section ends with the ﬁrst non-blank line which does not correspond to a

recognized redirection. Described in Section 19.9.

Group information Read if ntr, ibelly or idecomp are set to nonzero values, and if some other conditions are

satisﬁed; see sections on these variables, below. Described in Appendix 21.3.

19.6. General minimization and dynamics parameters

Each of the variables listed below is input in a namelist statement with the namelist identiﬁer &cntrl.cmmu can
enter the parameters in any order, using keyword identiﬁers. Variables that are not given in the namelist input
retain their default values. Support for namelist input is included in almost all current Fortran compilers, and is a
standard feature of Fortran 90. A detailed description of the namelist convention is given in Appendix A.

In general, namelist input consists of an arbitrary number of comment cards, followed by a record whose ﬁrst
seven characters after a " &" (e.g. " &cntrl ") name a group of variables that can be set by name.cmsys is followed
by statements of the form " maxcyc=500, diel=2.0, ... ", and is concluded by an " / " token. The ﬁrst line of
input contains a title, which is then followed by the &cntrl namelist. Note that the ﬁrst character on each line of a
namelist block must be a blank.

Some of the options and variables are much more important, and commonlycmrdiﬁed, than are others. We have
denoted the "common" options by printing them in boldface below. In general, you can skip reading about the
non-bold options on a ﬁrst pass, and you should change these from their defaults only if you think you know what
you are doing.

19.6.1. General ﬂags describing the calculation

imin

Flag to run minimization.

340

19.6. General minimization and dynamics parameters

= 0 (default) Run molecular dynamics without any minimization.
= 1 Perform an energy minimization.
= 5 Read in a trajectory for analysis.

Although sander will write energy information in the output ﬁles (using ntpr), it is often desir-
able to calculate the energies of a set of structures at a later point. In particular, one may wish
to post-process a set of structures using a different energy function than was used to generate
the structures. An example of this is MM-PBSA analysis, where the explicit water is removed
and replaced with a continuum model.
If imin is set to 5, sander will read a trajectory ﬁle (the “inptraj” argument, speciﬁed using -y
on the command line), and will perform the functions described in the mdin ﬁle (e.g., an energy
minimization) for each of the structures in this ﬁle. The ﬁnal structure from each minimization
will be written out to the normal mdcrd ﬁle. If you wish to read in a binary (i.e., NetCDF
format) trajectory, be sure to set ioutfm to 1 (see below). Note that this will result in the output
trajectory having NetCDF format as well.
For example, when imin = 5 and maxcyc = 1000, sander will minimize each structure in the
trajectory for 1000 steps and write a minimized coordinate set for each frame to the mdcrd ﬁle.
If maxcyc = 1, the output ﬁle can be used to extract the energies of each of the coordinate sets
in the inptraj ﬁle.
Trajectories containing box coordinates can be post-processed. In order to read trajectories
with box coordinates, ntb should be greater than 0.
IMPORTANT CAVEAT: The initial coordinates input ﬁle used (-c <inpcrd>) should be the
same as the initial coordinates input ﬁle usedto generate the original trajectory. This is because
sander sets up parameters for PME from the box coordinates in the initial coordinates input
ﬁle.

nmropt

= 0 (default) No nmr-type analysis will be done.
= 1 NMR restraints and weight changes will be read.
= 2 NMR restraints, weight changes, NOESY volumes, chemical shifts and residual dipolar re-

straints will be read.

19.6.2. Nature and format of the input

ntx

Option to read the initial coordinates, velocities and box size from the inpcrd ﬁle. Option 1 must be
used when one is starting from minimized or model-built coordinates. If an MD restrt ﬁle is used
as inpcrd, then option 5 is generally used (unless you explicitly wish to ignore the velocities that are
present).

= 1 (default) Coordinates, but no velocities, will be read; either formatted (ASCII) ﬁles or NetCDF

ﬁles can be used, as the input ﬁle type will be auto-detected.

= 5 Coordinates and velocities will be read from either a NetCDF or a formatted (ASCII) coordinate
ﬁle. Box information will be read if ntb > 0. The velocity information will only be used if irest
= 1 (see below).

irest

Flag to restart a simulation.

= 0 (default) Do not restart the simulation; instead, run as a new simulation. Velocities in the input
coordinate ﬁle, if any, will be ignored, and the time step count will be set to 0 (unless overridden
by t; see below).

= 1 Restart the simulation, reading coordinates and velocities from a previously saved restart ﬁle.
The velocity information is necessary when restarting, so ntx (see above) must be 4 or higher
if irest = 1.

341

19. sander

19.6.3. Nature and format of the output

ntxo

ntpr

ntave

ntwr

iwrap

ntwx

ntwv

Format of the ﬁnal coordinates, velocities, and box size (if constant volume or pressure run) written
to ﬁle "restrt".
= 1 Formatted (ASCII)
= 2 (default) NetCDF ﬁle (recommended, unless you have a workﬂow that requires the formatted

form.)

Every ntpr steps, energy information will be printed in human-readable form to ﬁles "mdout" and
"mdinfo". "mdinfo" is closed and reopened each time, so it always contains the most recent energy
and temperature. Default 50.

Every ntave steps of dynamics, running averages of average energies and ﬂuctuations over the last
ntave steps will be printed out. A value of 0 disables this printout. Setting ntave to a value 1/2 or 1/4
of nstlim provides a simple way to look at convergence during the simulation. Default = 0 (disabled).

Every ntwr steps during dynamics, the “restrt” ﬁle will be written, ensuring that recovery from a
crash will not be so painful. No matter what the value of ntwr, a restrt ﬁle will be written at the end
of the run, i.e., after nstlim steps (for dynamics) or maxcyc steps (for minimization). If ntwr < 0, a
unique copy of the ﬁle, “restrt_<nstep>”, is written every abs(ntwr) steps. This option is useful if for
example one wants to run free energy perturbations from multiple starting points or save a series of
restrt ﬁles for minimization. Default = nstlim.

If iwrap = 1, the coordinates written to the restart and trajectory ﬁles will be "wrapped" into a primary
box. This means that for each molecule, its periodic image closest to the middle of the "primary box"
(with x coordinates between 0 and a, y coordinates between 0 and b, and z coordinates between 0
and c) will be the one written to the output ﬁle. This often makes the resulting structures look better
visually, but has no effect on the energy or forces. Performing such wrapping, however, can mess
up diffusion and other calculations. If iwrap = 0, no wrapping will be performed, in which case it is
typical to use cpptraj as a post-processing program to translate molecules back to the primary box.
For very long runs, setting iwrap = 1 may be required to keep the coordinate output from overﬂowing
the trajectory and restart ﬁle formats, especially if trajectories are written in ASCII format instead of
NetCDF (see also the ioutfm option). Default = 0.

Every ntwx steps, the coordinates will be written to the mdcrd ﬁle.
trajectory ﬁle will be written. Default = 0.

If ntwx = 0, no coordinate

Every ntwv steps, the velocities will be written to the mdvel ﬁle. If ntwv = 0, no velocity trajectory
ﬁle will be written. If ntwv = -1, velocities will be written to mdcrd, which then becomes a combined
coordinate/velocity trajectory ﬁle, at the interval deﬁned by ntwx. This option is available only for
binary NetCDF output (ioutfm = 1). Most users will have no need for a velocity trajectory ﬁle and so
can safely leave ntwv at the default. Default = 0. Note that dumping velocities frequently, like forces
or coordinates, will introduce potentially signiﬁcant I/O and communication overhead, hurting both
performance and parallel scaling.

ionstepvelocities Controls whether to print the half-step-ahead velocities (0, default) or on-step velocities
(1). The half-step-ahead velocities can potentially be used to restart calculations, but the on-step
velocities correspond to calculated kinetic energy/temperature.

Every ntwf steps, the forces will be written to the mdfrc ﬁle. If ntwf = 0, no force trajectory ﬁle
will be written. If ntwf = -1, forces will be written to the mdcrd, which then becomes a combind
coordinate/force trajectory ﬁle, at the interval deﬁned by ntwx. This option is available only for
binary NetCDF output (ioutfm = 1). Most users will have no need for a force trajectory ﬁle and so
can safely leave ntwf at the default. Default = 0. Note that dumping forces frequently, like velocities
or coordinates, will introduce potentially signiﬁcant I/O and communication overhead, hurting both
performance and parallel scaling.

ntwf

342

19.6. General minimization and dynamics parameters

ntwe

ioutfm

Every ntwe steps, the energies and temperatures will be written to ﬁle "mden" in a compact form. If
ntwe = 0 then no mden ﬁle will be written. Note that energies in the mden ﬁle are not synchronized
with coordinates or velocities in the mdcrd or mdvel ﬁle(s). Assuming identical ntwe and ntwx values
the energies are one time step before the coordinates (as well as the velocities which are synchronized
with the coordinates). Consequently, an mden ﬁle is rarely written. Default = 0.

The format of coordinate and velocity trajectory ﬁles (mdcrd, mdvel and inptraj). As of Amber 9,
the binary format used in previous versions is no longer supported; binary output is now in NetCDF
trajectory format. Binary trajectory ﬁles have many advantages: they are smaller, higher precision,
much faster to read and write, and able to accept a wider range of coordinate (or velocity) values
than formatted trajectory ﬁles.

= 0 Formatted ASCII trajectory
= 1 (default) Binary NetCDF trajectory

ntwprt The number of atoms to include in trajectory ﬁles (mdcrd and mdvel). This ﬂag can be used to decrease the
size of the these ﬁles, by including only the ﬁrst part of the system, which is usually of greater interest (for
instance, one might include only the solute and not the solvent). If ntwprt = 0, all atoms will be included.

= 0 (default) Include all atoms of the system when writing trajectories.
> 0 Include only atoms 1 to ntwprt when writing trajectories.

idecomp Perform energy decomposition according to a chosen scheme. In former distributions this option was
only really useful in conjunction with mm_pbsa, where it is turned on automatically if required. Now, a
decomposition of (cid:104)∂V /∂λ(cid:105) on a per-residue basis in thermodynamic integration (TI) simulations is also
possible.[401] The options are:

= 0 (default) Do not decompose energies.
= 1 Decompose energies on a per-residue basis; 1-4 EEL + 1-4 VDW are added to internal (bond, angle,

dihedral) energies.

= 2 Decompose energies on a per-residue basis; 1-4 EEL + 1-4 VDW are added to EEL and VDW.
= 3 Decompose energies on a pairwise per-residue basis; otherwise equivalent to idecomp = 1. Not available

in TI simulations.

= 4 Decompose energies on a pairwise per-residue basis; otherwise equivalent to idecomp = 2. Not available

in TI simulations.

If energy decomposition is requested, residues may be chosen by the RRES and/or LRES card. The RES card
is used to select the residues about which information is written out. See chapters 23.1 for more information.
Use of idecomp > 0 is incompatible with ntr > 0 or ibelly > 0.

19.6.4. Frozen or restrained atoms

ibelly

Flag for belly type dynamics. If set to 1, a subset of the atoms in the system will be allowed to move,
and the coordinates of the rest will be frozen. The moving atoms are speciﬁed with bellymask. This
option is not available when igb>0. When belly type dynamics is in use, bonded energy terms, vdW
interactions, and direct space electrostatic interactions are not calculated for pairs of frozen atoms.
Note that this does not provide any signiﬁcant speed advantage. Freezing atoms can be useful for
some applications but is maintained primarily for backwards compatibility with older versions of
Amber. Most applications should use the ntr variable instead to restrain parts of the system to stay
close to some initial conﬁguration. Default = 0.

ntr

Flag for restraining speciﬁed atoms in Cartesian space using a harmonic potential, if ntr > 0. The
restrained atoms are determined by the restraintmask string. The force constant is given by re-
straint_wt. The coordinates are read in "restrt" format from the "refc" ﬁle. Default = 0.

343

19. sander

restraint_wt The weight (kcal·mol−1·Å

−2) for the positional restraints. The restraint is of the form k(∆x)2, where
k is the value given by this variable, and ∆x is the difference between one of the Cartesian coordinates
of a restrained atom and its reference position. There is a term like this for each Cartesian coordinate
of each restrainted atom.

restraintmask String that speciﬁes the restrained atoms when ntr=1.

bellymask

String that speciﬁes the moving atoms when ibelly=1.
The syntax for both restraintmask and bellymask is given in Section 21.1.1. Note that these mask
strings are limited to a maximum of 256 characters.

19.6.5. Energy minimization

maxcyc

The maximum number of cycles of minimization. Default = 1.

ncyc

If NTMIN is 1 then the method of minimization will be switched from steepest descent to conjugate
gradient after NCYC cycles. Default 10.

ntmin

Flag for the method of minimization.

= 0 Full conjugate gradient minimization. The ﬁrst 4 cycles are steepest descent at the start of the

run and after every nonbonded pairlist update.

= 1 For NCYC cycles the steepest descent method is used then conjugate gradient is switched on

(default).

= 2 Only the steepest descent method is used.
= 3 The XMIN method is used, see Section 22.7.1.
= 4 The LMOD method is used, see Section 22.7.2.

dx0

drms

The initial step length. If the initial step length is too big then will give a huge energy; however the
minimizer is smart enough to adjust itself. Default 0.01.

The convergence criterion for the energy gradient: minimization will halt when the root-mean-square
of the Cartesian elements of the gradient is less than this. Default is 10−4kcal· mol−1 · Å

−1.

19.6.6. Molecular dynamics

nstlim

Number of MD-steps to be performed. Default 1.

Flag for the removal of translational and rotational center-of-mass (COM) motion at regular intervals
(default is 1000). For non-periodic simulations, after every NSCM steps, translational and rotational
motion will be removed. For periodic systems, just the translational center-of-mass motion will be
removed. This ﬂag is ignored for belly simulations.
For Langevin dynamics, the position of the center-of-mass of the molecule is reset to zero every
NSCM steps, but the velocities are not affected. Hence there is no change to either the translation or
rotational components of the momenta. (Doing anything else would destroy the way in which tem-
perature is regulated in a Langevin dynamics system.) The only reason to even reset the coordinates
is to prevent the molecule from diffusing so far away from the origin that its coordinates overﬂow
the format used in restart or trajectory ﬁles.

The time at the start (psec) this is for your own reference and is not critical. Start time is taken from
the coordinate input ﬁle if IREST=1. Default 0.0.

nscm

t

344

dt

nrespa

19.6. General minimization and dynamics parameters

The time step (psec). Recommended MAXIMUM is .002 if SHAKE is used, or .001 if it isn’t. Note
that for temperatures above 300K, the step size should be reduced since greater temperatures mean
increased velocities and longer distance traveled between each force evaluation, which can lead to
anomalously high energies and system blowup. Default 0.001.
The use of Hydrogen Mass Repartitioning (HMR) (see [381] and references therein for more infor-
mation), together with SHAKE, allows the time step to be increased in a stable fashion by about a
factor of two (up to .004) by slowing down the high frequency hydrogen motion in the system. To
use HMR, the masses in the topology ﬁle need to be altered before starting the simulation. ParmEd
can do this automatically with the HMassRepartition option; see Section 14.2 .

This variable allows the user to evaluate slowly-varying terms in the force ﬁeld less frequently. For
PME, "slowly-varying" (now) means the reciprocal sum. For generalized Born runs, the "slowly-
varying" forces are those involving derivatives with respect to the effective radii, and pair interactions
whose distances are greater than the "inner" cutoff, currently hard-wired at 8 Å. If NRESPA>1
these slowly-varying forces are evaluated every nrespa steps. The forces are adjusted appropriately,
leading to an impulse at that step. If nrespa*dt is less than or equal to 4 fs the energy conservation is
not seriously compromised. However if nrespa*dt > 4 fs the simulation becomes less stable. Note
that energies and related quantities are only accessible every nrespa steps, since the values at other
times are meaningless.

19.6.7. Temperature regulation

Note: Flag "ntt" is used for the temperature regulation in the default thermostat scheme as shown below. The
"middle" thermostat scheme [Section 19.6.10] is much more efﬁcient than the default scheme to accurately sample
the conﬁguration/conformation space in the molecular dynamics simulation for the NVT ensemble. Please read
Section 19.6.10 for more details.

ntt

Switch for temperature scaling. Note that setting ntt=0 corresponds to the microcanonical (NVE) en-
semble (which should approach the canonical one for large numbers of degrees of freedom). Some
aspects of the "weak-coupling ensemble" (ntt=1) have been examined, and roughly interpolate be-
tween the microcanonical and canonical ensembles.[402, 403] The ntt=2 and 3 options correspond
to the canonical (constant T) ensemble.
= 0 Constant total energy classical dynamics (assuming that ntb<2, as should probably always be

the case when ntt=0).

= 1 Constant temperature, using the weak-coupling algorithm.[404] A single scaling factor is used
for all atoms. Note that this algorithm just ensures that the total kinetic energy is appropri-
ate for the desired temperature; it does nothing to ensure that the temperature is even over all
parts of the molecule. Atomic collisions will tend to ensure an even temperature distribution,
but this is not guaranteed, and there are many subtle problems that can arise with weak tem-
perature coupling.[405] Using ntt=1 is especially dangerous for generalized Born simulations,
where there are no collisions with solvent to aid in thermalization.) Other temperature coupling
options (especially ntt=3) should be used instead.

= 2 Andersen-like temperature coupling scheme,[406] in which imaginary "collisions" randomize
the velocities to a distribution corresponding to temp0 every vrand steps. Note that in between
these "massive collisions", the dynamics is Newtonian. Hence, time correlation functions (etc.)
can be computed in these sections, and the results averaged over an initial canonical distribu-
tion. Note also that too high a collision rate (too small a value of vrand) will slow down the
speed at which the molecules explore conﬁguration space, whereas too low a rate means that
the canonical distribution of energies will be sampled slowly. A discussion of this rate is given
by Andersen.[407] Note that this option is not equivalent to the original thermostat described
by Andersen[407].

= 3 Use Langevin dynamics with the collision frequency γ given by gamma_ln, discussed below.
Note that when γ has its default value of zero, this is the same as setting ntt = 0. Since Langevin

345

19. sander

simulations are highly susceptible to "synchronization" artifacts,[408, 409] you should explic-
itly set the ig variable (described below) to a different value at each restart of a given simulation.
= 9 Optimized Isokinetic Nose-Hoover chain ensemble (OIN) [291, 410]. Constant temperature
simulation utilizing Nose-Hoover chains and an isokinetic constraint on the particle and ther-
mostat velocities, implemented for use in multiple time-stepping methods, namely for 3D-
RISM and RESPA. Stabilizes and smooths particle dynamics and mitigates resonance insta-
bilities, allowing for larger intermediate times steps, up to 16 fs for RESPA (nrespa=16 for
dt=0.001) and 8 fs for 3D-RISM MTS size (rismnrespa=8). Each atom is coupled to three
Nose-Hoover chains per atom and the thermostat coupling constant (relaxation time) is de-
termined from 1/gamma_ln, hence gamma_ln must be > 0 if ntt=9 invoked. Variable nkija
speciﬁes the number of substeps of dt to use for integrating the equations of motion and idistr
speciﬁes the frequency at which the thermostat velocity distribution functions are accumulated
(if > 0). Such functions are written at frequency ntpr. Two additional ﬁles containing the
thermostat and chain restart velocities, tfreeze.rst and vfreez.rst, are written at frequency ntwr.
= 10 Stochastic Isokinetic Nose-Hoover RESPA integrator [411]. A novel isokinetic integrator
developed by Tuckerman and co-workers that invokes an isokinetic constraint on the par-
ticle velocities combined with nkija (see below) auxiliary thermostat velocities v1 and v2.
The integrator includes a stochastic component in the equations of motion, which introduces
white noise into the system, for the purpose of minimizing resonance instabilities in the ve-
locities, ultimately allowing for larger RESPA steps. The isokinetic constraint has the form
mv2 + L
1i = LkBT . Here L is the number of additional thermostat degrees of free-
dom, deﬁned in AMBER as nkija (see below), and Q1is the thermostat mass, determined from
sinrtau (below), v is the particle velocity and v1 is one of two auxiliary velocities (e.g. ther-
mostat velocities), and m, kB, and T , are the particle mass, Boltzmann constant, and system
temperature (temp0), respectively. In using this integrator, the system is placed in the isokinetic
ensemble, as such the velocities are NOT canonical and no thermodynamic observables can be
derived from them. This will lead to anomalous temperature readings throughout the simulation
- for 1 thermostat degree of freedom (L = nkija = 1) the temperature will appear about one-half
the speciﬁed temperature (temp0), and with additional thermostat DOF, the temperature will
approach, but never exceed, the desired temperature, temp0. However, the particle coordinates
ARE canonical and it can be said the conﬁgurations obtained from a simulation were sampled
from a Boltzmann distribution at the speciﬁed temperature (temp0).

i=1 Q1v2

L+1 ∑L

= 11 Stochastic version of Berendsen thermostat, also known as Bussi thermostat [412]. This ther-
mostat samples canonical distribution by scaling all velocities to a random temperature probed
from canonical distribution. Collision frequency with thermostat is controled by tautp.

temp0

temp0les

Reference temperature at which the system is to be kept, if ntt > 0. Note that for temperatures above
300K, the step size should be reduced since increased distance traveled between evaluations can lead
to SHAKE and other problems. Default 300.

This is the target temperature for all LES particles (see Chapter 6). If temp0les<0, a single tem-
perature bath is used for all atoms, otherwise separate thermostats are used for LES and non-LES
particles. Default is -1, corresponding to a single (weak-coupling) temperature bath.

Initial temperature. For the initial dynamics run, (NTX .lt. 3) the velocities are assigned from a
Maxwellian distribution at TEMPI K. If TEMPI = 0.0, the velocities will be calculated from the
forces instead. TEMPI has no effect if NTX .gt. 3. Default 0.0.

The seed for the pseudo-random number generator. The MD starting velocity is dependent on the
random number generator seed if NTX .lt. 3 .and. TEMPI .ne. 0.0. The value of this seed also
affects the set of pseudo-random values used for Langevin dynamics or Andersen-like coupling, and
hence should be set to a different value on each restart if ntt = 2 or 3. If ig=-1, (the default) the
random seed will be based on the current date and time, and hence will be different for every run.

tempi

ig

346

tautp

gamma_ln

vrand

vlimit

nkija

idistr

sinrtau

19.6. General minimization and dynamics parameters

It is recommended that, unless you speciﬁcally desire reproducibility, that you set ig=-1 for all runs
involving ntt=2 or 3.

Time constant, in ps, for heat bath coupling for the system, if ntt = 1. Default is 1.0. Generally, values
for TAUTP should be in the range of 0.5-5.0 ps, with a smaller value providing tighter coupling to
the heat bath and, thus, faster heating and a less natural trajectory. Smaller values of TAUTP result in
smaller ﬂuctuations in kinetic energy, but larger ﬂuctuations in the total energy. Values much larger
than the length of the simulation result in a return to constant energy conditions.
The collision frequency γ, in ps−1, when ntt = 3. Default is 0. A simple Leapfrog integrator is used
to propagate the dynamics, with the kinetic energy adjusted to be correct for the harmonic oscillator
case.[413, 414] Note that it is not necessary that γ approximate the physical collision frequency,
which is about 50 ps−1 for liquid water. In fact, it is often advantageous, in terms of sampling[414,
415] or stability of integration[416], to use much smaller values, around 2 to 5 ps−1.[414, 416] For
implicit solvent (GB), even much lower values may be useful: for example, setting gamma_ln to 0.01
ps−1 can lead to signiﬁcant, up to 100-fold in some cases, speedup of conformational sampling.[168]
Also used to determine thermostat coupling constant for the Optimized Isokinetic Nose-Hoover chain
integrator (OIN, ntt=9), which is equal to 1/gamma_ln [291], so the speciﬁed gamma_ln must be >
0. A gamma_ln of 10 ps−1 represents a coupling constant of 100 fs. For ntt=10, this is the friction
constant associated with the stochastic component of the integrator, essentially serving the same role
as in the Langevin integrator [411]. This parameter is required for ntt=10 and must be > 0.

If vrand>0 and ntt=2, the velocities will be randomized to temperature TEMP0 every vrand steps.
Default is 1000.

If not equal to 0.0, then any component of the velocity that is greater than abs(VLIMIT) will be
reduced to VLIMIT (preserving the sign). This can be used to avoid occasional instabilities in
molecular dynamics runs. VLIMIT should generally be set to a value like 20 (the default), which is
well above the most probable velocity in a Maxwell-Boltzmann distribution at room temperature. A
warning message will be printed whenever the velocities are modiﬁed. Runs that have more than a
few such warnings should be carefully examined.

For use with ntt=9 and ntt=10., For ntt=9, this the number of substeps of dt when integrating the
thermostat equations of motion, for greater accuracy. For ntt=10, this speciﬁes the number of addi-
tional auxiliary velocity variables v1 and v2, which will total nkija×v1 +nkija×v2 [411]. Default is
1 for both integrators.

For the isokinetic integrator (ntt=9), the frequency at which the thermostat velocity distribution func-
tions are accumulated.

For the SINR (Stochastic Isokinetic Nose-Hoover RESPA) integrator (ntt=10), this speciﬁes the time
scale for determining the masses associated with the two auxiliary velocity variables v1 and v2 (e.g.
thermostat velocities) and hence the magnitude of the coupling of the physical velocities with the
auxiliary velocities. Generally this should be related to the time scale of the system. See [411] for
more explanation. Default is 1.0.

19.6.8. Pressure regulation

In "constant pressure" dynamics, the volume of the unit cell is adjusted (by small amounts on each step) to make
the computed pressure approach the target pressure, pres0. Equilibration with ntp > 0 is generally necessary to
adjust the density of the system to appropriate values. Note that ﬂuctuations in the instantaneous pressure on each
step will appear to be large (several hundred bar), but the average value over many steps should be close to the
target pressure. Pressure regulation only applies when Constant Pressure periodic boundary conditions are used
(ntp > 0). The two available pressure coupling algorithms available in Amber are of the “weak-coupling” variety,
analogous to temperature coupling,[404] and the use of the Monte Carlo barostat. While the Berendsen barostat

347

19. sander

yields the correct target density, it does not strictly sample from the isothermal-isobaric ensemble and typically
yields volume ﬂuctuations that are too low. The Monte Carlo barostat, on the other hand, samples rigorously from
the isobaric-isothermal ensemble and does not necessitate computing the virial. Please note: in general you will
need to equilibrate the temperature to something like the ﬁnal temperature using constant volume (ntp=0) before
switching on constant pressure simulations to adjust the system to the correct density. If you fail to do this, the
program will try to adjust the density too quickly, and bad things (such as SHAKE failures) are likely to happen.

ntp

Flag for constant pressure dynamics. This option should be set to 1 or 2 when Constant Pressure
periodic boundary conditions are used.

= 0 No pressure scaling (Default)
= 1 md with isotropic position scaling
= 2 md with anisotropic (x-,y-,z-) pressure scaling: this should only be used with orthogonal boxes
(i.e. with all angles set to 90 degrees). Anisotropic scaling is primarily intended for non-
isotropic systems, such as membrane simulations, where the surface tensions are different
in different directions; it is generally not appropriate for solutes dissolved in water. )[291]
Anisotropic pressure scaling can also be applied to just one speciﬁed direction (x, y or z) with
the directional pressure scaling option (baroscalingdir > 0). In this case the box scales along
the one chosen direction only, and its dimensions along the other two directions remain ﬁxed.
This type of directional pressure control option can be useful in situations where one needs to
keep the solvent box unchanged along two direction, while still maintaining a constant pres-
sure in the system. For example, a phase boundary can be created by placing two boxes from
different simulations in contact with each other along a common face, which can be useful for
simulating phase transitions such as water to ice[417].

= 3 md with semiisotropic pressure scaling:

this is only available with constant surface tension
(csurften > 0) and orthogonal boxes. This links the pressure coupling in the two directions
tangential to the interface.

barostat

Flag used to control which barostat to use in order to control the pressure.

= 1 Berendsen (Default)
= 2 Monte Carlo barostat

mcbarint

pres0

comp

taup

Number of steps between volume change attempts performed as part of the Monte Carlo barostat.
Default is 100.
Reference pressure (in units of bars, where 1 bar ≈ 0.987 atm) at which the system is maintained (
when NTP > 0). Default 1.0.

compressibility of the system when NTP > 0. The units are in 1.0 × 10-6 bar-1; a value of 44.6
(default) is appropriate for water.

Pressure relaxation time (in ps), when NTP > 0. The recommended value is between 1.0 and 5.0
psec. Default value is 1.0, but larger values may sometimes be necessary (if your trajec)[291]tories
seem unstable).

baroscalingdir Flag for pressure scaling direction control. Applicable when using Monte Carlo barostat (baro-

stat = 2) with anisotropic pressure scaling (ntp = 2).
= 0 box size scales randomly (x, y or z) each scaling step (default)
= 1 box scales only along x-direction, dimensions along y-, z-axes are ﬁxed
= 2 box scales only along y-direction, dimensions along x-, z-axes are ﬁxed
= 3 box scales only along z-direction, dimensions along x-, y-axes are ﬁxed

348

19.6. General minimization and dynamics parameters

Surface tension regulation

Constant surface tension is used in statistical ensembles for simulating liquid interfaces. This is primarily in-
tended for lipid membrane simulations with two or more interfaces. Constant surface tension is only available for
simulations with anisotropic pressure or semiisotropic scaling. This algorithm is an extension to the Berendsen
pressure scaling algorithm that adjusts the tangential pressure evaluation in order to maintain a “constant” surface
tension.[418] Since the surface tension is a function of the pressure tensor, ﬂuctuations of the surface tension will
be large.

In order to use constant surface tension, periodic boundary conditions (ntb = 2), anisotropic or semiisotropic

pressure scaling (ntp = 2 or ntp =3), and an orthogonal box must be used.

csurften

Flag for constant surface tension dynamics.

= 0 No constant surface tension (default)
= 1 Constant surface tension with interfaces in the yz plane
= 2 Constant surface tension with interfaces in the xz plane
= 3 Constant surface tension with interfaces in the xy plane

gamma_ten Surface tension value in units of dyne/cm. Default value is 0.0 dyne/cm.

ninterface Number of interfaces in the periodic box. There must be at least two interfaces in the periodic box.

Two interfaces is appropriate for a lipid bilayer system and is the default value.

19.6.9. SHAKE bond length constraints

ntc

Flag for SHAKE to perform bond length constraints.[419] (See also NTF in the Potential function
section. In particular, typically NTF = NTC.) The SHAKE option should be used for most MD cal-
culations. The size of the MD timestep is determined by the fastest motions in the system. SHAKE
removes the bond stretching freedom, which is the fastest motion, and consequently allows a larger
timestep to be used. For water models, a special "three-point" algorithm is used.[420] Consequently,
to employ TIP3P set NTF = NTC = 2.
Since SHAKE is an algorithm based on dynamics, the minimizer is not aware of what SHAKE is
doing; for this reason, minimizations generally should be carried out without SHAKE. One exception
is short minimizations whose purpose is to remove bad contacts before dynamics can begin.
For parallel versions of sander only intramolecular atoms can be constrained. Thus, such atoms must
be in the same chain of the originating PDB ﬁle.
= 1 SHAKE is not performed (default)
= 2 bonds involving hydrogen are constrained
= 3 all bonds are constrained (not available for parallel or qmmm runs in sander)

tol

jfastw

Relative geometrical
<0.00005 Angstrom Default 0.00001.

tolerance for coordinate resetting in shake. Recommended maximum:

Fast water deﬁnition ﬂag. By default, the system is searched for water residues, and special routines
are used to SHAKE these systems.[420]

= 0 Normal operation. Waters are identiﬁed by the default names (given below), unless they are

redeﬁned, as described below.

= 4 Do not use the fast SHAKE routines for waters.

The following variables allow redeﬁnition of the default residue and atom names used by the program
to determine which residues are waters.
WATNAM The residue name the program expects for water. Default ’WAT ’.

349

19. sander

OWTNM The atom name the program expects for the oxygen of water. Default ’O ’.
HWTNM1 The atom name the program expects for the 1st H of water. Default ’H1 ’.
HWTNM2 The atom name the program expects for the 2nd H of water. Default ’H2 ’.

noshakemask String that speciﬁes atoms that are not to be shaken (assuming that ntc>1). Any bond that would
otherwise be shaken by virtue of the ntc ﬂag, but which involves an atom ﬂagged here, will *not* be
shaken. The syntax for this string is given in Chap. 13.5. Default is an empty string, which matches
nothing. A typical use would be to remove SHAKE constraints from all or part of a solute, while
still shaking rigid water models like TIPnP or SPC/E. Another use would be to turn off SHAKE
constraints for the parts of the system that are being changed with thermodynamic integration, or
which are the EVB or quantum regions of the system.
If this option is invoked, then all parts of the potential must be evaluated, that is, ntf must be one.
The code enforces this by setting ntf to 1 when a noshakemask string is present in the input.
If you want the noshakemask to apply to all or part of the water molecules, you must also set
jfastw=4, to turn off the special code for water SHAKE. (If you are not shaking waters, you pre-
sumably also want to issue the "set default FlexibleWater on" command in LEaP; see that chapter
for more information.)

19.6.10. The “middle” scheme

19.6.10.1. Introduction

The “middle” scheme offers a uniﬁed framework to develop efﬁcient thermostatting algorithms for conﬁgura-
tional sampling for the canonical ensemble, as described in Refs. [421–425]. It can be implemented for performing
molecular dynamics (MD) or path integral molecular dynamics (PIMD), either with or without holonomic con-
straints. The “middle” scheme allows the use of much larger time intervals (i.e., time stepsizes) ∆t to maintain
the same accuracy, which signiﬁcantly improves the conﬁgurational sampling efﬁciency. That is, it is efﬁcient
for calculating structural properties and thermodynamic observables that depend on coordinate variables. Most
thermostats control the temperature by updating momenta of the system. Some prevailing thermostats include
stochastic ones (such as the Andersen thermostat and Langevin dynamics) and deterministic ones (such as the
Nosé-Hoover thermostat and Nosé-Hoover chain).
In the “middle” scheme, immediately after the coordinate-
updating step for half a time interval, the thermostat process for a full time interval takes place, which is then
followed by the coordinate-updating step for another half time interval[421, 425].

Here we present a brief introduction to the “middle” scheme. For many thermostats, the integration in one time
step ∆t can be splitted into three parts, the steps for updating coordinates, momenta and thermostat, denoted as
“x”, “p” and “T”, respectively. In this case the “equation of motion” may be expressed as

(cid:21)

(cid:20)dxt

dpt

=

(cid:21)

(cid:20)M−1pt
(cid:123)(cid:122)
(cid:124)

0

x

(cid:20)
(cid:21)
(cid:124)
(cid:123)(cid:122)
−∇xtU(xt )

0

p

+

dt

(cid:125)

+(cid:2)thermostat(cid:3)
(cid:125)
(cid:124)

(cid:123)(cid:122)

T

dt

(cid:125)

Here, U is the potential energy, M is the diagonal mass matrix, x and p are the vectors of coordinate and momentum,
respectively. Equation (19.1) is, however, not convenient to do the analysis.

A more useful approach is to employ the forward Kolmogorov equation to express the evolution of the density

distribution in the phase space ρ(x,p).

∂
∂t

ρ =L ρ

=(Lx + Lp + LT)ρ

The relevant Kolmogorov operators for the 1st and 2nd terms of the right-hand side (RHS) are

Lxρ = −pT M−1∇xρ

350

(19.1)

(19.2)

(19.3)

19.6. General minimization and dynamics parameters

(19.4)
respectively. The deﬁnition of LT depends on the speciﬁc thermostat. The phase space propagators for a time
interval ∆t for the three parts are eLx∆t, eLp∆t, and eLT∆t, respectively.

Lpρ = ∇xU(x)· ∇pρ

The propagation in each time step with the velocity Verlet (VV) algorithm is performed as

eL ∆t ≈ eL VV

middle∆t = eLp∆t/2eLx∆t/2eLT∆teLx∆t/2eLp∆t/2

(19.5)

The phase space propagator for the thermostat part eLT∆t is designed in the middle. Equation (19.5) is denoted as
“VVMiddle”. The numerical algorithm reads

∆t
Update Momenta for half a step: p ← p− ∂U
∂x
2
∆t
Update Coordinates for half a step: x ← x + M−1p
2
thermostat_step
∆t
Update Coordinates for another half step: x ← x + M−1p
2
∆t
Update Momenta for another half step: p ← p− ∂U
∂x
2

Thermostat for a full time step:

(19.6)

where thermostat_step is the subroutine for the thermostat process, which is determined according to the thermostat
method of choice.

The stationary state distribution of “VVMiddle” for a harmonic system U(x) = 1

2 (x− xeq)T A(x− xeq) is

ρVV
middle(x,p) =

1
ZN

exp

−β

1
2

pT

(cid:40)

(cid:34)

(cid:18)

(cid:19)−1

∆t2
4

M− A

(cid:21)(cid:27)

+

1
2

(x− xeq)T A(x− xeq)

p

(19.7)

as long as the thermostat process keeps the Maxwell (or Maxwell-Boltzmann) momentum distribution unchanged,
i.e.

where the Maxwell momentum distribution is

eLT∆tρMB(p) = ρMB(p)

(cid:19)3N/2|M|−1/2 exp

(cid:20)

−β

(cid:18) β

2π

(cid:19)(cid:21)

pT M−1p

(cid:18)1

2

ρMB(p) =

(19.8)

(19.9)

Here β = 1
kBT with kB as the Boltzmann constant, T is the temperature of the system. (N is the number of particles.)
It is then easy to verify that the marginal distribution of coordinates for “VVMiddle” is exact in the harmonic
limit. Many types of thermostats satisfy the criteria (thermostat process keeps the Maxwell momentum distribution
unchanged, Equation (19.8)), which include, but not limited to, the thermostats listed below.

• Andersen thermostat (real dynamics case)

In this thermostat, each particle of the system stochastically collides with a ﬁctitious heat bath, and once the
collision occurs, the momentum of this particle is chosen afresh from the Maxwell-Boltzmann momentum
distribution. The explicit form for the thermostat process can be expressed as

(cid:114) m j

β

p( j) ←

θθθ j, ( j = 1,N)

if µ j < ν∆t (or more precisely µ j < 1− e−ν∆t )

(19.10)

Here ν is the collision frequency, θθθ j is a vector of independent Gaussian-distributed random numbers with

351

19. sander

zero mean and unit variance, m j the mass for the jth atom, µ j is a uniformly distributed random number in
the range (0,1). Here µ j may be different for each particle ( j = 1,N). In the current version of AMBER µ j
is the same for all particles. (I.e., the global Andersen thermostat is employed.)

(19.11)

(19.12)

(19.13)

(19.14)

(19.15)

The phase space propagator for the thermostat process is

eLT∆tρ =e−ν∆tρ(x,p)

+ (1− e−ν∆t )ρMB(p)

(cid:90) ∞

−∞

ρ(x,p)dp

• Andersen thermostat (virtual dynamics case)

The explicit form for the virtual dynamics case of the Andersen thermostat is expressed as

(cid:114) m j

p( j) ←
p( j) ←− p( j),

β

θθθ j, if µ j < 1− e−ν∆t

otherwise

 ( j = 1,N)

The phase space propagator for the thermostat process is
eLT∆tρ =e−ν∆tρ(x,−p)

+ (1− e−ν∆t )ρMB(p)

(cid:90) ∞

−∞

ρ(x,p)dp

• Langevin dynamics (real dynamics case)

The thermostat process is the solution to the Ornstein-Uhlenbeck (OU) process

p ← e−γγγ∆tp +

M1/2(1− e−2γγγ∆t )1/2ηηη

1
β

(cid:115)

(cid:115)

Here, ηηη is a vector of independent Gaussian-distributed random numbers with zero mean and unit variance,
γγγ is the diagonal friction coefﬁcient matrix. In the current version of AMBER all diagonal elements of γγγ
are set to be the same. (That is, the friction coefﬁcient is the same for all particles. The global Langevin
thermostat is used.)
The phase space propagator for the thermostat process is

eLT∆tρ =

2π

(cid:19)3N/2|M(1− e−2γγγ∆t )|−1/2

(cid:18) β
(cid:90)
·
·M−1(1− e−2γγγ∆t )−1(p− e−γγγ∆tp0)

(cid:20)
−β
2

dp0 ρ(x,p0)exp

(cid:105)

(p− e−γγγ∆tp0)T

• Langevin dynamics (virtual dynamics case)

The virtual dynamics case represents another type of discrete evolution that may not correspond to a contin-
uous, real dynamical counterpart of the Langevin equation.

p ← −e−γγγ∆tp +

M1/2(1− e−2γγγ∆t )1/2ηηη

1
β

(19.16)

The virtual dynamics case is also able to produce the desired stationary distribution. The phase space prop-

352

19.6. General minimization and dynamics parameters

agator for the thermostat process is then

eLT∆tρ =

2π

(cid:19)3N/2|M(1− e−2γγγ∆t )|−1/2

(cid:18) β
(cid:90)
·
·M−1(1− e−2γγγ∆t )−1(p + e−γγγ∆tp0)

(cid:20)
−β
2

dp0 ρ(x,p0)exp

(cid:105)

(p + e−γγγ∆tp0)T

(19.17)

• Nosé-Hoover (NH) thermostat and Nosé-Hoover chain (NHC)

See Ref. [421] for more detailed discussions.

The “middle” scheme of a thermostat includes both real and virtual dynamics cases. (See Refs. [423, 424].) It
is proved in Ref. [423] that, while the Langevin equation algorithm (BAOAB) proposed in Ref. [426] is simply
only the real dynamics case of “VVMiddle”, another Langevin equation algorithm proposed (without employing
the Lie-Trotter splitting) in Ref. [427] is equivalent to “VVMiddle” for Langevin dynamics. The real dynamics
case for the Andersen thermostat and that for Langevin dynamics have been implemented in the current version of
AMBER.

When the leapfrog algorithm, rather than the velocity-Verlet algorithm, is employed in the “middle” scheme, it
is denoted as “LFMiddle”[425]. The propagation in each time step with the leapfrog (LF) algorithm is performed
as

eL ∆t ≈ eL LF
The numerical algorithm of “LFMiddle” reads

middle∆t = eLx∆t/2eLT∆teLx∆t/2eLp∆t

Update Momenta for a full time step: p ← p− ∂U
∆t
∂x
∆t
Update Coordinates for half a step: x ← x + M−1p
2
thermostat_step
∆t
Update Coordinates for another half step: x ← x + M−1p
2

Thermostat for a full time step:

(19.18)

(19.19)

For any general systems, “LFMiddle” shares the same accuracy as “VVMiddle” for sampling the marginal distribu-
tion of coordinates. In addition, “LFMiddle” leads to the exact marginal distribution of momenta in the harmonic
limit[425]. For simplicity and compatibility, only “LFMiddle” is integrated into AMBER.

The “middle” scheme with holonomic constraints (such as bond length constraints) is also implemented. While
MD with holonomic constraints are widely used in biological simulations, PIMD with holonomic constraints may
help understand nuclear quantum effects of different motions in molecular systems. For instance, help assign spec-
tral features as shown in Ref. [428]. In the “middle” scheme, when holonomic constraints are applied, the SHAKE
[419] and RATTLE [429] algorithms are used for ﬁxing coordinates and velocities, respectively. Particularly for
the molecular system that contains water molecules, the analytical SETTLE algorithm [420] may be used to apply
the constraint to the water molecule.

Besides Refs. [421–425], one more paper is in preparation for the “middle” scheme [430].
While the “middle” scheme for PIMD with the staging transformation (staging PIMD) was ﬁrst demonstrated
in Ref. [422], that for PIMD with the normal-mode transformation (normal-mode PIMD) was ﬁrst proposed in the
supplemental material of Ref. [422] in 2016, which can be found via the URLs provided by the publisher:

• https://aip.scitation.org/doi/suppl/10.1063/1.4954990/suppl_file/supplemental+

material-submitted.docx

• ftp://ftp.aip.org/epaps/journ_chem_phys/E-JCPSA6-145-007626

353

19. sander

In addition, the arXiv preprint (that includes Ref. [422] and its supplemental material) is also available (https:
//arxiv.org/ftp/arxiv/papers/1611/1611.06331.pdf). In the current version, the “middle” scheme is im-
plemented for the primitive version of PIMD (PRIMPIMD) of AMBER. The staging PIMD or normal-mode PIMD
algorithms in the “middle” scheme will also be implemented into AMBER soon.

19.6.10.2. Input parameters

In order to perform MD or PRIMPIMD simulations with the “middle” scheme, three additional ﬂags should be

added in the mdin ﬁle, which are used to distinguish different methods.

ischeme

Flag for choosing an integration scheme for molecular dynamics.
=0 (default) conventional scheme in AMBER.
=1 “middle” scheme based on the leapfrog algorithm.

ithermostat Flag for different thermostats when the “middle” scheme is employed. Two types of thermostats

are currently available.
=1 Langevin dynamics.
=2 Andersen thermostat.
The parameter used in a thermostatting method of the “middle” scheme, in the unit of ps−1, which
should always be a positive number. It refers to the friction coefﬁcient for Langevin dynamics
(ithermostat = 1) or the collision frequency for the Andersen thermostat (ithermostat = 2).

therm_par

The recommended value for therm_par is related to the characteristic frequency ( ˜ω) of the speciﬁc system. The
characteristic time of the potential energy autocorrelation function is

(cid:90) ∞

(cid:104)U(0)U(t)(cid:105)−(cid:104)U(cid:105)2

0

dt

(19.20)

(cid:104)U 2(cid:105)−(cid:104)U(cid:105)2

τUU =
ξ opt ≈ ˜ω for Langevin dynamics and ξ opt ≈ √
The optimal value of the thermostat parameter that produces the minimum correlation time of the potential is
2 ˜ω for the Andersen thermostat, as the time interval ∆t approaches
zero. E.g. for a HO molecule, the frequency of the O-H stretch is around 3600 cm−1( 680 ps−1), so one can choose
680 ps−1 as the value of therm_par when Langevin dynamics is used, or 960 ps−1 when the Andersen thermostat is
employed. When the time interval ∆t is ﬁnite in the two thermostatting methods, while the characteristic correlation
time goes to inﬁnity as the thermostat parameter approaches zero, the characteristic correlation time gradually
reaches a plateau as the thermostat parameter increases. (Please see Refs. [423–425] for more discussions.) When
condensed phase systems are simulated, it is not straightforward to estimate the optimal thermostat parameter(s)
that could be related to the mixing of frequencies (or time scales) of the system [407]. Some numerical tests are
necessary for obtaining the reasonable region for the thermostat parameter such that the charateristic time divided
by the time interval is relatively small.
(This is true not only for the “middle” scheme but for all thermostat
algorithms.) For a liquid water system (216 water molecules in a cell with periodic boundary conditions) with no
holonomic constraints, the thermostat parameter is usually chosen to be 2− 50 ps−1.

19.6.10.3. Examples

Examples include a liquid water system (216 water molecules in a cell with the periodic boundary conditions)
with the q-SPC/Fw model, an alanine dipeptide (ACE-ALA-NME) solved in a box with 401 methol molecules,
and a peptide chain ACE-ALA-ALA-ALA-NME in vacuum. One is also encouraged to check the test cases in
$AMBERHOME/test/middle-scheme. In AMBER the analytical SETTLE algorithm is the default (jfastw=0) for
applying the constraints for the water molecule. (Note that in some liquid water models, the intramolecular H-H
is speciﬁed as a bond in the topology ﬁle, so all the intramolecular O-H and H-H distances are constrained when
ntc=2 is employed in AMBER.)

354

19.6. General minimization and dynamics parameters





/

Molecular dynamics (for classical statistics)

(1) MD input using the Langevin thermostat with the “LFMiddle” scheme for liquid water.
Test: $AMBERHOME/test/middle-scheme/MD_Unconstr_Langevin_water

MD: NVT simulation of liquid water
&cntrl
ipimd = 0, nstlim = 10
ntx = 1, irest = 0
temp0 = 300, tempi = 300
dt = 0.001
cut = 7.0
ischeme = 1
ithermostat = 1
therm_par = 5.0
ig = 1000
ntc = 1, ntf = 1
ntpr = 1, ntwr = 5, ntwx = 5

! MD for 10 steps
! read coordinates
! temperature: target and initial
! time step in ps
! non-bond cut off
!! leapfrog middle scheme
!! Langevin thermostat
!! thermostat parameter in 1/ps
! random seed
! no constraints
! output settings

/

One can run either a serial job (using sander):

$ sander -O -i md_LGV.in -p qspcfw216.top -c nvt.rst -o md_LGV.out \

-r lgv.rst -info lgv.info

or a parallel job (using sander.MPI):

$ mpirun -np 4 sander.MPI -O -i md_LGV.in -p qspcfw216.top -c nvt.rst \

-o md_LGV.out -r lgv.rst -info lgv.info

(2) MD input using Langevin dynamics with the “LFMiddle” scheme for the liquid water. Lengths of the bonds

having hydrogen atoms are constrained.

Test: $AMBERHOME/test/middle-scheme/MD_Constr_Langevin_water

MD: NVT simulation of liquid water
&cntrl
ipimd = 0, nstlim = 10
ntx = 1, irest = 0
temp0 = 300, tempi = 300
dt = 0.004
cut = 7.0
ischeme = 1,
ithermostat = 1,
therm_par = 5.0
ntc = 2, ntf = 2
ntpr = 1, ntwr = 5, ntwx = 5

! MD for 10 steps
! read coordinates
! temperature: target and initial
! time step in ps
! non-bond cut off
!! leapfrog middle scheme
!! Langevin thermostat, random seed is default value
!! thermostat parameter, in 1/ps
! constrain lengths of the bonds having hydrogen atoms
! output settings

Run either a serial way (using sander):

$ sander -O -i md_LGV.in -p qspcfw216.top -c nvt.rst -o md_LGV.out \

-r lgv.rst -info lgv.info

or a parallel job (using sander.MPI):

$ mpirun -np 4 sander.MPI -O -i md_LGV.in -p qspcfw216.top -c nvt.rst \

-o md_LGV.out -r lgv.rst -info lgv.info

355











/


/




19. sander

Path integral molecular dynamics (for quantum statistics)

(1) PRIMPIMD input using the Andersen thermostat with the “LFMiddle” scheme for the liquid water. Lengths

of the bonds having hydrogen atoms are constrained.

Test: $AMBERHOME/test/middle-scheme/PIMD_Constr_Andersen_water

! PRIMPIMD for 10 steps
! read coordinates

PRIMPIMD: NVT simulation of liquid water
&cntrl
ipimd = 1, nstlim = 10
ntx = 5, irest = 0
temp0 = 300, tempi = 300 ! target temperature and initial temperature
dt = 0.002
cut = 7.0
ischeme = 1,
ithermostat = 2,
therm_par = 8.0
ig = 777
ntc = 2,ntf = 2
ntpr=1, ntwr=5, ntwx=5

! time step in ps
! non-bond cut-off
!! leapfrog middle scheme
!! Andersen thermostat
!! thermostat parameter, in 1/ps
! random seed
! constrain lengths of the bonds having hydrogen atoms
! output settings

(2) PRIMPIMD input using Langevin dynamics with the “LFMiddle” scheme for the liquid water. No constraints

are applied.

Test: $AMBERHOME/test/middle-scheme/PIMD_Langevin_water

PRIMPIMD: NVT simulation of liquid water
&cntrl
ipimd = 1,nstlim = 10
ntx = 5,irest = 0

! PRIMPIMD for 10 steps
! read coordinates,
! and run as a new simulation.

temp0 = 300,tempi = 300 ! target and initial temperature
dt = 0.001
cut = 7.0
ischeme = 1,
ithermostat = 1,
therm_par = 5.0
ntc = 1
ntpr=1, ntwr=5, ntwx=5 ! output settings

! time step, in ps
! non-bond cut off
!! leapfrog middle scheme
!! Langevin thermostat
!! thermostat parameter, in 1/ps
! no constraints, default

When one runs PIMD in AMBER, a groupﬁle is needed. The groupﬁle gf_pimd may look like:

-O -i pimd.in -p qspcfw216.top -c nvt1.rst -o bead1.out -r bead1.rst

-x bead1.mdcrd -inf bead1.mdinfo

-O -i pimd.in -p qspcfw216.top -c nvt2.rst -o bead2.out -r bead2.rst

-x bead2.mdcrd -inf bead2.mdinfo

-O -i pimd.in -p qspcfw216.top -c nvt3.rst -o bead3.out -r bead3.rst

-O -i pimd.in -p qspcfw216.top -c nvt4.rst -o bead4.out -r bead4.rst

-x bead3.mdcrd -inf bead3.mdinfo

-x bead4.mdcrd -inf bead4.mdinfo

Note that each line starts with “-O” and ends with “-inf <info>”. The groupﬁle above contains 4 lines, which
means 4 path integral beads are used.

sander.MPI is executed via the following command:

$ mpirun -np 8 sander.MPI -ng 4 -groupfile gf_pimd

The number of processes (8) that is speciﬁed by “-np” is a multiple of the number of groups (4). In this case 2
CPU processes are used on each path integral bead.

356











QM/MM molecular dynamics

19.6. General minimization and dynamics parameters

QM/MM MD input using the Langevin thermostat with the “LFMiddle” scheme for the alanine dipeptide solved
in methol box. Lengths of the bonds having hydrogen atoms are constrained for the MM part, while no constraints
are applied to the QM part.

Test: $AMBERHOME/test/middle-scheme/QMMM_Constr_ALA_Methol



! MD for 10 steps
! read coordinates
! target temperature
! initial temperature
! time step, in ps
! non-bond cut off
! random seed for reproducing results
!! leapfrog middle scheme
!! Langevin thermostat
!! thermostat parameter, in 1/ps
! constrain lengths of bonds having hydrogen atoms atoms
! output settings
! switch on QM/MM coupled potential

constrained MD NVT: Alanine dipeptide in meoh (explicit solvent).
&cntrl
ipimd = 0, nstlim = 10,
irest = 0, ntx = 1,
temp0 = 300
tempi = 300
dt = 0.002,
cut = 8,
ig = 6666,
ischeme = 1,
ithermostat = 1
therm_par = 5.0,
ntc=2,ntf=2
ntpr=1, ntwr=1, ntwx=1
ifqnt=1
/
&qmmm qmmask=':ACE,ALA,NME', ! residues treated using QM
qmcharge=0,
qmshake=0,
qm_theory='PM3',
qmcut=8.0

! charge on QM region is 0
! no SHAKE for QM region
! use the PM3 semi-empirical Hamiltonian
! use 8 angstrom cut off for QM region

/

One can run either a serial job (using sander):

$ sander -O -i qmmm.in -p ala.top -c ala.crd -o qmmm.out -r qmmm.rst \

-x qmmm.crd -info qmmm.info

or a parallel job (using sander.MPI):

$ mpirun -np 4 sander.MPI -O -i qmmm.in -p ala.top -c ala.crd \

-o qmmm.out -r qmmm.rst -x qmmm.crd -info qmmm.info

Replica exchange molecular dynamics

REMD input using the Langevin thermostat with the “LFMiddle” scheme for the ACE-ALA-ALA-ALA-NME in

vacuum.Lengths of the bonds having hydrogen atoms are constrained.

Test: $AMBERHOME/test/middle-scheme/REMD_Constr_ALA
Below is the input ﬁle for one of the replicas. The target temperatures are 300, 325, 350, and 400K for the 4



replicas, respectively.

! MD for 100 steps
! read coordinates and velocities

REMD test with 4 replicas
&cntrl
imin = 0, nstlim = 100,
irest=1,ntx = 5,
tempi = 0.0, temp0 = 300.0, ! initial and target temperature
ischeme= 1,
ithermostat = 1,
therm_par = 1.0,
dt = 0.002,
ig=6666,

!! leapfrog middle scheme
!! Langevin thermostat
!! thermostat parameter,in 1/ps
! time step, in ps
! random seed

357







19. sander

&end


! constrain lengths of the bonds having hydrogen atoms

ntc = 2, ntf = 2,
ntwx = 50, ntwr =50, ntpr = 50,
ntb=0,
cut = 99.0,
numexchg=5,

! output setting

! no periodicity
! non bond cut off
! exchange frequency

When one runs REMD in AMBER, a groupﬁle is needed. The groupﬁle groupﬁle may look like:

-O -rem 1 -remlog rem.log -i rem.in.000 -p ala3.top -c mdrestrt -o rem.out.000

-r rem.r.000 -inf reminfo.000

-O -rem 1 -remlog rem.log -i rem.in.001 -p ala3.top -c mdrestrt -o rem.out.001

-r rem.r.001 -inf reminfo.001

-O -rem 1 -remlog rem.log -i rem.in.002 -p ala3.top -c mdrestrt -o rem.out.002

-O -rem 1 -remlog rem.log -i rem.in.003 -p ala3.top -c mdrestrt -o rem.out.003

-r rem.r.002 -inf reminfo.002

-r rem.r.003 -inf reminfo.003








Note that each line starts with “-O” and ends with “-inf <info>”. The groupﬁle has 4 lines, which means 4 replicas
are employed in REMD.

sander.MPI is executed via the following command:

$ mpirun -np 4 sander.MPI -ng 4 -groupfile groupfile

The number of processes (4) that is speciﬁed by “-np” can be replaced by any multiple of the number of replicas
used in REMD (4 in this case).

One is also encouraged to access the tutorial for the “middle” scheme on the webpage

http://jianliugroup.pku.edu.cn/tutorials.html

19.6.11. Water cap

ivcap

Flag to control cap option. The "cap" refers to a spherical portion of water centered on a point in
the solute and restrained by a soft half-harmonic potential. For the best physical realism, this option
should be combined with igb=10, in order to include the reaction ﬁeld of waters that are beyond the
cap radius.
= 0 Cap will be in effect if it is in the prmtop ﬁle (default).
= 1 With this option, a cap can be excised from a larger box of water. For this, cutcap (i.e., the
radius of the cap), xcap, ycap, and zcap (i.e., the location of the center of the cap) need to be
speciﬁed in the &cntrl namelist. Note that the cap parameters must be chosen such that the
whole solute is covered by solvent. Solvent molecules (and counterions) located outside the
cap are ignored. Although this option also works for minimization and dynamics calculations
in general, it is intended to post-process snapshots in the realm of MM-PBSA to get a linear-
response approximation of the solvation free energy, output as ’Protein-solvent interactions’.

= 2 Cap will be inactivated, even if parameters are present in the prmtop ﬁle.
= 5 With this option, a shell of water around a solute can be excised from a larger box of water. For
this, cutcap (i.e., the thickness of the shell) needs to be speciﬁed in the &cntrl namelist. Solvent
molecules (and counterions) located outside the cap are ignored. This option only works for a
single-step minimization. It is intended to post-process snapshots in the realm of MM-PBSA
to get a linear-response approximation of the solvation free energy, output as ’Protein-solvent
interactions’.

fcap

The force constant for the cap restraint potential.

cutcap

Radius of the cap, if ivcap=1 is used.

xcap,ycap,zcap Location of the cap center, if ivcap=1 is used.

358

19.6.12. NMR reﬁnement options

(Users to should consult the section NMR reﬁnement to see the context of how the following parameters would

be used.)

19.7. Potential function parameters

iscale

noeskp

ipnlty

mxsub

scalm

pencut

tausw

Number of additional variables to optimize beyond the 3N structural parameters. (Default = 0). At
present, this is only used with residual dipolar coupling and CSA or pseudo-CSA restraints.

The NOESY volumes will only be evaluated if mod(nstep, noeskp) = 0; otherwise the last computed
values for intensities and derivatives will be used. (default = 1, i.e. evaluate volumes at every step)

This parameter determines the the functional form of the penalty function for NOESY volume and
chemical shift restraints.
= 1 the program will minimize the sum of the absolute values of the errors; this is akin to minimizing

the crystallographic R-factor (default).

= 2 the program will optimize the sum of the squares of the errors.
= 3 For NOESY intensities, the penalty will be of the form awt[I1/6

c − I1/6

o

ties will be as for ipnlty=1.

]2. Chemical shift penal-

Maximum number of submolecules that will be used. This is used to determine how much space to
allocate for the NOESY calculations. Default 1.

"Mass" for the additional scaling parameters. Right now they are restricted to all have the same value.
The larger this value, the slower these extra variables will respond to their environment. Default 100
amu.

In the summaries of the constraint deviations, entries will only be made if the penalty for that term
is greater than PENCUT. Default 0.1.

For noesy volume calculations (NMROPT = 2), intensities with mixing times less that TAUSW (in
seconds) will be computed using perturbation theory, whereas those greater than TAUSW will use a
more exact theory. See the theory section (below) for details. To always use the "exact" intensities
and derivatives, set TAUSW = 0.0; to always use perturbation theory, set TAUSW to a value larger
than the largest mixing time in the input. Default is TAUSW of 0.1 second, which should work pretty
well for most systems.

19.6.13. EMAP restraints

EMAP restraints are used to perform targeted conformational search (TCS)[431]. EMAP uses maps to deﬁne
restraints to maintain conformations and/or to induce simulation systems to the target conformations. The restraint
map can be either obtained from electron microscopy experiments or derived from known protein structures, or
deﬁned from initial simulation coordinates. EMAP can be used to do rigid docking of molecules into maps and
to do ﬂexible ﬁtting to obtain conformations deﬁned by experimental maps. EMAP can also be used to maintain
conformations of protein domains when studying large scale conformational change. Users should consult the
section 28.1 to see how to deﬁne EMAP restraints.

iemap

Turn on EMAP restrained simulation when iemap>0. (Default = 0). EMAP restraint information
must be input from &emap namelists in the input ﬁle.

gammamap

Friction constant for the EMAP restraint maps when allowed to move. (Default=1/ps). (See Section
28.1)

19.7. Potential function parameters

The parameters in this section generally control what sort of force ﬁeld (or potential function) is used for the

simulation.

359

19. sander

19.7.1. Generic parameters

ntf

Force evaluation. Note: If SHAKE is used (see NTC), it is not necessary to calculate forces for the
constrained bonds.

= 1 complete interaction is calculated (default)
= 2 bond interactions involving H-atoms omitted (use with NTC=2)
= 3 all the bond interactions are omitted (use with NTC=3)
= 4 angle involving H-atoms and all bonds are omitted
= 5 all bond and angle interactions are omitted
= 6 dihedrals involving H-atoms and all bonds and all angle interactions are omitted
= 7 all bond, angle and dihedral interactions are omitted
= 8 all bond, angle, dihedral and non-bonded interactions are omitted

ntb

This variable controls whether or not periodic boundaries are imposed on the system during the
calculation of non-bonded interactions. Bonds spanning periodic boundaries are not yet supported.
There is no longer any need to set this variable, since it can be determined from igb and ntp pa-
rameters. The “proper” default for ntb is chosen (ntb=0 when igb > 0, ntb=2 when ntp > 0, and
ntb=1 otherwise). This behavior can be overridden by supplying an explicit value, although this is
discouraged to prevent errors. The allowed values for NTB are

= 0 no periodicity is applied and PME is off (default when igb > 0)
= 1 constant volume (default when igb and ntp are both 0, which are their defaults)
= 2 constant pressure (default when ntp > 0)

If NTB is nonzero then there must be a periodic boundary in the topology ﬁle. Constant pressure is
not used in minimization (IMIN=1, above).
For a periodic system, constant pressure is the only way to equilibrate density if the starting state is
not correct. For example, the solvent packing scheme used in LEaP can result in a net void when
solvent molecules are subtracted which can aggregate into "vacuum bubbles" in a constant volume
run. Another potential problem are small gaps at the edges of the box. The upshot is that almost
every system needs to be equilibrated at constant pressure (ntb=2, ntp>0) to get to a proper density.
But be sure to equilibrate ﬁrst (at constant volume) to something close to the ﬁnal temperature, before
turning on constant pressure.

Dielectric multiplicative constant for the electrostatic interactions. Default is 1.0. Please note this
is NOT related to dielectric constants for generalized Born or Poisson-Boltzmann calculations. It
should only be used for quasi-vacuum simulations.

This is used to specify the nonbonded cutoff, in Angstroms. For PME, the cutoff is used to limit direct
space sum, and 8.0 is usually a good value. When igb>0, the cutoff is used to truncate nonbonded
pairs (on an atom-by-atom basis); here a larger value than the default is generally required. A
separate parameter (RGBMAX) controls the maximum distance between atom pairs that will be
considered in carrying out the pairwise summation involved in calculating the effective Born radii,
see the generalized Born section below.
When igb > 0, the default is 9999.0 (effectively inﬁnite)
When igb==0, the default is 8.0.

dielc

cut

fswitch

When off, fswitch<=0 , uses a truncation cutoff. When on fswitch>0, sets a force switching region
where the force cutoff smoothly approaches 0 between the region of the fswitch value to the cut
value. Force values below the fswitch value follow the standard Lennard-Jones force. Default is
-1. This option is not supported for use with GB (i.e., only igb=0 and ntb>0), nor is it compatible
with the 12-6-4 Lennard-Jones model (lj1264=1). Due to performance regressions (about 20%) with

360

nsnb

ipol

ifqnt

igb

irism

ievb

iamoeba

lj1264

efx

efy

efz

efn

efphase

effreq

19.7. Potential function parameters

running with the force switching on, it is recommended that simulations run with fswitch off unless
using a force ﬁeld that requires or recommends using the force switch.

Determines the frequency of nonbonded list updates when igb=0 and nbﬂag=0; see the description
of nbﬂag for more information. Default is 25.

When set to 1, use a polarizable force ﬁeld. See Section 19.7.5 for more information. Default is 0.

Flag for QM/MM run; if set to 1, you must also include a &qmmm namelist. See Section 6.4 for
details on this option. Default is 0.

Flag for using the generalized Born or Poisson-Boltzmann implicit solvent models. See Section 4
for information about using this option. Default is 0.

Flag for 3D-reference interaction site model (RISM) molecular solvation method. See Section7.7for
information about this option. Default is 0.

If set to 1, use the empirical valence bond method to compute energies and forces. See Section 6.3
for information about this option. Default is 0.

Flag for using the amoeba polarizable potentials of Ren and Ponder.[432, 433] When this option is
set to 1, you need to prepare an amoeba namelist with additional parameters. Also, the prmtop ﬁle is
built in a special way. See Section 30 for more information about this option. Default is 0.

In general, you should rarely have to set this variable. When the Lennard-Jones C-coefﬁcient is
found in your prmtop ﬁle, the default value is set to 1 (meaning it is active). When this ﬂag is not
present in the prmtop ﬁle, the default value is set to 0 (meaning the 12-6-4 potential [117] is inactive).
Setting this to 0 when the C-coefﬁcient is present will forcibly turn off the 12-6-4 potential. Setting
lj1264 to 1 when no C-coefﬁcient is present will result in a fatal error. Therefore, this ﬂag can be
used to quickly disable the r−4 term. However, the remaining L-J parameters will still be optimized
for the 12-6-4 potential, so this should only be done when testing! It currently only supports sander
and pmemd (both the serial and MPI versions) but not pmemd.cuda. It is currently only compatible
with the Particle Mesh Ewald method for long-range electrostatics. For more information please see
Section 3.6. For adding it to your topology ﬁle, see Subsection 14.2.2.6.

This sets the x component of the electric ﬁeld in kcal/(mol*A*e). Electric ﬁelds are naturally off if
efx, efy, efz are 0. Default value is 0. It currently only supports pmemd (both the serial and MPI
versions).

This sets the y component of the electric ﬁeld in kcal/(mol*A*e). Electric ﬁelds are naturally off if
efx, efy, efz are 0. Default value is 0. It currently only supports pmemd (both the serial and MPI
versions).

This sets the z component of the electric ﬁeld in kcal/(mol*A*e). Electric ﬁelds are naturally off if
efx, efy, efz are 0. Default value is 0. It currently only supports pmemd (both the serial and MPI
versions).

If efn is on (efn=1), the x, y, z (efx, efy, efz) components are scaled to box size. For example efx/x
length of box size, efy/y length of box size, efz/z length of box size. This normalizes the electric
ﬁeld charge to your box size. It is off when it is 0. It currently only supports pmemd (both the serial
and MPI versions).

sets

efphase
equationcos ((2π × e f f req/1000)(dt × step)− (π × e f phase/180)).
pmemd (both the serial and MPI versions).

timestep

phase

the

the

for

electric

ﬁeld

the
It currently only supports

using

the

sets

effreq
cos ((2π × e f f req/1000)(dt × step)− (π × e f phase/180)).
(both the serial and MPI versions).

frequency

timestep

the

for

electric

ﬁeld

equation
It currently only supports pmemd

using

the

361

19. sander

mcwat

controls the Monte Carlo (MC) water equilibration function. Set 1 to run, 0 otherwise. mcint,
mcrescyc, mcwatmaxdif, and mcboxshift are variables control the frequency and functionality of
this feature. Currently only supported on pmemd and pmemd.cuda.

mcint

Number of MD steps between each cycle of MC. Preliminary recommendation is 1,000.

mcrescyc

Number of MC move attempts in each MC cycle. Preliminary recommendation is 10,000-100,000.

mcwatmaxdif Sets the maximum absolute difference for MC acceptance between old and new energy in kcal/mol
(recommended value 100). This variable is intended to prevent artifacts from numerical “rollover”,
where an energy is so high, due to a severe clash at the trial water position, that Fortran rolls it over
to a large negative value which would be accepted by the Metropolis criterion.

mcboxshift Trims the region in which waters are moved away from the edges of the simulation box, to reduce the
number of uninteresting “bulk to bulk” moves, and instead focus on moves connecting bulk with the
solute at the middle of the box.. If the system was prepared with cubic periodic boundary conditions
with an equal amount of solvent padding along all three axes, it is recommended that this value be
set to amount of padding (default is 10 Angstroms).

ramdboost Sets default random boost acceleration for ramd (default 1). This boost is multiplied by the mass
of each atom in the ligand to determine the force each atom receives. This value is in internal
acceleration units refer to the Amber units. Ramd is a pmemd and pmemd.cuda only feature and
does not support MPI.

ramdboostfreq Sets number of steps between each time ramd boost strength is increased (defualt 0).

ramdboostrate Sets the amount to increase the ramdboost acceleration each time ramdboostfreq (default is 0).

ramdint

Sets the time step interval to apply ramd boost on to the ligand (default is 0).

ramdmaxdist Determines the end condition for the simulation (ramd terminates when nstlim is reached or when
ramdmaxdist is satisﬁed). ramdmaxdist is the amount of angstrom displacement from initial center
of mass distance of protein and ligand to when this displacement increases by ramdmaxdist.

ramdligmask Amber selection mask for what is considered the ligand that needs to be boosted in ramd.

ramdprotmask Amber selection mask for what is considered the protein that is used to calculate the distance the

ligand has moved.

reweight

Allows the re-evaluation of trajectories (usually with a new parameter ﬁle). Set 1 to turn on. When
running this command, in the topology command of the run ﬁle (-c) place the trajectory instead of
the topology ﬁle. This supports netcdf only. Do note if matching against an older run, this does not
capture step 0 because step 0 usually evaluates off of the topology which the trajectory generally
does not contain. It is recommended to rerun with the same parameter ﬁle to check if the feature is
working as intended before proceeding with a modiﬁed parameter topology ﬁle as Amber has a lot
of features and not all of them were tested for this feature (was primarily written for TI calculation
reweighting). Reweight is supported in pmemd and pmemd.cuda, and does not support MPI.

midpoint

Turns on midpoint optimizations (usage of 3-D spatial decomposition). 1 is on, 0 is off (default).
This switch is currently experimental. Please consult ambermd.org/intel/midpoint.htm for currently
supported features and advanced user compilations. Currently only supported on pmemd.MPI.

19.7.2. Particle Mesh Ewald

The Particle Mesh Ewald (PME) method is always "on", unless ntb = 0. PME is a fast implementation of the
Ewald summation method for calculating the full electrostatic energy of a unit cell (periodic box) in a macroscopic
lattice of repeating images. The PME method is fast since the reciprocal space Ewald sums are B-spline interpo-
lated on a grid and since the convolutions necessary to evaluate the sums are calculated via fast Fourier transforms.

362

19.7. Potential function parameters

Note that the accuracy of the PME is related to the density of the charge grid (NFFT1, NFFT2, and NFFT3), the
spline interpolation order (ORDER), and the direct sum tolerance (DSUM_TOL); see the descriptions below for
more information.

The particle mesh Ewald (PME) method was implemented originally in Amber 3a by Tom Darden, and has been
developed in subsequent versions of Amber by many people, in particular by Tom Darden, Celeste Sagui, Tom
Cheatham and Mike Crowley.[434–437] Generalizations of this method to systems with polarizable dipoles and
electrostatic multipoles is described in Refs. [438, 439].

The &ewald namelist is read immediately after the &cntrl namelist. We have tried hard to make the defaults for
these parameters appropriate for solvated simulations. Please take care in changing any values from their defaults.
The &ewald namelist has the following variables:

nfft1, nfft2, nfft3 These give the size of the charge grid (upon which the reciprocal sums are interpolated) in
each dimension. Higher values lead to higher accuracy (when the DSUM_TOL is also lowered) but
considerably slow the calculation. Generally it has been found that reasonable results are obtained
when NFFT1, NFFT2 and NFFT3 are approximately equal to A, B and C, respectively, leading to
a grid spacing (A/NFFT1, etc.) of 1.0 Å. Signiﬁcant performance enhancement in the calculation
of the fast Fourier transform is obtained by having each of the integer NFFT1, NFFT2 and NFFT3
values be a product of powers of 2, 3, and/or 5. If the values are not given, the program will chose
values to meet these criteria.

order

verbose

ew_type

The order of the B-spline interpolation. The higher the order, the better the accuracy (unless the
charge grid is too coarse). The minimum order is 3. An order of 4 (the default) implies a cubic spline
approximation which is a good standard value. Note that the cost of the PME goes as roughly the
order to the third power.

Standard use is to have VERBOSE = 0. Setting VERBOSE to higher values (up to a maximum of 3)
leads to voluminous output of information about the PME run.

Standard use is to have EW_TYPE = 0 which turns on the particle mesh ewald (PME) method. When
EW_TYPE = 1, instead of the approximate, interpolated PME, a regular Ewald calculation is run.
The number of reciprocal vectors used depends upon RSUM_TOL, or can be set by the user. The
exact Ewald summation is present mainly to serve as an accuracy check allowing users to determine
if the PME grid spacing, order and direct sum tolerance lead to acceptable results. Although the cost
of the exact Ewald method formally increases with system size at a much higher rate than the PME,
it may be faster for small numbers of atoms (< 500). For larger, macromolecular systems, with >
500 atoms, the PME method is signiﬁcantly faster.

dsum_tol

This relates to the width of the direct sum part of the Ewald sum, requiring that the value of the direct
sum at the Lennard-Jones cutoff value (speciﬁed in CUT as during standard dynamics) be less than
DSUM_TOL. In practice it has been found that the relative error in the Ewald forces (RMS) due to
cutting off the direct sum at CUT is between 10.0 and 50.0 times DSUM_TOL. Standard values for
DSUM_TOL are in the range of 10−6 to 10−5 , leading to estimated RMS deviation force errors of
0.00001 to 0.0005. Default is 10−5.

rsum_tol

This serves as a way to generate the number of reciprocal vectors used in an Ewald sum. Typically
the relative RMS reciprocal sum error is about 5-10 times RSUM_TOL. Default is 5 x 10−5.

mlimit(1,2,3) This allows the user to explicitly set the number of reciprocal vectors used in a regular Ewald
run. Note that the sum goes from -MLIMIT(2) to MLIMIT(2) and -MLIMIT(3) to MLIMIT(3) with
symmetry being used in ﬁrst dimension. Note also the sum is truncated outside an automatically
chosen sphere.

ew_coeff

Ewald coefﬁcient, in Å
then that value is used, and dsum_tol is computed from ew_coeff and cutoff.

−1 . Default is determined by dsum_tol and cutoff. If it is explicitly inputed

363

19. sander

nbflag

skinnb

If nbﬂag = 0, construct the direct sum nonbonded list in the "old" way, i.e. update the list every nsnb
steps. If nbﬂag = 1 (the default when imin = 0 or ntb > 0), nsnb is ignored, and the list is updated
whenever any atom has moved more than 1/2 skinnb since the last list update.

Width of the nonbonded "skin". The direct sum nonbonded list is extended to cut + skinnb, and the
van der Waals and direct electrostatic interactions are truncated at cut. Default is 2.0 Å. Use of this
parameter is required for energy conservation, and recommended for all PME runs.

skin_permit (pmemd.cuda only) The threshold, as a fraction ofskinnb, at which particle migration will trigger
a non-bonded pair list rebuild. Enter values between 0.5 (minimum, default) and 1.0 (maximum).
Once a particle has traveled more than half the non-bonded pair list margin skinnb, it is possible,
although improbable, that another particle has also traveled this distance towards the ﬁrst, and the
pair is then within the non-bonded cutoff but not counted in the pair list. However, as the system gets
larger, the probability that any one particle will travel 0.5 times the margin grows linearly, while the
likelihood of a pair of nearby particles causing a violation remains constant and low. The frequency
of pair list updates is a major factor in the moderate decrease in performance seen in very large
systems (the scaling of the FFT is a smaller factor). Furthermore, if an interaction is missing, it
will be at the periphery of the cutoff–the threshold at which non-bonded interactions are omitted by
construction. Other codes have already implemented “sloppy pair lists,” so Amber is following suit
and letting the user control the level of risk. By permitting particles to travel up to 0.75 times the
pair list margin, pair list updates can be reduced by approximately half and miss one interaction in
tens of millions. The most aggressive setting, 1.0, will see the pair list rebuilt at a third of original
rate and omit about one of every million valid interactions. A setting of 0.75 is recommended for the
best tradeoff of performance to safety.

nbtell

netfrc

vdwmeth

eedmeth

If nbtell = 1, a message is printed when any atom has moved far enough to trigger a list update. Use
only for debugging or analysis. Default of 0 inhibits the message.

The basic "smooth" PME implementation used here does not necessarily conserve momentum. If
netfrc = 1, (the default) the total force on the system is artiﬁcially removed at every step. This
parameter is set to 0 if minimization is requested, which implies that the gradient is an accurate
derivative of the energy. You should only change this parameter if you really know what you are
doing.

Determines the method used for van der Waals interactions beyond those included in the direct sum.
A value of 0 includes no correction; the default value of 1 uses a continuum model correction for
energy and pressure.

Determines how the switch function for the direct sum Coulomb interaction is evaluated. The default
value of 1 uses a cubic spline. A value of 2 implies a linear table lookup. A value of three implies
use of an "exact" subroutine call.

eedtbdns

Density of spline or linear lookup table, if eedmeth is 1 or 2. Default is 500 points per unit.

column_fft 1 or 0 ﬂag to turn on or off, respectively, column-mode fft for parallel runs. The default mode is
slab mode which is efﬁcient for low processor counts. The column method can be faster for larger
processor counts since there can be more columns than slabs and the communications pattern is less
congested. This ﬂag has no effect on non-parallel runs. Users should test the efﬁciency of the method
in comparison to the default method before performing long calculations. Default is 0 (off).

19.7.3. Using IPS for the calculation of nonbonded interactions

Isotropic Periodic Sum (IPS) is a method for long-range interaction calculation.[440–445] Unlike the Ewald
method, which uses periodic boundary images to calculate long range interactions, IPS uses isotropic periodic
images of a local region to calculate the long-range contributions.

364

19.7. Potential function parameters

The IPS method in the current version is different from that implemented in Amber10. All IPS potentials
use rationalized polynomial forms and the electrostatic interaction is calculated using the polar IPS potential.
[444] In addition, the 3D IPS/DFFT algorithm [443] is implemented to handle heterogeneous systems as well as
ﬁnite systems. A homogeneous system is deﬁned as the one where a cutoff region (with cut as its radius) has
similar composition throughout the system, such as small molecular solutions. Otherwise, a system is deﬁned as
a heterogeneous system, such as interfacial systems or ﬁnite systems. For heterogeneous systems, a local region
larger than the cutoff region, normally equal or larger than the periodic boundary box, must be used to produce
accurate long range interactions. For homogeneous systems, it is recommended to use the 3D IPS method (ips≤3),
which uses the cutoff distance, cut, to deﬁne the local region radius. cut is typically around 10 Å. The 3D IPS/DFFT
method (ips≥4) can be used for any type of systems, but is recommended for heterogeneous systems only due to
the extra discrete fast Fourier transform (DFFT) expense.

For the amoeba polarizable potentials in sander, 3D IPS is implemented for interactions between charges,
dipoles, and multipoles. The local region radius takes the value of ee_dsum_cut in the amoeba namelist, typi-
cally, 7 Å.

ips

Flag to control nonbonded interaction calculation method. The cut value will be used to deﬁne the
local region radius for ips≤3. When IPS is used for electrostatic interaction, PME will be turned
off. When using the amoeba polarizable potentials, iamoeba=1, ips>0 (same as ips=2)will turn on
3D IPS for all charge, dipole, and quadrupole interactions and the ee_dsum_cut value will be used
to deﬁne the local region radius.

= 0 IPS will not be used (default).

= 1 3D IPS will be used for both electrostatic and L-J interactions.

= 2 3D IPS will be used only for electrostatic, including all multipole, interactions.

= 3 3D IPS will be used only for L-J interactions.

= 4 3D IPS/DFFT will be used for both electrostatic and L-J interactions.

= 5 3D IPS/DFFT will be used only for electrostatic interactions.

raips

= 6 3D IPS/DFFT will be used only for L-J interactions.
Local region radius. raips is automatically set to cut for 3D IPS calculations (ips≤3) and should
be set larger than cut for 3D IPS/DFFT calculations (ips≥4). A negative value indicates that it is
set to the longest box side of a simulation system. For ﬁnite systems, i.e., system without periodic
boundary conditions, raips=∞, which corresponding no image interaction. The default value is -1 Å.

mipso

mipsx,mipsy,mipsz Number of grids along three periodic boundary sides when using 3D IPS/DFFT method
(ips≥4). Negative values indicate they are calculated based on the grid size, gridips. Typical numbers
are the lengths of box sides (in Å) divided by 2 Å. Default values are -1. When ips=6 and PME is
used for electrostatic interaction, they are set to nfft1, nfft2, and nfft3 deﬁned for PME, respectively.
The order of the B-spline interpolation (ips≥4). The higher the order, the better the accuracy (unless
the charge grid is too coarse). The minimum order is 3. An order of 4 (the default) implies a cubic
spline approximation which is a good standard value. The cost for the DFFT calculation goes as
roughly the order to the third power. For ips=6 and PME is used to electrostatic interaction, it is set
to order deﬁned for PME.
Grid size for 3D IPS/DFFT calculation (ips≥4). The default value is 2 Å.
Volume tolerance for updating IPS function grids (ips≥4). When volume changes like in NPT sim-
ulations, the grid size changes and IPS function on grid points need be updated. The updating only
happens when the volume change ratio is more than dvbips. The default value is 1×10-8.

gridips

dvbips

365

19. sander

19.7.4. Extra point options

Several parameters deal with "extra-points" (sometimes called lone-pairs), which are force centers that are not
at atomic positions. These are currently deﬁned as atoms with "EP" in their names. These input variables are really
only for the convenience of force-ﬁeld developers; do not change the defaults unless you know what you are doing,
and have read the code. These variables are set in the &ewald namelist.

frameon

chngmask

If frameon is set to 1, (default) the bonds, angles and dihedral interactions involving the lone pairs/ex-
tra points are removed except for constraints added during parm. The lone pairs are kept in ideal
geometry relative to local atoms, and resulting torques are transferred to these atoms. To treat extra
points as regular atoms, set frameon=0.

If chngmask=1 (default), new 1-1, 1-2, 1-3 and 1-4 interactions are calculated. An extra point be-
longing to an atom has a 1-1 interaction with it, and participates in any 1-2, 1-3 or 1-4 interaction that
atom has. For example, suppose (excusing the geometry) C1,C2,C3,C4 form a dihedral and each has
1 extra point attached as below

C1------C2------C3------C4

|

Ep1

|

Ep2

|

Ep3

|

Ep4

The 1-4 interactions include C1-C4, Ep1-C4, C1-Ep4, and Ep1-Ep4. (To see a printout of all 1-1,
1-2, 1-3 and 1-4 interactions set verbose=1.) These interactions are masked out of nonbonds. Thus
the amber mask list is rebuilt from these 1-1, 1-2, 1-3 and 1-4 pairs. A separate list of 1-4 nonbonds
is then compiled. This list does not agree in general with the above 1-4, since a 1-4 could also be
a 1-3 if its in a ring. See the ephi() routine for the precise algorithm involved here. The list of 1-4
nonbonds is printed if verbose=1.

19.7.5. Polarizable potentials

The following parameters are relevant for polarizable potentials, that is, when ipol is set to 1 in the &cntrl

namelist. These variables are set in the &ewald namelist.

indmeth

If indmeth is 0, 1, or 2 then the nonbond force is called iteratively until successive estimates of the
induced dipoles agree to within DIPTOL (default 0.0001 debye) in the root mean square sense. The
difference between indmeth = 0, 1, or 2 have to do with the level of extrapolation (1st, 2nd or 3rd-
order) used from previous time steps for the initial guess for dipoles to begin the iterative loop. So
far 2nd order (indmeth=1) seems to work best.
If indmeth = 3, use a Car-Parinello scheme wherein dipoles are assigned a ﬁctitious mass and inte-
grated each time step. This is much more efﬁcient and is the current default. Note that this method
is unstable for dt > 1 fs.

diptol

Convergence criterion for dipoles in the iterative methods. Default is 0.0001 Debye.

For iterative methods (indmeth<3), this is the maximum number of iterations allowed per time step.
Default is 20.

The ﬁctitious mass assigned to dipoles. Default value is 0.33, which works well for 1fs time steps.
If dipmass is set much below this, the dynamics are rapidly unstable. If set much above this the
dynamics of the system are affected.

This is used for temperature control of the dipoles (for indmeth=3). If diptau is greater than 10
(ps units) temperature control of dipoles is turned off. Experiments so far indicate that running
the system in NVE with no temperature control on induced dipoles leads to a slow heating, barely
noticeable on the 100ps time scale. For runs of length 10ps, the energy conservation with this method
rivals that of SPME for standard ﬁxed charge systems. For long runs, we recommend setting a weak
temperature control (e.g. 9.99 ps) on dipoles as well as on the atoms. Note that to achieve good

maxiter

dipmass

diptau

366

19.8. Varying conditions

energy conservation with iterative method, the diptol must be below 10 -7 debye, which is much
more expensive. Default is 11 ps (i.e. default is turned off).

irstdip

scaldip

If indmeth=3, a restart ﬁle for dipole positions and velocities is written along with the restart for
atomic coordinates and velocities. If irstdip=1, the dipolar positions and velocities from the inpdip
ﬁle are read in. If irstdip=0, an iterative method is used for step 1, after which Car-Parrinello is used.

To scale 1-4 charge-dipole and dipole-dipole interactions the same as 1-4 charge-charge (i.e. divided
by scee) set scaldip=1 (default). If scaldip=0 the 1-4 charge-dipole and dipole-dipole interactions are
treated the same as other dipolar interactions (i.e. divided by 1).

19.7.6. Dipole Printing

By including a &dipoles namelist containing a series of groups, at the end of the input ﬁle, the printing of

permanent, induced and total dipoles is enabled.

The X, Y and Z components of the dipole (in debye) for each group will be written to mdout every NTPR steps.
In order to avoid ambiguity with charged groups all of the dipoles for a given group are calculated with respect to
the centre of mass of that group.

It should be noted that the permanent, inducible and total dipoles will be printed regardless of whether a polariz-
able potential is in use. However, only the permanent dipole will have any physical meaning when non-polarizable
potentials are in use.

It should also be noted that the groups used in the dipole printing routines are not exclusive to these routines and
so the dipole printing procedure can only be used when group input is not in use for something else (i.e. restraints).

19.7.7. Detailed MPI Timings
profile_mpi Adjusts whether detailed per thread timings should be written to a ﬁle called proﬁle_mpi when
running sander in parallel. By default only average timings are printed to the output ﬁle. This is
done for performance reasons, especially when running multisander runs. However for development
it is useful to know the individual timings for each mpi thread. When running in serial the value of
proﬁle_mpi is ignored.
= 0 No detailed MPI timings will be written (default).
= 1 A detailed breakdown of the timings for each MPI thread will be written to the ﬁle: proﬁle_mpi.

19.8. Varying conditions

This section of information is read (if NMROPT > 0) as a series of namelist speciﬁcations, with name "&wt".

This namelist is read repeatedly until a namelist &wt statement is found with TYPE=END.

TYPE

Deﬁnes quantity being varied; valid options are listed below.

ISTEP1,ISTEP2 This change is applied over steps/iterations ISTEP1 through ISTEP2. If ISTEP2 = 0, this change
will remain in effect from step ISTEP1 to the end of the run at a value of VALUE1 (VALUE2 is
ignored in this case). (default= both 0)

VALUE1,VALUE2 Values of the change corresponding to ISTEP1 and ISTEP2, respectively.

If ISTEP2=0, the

change is ﬁxed at VALUE1 for the remainder of the run, once step ISTEP1 is reached.

IINC

IMULT

If IINC > 0, then the change is applied as a step function, with IINC steps/iterations between each
change in the target VALUE (ignored if ISTEP2=0). If IINC =0, the change is done continuously.
(default=0)

If IMULT=0, then the change will be linearly interpolated from VALUE1 to VALUE2 as the step
number increases from ISTEP1 to ISTEP2. (default) If IMULT=1, then the change will be effected
by a series of multiplicative scalings, using a single factor, R, for all scalings. i.e.

367

19. sander

VALUE2 = (R**INCREMENTS) * VALUE1.

INCREMENTS is the number of times the target value changes, which is determined by ISTEP1,
ISTEP2, and IINC.

The remainder of this section describes the options for the TYPE parameter. For a few types of cards, the meanings
of the other variables differ from that described above; such differences are noted below. Valid Options for TYPE
(you must use uppercase) are:

BOND

ANGLE

TORSION

Varies the relative weighting of bond energy terms.

Varies the relative weighting of valence angle energy terms.

Varies the relative weighting of torsion (and J-coupling) energy terms. Note that any restraints de-
ﬁned in the input to the PARM program are included in the above. Improper torsions are handled
separately (IMPROP).

IMPROP

Varies the relative weighting of the "improper" torsional terms. These are not included in TORSION.

VDW

HB

ELEC

NB

Varies the relative weighting of van der Waals energy terms. This is equivalent to changing the well
depth (epsilon) by the given factor.

Varies the relative weighting of hydrogen-bonding energy terms.

Varies the relative weighting of electrostatic energy terms.

Varies the relative weights of the non-bonded (VDW, HB, and ELEC) terms.

ATTRACT

Varies the relative weights of the attractive parts of the van der waals and h-bond terms.

REPULSE

Varies the relative weights of the repulsive parts of the van der waals and h-bond terms.

RSTAR

Varies the effective van der Waals radii for the van der Waals (VDW) interactions by the given factor.
Note that this is done by changing the relative attractive and repulsive coefﬁcients, so ATTRACT/RE-
PULSE should not be used over the same step range as RSTAR.

INTERN

Varies the relative weights of the BOND, ANGLE and TORSION terms. "Improper" torsions (IM-
PROP) must be varied separately.

Varies the relative weights of all the energy terms above (BOND, ANGLE, TORSION, VDW, HB,
and ELEC; does not affect RSTAR or IMPROP).

Varies the relative weights of *all* the NMR restraint energy terms.

Varies the weights of the "short-range" NMR restraints. Short- range restraints are deﬁned by the
SHORT instruction (see below).

Varies the weights of any NMR restraints which are not deﬁned as "short range" by the SHORT
instruction (see below). When no SHORT instruction is given, RESTL is equivalent to REST.

Varies the overall weight for NOESY volume restraints. Note that this value multiplies the individual
weights read into the "awt" array. (Only if NMROPT=2; see Section 4 below).

Varies the overall weight for chemical shift restraints. Note that this value multiplies the individual
weights read into the "wt" array. (Only if NMROPT=2; see section 4 below).

Deﬁnes the short-range restraints. For this instruction, ISTEP1, ISTEP2, VALUE1, and VALUE2
have different meanings. A short-range restraint can be deﬁned in two ways.
(1) If the residues containing each pair of bonded atoms comprising the restraint are close enough in
the primary sequence:

ALL

REST

RESTS

RESTL

NOESY

SHIFTS

SHORT

368

ISTEP1 ≤ ABS(delta_residue) ≤ ISTEP2,

19.8. Varying conditions

where delta_residue is the difference in the numbers of the residues containing the pair of bonded
atoms.
(2) If the distances between each pair of bonded atoms in the restraint fall within a prescribed range:

VALUE1 ≤ distance ≤ VALUE2.

Only one SHORT command can be issued, and the values of ISTEP1, ISTEP2, VALUE1, and
VALUE2 remain ﬁxed throughout the run. However, if IINC>0, then the short-range interaction
list will be re-evaluated every IINC steps.

TGTRMSD

Varies the RMSD target value for targeted MD.

TEMP0

Varies the target temperature TEMP0.

TEMP0LES

Varies the LES target temperature TEMP0LES.

TAUTP

CUT

NSTEP0

Varies the coupling parameter, TAUTP, used in temperature scaling when temperature coupling op-
tions NTT=1 is used.

Varies the non-bonded cutoff distance.

If present,
this instruction will reset the initial value of the step counter (against which IS-
TEP1/ISTEP2 and NSTEP1/NSTEP2 are compared) to the value ISTEP1. This only affects the
way in which NMR weight restraints are calculated. It does not affect the value of NSTEP that is
printed as part of the dynamics output. An NSTEP0 instruction only has an effect at the beginning of
a run. For this card (only) ISTEP2, VALUE1, VALUE2 and IINC are ignored. If this card is omitted,
NSTEP0 = 0. This card can be useful for simulation restarts, where NSTEP0 is set to the ﬁnal step
on the previous run.

STPMLT

If present, the NMR step counter will be changed in increments of STPMLT for each actual dynamics
step. For this card, only VALUE1 is read.
ISTEP1, ISTEP2, VALUE2, IINC, and IMULT are
ignored. Default = 1.0.

DISAVE, ANGAVE, TORAVE If present, then by default time-averaged values (rather than instantaneous values) for
the appropriate set of restraints will be used. DISAVE controls distance data, ANGAVE controls
angle data, TORAVE controls torsion data. See below for the functional form used in generating
time-averaged data.
For these cards: VALUE1 = τ (characteristic time for exponential decay) VALUE2 = POWER (power
used in averaging; the nearest integer of value2 is used) Note that the range (ISTEP1→ISTEP2)
applies only to TAU; The value of POWER is not changed by subsequent cards with the same ITYPE
ﬁeld, and time-averaging will always be turned on for the entire run if one of these cards appears.
Note also that, due to the way that the time averaged internals are calculated, changing τ at any time
after the start of the run will only affect the relative weighting of steps occurring after the change in
τ . Separate values for τ and POWER are used for bond, angle, and torsion averaging.
The default value of τ (if it is 0.0 here) is 1.0D+6, which results in no exponential decay weighting.
Any value of τ ≥ 1.D+6 will result in no exponential decay.
If DISAVE,ANGAVE, or TORAVE is chosen, one can still force use of an instantaneous value for
speciﬁc restraints of the particular type (bond, angle, or torsion) by setting the IFNTYP ﬁeld to "1"
when the restraint is deﬁned (IFNTYP is deﬁned in the DISANG ﬁle).
If time-averaging for a particular class of restraints is being performed, all restraints of that class that
are being averaged (that is, all restraints of that class except those for which IFNTYP=1) *must*
have the same values of NSTEP1 and NSTEP2 (NSTEP1 and NSTEP2 are deﬁned below). (For
these cards, IINC and IMULT are ignored) See the discussion of time-averaged restraints following
the input descriptions.

369

19. sander

DISAVI, ANGAVI, TORAVI ISTEP1: Ignored.

ISTEP2: Sets IDMPAV. If IDMPAV > 0, and a dump ﬁle has been speciﬁed (DUMPAVE is set
in the ﬁle redirection section below), then the time-averaged values of the restraints will be
written every IDMPAV steps. Only one value of IDMPAV can be set (corresponding to the
ﬁrst DISAVI/ANGAVI/TORAVI card with ISTEP2 > 0), and all restraints (even those with
IFNTYP=1) will be "dumped" to this ﬁle every IDMPAV steps. The values reported reﬂect the
current value of τ.

VALUE1: The integral which gives the time-averaged values is undeﬁned for the ﬁrst step. By
default, for each time-averaged internal, the integral is assigned the current value of the internal
on the ﬁrst step. If VALUE1(cid:54)=0, this initial value of internal r is reset as follows:
-1000. < VALUE1 < 1000.: Initial value = r_initial + VALUE
VALUE1 <= -1000.: Initial value = r_target + 1000.
1000. <= VALUE1 : Initial value = r_target - 1000.

r_target is the target value of the internal, given by R2+R3 (or just R3, if R2 is 0). VALUE1 is
in angstroms for bonds, in degrees for angles.

VALUE2: This ﬁeld can be used to set the value of τ used in calculating the time-averaged values
of the internal restraints reported at the end of a simulation (if LISTOUT is speciﬁed in the
redirection section below). By default, no exponential decay weighting is used in calculating
the ﬁnal reported values, regardless of what value of τ was used during the simulation.
If
VALUE2>0, then τ = VALUE2 will be used in calculating these ﬁnal reported averages. Note
that the value of VALUE2 = τ speciﬁed here only affects the reported averaged values in at
the end of a simulation. It does not affect the time-averaged values used during the simulation
(those are changed by the VALUE1 ﬁeld of DISAVE, ANGAVE and TORAVE instructions).

IINC: If IINC = 0, then forces for the class of time-averaged restraints will be calculated exactly
as (dE/dr_ave) (dr_ave/dx). If IINC = 1, then then forces for the class of time-averaged re-
straints will be calculated as (dE/dr_ave) (dr(t)/dx). Note that this latter method results in a
non-conservative force, and does not integrate to a standard form. But this latter formulation
helps avoid the large forces due to the (1+i) term in the exact derivative calculation–and may
avert instabilities in the molecular dynamics trajectory for some systems. See the discussion of
time-averaged restraints following the input description. Note that the DISAVI, ANGAVI, and
TORAVI instructions will have no affect unless the corresponding time average request card
(DISAVE, ANGAVE or TORAVE, respectively) is also present.

DUMPFREQ

Istep1 is the only parameter read, and it sets the frequency at which the coordinates in the distance or
angle restraints are dumped to the ﬁle speciﬁed by the DUMPAVE command in the I/O redirection
section. (For these cards, ISTEP1 and IMULT are ignored).

END of this section.

END

NOTES:

1. All weights are relative to a default of 1.0 in the standard force ﬁeld.

2. Weights are not cumulative.

3. For any range where the weight of a term is not modiﬁed by the above, the weight reverts to 1.0. For any
range where TEMP0, SOFTR or CUTOFF is not speciﬁed, the value of the relevant constant is set to that
speciﬁed in the input ﬁle.

4. If a weight is set to 0.0, it is set internally to 1.0D-7. This can be overridden by setting the weight to a
negative number. In this case, a weight of exactly 0.0 will be used. However, if any weight is set to exactly
0.0, it cannot be changed again during this run of the program.

370

19.9. File redirection commands

5. If two (or more) cards change a particular weight over the same range, the weight given on the last applicable

card will be the one used.

6. Once any weight change for which NSTEP2=0 becomes active (i.e. one which will be effective for the

remainder of the run), the weight of this term cannot be further modiﬁed by other instructions.

7. Changes to RSTAR result in exponential weighting changes to the attractive and repulsive terms (propor-
tional to the scale factor**6 and **12, respectively). For this reason, scaling RSTAR to a very small value
(e.g. ≤0.1) may result in a zeroing-out of the vdw term.

19.9. File redirection commands

Input/output redirection information can be read as described here. Redirection cards must follow the end of the
weight change information. Redirection card input is terminated by the ﬁrst non-blank line which does not start
with a recognized redirection TYPE (e.g. LISTIN, LISTOUT, etc.).

The format of the redirection cards is

TYPE = ﬁlename

where TYPE is any valid redirection keyword (see below), and ﬁlename is any character string. The equals sign

("=") is required, and TYPE must be given in uppercase letters.

Valid redirection keywords are:

LISTIN

LISTOUT

DISANG

NOESY

SHIFTS

An output listing of the restraints which have been read, and their deviations from the target distances
before the simulation has been run. By default, this listing is not printed. cedureIf POUT is used for
the ﬁlename, these deviations will be printed in the normal output ﬁle.

An output listing of the restraints which have been read, and their deviations from the target distances
_after the simulation has ﬁnished. By default, this listing is not printed. If POUT is used for the
ﬁlename, these deviations will be printed in the normal output ﬁle.

The ﬁle from which the distance and angle restraint information described below (Section 27.1) will
be read.

File from which NOESY volume information (Section 27.2) will be read.

File from which chemical shift information (Section 27.3) will be read.

PCSHIFT

File from which paramagnetic shift information (Section 27.3) will be read.

DIPOLE

File from which residual dipolar couplings (Section 27.5) will be read.

CSA

File from which CSA or pseduo-CSA restraints (Section 27.6) will be read.

DUMPAVE

File to which the time-averaged values of all restraints will be written.
If DISAVI / ANGAVI /
TORAVI has been used to set IDMPAV(cid:54)=0, then averaged values will be output. If the DUMPFREQ
command has been used, the instantaneous values will be output.

19.10. Getting debugging information

The debug options in sander are there principally to help developers test new options or to test results between
two machines or versions of code, but can also be useful to users who want to test the effect of parameters on the
accuracy of their ewald or pme calculations. If the debug options are set, sander will exit after performing the
debug tasks set by the user.

To access the debug options, include a &debugf namelist. Input parameters are:

371

19. sander

do_debugf Flag to perform this module. Possible values are zero or one. Default is zero. Set to one to turn on

debug options.

One set of options is to test that the atomic forces agree with numerical differentiation of energy.

atomn

nranatm

ranseed

neglgdel

Array of atom numbers to test atomic forces on. Up to 25 atom numbers can be speciﬁed, separated
by commas.

number of random atoms to test atomic forces on. Atom numbers are generated via a random number
generator.

seed of random number generator used in generating atom numbers default is 71277
negative log of delta used in numerical differentiating; e.g. 4 means delta is 10−4 Angstroms. Default
is 5. Note: In general it does no good to set nelgdel larger than about 6. This is because the relative
force error is at best the square root of the numerical error in the energy, which ranges from 10−15
up to 10−12 for energies involving a large number of terms.

chkvir

Flag to test the atomic and molecular virials numerically. Default is zero. Set to one to test virials.

dumpfrc

rmsfrc

Flag to dump energies, forces and virials, as well as components of forces (bond, angle forces etc.)
to the ﬁle "forcedump.dat" This produces an ascii ﬁle. Default is zero. Set to one to dump forces.

Flag to compare energies forces and virials as well as components of forces (bond, angle forces etc.)
to those in the ﬁle "forcedump.dat". Default is zero. Set to one to compare forces.

Several other options are also possible to modify the calculated forces.

zerochg

Flag to zero all charges before calculating forces. Default zero. Set to one to remove charges.

zerovdw

zerodip

Flag to remove all van der Waals interactions before calculating forces. Default zero. Set to one to
remove van der Waals.

Flag to remove all atomic dipoles before calculating forces. Only relevant when polarizability is
invoked.

do_dir, do_rec, do_adj, do_self, do_bond, do_cbond, do_angle, do_ephi, do_xconst, do_cap

These are ﬂags which turn on or off the subroutines they refer to. The defaults are one. Set to zero to
prevent a subroutine from running. For example, set do_dir=0 to turn off the direct sum interactions
(van der Waals as well as electrostatic). These options, as well as the zerochg, zerovdw, zerodip
ﬂags, can be used to ﬁne tune a test of forces, accuracy, etc.

EXAMPLES:

This input list tests the reciprocal sum forces on atom 14 numerically, using a delta of 10−4.

&debugf
neglgdel=4, nranatm = 0, atomn = 14,
do_debugf = 1,do_dir = 0,do_adj = 0,do_rec = 1, do_self = 0,
do_bond = 1,do_angle = 0,do_ephi = 0, zerovdw = 0, zerochg = 0,
chkvir = 0,
dumpfrc = 0,
rmsfrc = 0,
/

This input list causes a dump of force components to "forcedump.dat". The bond, angle and dihedral forces are
not calculated, and van der Waals interactions are removed, so the total force is the Ewald electrostatic force, and
the only nonzero force components calculated are electrostatic.

372

19.10. Getting debugging information

&debugf
neglgdel=4, nranatm = 0, atomn = 0,
do_debugf = 1,do_dir = 1,do_adj = 1,do_rec = 1, do_self = 1,
do_bond = 0,do_angle = 0,do_ephi = 0, zerovdw = 1, zerochg = 0,
chkvir = 0,
dumpfrc = 1,
rmsfrc = 0,
/

In this case the same force components as above are calculated, and compared to those in "forcedump.dat".
Typically this is used to get an RMS force error for the Ewald method in use. To do this, when doing the force
dump use ewald or pme parameters to get high accuracy, and then normal parameters for the force compare:

&debugf
neglgdel=4, nranatm = 0, atomn = 0,
do_debugf = 1,do_dir = 1,do_adj = 1,do_rec = 1, do_self = 1,
do_bond = 0,do_angle = 0,do_ephi = 0, zerovdw = 1, zerochg = 0,
chkvir = 0,
dumpfrc = 0,
rmsfrc = 1,
/

For example, if you have a 40x40x40 unit cell and want to see the error for default pme options (cubic spline,
40x40x40 grid), run 2 jobs—— (assume box params on last line of inpcrd ﬁle)

Sample input for 1st job:

&cntrl
dielc =1.0,
cut = 11.0, nsnb = 5, ibelly = 0,
ntx = 5, irest = 1,
ntf = 2, ntc = 2, tol = 0.0000005,
ntb = 1, ntp = 0, temp0 = 300.0, tautp = 1.0,
nstlim = 1, dt = 0.002, maxcyc = 5, imin = 0, ntmin = 2,
ntpr = 1, ntwx = 0, ntt = 0, ntr = 0,
jfastw = 0, nmrmax=0, ntave = 25,
/
&debugf
do_debugf = 1,do_dir = 1,do_adj = 1,do_rec = 1, do_self = 1,
do_bond = 0,do_angle = 0,do_ephi = 0, zerovdw = 1, zerochg = 0,
chkvir = 0,
dumpfrc = 1,
rmsfrc = 0,
/
&ewald
nfft1=60,nfft2=60,nfft3=60,order=6, ew_coeff=0.35,
/

Sample input for 2nd job:

&cntrl
dielc =1.0,
cut = 8.0, nsnb = 5, ibelly = 0,
ntx = 7, irest = 1,
ntf = 2, ntc = 2, tol = 0.0000005,
ntb = 1, ntp = 0, temp0 = 300.0, tautp = 1.0,

373

19. sander

nstlim = 1, dt = 0.002, maxcyc = 5, imin = 0, ntmin = 2,
ntpr = 1, ntwx = 0, ntt = 0, ntr = 0,
jfastw = 0, nmrmax=0, ntave = 25,
/
&debugf
do_debugf = 1,do_dir = 1,do_adj = 1,do_rec = 1, do_self = 1,
do_bond = 0,do_angle = 0,do_ephi = 0, zerovdw = 1, zerochg = 0,
chkvir = 0,
dumpfrc = 0,
rmsfrc = 1,
/
&ewald
ew_coeff=0.35,
/

Note that an Ewald coefﬁcient of 0.35 is close to the default error for an 8 Angstrom cutoff. However, the ﬁrst
job used an 11 Angstrom cutoff. The direct sum forces calculated in the 2nd job are compared to these, giving the
RMS error due to an 8 Angstrom cutoff, with this value of ew_coeff. The reciprocal sum error calculated in the
2nd job is with respect to the pme reciprocal forces in the 1st job considered as "exact".
Note further that if in these two jobs you had not speciﬁed "ew_coeff" sander would have calculated ew_coeff
according to the cutoff and the direct sum tolerance, defaulted to 10−5. This would give two different ewald
coefﬁcients. Under these circumstances the direct, reciprocal and adjust energies and forces would not agree well
between the two jobs. However the total energy and forces should agree reasonrespanably, (forces to within about
5x10−4 relative RMS force error) Since the totals are invariant to the coefﬁcient.

Finally, note that if other force components are calculated, such as van der Waals, bond, angle, etc., then the total
force will include these, and the relative RMS force errors will be with respect to this total force in the denominator.

19.11. multisander (and multipmemd)

The multisander and multipmemd functionality are available in the parallel versions of the programs (i.e.,

sander.MPI and pmemd.MPI). This mode allows multiple independent simulations, or replicas, to be run in the
same program instance. It is particularly useful for computer clusters in which priority is given to large
CPU-count jobs. In this case, the command-line usage of sander and pmemd is slightly altered, as shown below:

mpirun -np <#proc> sander.MPI -ng <#groups> -groupfile groupfile

In this case, #proc processors will be evenly divided among #groups individual simulations (#proc must be a
multiple of #group!). The groupﬁle consists of a number of lines which is the command-line for each of the
#groups simulations you wish to run. Comment lines (i.e., those with # in the ﬁrst column) are ignored, after
which the ﬁrst #groups lines are read as the command-line ﬂags of the Nth simulation.

The multisander and multipmemd mechanisms are also utilized for methods requiring multiple simulations to
communicate with one another, such as thermodynamic integration in sander and replica exchange molecular
dynamics (both described later). An example groupﬁle and program call are shown below.

Groupﬁle:

# Comment lines must start with a pound sign
# and there can be as many comment lines as you
# want, wherever you want them.
-O -p prmtop1 -c inpcrd1 -i replica1.mdin -suffix replica1
-O -p prmtop2 -c inpcrd2 -i replica2.mdin -suffix replica2
-O -p prmtop3 -c inpcrd3 -i replica3.mdin -suffix replica3
-O -p prmtop4 -c inpcrd4 -i replica4.mdin -suffix replica4

The -suffix ﬂag behaves slightly differently than it does for classical use. In standard simulations (i.e., without
multisander or multipmemd), the provided sufﬁx will be applied only to output ﬁles that are printed but were not

374

19.12. APBS as an alternate PB solver in Sander

given names on the command-line. With multisander, however, each thread has to produce different output ﬁles so
that different replicas do not try to write to the same ﬁle. As a result, a default sufﬁx of 000, 001, 002, etc. is given
to the replicas and is added to every unspeciﬁed output ﬁle. If a -suffix is speciﬁed in the groupﬁle, as shown
above, every output ﬁle—including those given an explicit name for that replica—are given the additional sufﬁx.

The four simulations shown in the groupﬁle above can be run on 8 processors each with the following

command (note, running sander.MPI may differ on your system).

mpirun -np 32 sander.MPI -ng 4 -groupfile groupfile

The multisander and multipmemd concepts are implemented via the use of MPI communicators. Each replica is
assigned a replica-wide communicator along which all communications required for standard MD simulations are
performed (called commsander and pmemd_comm in sander and pmemd, respectively). Each replica communicator
has a master thread (rank 0 in that communicator), and the master thread of each replica are joined in another MPI
communicator of replica masters (called commmaster and pmemd_master_comm in sander and pmemd, respec-
tively). All inter-replica communication is performed via commmaster or pmemd_master_comm.

By default, all N threads are allocated to each of the M groups by dividing the threads sequentially. That is, the
ﬁrst N/M threads are assigned to replica 0, the second group of N/M threads are assigned to replica 1, etc. The
-ng-nonsequential ﬂag will stripe the thread assignments. Replica 0 will receive threads 0, N − 1, 2N − 1, etc.,
while replica 1 receives threads 1, N, 2N, etc.

19.12. APBS as an alternate PB solver in Sander

APBS is a robust, numerical Poisson-Boltzmann solver with many features (for more details see
http://apbs.sourceforge.net/). APBS can be used as an alternative PB solver in sander when compiled with sander
using iAPBS.[446] sander.APBS can be then used for implicit solvent MD simulations, calculation of solvation
energies and electrostatic properties and to generate electrostatic potential maps for visualization. It can also be
used in the MM_PBSA approach to estimate solvation and apolar (GAMMA * SASA) energy contributions to free
energies of binding.

Please see APBS documentation (http://apbs.sourceforge.net/doc/user-guide/index.html) for deﬁnition of APBS
input parameters and iAPBS documentation (http://mccammon.ucsd.edu/iapbs/) on how to build sander.APBS and
how to use it.

To use mm_pbsa.pl script with sander.APBS the following is necessary:

• - sander.APBS must be installed in $AMBERHOME/bin directory.

• - @GENERAL and @PB sections in input ﬁle need to be modiﬁed.

• - PQR ﬁles for ligand, receptor and complex need to be prepared if an

• alternate charge/radius scheme is used (which is recommended).

Input ﬁle description

The mm_pbsa.in input ﬁle which is included in the Amber distribution can be used with the following modiﬁ-

cations:

(1) Turn on PB and turn off GB and MS calculations in the @GENERAL section of the input ﬁle:

@GENERAL
MM 1
GB 0
PB 1
MS 0

(2) Input ﬁle @PB section:

375

19. sander

#
@PB
#
#
# PROC = 3 uses sander.APBS as the PB solver
# REFE - REFE = 0 is always used with sander.APBS
# INDI and EXDI are solute and solvent dielectric constants
# SCALE - grid spacing in number of grid points per A
# LINIT - no effect
# PRBRAD - solvent probe radius in A
# ISTRNG - ionic strength in mM
#
# RADIOPT - option to set up radii and charges for PB calculation:
# 0: uses the radii from prmtop files
# 2: reads in PQR files with radii/charges information from
# lig.pqr, rec.pqr and com.pqr PQR files
#
# APBS options:
# BCFL, SRFM, CHGM, SWIN, GAMMA - see APBS and iAPBS documentation for details
# GAMMA is surface tension for apolar energies (in kJ/mol/A**2),
# defaults to 0.105 (Please note the units!)
#
PROC 3
REFE 0
INDI 1.0
EXDI 80.0
SCALE 2
LINIT 1000
PRBRAD 1.4
ISTRNG 0.0
#
RADIOPT 0
#
BCFL 2
SRFM 1
CHGM 1
SWIN 0.3
GAMMA 0.105
#

PQR ﬁles

With RADIOPT=2 three PQR ﬁles are required: lig.pqr, rec.pqr and com.pqr with charge/radius information for
the ligand, receptor and complex, respectively. This is the recommended option to get better estimates of solvation
energies.

The PQR ﬁles can be created with pdb2pqr utility:

pdb2pqr.py --assign-only --ff=amber com.pdb com.pqr
pdb2pqr.py --assign-only --ff=amber rec.pdb rec.pqr
pdb2pqr.py --assign-only --ff=amber lig.pdb lig.pqr

where –ff=amber is the requested force ﬁeld charge/radius parameters. Several options are available (Amber,
CHARMM, PARSE, etc.) and also a user deﬁned charge/radius scheme is supported (with –ff=myff option).

376

pdb2pqr.py can be obtained from http://pdb2pqr.sourceforge.net/. PDB2PQR service is also available on the
web at http://nbcr.net/pdb2pqr/. The PDB ﬁles (com.pdb, rec.pdb and lig.pdb) can be generated using ambpdb
utility.

19.13. Programmer’s Corner: The sander API

19.13. Programmer’s Corner: The sander API

By Jason M. Swails

This section describes a new feature of sander—an application programmer interface (API) that encapsulates
some of sander’s basic functionality into a library that can be included in your own programs. sander was originally
written in Fortran as a standalone program that made extensive use of common blocks (i.e., global variables) and
uses MPI for the parallel implementation rather than a type of shared-memory parallelization scheme like OpenMP
or pthreads. This design conferred a number of constraints on the resulting API.

1. Only one system can be set up for use with the API at a time. Switching Hamiltonians or input parameters

requires a lot of deallocation and reallocation and will be inefﬁcient if done very frequently.

2. Only serial execution is supported.

3. LES and non-LES functionality cannot be combined in the same library.

4. File names have a ﬁxed maximum length (256 characters). This can be extended only by adjusting the sander

source code and recompiling.

Despite these limitations, the sander API provides functionality unavailable in other libraries, including QM/MM
forces and energies, PB and GB energies, and LES functionality (through a separate library). Although originally
written in Fortran, an API has been provided for four languages: Fortran, C, C++, and Python.

The next sections describe the general API design and then the Fortran, C, C++, and Python APIs speciﬁcally.
Note: the python version of this API is sometimes referred to as pysander. However, there is no program called
pysander; that term is rather a shorthand for using “import sander” within a python driver script.

19.13.1. General API Design

This section describes the functions that are available in each variant of the sander API. The exact syntax for
how the various functions and subroutines are called—and what, if anything, they return—is listed in the following
sections for each API.

19.13.1.1. Data Structures

The following data structures are provided as part of the API. These data structures provide a way to provide
input or query output from the API. They are the equivalent of C structs (Fortran type and Python class). All
ﬂoating point data types are double precision (double in C and C++, double precision in Fortran, and float in
Python). All integer data types are standard integers (int in C and C++, integer in Fortran, and int in Python).

sander_input

This contains variables used to provide input for the sander API. The attributes that are exposed here have
the same name, options, and function as the input options with the same name described earlier in this chapter
(and some in earlier chapters). These attributes are listed below, with their data type (ﬂoat or integer) listed in
parentheses at the end.

extdiel External dielectric constant for GB calculations. (ﬂoat)

intdiel Internal dielectric constant for GB calculations. (ﬂoat)

rgbmax Distance cutoff in Angstroms to use when computing effective GB radii. (ﬂoat)

377

19. sander

saltcon Salt concentration, in Molarity, to use when modeling ionic strength effects in a GB calculation. (ﬂoat)

cut Nonbonded cutoff in Angstroms. (ﬂoat)

dielc Dielectric constant to use for all electrostatic interactions. You should use extdiel or intdiel, described above,
for GB calculations (this option should only be used if you are sure it is what you want—it is usually not
what you want). (ﬂoat)

rdt This is an option speciﬁc to GB calculations with LES (and only has an effect when using the sanderles library).
When using GB with LES, non-LES atoms require multiple effective radii due to alternate descreening
effects from the different copies. When the multiple radii differ by less than rdt, only a single radius will be
used for this atom. Default is 0.0. See Chapter 29 for more information. (ﬂoat)

igb GB model to use for GB calculations. Allowable values are 0 (no GB), 1, 2, 5, 6 (vacuum), 7, 8, and 10 (PB).

More information is available on page 69. (integer)

alpb If 1, use the analytical linearized Poisson-Boltzmann approximation. See Section 4.2 for more information.

(integer)

gbsa If set to 0, no SASA-based nonpolar free energy of solvation correction is used. If set to 1, the SASA is
approximated using the linear combination of pairwise overlaps method (LCPO). If set to 2, the SASA is
approximated using a recursive algorithm constructing spheres around each atom. Note, gradients (forces)
are not available from this model, so the forces returned by the API will be incorrect if this option is used.
(integer)

lj1264 If 1, use the 12-6-4 Lennard Jones potential form designed for divalent metal ions. If 0, do not use the
12-6-4 Lennard-Jones model. The topology ﬁle must be set up correctly to use the 12-6-4 model ﬁrst!
(integer)

ipb Option to compute the solvation free energy using the Poisson-Boltzmann equation. Allowable values are 0

(no PB equation), 1, 2, and 4. See Chapter 6 for more information. (integer)

vdwmeth For periodic simulations only (i.e., when ntb, below, is set to 1). When set to 1, a long-range dispersion
correction based on an analytical integral assuming an isotropic, uniform bulk particle distribution beyond
the cutoff is added to the van der Waals energy. When set to 0, no correction is used. (integer)

ew_type For periodic simulations only (i.e., when ntb, below, is set to 1). When set to 0, the particle-mesh Ewald
method is used to compute long-range electrostatics. When set to 1, a traditional Ewald method is used
to compute long-range electrostatics (PME is much faster for systems with more than 500 atoms or so).
(integer)

ntb If set to 0, periodic boundaries are not applied. If set to 1, periodic boundaries are used. The value of 2 does

not (yet) apply to the API (i.e., constant pressure), as this is an MD-speciﬁc option. (integer)

ifqnt If set to 1, a QM/MM potential is used (and you must provide a set of valid QM options as well). If set to 0,

no QM/MM potential is used. (integer)

jfastw Fast water deﬁnition ﬂag. By default, the system is searched for water residues, and special routines are
used to SHAKE these systems (i.e., they are constrained using the analytical SETTLE algorithm). If set to
0, this default behavior is triggered. If set to 4, the numerical SHAKE routines are used. (integer)

ntf Flag to determine which, if any, interactions to omit from the energy calculation. (integer)

ntc Flag to determine whether to use the SHAKE algorithm to constrain bond distances. (integer)

There are two subroutines that will initialize a sander_input instance with default values—one that prepares the
input for a periodic simulation and one that prepares the input for an aperiodic system (either gas phase or GB
calculation). The default values assigned are summarized in table 19.1.

378

19.13. Programmer’s Corner: The sander API

Table 19.1.: Summary of default values assigned to sander_input variables by the two initialization subroutines
provided in the sander API. When alternate values are given for gas_sander_input, the latter corre-
sponds to the value assigned if a GB model is requested.

sander_input variable

gas_sander_input default

pme_sander_input default

extdiel
intdiel
rgbmax
saltcon

cut
dielc
rdt
igb
alpb
gbsa
lj1264

ipb
inp

vdwmeth
ew_type

ntb
ifqnt
jfastw

ntc
ntf

qmmm_input_options

1 or 78.5

1

25.0

0

1000.0

1
0

6 or input value

0
0
0
0
0
0
0
0
0
0
1
1

0
0

25.0

0
8.0
1
0
0
0
0
0
0
0
1
0
1
0
0
1
1

This struct contains a set of options for controlling what portion of the system is treated using quantum mechan-
ics (QM), which QM Hamiltonian is used to treat the QM portion of the system, how the boundary between the
QM and MM portions of the system are handled, and how the QM and MM portions interact.

The variables in this data structure have the same name and function as the variables deﬁned in the &qmmm
namelist of the input ﬁle. You can ﬁnd more information about QM/MM in Chatper 10 on page 156 and about the
options speciﬁcally in Chapter 9 and Subsection 10.1.6.

There are three types of data types in this struct. Floating point, integer, and character array (i.e., string) values.
Like with sander_input above, ﬂoating point numbers are represented in full double precision and integers as
standard integers. The strings in this section are ﬁxed-size arrays of characters. The type of each variable is
indicated in parentheses after the variable is deﬁned followed by the ﬁxed-size length of the array if it is an array
value. The standard value for the maximum number of QM atoms (MAX_QUANTUM_ATOMS) is 10,000.

Note that strings are treated by the API as Fortran strings, not C-style strings. The main difference is that Fortran
strings do not have a null terminal character (’\0’), which means that every character after the ﬁnal “letter” of the
string must contain a space (or null character). As a result, the typical string routines deﬁned in the C string.h
header ﬁle (e.g., strcpy and strncpy) may not assign the strings correctly if they are not properly initialized
entirely with spaces ﬁrst. That is why the qm_sander_input function is provided as part of the API, so I suggest
that you always initialize a qmmm_input_options data structure using this method when using the C or C++ APIs.
The defaults listed below are those assigned by the qm_sander_input function in the API (and are the same as

the defaults deﬁned in Subsection 10.1.6).

qmcut Nonbonded cutoff in Angstroms used for QM/MM nonbonded interactions (note there is no such thing as
a cutoff within the QM region, since it is the wavefunction of the entire system we are optimizing). The
default value is the MM cutoff being used (i.e., cut from sander_input, above). (ﬂoat)

lnk_dis Distance in Angstroms of the QM atom to its link atom. Default is 1.09. (ﬂoat)

379

19. sander

scfconv Controls the convergence of the SCF calculation. The SCF terminates when the energy difference be-
tween the last two steps is smaller than the value given here. Default is 10−8 and the smallest value that can
practically be used within the limits of double precision ﬂoating point arithmetic is 10−14. (ﬂoat)

errconv SCF tolerance on the maximum absolute value of the erro matrix (i.e., the commutator of the Fock matrix
with the density matrix). The value is in units of Hartrees. The default value is large enough that scfconv
will always be more strict. (ﬂoat)

dftb_telec Electronic temperature, in K, used to accelerate SCC convergence in DFTB calculations. The elec-
tronic temperature affects the Fermi distribution promoting some HOMO/LUMO mixing, which can accel-
erate the convergence in difﬁcult cases. In most cases, a low telec (around 100K) is enough. Should be used
only when necessary, and the results checked carefully. Default: 0.0 (ﬂoat)

dftb_telec_step The size of the step to take when reducing the electronic temperature in a DFTB calculation. The

smaller the step, the longer it will take to get the electronic temperature to zero. (ﬂoat)

fockp_d1 First prefactor for the Fock matrix prediction. Default is 2.4. Changing this is not recommended. (ﬂoat)

fockp_d2 Second prefactor for the Fock matrix prediction. Default is -1.2. Changing this is not recommended.

(ﬂoat)

fockp_d3 Third prefactor for the Fock matrix prediction. Default is -0.8. Changing this is not recommended.

(ﬂoat)

fockp_d4 Fourth prefactor for the Fock matrix prediction. Default is 0.6. Changing this is not recommended.

(ﬂoat)

damp SCF damping factor. Default is 1.0. Changing this is not recommended. (ﬂoat)

vshift Controls level shifting for NDDO methods (not DFTB). Virtual orbitals can be shifted up by vshift (in eV)

to improve SCF convergence in cases with a small HOMO/LUMO gap. Default is 0.0. (ﬂoat)

kappa Related to the Debye salt concentration for GB models. This is set automatically from saltcon in the

sander_input data structure. (ﬂoat)

pseudo_diag_criteria Controls whether a pseudo-diagonalization of the Fock matrix can be performed (not ap-

plicable for DFTB). Default is 0.05. (ﬂoat)

min_heavy_mass The smallest value, in atomic mass units, that an atomic mass can have and still be considered

a “heavy-atom” (i.e., anything besides Hydrogen). Default is 4.0. (ﬂoat)

r_switch_hi If qmmm_switch (below) is turned on, this is the distance, in Angstroms, at which the switch goes to

zero. By default, it is the same as qmcut. (ﬂoat)

r_switch_lo If qmmm_switch (below) is turned on, this is the distance, in Angstroms, at which the switch turns

on. By default, it is 2 Angstroms smaller than r_switch_hi. (ﬂoat)

iqmatoms List of atom indexes, starting from 1, that will be treated using QM. This is one way, along with

qmmask, of specifying the QM region. Default is an empty list. (integer array, MAX_QUANTUM_ATOMS).

qmgb Speciﬁes how the QM region should be treated with Generalized Born. (integer)

= 2 (default) As described above, the electrostatic and “polarization” ﬁelds from the MM charges and the

exterior dielectric, respectively, are included in the Fock matrix for the QM Hamiltonian.

= 3 This is intended for debugging and is only useful for single-point calculations. This computes the GB
energy by treating every atom in the QM region as a point charge equal to its Mulliken charge. This can
be compared to the result when qmgb is set to 2 to evaluate the “strain” energy from the GB solvation.

380

19.13. Programmer’s Corner: The sander API

lnk_atomic_no The atomic number of the element you wish to use as the link atom. Default is 1 (Hydrogen).

(integer)

ndiis_matrices The number of error vectors to use for the DIIS convergence algorithm. Default is 6. (integer)

ndiis_attempts The number of iterations that DIIS extrapolation will be attempted. Not available for DFTB.

Default value is 0, maximum is 1000. (integer)

lnk_method The method used to deﬁne how classical valence terms across the QM/MM boundary will be treated.

See Subsection 10.1.7 for more information. Default is 1. (integer)

qmcharge The net charge of the QM region. Default is 0. (integer)

corecharge The net charge of the core QM region. Default is 0. (integer)

buffercharge The net charge of the buffer QM region. Default is 0. (integer)

spin Spin multiplicity of the QM region. Default is 1 (singlet). (integer)

qmqmdx Controls whether QM-QM derivatives are computed analytically or pseudo-numerically. The default
(and recommended) is to use analytical QM-QM derivatives. Set to 1 for analytical derivatives, 2 for pseudo-
numerical derivatives. Default is 1. (integer)

verbosity This has no effect on the API, since output is suppressed. Keep the default value of 0. (integer)

printcharges This has no effect on the API since output is suppressed. Keep the default value of 0. (integer)

printdipole This has no effect on the API, since output is suppressed. Keep the default value of 0. (integer)

print_eigenvalues This has no effect on the API, since output is suppressed. Keep the default value of 0. (integer)

peptide_corr If set to 0, (default), do not apply a correction to peptide linkages. If set to 1, apply a MM correction

to peptide linkforages. (integer)

itrmax Maximum number of SCF iterations to perform before deciding that the convergence has failed. Default is

1000. (integer)

printbondorders This has no effect on the API, since output is suppressed. Keep the default value of 0. (integer)

qmshake Controls whether SHAKE is applied to QM atoms. If 0, no SHAKE. If 1 (default), SHAKE QM atoms
if MM SHAKE is turned on. By default, MM SHAKE is not turned on. This really has no effect, anyway,
since the API does not currently support dynamics. (integer)

qmmmrij_incore If set to 1 (default), store QM-MM pairs and related equations in memory. If set to 0, do not.

(integer)

qmqm_erep_incore If set to 1 (default), store QM-QM 1-electron repulsion integrals to memory. If set to 0,

calculate them on-the-ﬂy. (integer)

pseudo_diag If set to 1 (default), allow the use of pseudo-diagonalization of the Fock matrix as long as the

pseudo_diag_criteria is met. (integer)

qm_ewald Speciﬁes how the long-range electrostatics for the QM region should be treated. See the description in

Subsection 10.1.6 for more information. (integer)

qm_pme If 0, use a regular Ewald sum for computing QM-QM and QM-MM long-range electrostatic interactions.

If 1 (default), use PME instead. (integer)

kmaxqx Number of K-space vectors to use in the Ewald/PME calculations in the X-dimension. Default value is

8. (integer)

381

19. sander

kmaxqy Same as above, but in the Y-dimension. (integer)

kmaxqz Same as above, but in the Z-dimension. (integer)
ksqmaxsq Speciﬁes the maximum number of K2 values for the spherical cutoff in reciprocal space when doing a

QM-MM Ewald sum. The default value of 100 should be optimal for most systems. (integer)

qmmm_int Controls the way in which the QM-MM interaction is handled. See Subsection 10.1.6 for more infor-

mation. Default is 1. (integer)

adjust_q Controls how charge is conserved during a QM/MM calculation with respect to link atoms. See Subsec-

tion 10.1.6 for more information. Default is 2. (integer)

tight_p_conv Controls the tightness of the convergence criteria on the density matrix in the SCF. If 0 (default),

the convergence is loose. If set to 1, convergence is tight. See Chapter 9 for more information. (integer)

diag_routine The diagonalization routine to use to diagonalize the Fock matrix. By default (diag_routine = 0),

the fastest routine is chosen. See the description in Chapter 9 for more details. (integer)

density_predict If 1, use the density matrix from the previous MD step. Since MD is not currently supported in

the API, do not deviate from the default value of 0. (integer)

fock_predict If set to 0, do not attempt to predict the Fock matrix. (Default). If set to 1, try to. (integer)

vsolv If set to 1, use variable solvent QM/MM. If set to 0 (default), do not. This option is irrelevant to the API

since it does not support QM/MM. (integer)

dftb_maxiter The maximum number of SCF iterations to be used in SCC-DFTB calculations. Default is 70.

(integer)

dftb_disper If set to 1, use a dispersion correction for DFTB/SCC-DFTB. If set to 0 (default), do not. (integer)

dftb_chg Has no effect on the API, since printing is disabled. (integer)

abfqmmm Toggles the adaptive biased force QM/MM. Since the API does not support MD, this option has no

effect. Default is 0. (integer)

hot_spot If set to 1, activates hot spot-like adaptive calculation in which the forces of atoms in the buffer region
are linear combinations of the forces obtained from the extended and reduced calculations using a smoothing
function. If set to 0 (default), disable this behavior. (integer)

qmmm_switch If set to 1, use a switching function deﬁned by r_switch_lo and r_switch_hi.

(default), do not. (integer)

If set to 0

core_iqmatoms A list of atom indices (starting at 1) that are selected for inclusion in the core QM/MM region in

adaptive simulations. (integer array, MAX_QUANTUM_ATOMS)

buffer_iqmatoms A list of atom indices (starting at 1) that are selected for inclusion in the buffer QM/MM region

in adaptive simulations. (integer array, MAX_QUANTUM_ATOMS)

qmmask An Amber selection mask that provides another way of deﬁning the QM region instead of iqmatoms.

(character array, 8192)

coremask An Amber selection mask that provides another way of deﬁning the core QM region in adaptive simu-

lations instead of core_iqmatoms. (character array, 8192)

buffermask An Amber selection mask that provides another way of deﬁning the buffer QM region in adaptive

simulations instead of buffer_iqmatoms. (character array, 8192)

centermask An Amber selection mask that deﬁnes the center region. If not set, it defaults to coremask. (character

array, 8192)

382

19.13. Programmer’s Corner: The sander API

dftb_3rd_order Speciﬁes the 3rd-order DFTB correction. Default (’NONE’) means no 3rd order correction is

used. See Chapter 9 for more information. (character array, 256)

qm_theory String that deﬁnes which level of QM theory to use. There is no default and this must be supplied.

Available options are deﬁned in Chapter 9. (character array, 12)

pot_ene

This data structure is populated when the energy and forces are computed for the positions that are currently set.
All elements of this data structure are double-precision ﬂoating point numbers and are given in kilocalories per
mole.
tot The total potential energy

vdw The van der Waals contribution to the total energy (not including 1-4 interactions)

elec The electrostatic contribution to the total energy (not including 1-4 interactions)

gb Polar solvation free energy from GB calculations

bond The energy contribution from valence bonds.

angle The energy contribution from valence angles.

dihedral The energy contribution from valence torsions.

vdw_14 The energy contribution from 1-4 van der Waals interactions

elec_14 The energy contribution from 1-4 electrostatic interactions

constraint Really misnamed, this is the total restraint energy if NMR or positional restraints are used.

polar Polarization energy if you are using a polarizable force ﬁeld.

hbond The 10-12 contribution to the total energy (not used in modern force ﬁelds)

surf The non-polar solvation free energy contribution from GB and PB calculations.

scf The QM energy contribution (includes charge-charge interactions between MM and QM atoms, but not dis-

persion interactions—those are added to the vdw component).

disp Dispersion energy contribution (?? not really sure what this is)

dvdl Not really applicable to the API, since it is used for constant pH MD calculations. This should always be 0.

angle_ub For CHARMM force ﬁeld, this is the Urey-Bradley contribution to the total energy.

imp For CHARMM force ﬁeld, this is the improper torsion contribution to the total energy.

cmap For CHARMM force ﬁeld, this is the correction map energy contribution for coupled torsions.

emap When ﬁtting to an electron density map, this is the restraint energy derived from violations to the map.

les The total energy contributed by the LES copies.

noe The energy penalty for NOE violations.

pb The total polar solvation free energy from PB calculations.

rism The total solvation free energy from 3D-RISM calculations.

ct Charge transfer energy (for crg_reloc)

amd_boost This is the AMD boosting energy. It is not applicable for the API since molecular dynamics is not

currently supported.

383

19. sander

19.13.1.2. Basic subroutines

This section describes the functions and subroutines that are deﬁned by the API and explains what they do.
Since their exact behavior (e.g., their arguments and return values) differ depending on which API you are using,
the exact usage is deferred to later sections. However, what they do is described here.

There are very strong similarities between the C/C++ and Fortran function calls. While the Python function calls

are also similar, the Python behavior often differs the most.

gas_sander_input This function will initialize a sander_input data structure with the appropriate defaults for
carrying out either a gas-phase calculation or an implicit solvent GB calculation. It takes an integer argument
deﬁning the GB model to use. See the igb variable in the sander_input data structure above for allowable
values.
is

routine or
pme_sander_input to make sure that all variables are initialized. Uninitialized variables in any of the compiled
languages (i.e., not Python) take on undeﬁned behavior and could result in strange bugs.

recommended that you initialize your sander_input instance using either

this

It

This can be called regardless of whether or not a system is currently set up.

pme_sander_input This function will initialize a sander_input data structure with the appropriate defaults for
carrying out a PME calculation on a periodic system. It is recommended that you initialize your sander_input
instance using either this routine or gas_sander_input to make sure that all variables are initialized. Uninitialized
variables in any of the compiled languages (i.e., not Python) take on undeﬁned behavior and could result in strange
bugs.

This can be called regardless of whether or not a system is currently set up.

qm_sander_input This function will initialize a qmmm_input_options data structure with the defaults listed in
Subsection 19.13.1.1. This is the recommended method for initializing QM input options, particularly in the C and
C++ interfaces where string handling is fragile.

sander_setup These functions take a topology ﬁle, coordinates, box dimensions, and a set of input options
(sander_input and qmmm_input_options) and sets up the sander API so that energies and forces can be calcu-
lated.

These functions can only be called if no system is currently set up. You must call sander_cleanup before

setting up a different system (or changing input parameters).

set_positions This function takes an array of double precision particle positions (3× natom) and sets them as
the active conformation.

This function can only be called if there is currently a system set up.

set_box This function takes three box lengths and the angles between them and sets the unit cell (and reciprocal
unit cell) vectors from these values.

This function can only be called if there is currently a system set up.

sander_natom This function returns the number of atoms present in the system that is currently set up.

This function can only be called if there is currently a system set up.

get_positions This function returns the currently active atomic coordinates for the system that is currently set
up.

This function can only be called if there is currently a system set up.

384

19.13. Programmer’s Corner: The sander API

get_inpcrd_natom This function takes the name of an inpcrd ﬁle and reads the number of atoms that are deﬁned
in this ﬁle. If this ﬁle is not present or its format cannot be determined, the number of atoms is set to -1, which
indicates an error.

This function can be called regardless of whether or not a system is currently set up.

read_inpcrd_ﬁle This function takes the name of an inpcrd ﬁle, an array of length 3 × natom double preci-
sion ﬂoating point numbers, and an array of 6 double precision ﬂoating numbers and ﬁlls them with the atomic
coordinates and box dimensions, respectively. The box dimensions are stored as a, b, c, α, β , and γ.

Since the two arrays must already be allocated, the typical workﬂow is to call get_inpcrd_natom to determine
how large the coordinate array must be made. Then call read_incprd_file after allocating the coordinate array.

This function can be called regardless of whether or not a system is currently set up.

is_setup This function returns whether a system is currently set up or not.

This function can be called regardless of whether or not a system is currently set up.

energy_forces This function computes the energy and forces for the current coordinates of the system that is
currently set up and returns them in the potential energy data structure and (3× natom)-length double precision
array that is passed to this routine.

This function can only be called if a system is currently set up.

sander_cleanup This function clears all of the internal memory initialized and allocated by the sander_setup
routines. This function can only be called if a system is set up, but after this function completes, a system is no
longer set up.

19.13.2. The Fortran API

The Fortran API is implemented with a Fortran module. The module is compiled when AmberTools is built and

the moduleﬁle is deposited in $AMBERHOME/include.

One of the limitations of Fortran modules is that you must use the same compiler to build your program as you
used to compile AmberTools in the ﬁrst place. If you wish to change compilers (in many cases, this also includes
compiler versions as well), then you need to recompile AmberTools with that same compiler as well. The available
API modules are sander_api for the standard sander functionality and sanderles_api for the LES capabilities.

19.13.2.1. Data structures

The Fortran data structures are all different sequence types. The sequence descriptor simply means that they
are layed out sequentially in memory in exactly the same way that a struct is in C or C++. Variables within a type
are accessed using the % operator.

The sander

input options are available as type(sander_input),

the QM/MM input options are
available as type(qmmm_input_options),
and the potential energy data structure is available as
type(potential_energy_rec). The names of the variables that make up each of these types are the same as
those deﬁned in Subsection 19.13.1.1.

An example of using the sander_input type is shown in the small code fragment below

use sander_api, only : sander_input
type(sander_input) :: inp
inp%cut = 9999.d0
inp%ifqnt = 0
inp%igb = 5

385

19. sander

19.13.2.2. Function call syntax

This section details the function calls for the various subroutines available in the Fortran API. All of these

subroutines and functions are public members of both sanderapi_mod and sanderlesapi_mod.

subroutine gas_sander_input(sander_input inp, int igb)

This subroutine takes a sander_input instance and optionally an integer corresponding to the GB model you
want to use (see the description for igb above with regards to permissible values). If an illegal igb value is
provided, a warning is printed to stderr and a value of 6 (corresponding to vacuum) is given to inp%igb. See
table 19.1 for a list of the default values assigned to each variable.

subroutine pme_sander_input(sander_input inp)

This subroutine takes a sander_input instance and initializes every variable inside with the value listed in table
19.1.

subroutine qm_sander_input(qmmm_input_options inp)

This subroutine takes a qmmm_input_options instance and initializes all of the variables to the values given in
Subsection 19.13.1.1. This is the recommended way to initialize the QM/MM options type.

subroutine sander_setup(character(len=*) top,

double precision, dimension(3*natom) crd,
double precision, dimension(6) box,
sander_input inp,
qmmm_input_options qm_inp,
integer ierr)

This subroutine sets up sander with the given topology ﬁle name, given coordinates, given box dimensions, input
options, and QM/MM input options. The ierr variable is an error ﬂag and will come back with a value of 0 if the
setup succeeded or a value of 1 if it failed. Every other variable is input and guaranteed not to change.

No checking is done to make sure that the number of coordinates provided is correct compared to the number
of atoms deﬁned in the topology ﬁle. Note that answers will be ridiculous if the coordinate order does not match
the atom order in the topology ﬁle. Segfaults and other memory violations are possible if the provided coordinate
array or box array are too small.

The box array is given in the format (a,b,c,α,β ,γ), which is the same as the format used at the bottom of the
input coordinate and restart ﬁles. This argument is required even if the system is not periodic, but the values are
not used (so they can be initialized to anything).

The qmmm_input_options variable is optional, but must be present if inp%ifqnt is 1. If qm_inp is not provided

but QM/MM is requested, an error message will be printed to stderr and ierr will return with a value of 1.

The error ﬂag ierr is required. If qm_inp is omitted, then ierr must be speciﬁed via keyword. See the

examples at the end of this section. This function should never be called if a system is already set up.

subroutine set_positions(double precision, dimension(3*natom) crd)

This subroutine sets the current positions of the active system (and so can only be called if a system is currently
set up). Note that the onus is on the programmer to make sure that the coordinate array is large enough. No error
checking is done. The input parameter is guaranteed not to change.

subroutine set_box(double precision a, double precision b,

double precision c,
double precision alpha, double precision beta,
double precision gamma)

This subroutine sets the box dimensions and angles from the input parameters (which are guaranteed not to
change).

subroutine get_positions(double precision, dimension(3*natom) positions)

386

19.13. Programmer’s Corner: The sander API

This subroutine stores the currently active positions inside the passed array.

subroutine energy_forces(type(potential_energy_rec) ener,

double precision, dimension(3*natom) forces)

This subroutine will compute the energies and forces from the current conformation of the system that is currently
set up and populate the ener type and forces array with the resulting values. Those parameters are purely
output. The energies are all given in units of kilocalories per mole and forces are given in kcal/mol/ ˚A. This
subroutine can only be called if a system is currently set up.

subroutine sander_cleanup()

This subroutine will deallocate all memory used by the sander API and return it to a state where no system is set
up and a new one can be initialized.

logical function is_setup()

This function can be called to query whether there is currently a system set up for the sander API. It returns
.true. if a system is set up and .false. otherwise.

subroutine sander_natom(integer natom)

This subroutine will query the currently set up system and return the number of atoms deﬁned by the topology ﬁle
used during setup. The input parameter will return with the number of atoms in the system or 0 if no system is
currently set up.

subroutine get_inpcrd_natom(character(len=*) filename, integer natom)

This subroutine will open the speciﬁed ﬁle and try to read how many atoms are deﬁned in that coordinate ﬁle. It
supports both NetCDF and standard ASCII-formatted inpcrd and restart ﬁles. If there was an error in reading the
ﬁle—either because the ﬁle does not exist, read permissions are not set, or the format is unrecognized—natom
will return with a value of -1. Otherwise, natom returns with the number of atoms deﬁned in the inpcrd ﬁle,
filename.

subroutine read_inpcrd_file(character(len=*) filename,

double precision, dimension(3*natom) crd,
double precision, dimension(6) box,
integer ierr)

This subroutine will read the speciﬁed coordinate ﬁle and ﬁll the crd and box arrays with the coordinates and box
deﬁned in the ﬁle. Both NetCDF restart ﬁles and ASCII restart ﬁles are supported. If no box is deﬁned in the
speciﬁed ﬁle, the box array is initialized to 0. The coordinate array is expected to be allocated with the appropriate
amount of space. You can call get_inpcrd_natom (described above) to determine how large the coordinate array
must be.

If there is a problem reading the ﬁle—either because the ﬁle does not exist, read permissions are not set, or the
format is unrecognized—ierr will come back with a value of 1 and the crd array will be uninitialized (the box
array will still be set to 0). If reading succeeded, ierr will come back as 0. This function can be called regardless
of whether a system is currently set up or not.

19.13.2.3. Example uses of the Fortran API

In this section we show a series of example programs that use the sander Fortran API. At the end of this section,
we show how to compile your program using the same Fortran compiler you used to build Amber. We will assume
that you created a ﬁle with the same name as the program name using the .F90 sufﬁx. You are recommended to
use this sufﬁx for your own programs.

We do not do any error checking in these programs since it adds considerably to the length of the example
programs. However, you are encouraged to make use of the error reporting in your own programs to avoid program
crashes. Syntax highlighting is applied to make the code easier to read.

The ﬁrst example we provide below shows a sample program that computes purely MM energies for a

non-periodic system using one of the GB models available in Amber.

387

19. sander

program sample1

use sander_api, only: sander_input, gas_sander_input, &.

sander_setup, energy_forces, &
sander_cleanup, potential_energy_rec, &
get_inpcrd_natom, read_inpcrd_file, &
sander_natom

implicit none
double precision, allocatable, dimension(:) :: crd, frc
double precision, dimension(6) :: box
type(sander_input) :: inp
type(potential_energy_rec) :: ene
integer :: natom, ierr
! Find how many atoms are in our inpcrd file
call get_inpcrd_natom("inpcrd", natom)
allocate(crd(natom*3), stat=ierr)
! Parse the inpcrd file
call read_inpcrd_file("inpcrd", crd, box, ierr)
! Set up input options to use igb=5 with 0.2M salt
call gas_sander_input(inp, 5)
inp%saltcon = 2.0d-1
! Set up our system
call sander_setup("prmtop", crd, box, inp, ierr=ierr)
! Coordinate array is no longer needed
deallocate(crd)
! Find out how big our force array must be
call sander_natom(natom)
allocate(frc(natom*3), stat=ierr)
call energy_forces(ene, frc)
! Do whatever you want with the energies and forces
! ...
! Free up our memory
call sander_cleanup
deallocate(frc)
return

end program sample1

The second example we provide shows how to use the Fortran API to compute the energy for a periodic system
using a multiscale QM/MM Hamiltonian. We will treat residues 10, 11, 12, and 20 using the PDDG-PM3
Hamiltonian.

program sample2

use sander_api, only: sander_input, pme_sander_input, &

sander_setup, energy_forces, &
sander_cleanup, potential_energy_rec, &
get_inpcrd_natom, read_inpcrd_file, &
sander_natom, qmmm_input_options, &
qm_sande.r_input

implicit none
double precision, allocatable, dimension(:) :: crd, frc
double precision, dimension(6) :: box
type(sander_input) :: inp
type(qmmm_input_options) :: qm_inp
type(potential_energy_rec) :: ene
integer :: natom, ierr

388

19.13. Programmer’s Corner: The sander API

! Find how many atoms are in our inpcrd file
call get_inpcrd_natom("inpcrd", natom)
allocate(crd(natom*3), stat=ierr)
! Parse the inpcrd file
call read_inpcrd_file("inpcrd", crd, box, ierr)
! Set up input options to use PME with a 10A cutoff
call pme_sander_input(inp)
inp%cut = 10.d0
inp%ifqnt = 1
call qm_sander_input(qm_inp)
qm_inp%qmmask = ":10-12,20"
qm_inp%qm_theory = "PDDG-PM3"
! Set up our system
call sander_setup("prmtop", crd, box, inp, qm_inp, ierr)
! Coordinate array is no longer needed
deallocate(crd)
! Find out how big our force array must be
call sander_natom(natom)
allocate(frc(natom*3), stat=ierr)
call energy_forces(ene, frc)
! Do whatever you want with the energies and forces
! ...
! Free up our memory
call sander_cleanup
deallocate(frc)
return

end program sample2

To compile Fortran programs using the sander API, the compiler must be able to ﬁnd the sander_api (or
sanderles_api) module ﬁles, which are deposited in $AMBERHOME/include when you build AmberTools. You
must also link libsander.so (or libsanderles.so) when you link your program. On Mac OS X, these shared
libraries are named libsander.dylib and libsanderles.dylib instead.

The programs we’ve written above are simple enough that they can be compiled and linked at the same time.

The following command should compile the sample1 program above, assuming it was saved to a ﬁle called
sample1.F90. Note, make sure you use the same compiler you used to build AmberTools in the ﬁrst place.

gfortran -I$AMBERHOME/include -L$AMBERHOME/lib -o sample1 sample1.F90 -lsander

This command will create a program called sample1 that you can run from the command-line. Of course as it is
written, the program will require that the ﬁles prmtop and inpcrd be present in the current directory. It will initialize
the sander API, compute the energy, and quit without printing anything. Feel free to experiment with your own
modiﬁcations to these programs.

19.13.2.4. Using the LES Fortran API

To use the LES functionality, you need to use the sanderles_api module instead of sander_api and you

have to link to the sanderles library instead of the sander library (i.e., change -lsander to -lsanderles in the
above compilation step). Since both libraries deﬁne most of the same symbols, you unfortunately cannot link both
libraries to the same program. For example:

gfortran -I$AMBERHOME/include -L$AMBERHOME/lib -o sample1 sample1.F90 -lsanderles

389

19. sander

19.13.3. The C and C++ APIs

This section describes how to use the C and C++ APIs. These two APIs are the same, and operate very much like
a prototypical C API. This is because C and Fortran are both procedural languages (as opposed to object-oriented,
like C++). Therefore, Fortran functionality maps more completely onto C than it does onto C++.

The function prototypes and data structures used for the C and C++ APIs are deﬁned in the sander.h header

ﬁle that is installed to $AMBERHOME/include when you build AmberTools.

19.13.3.1. Data Structures

The C and C++ data structures are all different structs. Variables within a struct are accessed using the .

operator.

The sander input options are available as the type sander_input, the QM/MM input options are available as

the type qmmm_input_options, and the potential energy data structure is available as the type pot_ene.

An example of using the sander_input type is shown in the small code fragment below.

#include “sander.h”
sander_input inp;
inp.cut = 9999.0;
inp.ifqnt = 0;
inp.igb = 5;

19.13.3.2. Function call syntax

This section details the function calls for the various functions deﬁned in the sander.h header ﬁle. The syntax
is almost identical to the Fortran syntax, except that errors codes are typically returned by the function rather than
set in the ﬁnal input parameter.

void gas_sander_input(sander_input *inp, int igb)

Unlike the Fortran API, the GB parameter is not optional. This subroutine takes a pointer to a sander_input
instance and the GB model you wish to use (0 or 6 for vacuum). If an illegal igb value is provided, a warning is
printed to stderr and a value of 6 is given to inp->igb. See table 19.1 for the default values assigned to each
variable.

void pme_sander_input(sander_input *inp)

This subroutine takes a pointer to a sander_input instance and initializes every variable inside with the value
listed in table 19.1.

void qm_sander_input(qmmm_input_options *inp)

This subroutine takes a qmmm_input_options instance and initializes all of the variables to the values given in
Subsection 19.13.1.1. This is the recommended way to initialize the QM/MM options type.

int sander_setup_mm(const char* top, double *crd,

double *box, sander_input *inp)

This function sets up sander with the given topology ﬁle name, given coordinates, given box dimensions, and input
options. Since overloading is not permitted in C, the QM/MM input struct cannot be made optional. Therefore,
this function can only be used when inp->ifqnt is 0. This function returns 0 upon success or 1 upon failure. A
system is only considered set up if this function returns 0.

No checking is done to make sure that the number of coordinates provided is correct compared to the number
of atoms deﬁned in the topology ﬁle. Note that answers will be ridiculous if the coordinate order does not match
the atom order in the topology ﬁle. Segfaults and other memory violations are possible if the provided coordinate
array or box array are too small.

390

19.13. Programmer’s Corner: The sander API

The box array is given in the format (a,b,c,α,β ,γ), which is the same as the format used at the bottom of the
input coordinate and restart ﬁles. This argument is required even if the system is not periodic, but the values are
not used (so they can be initialized to anything).

This function should never be called if a system is already set up.

int sander_setup(const char* top, double *crd,

double *box, sander_input *inp,
qmmm_input_options *qm_inp)

This function does the same thing as sander_setup_mm described above, but it also requires a pointer to a
qmmm_input_options instance. If inp->ifqnt is set to 0, the contents of qm_inp are ignored and a standard
MM system is set up. If successful, this function returns 0. Otherwise, it returns 1.

This function should never be called if a system is already set up.

void set_positions(double *crd)

This function sets the current positions of the active system (and so can only be called if a system is currently set
up). Note that the onus is on the programmer to make sure that the coordinate array is large enough. No error
checking is done. The input parameter is guaranteed not to change.

void set_box(double a, double b, double c,

double alpha, double beta, double gamma)

This function sets the box dimensions and angles from the input parameters (which are guaranteed not to change).

void get_positions(double *positions)

This function gets the “active” positions for the system that is currently set up.

void energy_forces(pot_ene *ener, double *forces)

This function will compute the energies and forces from the current conformation of the system that is currently
set up and populate the ener type and forces array with the resulting values. Those parameters are purely
output. The energies are all given in units of kilocalories per mole and forces are given in kcal/mol/ ˚A. This
subroutine can only be called if a system is currently set up.

void sander_cleanup(void)

This function will deallocate all memory used by the sander API and return it to a state where no system is set up
and a new one can be initialized.

int is_setup(void)

This function can be called to query whether there is currently a system set up for the sander API. It returns 0 if
no system is set up and 1 if a system is set up.

int sander_natom(void)

This funcion will query the currently set up system and return the number of atoms deﬁned by the topology ﬁle
used during setup. If no system is set up, this function returns 0.

int get_inpcrd_natom(const char *filename)

This function will open the speciﬁed ﬁle and try to read how many atoms are deﬁned in that coordinate ﬁle. It
supports both NetCDF and standard ASCII-formatted inpcrd and restart ﬁles. If there was an error in reading the
ﬁle—either because the ﬁle does not exist, read permissions are not set, or the format is unrecognized—the return
value will be -1. Otherwise, this function returns the number of atoms deﬁned in the inpcrd ﬁle, filename.

int read_inpcrd_file(const char* filename, double *crd, double *box)

391

19. sander

This subroutine will read the speciﬁed coordinate ﬁle and ﬁll the crd and box arrays with the coordinates and box
deﬁned in the ﬁle. Both NetCDF restart ﬁles and ASCII restart ﬁles are supported. If no box is deﬁned in the
speciﬁed ﬁle, the box array is initialized to 0. The coordinate array is expected to be allocated with the appropriate
amount of space. You can call get_inpcrd_natom (described above) to determine how large the coordinate array
must be.

If there is a problem reading the ﬁle—either because the ﬁle does not exist, read permissions are not set, or the
format is unrecognized—this function will return 1 and the crd array will be uninitialized (the box array will still
be set to 0). If reading succeeded, this function will return 0. This function can be called regardless of whether a
system is currently set up or not.

19.13.3.3. Examples and uses of the C and C++ APIs

In this section, we show examples of how to use the C and C++ API. These samples do exactly the same thing
as the two examples in Subsection 19.13.2.3. At the end of this section, we show how to compile your C or C++
program.

We do not do any error checking in these programs since it adds considerably to the length of the example
programs. However, you are encouraged to make use of the error reporting in your own programs to avoid program
crashes. Syntax highlighting is applied to make the code easier to read.

The ﬁrst example we provide below shows a sample C program that computes purely MM energies for a

non-periodic system using one of the GB models available in Amber.

#include <stdlib.h>
#include "sander.h"
int main() {

sander_input inp;
double *crd, *frc;
double box[6];
pot_ene ene;
int natom, ierr;
// Find out how many atoms are in our inpcrd file
natom = get_inpcrd_natom("inpcrd");
crd = (double*) malloc(natom*3*sizeof(double));
ierr = read_inpcrd_file("inpcrd", crd, box);
// Set up input options to use igb=5 with 0.2M salt
gas_sander_input(&inp, 5);
inp.saltcon = 0.2;
// Set up our system
ierr = sander_setup_mm("prmtop", crd, box, &inp);
// Coordinate array is no longer needed
free(crd);
// Find out how big our force array must be
frc = (double*) malloc(sander_natom()*3*sizeof(double));
energy_forces(&ene, frc);
/* Do whatever you want with the energies and forces
* ...
* Free up our memory
*/
sander_cleanup();
free(frc);
return 0;

}

The second example we provide shows how to use the C API to compute the energy for a periodic system using a
multiscale QM/MM Hamiltonian (in a C++ program this time). We will treat residues 10, 11, 12, and 20 using the

392

19.13. Programmer’s Corner: The sander API

PDDG-PM3 Hamiltonian.

#include "sander.h"
#include <cstring>
int main() {

sander_input inp;
double *crd, *frc;
double box[6];
pot_ene ene;
int natom, ierr;
// Find out how many atoms are in our inpcrd file
natom = get_inpcrd_natom("inpcrd");
crd = new double[natom*3];
ierr = read_inpcrd_file("inpcrd", crd, box);
// Set up input options to use igb=5 with 0.2M salt
pme_sander_input(&inp);
inp.cut = 10.0;
qm_sander_input(&qm_inp);
strncpy(qm_inp.qmmask, “:10-12,20”, 9);
strncpy(qm_inp.qm_theory, “PDDG-PM3”, 8);
// Set up our system
ierr = sander_setup("prmtop", crd, box, &inp, &qm_inp);
// Coordinate array is no longer needed
delete[] crd;
// Find out how big our force array must be
frc = new double[sander_natom()*3];
energy_forces(&ene, frc);
/* Do whatever you want with the energies and forces
* ...
* Free up our memory
*/
sander_cleanup();
delete[] frc;
return 0;

}

To compile C or C++ programs using the sander API, the compiler must be able to ﬁnd the sander.h
header ﬁle, which are deposited in $AMBERHOME/include when you build AmberTools. You must also link
libsander.so (or libsanderles.so) when you link your program. On Mac OS X, these shared libraries are
named libsander.dylib and libsanderles.dylib instead.

The programs we’ve written above are simple enough that they can be compiled and linked at the same time.

The following command should compile the sample1 program above, assuming it was saved to a ﬁle called
sample1.F90. Note, make sure you use the same compiler you used to build AmberTools in the ﬁrst place.

gcc -I$AMBERHOME/include -L$AMBERHOME/lib -o sample1 sample1.c -lsander

This command will create a program called sample1 that you can run from the command-line. Of course as it
is written, the program will require that the ﬁles prmtop and inpcrd be present in the current directory. It will
initialize the sander API, compute the energy, and quit without printing anything. Feel free to experiment with
your own modiﬁcations to these programs. For the second sample, you need to use a C++ compiler instead of the
C compiler.

19.13.3.4. Using the LES C/C++ API

There is only one header ﬁle for the sander C/C++ API. The LES and standard functionalities are differentiated

using the LES preprocessor directive. To use the LES functionality, you need to deﬁne the LES macro. You can

393

19. sander

either do this in the source code (by putting “#define LES 1” before #include “sander.h”) or by compiling
with the -DLES ﬂag. If you use the LES symbol (either as a variable or a preprocessor macro), you will have to
implement this in the source code and undeﬁne the macro after sander.h is included. For example, on the
command line this would look like:

gcc -DLES -I$AMBERHOME/include -L$AMBERHOME/lib -o sample1 sample1.c -lsanderles

19.13.4. The Python API

This section describes how to use the Python API so that you can use sander functionality inside your own
Python scripts. Building the Python bindings requires that the Python development headers and libraries be in-
stalled. As long as you install the recommended packages listed on http://ambermd.org/amber_install.html for
your Linux, Mac or Windows distribution, the necessary prerequisites will be installed.

The sander functionality is implemented in the sander Python module. The sander LES functionality is im-
plemented in the sanderles module. While the Python API implements the functions described on page 384,
the semantics of how these functions are used in Python differs more than the difference between the C/C++ and
Fortran APIs.

The Python API has numerous advantages over the other options. First, processing strings is handled correctly
by the boilerplate that interfaces Python with C, meaning that the programmer does not have to worry about how
strings map to the underlying Fortran code. Second, data is always initialized, so the programmer does not have
to worry about bugs arising from uninitialized variables. Finally, array sizes are determined automatically and no
allocation or deallocation is required.

Furthermore, the Python API provided here interacts with other Python packages provided as part of Amber-
Tools—speciﬁcally several of the classes provided by ParmEd. See Section 14.2 for more information (speciﬁcally
Subsection 14.2.6.3 for the ParmEd Python API documentation).

19.13.4.1. Data Structures

The data structures in the Python API are all “restricted” classes, where restricted means setting new attributes
is not supported and will raise an AttributeError. The data types for the sander input options, QM/MM input
options, and potential energy terms are the classes InputOptions, QmInputOptions, and EnergyTerms, respec-
tively. The last class is part of the private sander._pys namespace since it is only produced as output and never
needed as input, whereas the ﬁrst two are members of the sander package namespace.

Unlike C and Fortran, the Python classes have default constructors that will initialize all of the variables for the

different classes. An example of using the InputOptions class is shown below.

import sander
inp = sander.InputOptions()
inp.cut = 9999.0
inp.extdiel = 78.5
inp.intdiel = 1

19.13.4.2. Function call syntax

This section details the function calls for the various functions deﬁned in the sander package.

inp = sander.gas_input(6)

The igb argument is an optional integer that defaults to 6 (vacuum). This function returns an initialized
InputOptions instance whose values are listed in table 19.1. If an illegal igb value is provided, a ValueError is
raised.

inp = sander.pme_input()

394

This subroutine returns a InputOptions instance and initializes every member with the value listed in table 19.1.

19.13. Programmer’s Corner: The sander API

qm_inp = sander.qm_input()
qm_inp = sander.QmInputOptions()

These two commands both return a QmInputOptions instance and initializes all of the variables to the values
given in Subsection 19.13.1.1. The function (sander.qm_input) is redundant, since the QmInputOptions
constructor does the same thing. The function was provided only for consistency with the Fortran and C/C++
APIs.

sander.setup(prmtop, coordinates, box, mm_options, qm_options=None)

This function sets up sander with the given topology ﬁle, coordinates, box dimensions, and input options.
If
mm_options.ifqnt is 1 and qm_options is not provided, a ValueError is raised. The topology ﬁle can be either
an AmberParm instance (see Subsection 14.2.6.3 for more information) or a string ﬁlename pointing to a valid
Amber topology ﬁle.
The coordinate array can either be a numpy.ndarray instance an array.array instance, or a list. The array
must be 1-dimensional with a length equal to 3× natom. In particular, the coordinate array taken from a Rst7
instance can be used. Alternatively, the coordinates argument can be a string that is the ﬁlename of a coordinate
or restart ﬁle.

The box array, too, can be a numpy.ndarray, array.array, or list instance of length 6. If it is not one of
those data types, a TypeError will be raised. If it does not have 6 elements, a ValueError will be raised. If no
box is needed, the box argument can be set to None. Alternatively, if box is set to None and a ﬁlename was passed
to the coordinates argument that contains box dimensions, the box will be set from the information in that ﬁle.
However, any box dimensions passed using the box argument will take precedence.

The mm_options must be a InputOptions instance or a TypeError will be raised. The qm_options must be a

QmInputOptions instance or None. Otherwise, a TypeError will be raised.

If there is any problem setting the system up, or if a system is already set up, a RuntimeError will be raised.
This “function” is actually a class that implements the context manager protocol via the with statement (Python
2.5 or greater, only—Python 2.4 users must use the syntax above).

with sander.setup(prmtop, coordinates, box, mm_options, qm_options=None):

... do stuff

The return value of sander.setup is a reference to the class (which itself can be used in a context manager).
Upon exiting the context manager, sander.cleanup is called (but only if sander.setup succeeded).

sander.set_positions(crd)

This function sets the current positions of the active system. The crd argument can be a numpy.ndarray,
array.array, or list instance and must be either 1-dimensional with a length 3× natom or 2-dimensional with
a shape of natom, 3. If the array is not the correct length, a ValueError will be raised. If it is not one of the
aforementioned types, a TypeError will be raised. If a system is not currently set up, a RuntimeError will be
raised. This function returns None.

sander.set_box(a, b, c, alpha, beta, gamma)

This function sets the box dimensions and angles from the input parameters. If the incorrect number of arguments
are given, or if the arguments are not all numbers, a TypeError is raised. If no system is currently set up, a
RuntimeError is raised. This function returns None.

positions = sander.get_positions()

This function returns the coordinates as a one-dimensional list for the currently active system. If no system is
currently set up, a RuntimeError is raised.

ene, frc = sander.energy_forces()

395

19. sander

This function will compute the energies and forces from the current conformation of the system that is currently
set up and returns a two-element tuple in which the ﬁrst element is an EnergyTerms instance with the attributes
listed in Subsection 19.13.1.1 and the second attribute is a 3× natom-length list with the atomic forces. The
energies are all given in units of kilocalories per mole and forces are given in kcal/mol/ ˚A. A RuntimeError is
raised if no system is currently set up.

sander.cleanup()

This function will deallocate all memory used by the sander API and return it to a state where no system is set up
and a new one can be initialized. If no system is set up, a RuntimeError is raised. This function returns None.

bool = sander.is_setup()

This function can be called to query whether there is currently a system set up for the sander API. It returns
False if no system is set up and True if a system is set up.

natom = sander.natom()

This function will query the currently set up system and return the number of atoms deﬁned by the topology ﬁle
used during setup. If no system is set up, this function raises a RuntimeError.

Coordinate ﬁle parsing No functions are provided to parse and query coordinate and restart ﬁles, since the Rst7
class from the parmed.amber package already does that. Examples using this class are shown in the next section.

19.13.4.3. Examples and uses of the Python API

In this section, we show examples of how to use the Python API. These samples do exactly the same thing as

the two examples in Subsection 19.13.2.3 and Subsection 19.13.3.3.

Unlike the previous APIs, the Python API has built-in error checking through the utilization of the Exception
mechanism. The various exceptions that can be raised and the circumstances in which they will be raised are
described in the previous section. You may wish to catch some of the exceptions in your own Python scripts to
implement more elaborate error handling. Notice that the Python program here is much simpler than the equivalent
Fortran and C programs presented earlier.

These programs also make use of the AmberParm class in the chemistry package that is part of the ParmEd

program (see Section 14.2).

import sander
from parmed.amber.readparm import AmberParm
# Initialize the topology object with coordinates
parm = AmberParm("prmtop", "inpcrd")
# Set up input options to use igb=5 with 0.2M salt
inp = sander.gas_input(5)
inp.saltcon = 0.2
sander.setup(parm, parm.coordinates,None, inp)
# Compute the energies and forces
ene, frc = sander.energy_forces()
# Do whatever you want with the energies and forces
# ...
# Free up our memory
sander.cleanup()

The second example we provide shows how to use the Python API to compute the energy for a periodic system
using a multiscale QM/MM Hamiltonian. We will treat residues 10, 11, 12, and 20 using the PDDG-PM3
Hamiltonian. Also, rather than loading the inpcrd ﬁle directly into the AmberParm object, we use the open
constructor of the Rst7 class to read in the coordinate ﬁle. While this is exactly what the AmberParm class does
under the hood, this approach is presented here to show how to use the Rst7 class in your own programs.

396

19.13. Programmer’s Corner: The sander API

import sander
from parmed.amber.readparm import AmberParm, Rst7
# Initialize the topology object with coordinates
parm = AmberParm("prmtop")
rst = Rst7.open("inpcrd")
# Set up input options to use PME with a 10A cutoff
inp = sander.gas_input(5)
inp.cut = 10.0
qm_inp = sander.QmInputOptions()
qm_inp.qmmask = “:10-12,20”
qm_inp.qm_theory = “PDDG-PM3”
sander.setup(parm, rst.coords, rst.box, inp, qm_inp)
# Compute the energies and forces
ene, frc = sander.energy_forces()
# Do whatever you want with the energies and forces
# ...
# Free up our memory
sander.cleanup()

One ﬁnal thing we will mention is that the sander Python API supports the context manager protocol! The
previous example can be rewritten as

import sander
from parmed.amber.readparm import AmberParm, Rst7
# Initialize the topology object with coordinates
parm = AmberParm("prmtop")
rst = Rst7.open("inpcrd")
# Set up input options to use PME with a 10A cutoff
inp = sander.gas_input(5)
inp.cut = 10.0
qm_inp = sander.QmInputOptions()
qm_inp.qmmask = “:10-12,20”
qm_inp.qm_theory = “PDDG-PM3”
with sander.setup(parm, rst.coords, rst.box, inp, qm_inp):

# Compute the energies and forces
ene, frc = sander.energy_forces()

# Do whatever you want with the energies and forces
# ...
# Free up our memory

When the context manager is exited (i.e., when program execution is no longer inside the with block), sander is
automatically cleaned up. This occurs regardless of whether or not an error was raised during the execution of the
code within the with block. Notice how sander.cleanup() is no longer necessary.

19.13.4.4. Using the LES Python API

To use the LES functionality in Python, you need to import the sanderles package instead of the sander
package. Note that while nothing stops you from importing both the sander and sanderles packages in the same
Python script, both packages will not work correctly in the same script.

397

20. pmemd

20.1. Introduction

PMEMD (Particle Mesh Ewald Molecular Dynamics) is the primary molecular dynamics engine within the
AMBER Software suite. Begun by Dr. Robert E. Duke with the goal of improving performance in the most
frequently used methods of sander, the code has since diverged into multiple integrated programs, offering mas-
sively parallel CPU and highly performant GPU [447–449] capabilities for common particle simulations as well
as sophisticated CPU implementations of advanced models for electronic polarization. PMEMD supports Particle
Mesh Ewald simulations, Generalized Born simulations, Isotropic Periodic Sums, ALPB (Analytical Linearized
Poisson-Boltzmann) solvent, and even gas phase simulations using both the AMBER and CHARMM Force ﬁelds.
Most of these capabilities are also supported on the GPU accelerators, as detailed in 20.6.

For the supported functionality, the input required and output produced are intended to replicate sander. The
agreement goes as far as the limits of machine roundoff differences for the CPU code, which performs essentially
all of its arithmetic in 64-bit precision. Likewise, the GPU code offers a double-precision variant for quality
assurance during code testing and after installation, but perfect agreement with CPU results is not guaranteed in
cases where the GPU and CPU must generate their own random number sequences with different routines. The
production GPU code, which performs most of its arithmetic in 32-bit precision, will necessarily diverge from
the CPU code, but maintains a high degree of numerical reproducibility thanks to ﬁxed-precision accumulation
of forces and energies. PMEMD simply runs more rapidly, scales better in parallel using MPI, can make use of
NVIDIA GPUs and Intel Xeon Phis for acceleration, and uses less resident memory than the more general sander
engine. Dynamic memory allocation is used so memory conﬁguration is not required. Benchmark data is available
on the Amber website, ambermd.org. Given the improvements in performance in both serial and parallel as well as
the incredible performance offered by GPU acceleration, it is advisable to always use PMEMD in place of sander
if the simulation requirements are within the functionality envelope provided by PMEMD.

PMEMD accepts sander input ﬁles (mdin, prmtop, inpcrd, refc). All options documented in the sander section
of this manual should be properly parsed and an error message generated if a requested feature is not supported.
PMEMD is also backward compatible in regard to input to the same extent as sander.

20.2. Functionality

New functionality that has been added to pmemd includes:

• Thermodynamic Integration, FEP and MBAR support on GPUs

• Support for Adaptively biased MD

• Improved CPU performance and scaling

• 12-6-4 ionic dispersion potentials are now supported on GPUs

The following functionality is also supported by the GPU version of pmemd in addition to the CPU version:

• Support for gas phase simulations (through igb=6)

• Support for external electric ﬁelds

• Support for the Charmm VDW Force switch

• Support for Gaussian accelerated molecular dynamics

398

20.2. Functionality

• Semi-Isotropic pressure scaling

• Enhanced NMR restraints and R^6 averaging support

• Expanded umbrella sampling support

• Constant pH and REMD Constant pH

As mentioned above, PMEMD is not a complete implementation of sander. Instead, it is intended to be a fast
implementation of the functionality most likely to be used by someone doing long time scale explicitly or implicitly
solvated systems. It also includes some additional functionality of it’s own.

Speciﬁcally the following functionality in sander is missing entirely:

imin=5

In &cntrl. Trajectory analysis is not supported.

nmropt=2

In &cntrl. A variety of NMR-speciﬁc options such as NOESY restraints, chemical shift restraints,
pseudocontact restraints, and direct dipolar coupling restraints are not supported.

idecomp!=0 In &cntrl. Energy decomposition options, used in conjunction with mm_pbsa, are not supported.

ipol!=0

In &cntrl. Polarizable force ﬁeld simulations are not supported.

igb==10

In &cntrl. Poisson-Boltzmann simulations are not supported.

ntmin>2

In &cntrl. XMIN and LMOD minimization methods are not supported.

Solvent Caps Solvent cap simulations are not supported.

itgtmd!=0 In &cntrl. Targeted molecular dynamics is not supported.

ievb!=0

In &cntrl. Empirical Valence Bond methods are not supported.

ifqnt!=0

In &cntrl. QM/MM methods are not supported.

&debugf namelist Use of the &debugf namelist is only supported in a very limited way. Speciﬁcally only the

do_charmm_dump_gold option is supported.

LES

The Locally Enhanced Sampling method is not supported.

REM==2

The partial REMD method (for LES) is not supported

iamoeba!=0 In &cntrl. The amoeba polarizable potentials of Ren and Ponder are not supported in pmemd, al-
though support is provided through a special pmemd.amoeba implementation provided as part of
Amber 16.

One niche feature of the CPU code that is currently missing on the GPU code is the ability to employ different
cutoffs for electrostatics and van-der Waals non-bonded interactions. In particle-mesh Ewald electrostatics, the
results are not necessarily more accurate for longer values of the cutoff–the mesh grid spacing can be reduced
to compensate for a short cutoff on charge:charge interactions, and there are often fewer van-der Waals than
electrostatic interactions in a simulation with explicit solvent. Advanced users of the CPU code can therefore tune
performance for small numbers of CPUs by reducing the cutoff on electrostatics while keeping a long van-der
Waals cutoff. This feature may be added to the GPU code in the near future for performance enhancements and
as a stepping stone to other functionality. The following &ewald options are supported generally in PMEMD, but
only with the indicated default values:

ew_type=0 Only Particle Mesh Ewald calculations are supported. ew_type = 1 (regular Ewald calculations) must

be done in sander.

nbflag=1

The nbﬂag option is ignored for MD, and all nonbonded list updates are scheduled based on "skin"
checks. This is more reliable and has little cost. The variable nsnb still can be set and has an
inﬂuence on minimizations but is ignored during MD. For PME calculations, list building may also
be scheduled based on heuristics to suit load balancing requirements in multiprocessor runs.

399

20. pmemd

nbtell=0

The nbtell option is not particularly useful and is ignored.

eedmeth=1 Only a cubic spline switch function (eedmeth = 1) for the direct sum Coulomb interaction is sup-
ported. This is the default, and most widely used setting for eedmeth. On some machine architec-
tures, energies and forces are actually splined as a function of r**2 to a higher precision than the
cubic spline switch.

column_fft=0 This is a sander-speciﬁc performance optimization option. PMEMD uses different mechanisms to

enhance performance, and ignores this option.

It is suggested that new PMEMD users simply take an existing sander mdin ﬁle and attempt a short 10-30 step run.
The output will indicate whether or not PMEMD will handle the particular problem at hand for all the functionality
that is supported by "standard" sander. For functionality that requires special builds of sander or sander-derived
executables (LES), there may be failures in namelist parsing.

20.3. PMEMD-speciﬁc namelist variables

The following namelist options are speciﬁc to PMEMD and generally relate to PMEMD speciﬁc performance

optimizations: default values:

mdout_flush_interval In &cntrl, this variable can be used to control the minimum time in integer seconds
between "ﬂushes" of the mdout ﬁle. PMEMD DOES NOT use ﬁle ﬂush() calls at all because ﬂush
functionality does not work for all fortran compilers used in building pmemd. Thus, pmemd does
an open/close cycle on mdout at a default minimum interval of 300 seconds. This interval can be
changed with this variable if desired in the range of 0-3600. If mdout_ﬂush_interval is set to 0, then
mdout will be reopened and closed for each printed step. This functionality is provided in pmemd
because some large systems have such large ﬁle i/o buffers that mdout will have 0 length on the disk
through 100’s of psec of simulated time. The default of 300 seconds provides a good compromise
between efﬁciency and being able to observe the progress of the simulation.

mdinfo_flush_interval In &cntrl, this variable can be used to control the minimum time in integer seconds
between "ﬂushes" of the mdinfo ﬁle. PMEMD DOES NOT use ﬁle ﬂush() calls at all because ﬂush
functionality does not work for all fortran compilers used in building pmemd. Thus, pmemd does
an open/close cycle on mdinfo at a default minimum interval of 60 seconds. This interval can be
changed with this variable if desired in the range of 0-3600. Note that mdinfo under pmemd simply
serves as a heartbeat for the simulation at mdinfo_ﬂush_interval, and mdinfo probably will not be
updated with the last step data at the end of a run. If mdinfo_ﬂush_interval is set to 0, then mdinfo
will be reopened and closed for each printed step.

es_cutoff, vdw_cutoff In &cntrl, these variables can be used to control the cutoffs used for vdw and electro-
static direct force interactions in PME calculations separately. If you specify these variables, you
should not specify the cut variable, and there is a requirement that vdw_cutoff >= es_cutoff. These
were introduced anticipating the need to support force ﬁelds where the direct force calculations
are more expensive. For the current force ﬁelds, one can get slightly improved performance and
about the same accuracy as one would get using a single cutoff. A good example would be using
vdw_cutoff =9.0, es_cutoff =8.0. For this scenario, one gets about the accuracy in calculations associ-
ated with 9.0 angstrom cutoffs, but at a cost intermediate between an 8.0 and a 9.0 angstrom cutoff.
As stated above, this feature is not currently available on the GPU, and the cut variable chould be
used exclusively.

no_intermolecular_bonds In &cntrl. New variable controlling molecule deﬁnition. If 1, any molecules (ie.,
molecules as deﬁned by the prmtop) joined by a covalent bond are fused to form a single molecule for
purposes of pressure and virial-related operations; if 0 then the old behaviour (use prmtop molecule
deﬁnitions) pertains. The default is 1; a value of 0 is not supported with forceﬁelds using extra points.
This option was necessitated in order to efﬁciently parallelize model systems with extra points. This

400

20.4. Slightly changed functionality

redeﬁnition of molecules actually allows for a more correct treatment of molecules during pressure
adjustments and should produce better results with less strain on covalent bonds joining prmtop-
deﬁned molecules, but if the default value is used for a NTP simulation, results will differ slightly
relative to sander if any intermolecular bonding was applied in forming the prmtop (eg., a cyx-cyx
bridge was added between two peptides that originated in a PDB ﬁle, with each peptide having its
own "TER" card). If consistency with sander is more important to you, and you are not using extra
points, then you may want to set no_intermolecular_bonds to 0.

ene_avg_sampling In &cntrl. New variable controlling the number of steps between energy samples used in
energy averages. If not speciﬁed, then ntpr is used (default). To match the behaviour of sander
or PMEMD v9 or earlier, this variable should be set to 1. This variable is only used for MD, not
minimization and will also effectively be turned off if ntave is in use (non-0) or RESPA is in use
(nrespa > 1). It is a fairly common situation that it is completely unnecessary to sample the energies
every step to get a good average during production, and this is costly in terms of performance. Thus,
performance can be improved (with greatest improvements for the ensembles in the order NVE >
NVT > NTP) without really losing anything of value by using the new default for energy average
sampling (specify nothing).

use_axis_opt In &ewald. For parallel runs, the most favorable orientation of an orthogonal unit cell is with
the longest side in the Z direction. Starting with pmemd 3.00, internal coordinates were actually
reoriented to take advantage of this, and in high processor count runs on oblong unit cells, using axis
optimization can improve performance on the order of 10%. However, if a system has hotspots, the
results produced with axes oriented differently may vary by on the order of 0.05% relatively quickly.
This effect has to do with the fact that axis optimization changes the order of LOTS of operations and
also the fft slab layout, and under mpi if the system has serious hotspots, shake will come up with
slightly different coordinate sets. This is really only a problem in pathological situations, and then
it is probably mostly telling you that the situation is pathological, and neither set of results is more
correct (typically the ewald error term is also high). In routine regression testing with over a dozen
tests, axis reorientation has no effect on results. Nonetheless, the defaults are now selected to be in
favor of higher reproducibility of results. Axis optimization is only done for mpi runs in which an
orthogonal unit cell has an aspect ratio of at least 3 to 2. It is turned off for all minimization runs and
for runs in which velocities are randomized (ntt = 2 or 3). If you want to force axis optimization, you
may set use_axis_opt = 1 in the &ewald namelist. If you set it to 0, you will force it off in scenarios
where it would otherwise be used.

fft_grids_per_ang In &ewald. This variable may be used to set the desired reciprocal space fft grid density
in terms of fft grids/angstrom. The nearest grid dimensions, given the prime factors supported by
the underlying fft implementation, that meet or exceed this density will be used (ie., nfft1,2,3 are
set based on this speciﬁcation). The default value is 1.0 grids/angstrom and gives very reasonable
accuracy. PMEMD is actually more stringent now than sander in that it will meet or exceed the
desired density instead of just approximating it. Thus, to get identical results with sander, one may
have to specify grid dimensions to be used with the nfft1,2,3 variables.

20.4. Slightly changed functionality

An I/O optimization has been introduced into PMEMD. If the user does not specify a value of NTWR then it
defaults to NSTLIM. In general, frequent writes of restrt, especially in runs with a high processor count or on
GPUs, is wasteful. Also, if the mden ﬁle is being written, it is always written as formatted output, regardless of the
value of ioutfm. SANDER now conforms to this convention regarding ioutfm and mden.

In thermodynamic integration calculations, the input format is different from SANDER. The differences are

explained in section 23.1 of the manual.

In addition, there are two command-line options unique to pmemd:

-l <logﬁle name> A name may be assigned to the log ﬁle on the command line.

401

20. pmemd

-gpes <process_map_ﬁle> This option controls the distribution of threads in a multipmemd simulation and al-
lows you to allocate threads to various processes however you want (rather than dividing up all threads
equally between each line of the groupﬁle). By default, the threads are allocated sequentially (that is, for
N groups given M threads per group, or N*M threads total, threads 0 to M-1 will be assigned to the ﬁrst
group, threads M to 2M-1 will be assigned to the second group, etc.). Using the -ng-nonsequential ﬂag,
threads will be allocated with a one-at-a-time approach. For instance, given the same setup as above, the
ﬁrst group gets threads 0, M, 2M, 3M, ... etc, the second group gets threads 1, M+1, 2M+1, 3M+1, ... etc.
The process_map_ﬁle is a ﬁle that contains as many lines as you have groups (although the last line can be
omitted, and the remaining unspeciﬁed threads will be assigned to the ﬁnal group). Each line must contain
space-delimited integers that correspond to the thread numbers you want assigned to that group. Each group
is assigned the threads listed in that line of the process_map_ﬁle. Every thread must be speciﬁed in the
process_map_ﬁle, and no thread can be speciﬁed more than once.

20.5. Parallel performance tuning and hints

As of AMBER 18, PMEMD now supports a neutral territory method (by turning on the midpoint variable) that
allows for 3-D domain decomposition of the simulation space. This means it is possible to divide the work each
process does in the non-bond space by dividing the simulation space into equivalent smaller boxes whereby each
process updates and keeps track of atoms it owns. The midpoint method improves memory usage (ongoing) and
dramatically improves the communication bottleneck from O(N) in the Amber16 pmemd.MPI to O(N/P) allowing
for stronger scaling across processors. As the midpoint method is still undergoing development and is considered
experimental, it is recommended to consult http://ambermd.org/intel/midpoint.htm to check on currently supported
features and information on compiling for further optimizations such as openmp and spdp mixed precision models.
In order to achieve higher scaling in other contexts, pmemd has implemented several performance algorithms,
the most notable of which is the option of using a "block" or pencil fft rather than the usual slab fft algorithm. The
block fft algorithm allows the reciprocal space and fft workload to be distributed to more processors, but at a cost of
higher communications overhead, both in terms of the distributed fft transpose cost and in terms of communication
of the data necessary to set up the fft grids in the ﬁrst place. A number of variables in the &ewald namelist can
be used to control whether the slab or block fft algorithm is used, how the block division occurs, whether direct
force work is also assigned to tasks doing reciprocal space and fft work, whether the master is given any force and
energy computation work to do, as opposed to being reserved strictly for handling output and loadbalancing, and
the frequency of atom ownership reassignment, an operation that counteracts rising communications costs caused
by diffusion. The various namelist variables involved have all been assigned defaults that adapt to run conditions,
and in general it is probably best that the user just use the defaults and not attempt to make adjustments. However,
in some instances, ﬁne tuning may yield slightly better performance. The variables involved include block_fft,
fft_blk_y_divisor, excl_recip, excl_master, and atm_redist_freq. These are described further in the README under
pmemd/src as well as in the sourcecode itself.

Performance depends not only on proper setup of hardware and software, but also on making good choices in
simulation conﬁguration. There are many tradeoffs between accuracy and cost, as one might expect, and under-
standing all of these comes with experience. However, I would like to suggest a couple of good choices for your
simulations, if you have facilities where you can routinely run at high processor count, say 32 processors or more.
First of all, there is an implementation of binary trajectory ﬁles in pmemd and sander, based on the netCDF binary
ﬁle format. This is invoked now using ioutfm == 1, assuming you have built either pmemd or sander with "bintraj"
support. Using this output format, i/o from the master process will be more efﬁcient and your ﬁlesize will be about
half what it would otherwise be. In Amber, ptraj can read these new netCDF trajectory ﬁles and can convert them
to ASCII format if needed. At really high processor count using the netCDF format can be on the order of 10%
more efﬁcient than using the standard formatted trajectory output. Secondly, other simulation packages typically
use multiple timestepping (respa) methods as an efﬁciency measure. These methods typically sample reciprocal
space forces for PME less frequently. Due to the limited use of such methods by Amber users this approach has
not been optimized in pmemd and hence while this can slightly improve performance for pmemd at low processor
count, at higher processor counts using respa typically makes loadbalancing less efﬁcient leading to a net loss of
performance. If you wish to use respa for pme simulations (done typically by setting nrespa to 2 or 4), then you

402

20.6. GPU Accelerated PMEMD

should check whether you actually get better performance. You may well not, and it will be at a cost of a loss in
accuracy. The GPU PME code requires nrespa to be 1, and for highly tuned runs making use of a 4fs time step
with SHAKE and hydrogen mass repartitioning, nrespa = 2 would be dangerous, in principle, with any version of
the code. Using nrespa for generalized Born simulations is ﬁne in all cases, however.

20.6. GPU Accelerated PMEMD

One of the newer features of PMEMD, is the ability to use NVIDIA GPUs to accelerate both explicit solvent
PME and implicit solvent GB simulations [447–449]. This aspect of the code base is currently maintained by
David Cerutti, Taisung Lee, and others, based on the foundational contributions of Scott Le Grand and Ross
Walker in collaboration with NVIDIA. While GPU acceleration is a longstanding feature, the error checking is
not as verbose in the GPU code as it is on the CPU and some aspects remain more constrictive. In particular,
simulation failures, such as atom collisions or other simulation instabilities, will manifest themselves as CUDA
launch errors or GPU download failures and not as informative error messages. Due to certain aspects of our GPU
pair list operation, we have found that it is unsafe to run simulations that are less than three times the non-bonded
cutoff in any given direction, and these cases will be trapped with an error message until a ﬁx can be implemented.
Furthermore, the pair list is only designed once on the current GPU implementation and may become invalid if the
simulation box shrinks too drastically, as may happen in systems that have not undergone pressure equilibration.
(The code will trap such simulations with an error in these circumstances.) If you encounter problems during a
simulation on the GPU you should ﬁrst try to run the identical simulation on the CPU to ensure that it is not your
simulation setup which is causing problems. Feedback and questions should be posted to the Amber mailing list
(see http://lists.ambermd.org/).

This section of the manual describes the feature set, installation, performance and accuracy considerations and
other aspects of GPUs at the time of Amber’s release. However, the rapidly changing nature of this ﬁeld means
that frequent updates are likely. You should refer to the web page http://ambermd.org/gpus/ for the most up to date
information.

20.6.1. Supported Features

The GPU accelerated version of PMEMD supports both explicit solvent PME simulations in all three canonical
ensembles (NVE, NVT and NPT) and implicit solvent Generalized Born simulations. It has been designed to
support as many of the standard PMEMD features as possible, however, there are some current limitations that are
detailed below. Some of these may be addressed in the future, and patches released, with the most up to date list
posted on the web page. The following options are NOT supported:

1. ibelly (cid:54)= 0 Simulations using belly style constraints are not supported.
2. icfe (cid:54)= 0 Support for TI is not currently implemented (but an update to support this in AMBER 16 is planned).
3. igb (cid:54)= 0 && cut < systemsize GPU accelerated implicit solvent GB simulations do not support a cutoff.
4. nmropt > 1 Support is not currently available for nmropt > 1. In addition for nmropt = 1 only features that do
not change the underlying force ﬁeld parameters are supported. For example umbrella sampling restraints
are supported as is Jarzynski sampling as well as simulated annealing functions such as variation of Temp0
with simulation step. However, varying the VDW parameters with step is not supported.

5. nrespa (cid:54)= 1 No multiple time stepping is supported.
6. imin = 1 with MPI Minimization is currently only supported for single GPU runs.
7. es_cutoff (cid:54)= vdw_cutoff Independent cutoffs for electrostatics and van der Waals are not supported on GPUs.
8. order > 4 PME interpolation orders of greater than 4 are not supported at present.
9. emil_do_calc (cid:54)= 0 Emil is not supported on GPUs.

403

20. pmemd

10. iemap > 0 EMAP restraints are not supported on GPUs.

11. isgld > 0 Self guided Langevin dynamics are not supported on GPUs.

Additionally there are some minor differences in the output format. For example the Ewald error estimate is not
calculated when running on a GPU, in fact a completely different spline table format is used. However, for the
purposes of nearly all investigators, the GPU diagnostic output will be sufﬁcient, and numerical accuracy will track
the CPU code in that the errors inherent non-bonded forces for most run settings will dwarf the errors incurred by
32-bit calculation, accumulation, and integration.

20.6.2. New in Amber 18

Amber 18 represents a continued evolution of the Amber GPU MD ecosystem with a number of additions to
functionality, support for new hardware and extensive optimization appearing in the latest release. Amber 18
continues the march towards greater performance, presenting up to 20% increased speed for PME simulations over
the Amber 16 product. While benchmarks are seldom consistent between packages, we are continuing to improve
the speed of the code and anticipate additional improvements throughout the Amber 18 release cycle. We endeavor
to maintain the one of the world’s fastest molecular dynamics software packages on commodity hardware.

Additional improvements in Amber 18 include:

• Thermodynamic Integration, FEP and MBAR

• Adaptively biased MD

• Enhanced NMR restraint and R^6 averaging support

• Gaussian accelerated molecular dynamics

• Expanded umbrella sampling support

• Complete constant pH support, also with pH replica exchange

20.6.3. Supported GPUs

GPU accelerated PMEMD has been implemented using CUDA and thus will only run on NVIDIA GPUs
at present. Due to accuracy concerns with pure single precision the code uses a custom designed hybrid
single/double/ﬁxed-precision model termed SPFP. This places the requirement that the GPU hardware supports
both double precision and integer atomics meaning only GPUs with hardware revision 3.0 or later (Kepler archi-
tecture, GTX 680 and higher) can be used. Support is provided for Tesla, Quadro and GeForce GPUs and almost
all mid to high end cards are supported. The new Volta architecture is supported, with the option of a special con-
ﬁguration ﬂag (-volta) which optimizes critical kernels for even more speed on the latest NVIDIA hardware. You
are encouraged to visit the AMBER website (ambermd.org/gpus/) for an update to date list of supported hardware
and performance numbers.

You should ensure that all GPUs on which you plan to run PMEMD are connected to PCI-E 2.0 x16 lane slots
or better. For peer to peer communication (required for multi-GPU scaling) the cards to be used need to be in the
same PCI-E domain. If this is not the case then you will likely see signiﬁcantly degraded performance in parallel.
For more information, and details of optimium hardware designs. please see Recommended Hardware under the
GPU section of the AMBER website (http://ambermd.org/gpus/).

Support is provided for single GPU and multiple GPU runs. Employing multiple GPUs in a single simulation
requires MPI and the pmemd.cuda.MPI executable. If you have multiple simulations to run then the recommended
method is to use one GPU per job. The pmemd GPU code has been developed in such a way that for single GPU
runs the PCI-E bus is only used for I/O. This sets AMBER apart from other MD packages since it means the CPU
specs do not feature in the GPU code performance. As such low end economic CPUs can be used. Addition-
ally it means that in a system containing 4 GPUs 4 individual calculations can be run at the same time without
interfering with each other’s performance. Selection of which GPU is used for single GPU runs is automatic if
the GPUs are set to process exclusive mode (nvidia-smi -c 3) but the recommended approach is to use the

404

20.6. GPU Accelerated PMEMD

CUDA_VISIBLE_DEVICES environment variable to select which GPU should be used. For parallel runs you
specify the same number of MPI threads as you have GPUs you want to use. The code will automatically use peer
to peer communication if available. Multi-GPU runs require the GPUs to be set to default mode (nvidia-smi -c
0). More details are provided in section 20.6.6.

20.6.4. Accuracy Considerations

The nature of current generation GPUs is such that single precision arithmetic is considerably faster than double
precision arithmetic, particularly on commodity gaming cards with a paucity of double-precision registers. This
poses an issue when trying to obtain good performance from GPUs. Traditionally the CPU code in Amber has
always used double precision throughout the calculation. While this full double precision approach has been
implemented in the GPU code it gives very poor performance and so the default precision model used when
running on GPUs is a combination of single and ﬁxed precision, termed hybrid precision (SPFP), that is discussed
in further detail in references [447–449]. This approach uses single precision for individual calculations within
the simulation but ﬁxed scaled integer precision for all accumulations.
It also uses ﬁxed precision for shake
calculations and for other parts of the code where loss of precision was deemed to be unacceptable. Tests have
shown that energy conservation is equivalent to the full double precision code and speciﬁc ensemble properties,
such as order parameters, match the full double precision CPU code. Previous acceleration approaches, such as
the MDGRAPE-accelerated sander, have used similar hybrid precision models and thus we believe that this is a
reasonable compromise between accuracy and performance. The user should understand though that this approach
leads to rapid divergence between GPU and CPU simulations, similar to that observed when running the CPU code
across different processor counts in parallel but occuring much more rapidly. Ultimately though this is simply a
cosmetic consideration since any statistical mechanical properties should converge to the same values.

While the default precision model is currently the hybrid SPFP model two additional precision models have
been implemented within version 16 of the GPU code to facilitate advanced testing and comparison. The choice of
default precision model may change in the future based on the outcome of detailed validation tests of the different
approaches. The precision models supported, all of which are built automatically at compile time are:

• SPFP - (Default) Use a combination of single precision for calculation and ﬁxed precision for accumulation.
This approach is believed to provide the optimum tradeoff between accuracy and peformance and hence at
the time of release is the default model invoked when using the executable pmemd.cuda.

• DPFP - Use double precision (and double precision equivalent ﬁxed precision) for the entire calculation.
This provides for careful regression testing against the CPU code. It makes no additional approximations
above and beyond the CPU implementation and would be the model of choice if performance was not a
consideration. On v2.0 NVIDIA hardware (e.g. M2090) the performance is approximately half that of the
SPFP model while on v3.0 NVIDIA hardware (e.g. K10) the performance is substantially less than the SPFP
model.

• SPXP - (Experimental) Use single precision for calculation and a combination of 32 bit integer accumulation
strategies to approximate 48 bit precision in the summation stage. This precision model has been designed
to provide future prooﬁng of performance on next and later generation hardware designs. It is considered
experimental at present and should not be used for production simulations except as a way to test how the
model performs.

20.6.5. Installation and Testing

The GPU version of PMEMD is called pmemd.cuda (or pmemd.cuda.MPI for the multi GPU version). Before
attempting to build the GPU version of PMEMD you should have built and tested at least the serial version of
Amber. This will help to ensure that basic issues relating to standard compilation on your hardware and operating
system do not lead to confusion with GPU related compilation and testing problems. You should also be familiar
with Amber’s compilation and test procedures.

It is assumed that you have already correctly installed and tested CUDA support on your GPU. Addition-
ally the environment variable CUDA_HOME should be set to point to your NVIDIA Toolkit installation and

405

20. pmemd

$CUDA_HOME/bin/ should be in your path. Information about supported GPU’s and NVIDIA Toolkits is avail-
able at ambermd.org/GPUSupport.php. Note that the instructions below will also install CUDA versions of cpptraj
and pbsa.

Building and Testing the GPU code

Assuming you have a working CUDA installation you can build all three precision models (pmemd.cuda_SPFP,

pmemd.cuda_DPFP and pmemd.cuda_SPXP) with pmemd.cuda linked to pmemd.cuda_SPFP as follows:

export CUDA_HOME=/usr/local/cuda
cd /home/xxxx/amber20_src/build

(or other appropriate location)

(again, you must replace

/home/xxxx with your chosen location)

# edit the run_cmake script to set -DCUDA=TRUE (you should also be using the GNU compilers here)
./run_cmake
make install

Next you can run the tests using the default GPU (the one with the largest memory followed by lowest GPU ID)
with:

cd $AMBERHOME
export CUDA_VISIBLE_DEVICES=0
make test.cuda.serial

(choose the GPU id you wish to test)

The majority of these tests should pass. However, given the parallel nature of GPUs, the synchrony of multiple
threads is not guaranteed and certain features of the code rely on GPU kernels to generate random number se-
quences that may not always agree. It is not uncommon for there to be several possible failures. You may also see
some tests fail with minute differences in one or two output values, even when running the tests with the double pre-
cision GPU code. The single precision GPU code will encounter higher numbers of failures–expect roughly 40%
of the tests to fail–but again the differences should still be small. Extract lines containing “maximum relative error”
or “maximum absolute error” from the compiled diffs ﬁle created in the $AMBERHOME/logs/test_amber_cuda/
directory to quickly assess the ﬁdelity of your build. You can inspect the diff ﬁle manually to verify any possible
failures. Differences which occur on only a few lines and are minor in nature can be safely ignored. Any large
differences, or if you are unsure, should be posted to the Amber mailing list for comment.

Building pmemd.cuda.MPI

The GPU version of pmemd can be run in parallel on multiple GPUs using the executable pmemd.cuda.MPI.
Some simulations, particularly replica exchange simulations, require a parallel executable in order to operate.
Please note, however, that most users do not need a parallel GPU version, since parallel scaling across many GPUs
is still very poor.

Assuming you have a working CUDA and MPI installation you can build pmemd.cuda.MPI as follows:

cd /home/xxxx/amber20_src/build
# edit the run_cmake script to have -DMPI=TRUE -DCUDA=TRUE
./run_cmake
make install

Next you can run the tests using the default GPUs (the one with the largest memory in descending order) with:

cd $AMBERHOME
export DO_PARALLEL="mpirun -np 2" # for bash/sh
make test.cuda.parallel

The majority of these tests should pass. However, as described above it is not uncommon for there to be some
possible failures. You should inspect the diff ﬁle created in the $AMBERHOME/logs/test_amber_cuda_parallel/
directory to manually verify any possible failures. Differences which occur on only a few lines and are minor in
nature can be safely ignored. Any large differences, or if you are unsure, should be posted to the Amber mailing
list for comment.

406

20.6. GPU Accelerated PMEMD

Building pmemd.cuda.MPI with NCCL support

The NVIDIA Collective Communications Library (NCCL) is a library of multi-GPU collective communication
primitives that are topology-aware. NCCL can be enabled when running on more than 2 GPUs in the same node.
This may improve multi-GPU scaling, especially on systems with NVLINKs between GPUs. NCCL requires glibc
2.17 or higher CUDA 10.0 or higher, and runs on GPU’s with a compute capability of 3.5 (K80 equivalent) and
higher..

To enable NCCL, ﬁrst install NCCL on your system. There are two ways to install NCCL. To install NCCL

from source:

git clone https://github.com/NVIDIA/nccl.git
cd nccl
git checkout ‘git tag | tail -n1‘
make src.build CUDA_HOME=/path_to_cuda_toolkit/

This installs NCCL to the directory nccl/build.

Alternatively,

pre-built NCCL packages

can be downloaded from NVIDIA’s website.

https://docs.nvidia.com/deeplearning/sdk/nccl-install-guide/index.html for details.

See

Next, the environment variable NCCL_HOME should be set to point to NCCL install path.
Finally, to enable NCCL in Amber, add -DNCCL=TRUE to the cmake conﬁgure options. Note NCCL build

requires both MPI and CUDA to be enabled.

20.6.6. Running GPU Accelerated Simulations

In order to run a GPU accelerated MD simulation the only change required is to use the executable

pmemd.cuda in place of pmemd. E.g.

$AMBERHOME/bin/pmemd.cuda -O -i mdin -o mdout -p prmtop \
-c inpcrd -r restrt -x mdcrd

This will automatically run the calculation on the GPU with the most memory even if that GPU is already in use.
If you have only a single CUDA capable GPU in your machine then this is ﬁne; however if you want to control
which GPU is used, or you want to run multiple independent simulations using different GPUs, then you manually
need to specify the GPU to use with the CUDA_VISIBLE_DEVICES environment variable.

CUDA_VISIBLE_DEVICES Speciﬁes which GPU should be used for running a GPU accelerated PMEMD calcu-
lation. This is based on the hardware ID of the GPU card which can be obtained by unsetting
the variable (unset CUDA_VISIBLE_DEVICES) and running the deviceQuery command from the
NVIDIA CUDA SDK. Valid values are a list of integers from 0 to 32. Multiple GPUs may be listed
with commas in between them, and the one with the most memory will be selected. For example:

export CUDA_VISIBLE_DEVICES=1,3
$AMBERHOME/bin/pmemd.cuda -O -i mdin -o mdout -p prmtop \
-c inpcrd -r restrt -x mdcrd

In this way it is possible to make use of multiple GPUs in a single node for multiple simultaneous calculations.
When running a single calculation across multiple GPUs using pmemd.cuda.MPI it also allows the selection of
speciﬁc GPUs on speciﬁc nodes. For example running a 2 GPU job with mpirun -np 2 pmemd.cuda.MPI with
the above listed CUDA_VISIBLE_DEVICES would automatically use the second (id=1) and fourth (id=3) GPU
in the node. The multi GPU code will avoid assigning MPI GPU tasks to the same GPU if sufﬁcient GPUs are
visible. For a more indepth explanation of running GPU accelerated calculations, including how to utilize the peer
to peer support in parallel please refer to the GPU section of the AMBER website (http://ambermd.org/gpus/).

407

20. pmemd

20.6.7. Considerations for Maximizing GPU Performance

There are a number of considerations above and beyond those typically used on a CPU for maximizing the
performance achievable for a GPU accelerated PMEMD simulation. The following provides some tips for ensuring
good performance.

1. Avoid using small values of NTPR, NTWX, NTWV, NTWE and NTWR. Writing to the output, restart
and trajectory ﬁles too often can hurt performance even on CPU runs; however, this is more acute for GPU
accelerated simulations because there is a substantial cost in copying data to and from the GPU. Performance
is maximized when CPU to GPU memory synchronizations are minimized. This is achieved by computing
as much as possible on the GPU and only copying back to CPU memory when absolutely necessary. There
is an additional overhead in that performance is boosted by only calculating the energies when absolutely
necessary, hence setting NTPR or NTWE to low values will result in excessive energy calculations. You
should typically not set any of these values to less than 100 (except 0 to disable them) and ideally use values
of 1000 or more. >100000 for NTWR is ideal, or even better let it just default fo NSTLIM.

2. Avoid setting ntave (cid:54)= 0. Turning on the printing of running averages results in the code needing to calculate
both energy and forces on every step. This can lead to a performance losses of 20% or more when running
on the GPU. This can also affect performance on CPU runs although the difference is not as marked. Similar
arguments apply to setting the value of ene_avg_sampling to small values.

3. Avoid using the NPT ensemble (ntb=2) when it is not required; if needed make use of the Monte Carlo

barostat (barostat=2). Performance will generally be NVE>NVT>NPT (NVT~NPT for barostat=2).

4. Use the GPU-suitable GBSA term (gbsa = 3) in implicit solvent GB simulations. Avoid the use of gbsa =
1 unless required. The gbsa = 1 term is calculated on the CPU and thus requires a synchronization between
GPU and CPU memory on every MD step, while gbsa = 3 calculates all energy terms on GPU without extra
I/O burdens.

5. Use the Berendsen Thermostat (ntt=1) or Anderson Thermostat (ntt=2) instead of the Langevin Thermostat
(ntt=3). Langevin simulations require very large numbers of random numbers which slows performance
slightly.

6. Set netfrc=0 in the &ewald namelist to get the ’legacy’ operation on pmemd.cuda, which did not calculate
or remove the net force during PME simulations. The net force arises from the mesh calculation, but due
to other algorithmic decisions can only be properly removed at the end of the force calculation. Generally
the effect is to randomly nudge the system as a whole very slightly in different directions with each PME
grid calculation. The nscm setting can be used to remove any net momentum on a much less frequent time
scale. Overall, the performance cost of this net force removal is a fraction of 1% of the total time, however,
so meticulous researchers can use net force removal conveniently.

7. Do not assume that for small systems the GPU will always be faster. Typically for GB simulations of less
than 150 atoms and PME simulations of less than 5,000 atoms it is not uncommon for the CPU version of
the code to outperform the GPU version on a single node. Typically the performance differential between
GPU and CPU runs will increase as atom count increases. Additionally the larger the non-bond cutoff used
the better the GPU to CPU performance gain will be.

8. When running in parallel across multiple GPUs you should restrict jobs to a single node and select GPUs
that are on the same PCIe domain and thus can communicate via peer to peer. For a discussion of PCIe
topologies in modern hardware see the following writeup http://tinyurl.com/h469f73. For most budget 4
GPU nodes gpus 0 and 1 can typically communicate via peer to peer and gpus 2 and 3 can communicate via
peer to peer. Thus you should not attempt to run a simulation across GPU combinations 0 and 2, or 0 and 3
or 1 and 2 or 1 and 3. The mdout ﬁle contains a section that indicates if peer to peer support is enabled.

9. Turn off ECC (Tesla models C2050 and later). ECC can cost you up to 10% in performance. You should
verify that your GPUs are working correctly, and not giving ECC errors for example before attempting this.

408

20.6. GPU Accelerated PMEMD

You can turn this off on Fermi based cards and later by running the following command for each GPU ID as
root, followed by a reboot:
nvidia-smi -g 0 --ecc-config=0 (repeat with -g x for each GPU ID)
Extensive testing of AMBER on a wide range of hardware has established that ECC has little to no beneﬁt
on the reliability of AMBER simulations. This is part of the reason it is acceptable (see recommended
hardware) to use the GeForce gaming cards for AMBER simulations. For more details of ECC and MD
simulations see the following paper [450].

10. If you see that performance when running multiple - multi-GPU runs is bad. That is that say you run 2 x
2GPU jobs and they don’t both run at full speed as if the other job was never running then make sure you turn
off thread afﬁnity within your MPI implementation or at least set each MPI thread to use a difference core.
In our experience MPICH does not have this on by default and so no special settings are needed however
both MVAPICH and OpenMPI set thread afﬁnity by default. This would actually be useful if they did it in
an intelligent way. However, it seems they pay no attention to load or even other MVAPICH or OpenMPI
runs and always just assign from core 0. So 2 x 2 GPU jobs are, rather foolishly, assigned to cores 0 and 1
in both cases. The simplest solution here is to just disable thread afﬁnity as follows:

a) MVAPICH: export MV2_ENABLE_AFFINITY=0; mpirun -np 2 ...
b) OpenMPI: mpirun –bind-to none -np 2 ...

409

21. Atom and Residue Selections

There are three ways to select atoms and residues in AMBER-related routines: the AMBER "mask" notation,
used by most programs, the NAB "atom expressions", which work only with NAB-compiled applications, and
an older “GROUP” speciﬁcation used in sander and pmemd. Information about these is collected in this chapter.

21.1. Amber Masks

A "mask" is a notation which selects atoms or residues for special treatment. A frequent usage is ﬁxing or

tethering selected atoms or residues during minimization or molecular dynamics.

The following lines are partially copied from the original AMBER documentation. For more details, refer to the

entire section of that documentation describing the ambmask utility.

The "mask" selection expression is composed of "elementary selections". These start with ":" to select by
residues, or "@" to select by atoms. Residues can be selected by numbers (given as numbers separated by commas,
or as ranges separated by a dash) or by names (given as a list of residue names separated by commas). The same
holds true for atom selections by atom numbers or atom names. In addition, atoms can be selected by AMBER
atom type, in which case "@" must be immediately followed by "%". The notation ":*" means all residues and
"@*" means all atoms. The following examples show the usage of this syntax.

Residue Number List Examples

:1-10
:1,3,5
:1-3,5,7-9 = "residues 1 to 3 and residue 5 and residues 7 to 9"

= "residues 1 to 10"
= "residues 1, 3, and 5"

Residue Name List Examples

:LYS
:ARG,ALA,GLY

= "all lysine residues"
= "all arginine and alanine and glycine residues"

Atom Number List Examples

Note that these masks use the actual sequential numbers of atoms in the ﬁle. This is tricky and a serious
source of error. You must know these numbers correctly. Using the atom numbers of a PDB ﬁle written out by an
AMBER tool is an appropriate way to avoid pitfalls. Do not use the original atom numbers from the raw PDB
ﬁle you started with.

@12,17
@54-85
@12,54-85,90 = "atom 12 and all atoms from 54 to 85 and atom 90"

= "atoms 12 and 17"
= "all atoms from 54 to 85"









410















21.1. Amber Masks







Atom Name List Examples

@CA
@CA,C,O,N,H = all atoms with names CA or C or O or N or H

= all atoms with the name CA (i.e., all C-alpha atoms)

(i.e., the entire protein backbone)

Atom Type List Examples

This last mask type is only used by specialists and mentioned here for completeness. It allows the selection of

AMBER atom types and requires detailed knowledge of AMBER force ﬁelds.

@%CT

@%N*,N3

= all atoms with the force field type CT

(the standard sp3 aliphatic carbon)

= all atoms with the force field type N* or N3

(N* is a special sp2 nitrogen, N3 is an sp3 nitrogen)

Note that in the above example, N* is actually an atom type. The * is not a wild card meaning "all N-something

types"!

Logical Combinations

The selections above can be combined by various logical operators, including selections like "all atoms within
a certain distance from...". The use of such combinations goes beyond this introductory script. Interested users
should refer to the next section for details.

21.1.1. ambmask

NAME

ambmask - test group input FIND mask (or mask string given in the &cntrl section) and dump the resulting atom
selection in a given format

SYNOPSIS

ambmask -p prmtop -c inpcrd -prnlev [0-3] -out [short| pdb| amber] -find [maskstr]

DESCRIPTION

ambmask acts as a ﬁlter that inputs an Amber topology ﬁle and an Amber coordinate ﬁle and applies the "maskstr"
selection string to select speciﬁc atoms or residues. (The "maskstr" selection string is similar syntactically to UCSF
Chimera/Midas.) Residues can be selected by their numbers or names. Atoms can be selected by numbers, names,
or Amber (forceﬁeld) type. Selections are case insensitive. The selected atoms are printed to stdout (by default,
in Amber-style PDB format). Atom and residue names and numbers are taken from the Amber topology. Beware
that the selection string works on those names and not the ones from the original PDB ﬁle. If you are not sure
how atoms or residues are named or numbered in the Amber topology, use ambmask with a selection string ":*"
(which is the default) to dump the whole PDB ﬁle with corresponding Amber atom/residue names and numbers.

The "maskstr" selection expression is composed of "elementary selections". These start with ":" to select by

residues, or "@" to select by atoms. Residues can be selected by numbers (given as numbers separated by
commas, or as ranges separated by a dash) or by names (given as a list of residue names separated by commas).
The same holds true for atom selections by atom numbers or atom names. In addition, atoms can be selected by
Amber atom type, in which case "@" must be immediately followed by "%". ":*" means all residues and "@*"
means all atoms. The following examples show the usage of this syntax. Square brackets should not be used in
actual expressions, they are only used below to denote individual selection string examples:

411

21. Atom and Residue Selections

:{residue numlist} [:1-10] [:1,3,5] [:1-3,5,7-9]
:{residue namelist} [:LYS] [:ARG,ALA,GLY]
@{atom numlist} [@12,17] [@54-85] [@12,54-85,90]
@{atom namelist} [@CA] [@CA,C,O,N,H]
@%{atom typelist} [@%CT] [@%N*,N3]

These "elementary selections" can be combined into more complex selections using binary operators "&" (and)
and "|" (or), unary operator "!" (negation), distance binary operators "< :", "> :", "< @", "> @", and
parentheses. Spaces around operators are irrelevant. Parentheses have the highest priority, followed by distance
operators ("< :", "> :", "< @", "> @"), "!" (negation), "&" (and) and "|" (or) in order of descending priority. A
wildcard "=" in an atom or residue name matches any name starting with a given character (or characters). For
example, [:AS=] would match all aspartic acid residues (ASP), and asparagines (ASN); [@H=] would match all
atom names starting with H (which are effectively all hydrogens). It cannot be used to match the end part of
names (such as [:=A]). Some examples of more complex selections follow:

[@C= & !@CA,C]

.. all carbons except backbone alpha and carbonyl carbon

[(:1-3@CA | :5-7@CB)]

.. alpha carbons in residues 1-3 and beta carbons in residues 5-7

[:CYS,ARG & !(:1-10 | @CA,CB)]

.. all CYS and ARG atoms except those which are in residues 1-10 and which are CA or CB

[:* & !@H=] or [!@H=]

.. all heavy atoms (i.e. except hydrogens)

[:5 <@4.5]

.. all atoms within 4.5A from residue 5

[(:1-55 <:3.0) & :WAT]

.. all water molecules within 3A from residues 1-55

Compound expressions of the following type are also allowed:

:{residue numlist|namelist}@{atom numlist|namelist|typelist}
[:1-10@CA] is equivalent to [:1-10 & @CA]
[:LYS@H=] is equivalent to [:LYS & @H=]

OPTIONS

The program needs an Amber topology ﬁle and coordinates (restrt format). The ﬁlename speciﬁed with the -p
option is Amber topology, while the ﬁlename given with the -c option is a coordinate ﬁle. If -p or -c options are
not given, the program expects that ﬁles "prmtop" and/or "inpcrd" exist in the current directory, which will be
taken as topology and coordinate ﬁles correspondingly. If no command line options are given, the program prints
the usage statement.

The option -prnlev speciﬁes how much (debugging) information is printed to stdout. If it is 0, only selected
atoms are printed. More verbose output (which might be useful for debugging purposes) is achieved with higher
values: 1 prints original "maskstr" in its tokenized (with operands enclosed in square brackets) and postﬁx (or
Reverse Polish Notation) forms; number of atoms and residues in the topology ﬁle and number of selected atoms
are also printed to stdout. 2 prints the resulting mask array, which is an array of integer values, with ’1’ representing
a selected atom, and ’0’ an unselected one. Value of 3, in addition, prints mask arrays as they are pushed or popped
from the stack (this is really only useful for tracing the problems occurring during stack operations). The -prnlev
values of 0 or 1 should sufﬁce for most uses.

412

21.2. "Atom Expressions" in NAB Applications

The option -out speciﬁes the format of printed atoms. "short" means a condensed output using residue (:) and
atom (@) designators followed by residue ranges and atom names. "pdb" (default) prints atoms in Amber-style
PDB format with the original "maskstr" printed as a REMARK at the top of the PDB ﬁle, and "amber" prints
atom/residue ranges in the format suitable for copying into group input section of Amber input ﬁle.

The option -ﬁnd is followed by "maskstr" expression. This is a string where some characters have a special
meaning and thus express what parts (atoms/residues) of the molecule will get selected. The syntax of this string
is explained in the section above (DESCRIPTION). If this option is left out, it defaults to ":*", which selects all
atoms in the given topology ﬁle. The length of "maskstr" is limited to 80 characters. If the "maskstr" contains
spaces or special characters (which would be expanded by the shell), it should be protected by single or double
quotes (depending on the shell). In addition, for C-shells even a quoted exclamation character may be expanded
for history substitution. Thus, it is recommended that the operand of the negation operator always be enclosed in
parentheses so that "!" is always followed by a "(" to produce "!(" which disables the special history interpretation.
For example, [@C= & !(@CA,C)] selects all carbons except backbone alpha and carbonyl carbon; the parentheses
are redundant but shell safe. The man page indicates further ways to disable history substitution.

FILES

Assumes that prmtop and inpcrd ﬁles exists in the current directory if they are not speciﬁed with -p and -c options.
Resulting (i.e. selected) atoms are written to stdout.

BUGS

Because all atom names are left justiﬁed in Amber topology and the selections are case insensitive, there is no way
to distinguish some atom names: alpha carbon CA and a calcium ion Ca are a notorious example of that.

21.2. "Atom Expressions" in NAB Applications

NAB applications do not use the AMBER mask scheme outlined in the previous sections. They use simpler

(but less powerful) selection criteria. The scheme is:

chains(or "strands"):residues:atoms

For example, A:GLU:CA would select all Cα carbons of all glutamate residues in chain A. A plain :: would select
all atoms in all residues and all chains (not very useful). ::H* would select all hydrogen atoms in any chain and
any residue, the * being a wild card for any sequence of characters. Similarly, ::*C* would select all atoms which
contain at least one "C" character, i.e., the wild card can be used in any position. The ? can be used as a wild card
for a single character. Thus, ::H? would select any atom starting with H plus one additional character (e.g., HC,
H1, HN, but not HG11).

The wild card can also be used in residue names. :A*: would select all alanines, asparagines, and arginines.
Selections can be combined separated by a vertical bar "|". :1-3,ALA:C*|:2-5:N* would select all carbon
atoms in residues 1 to 3, in all alanines and all nitrogen atoms in all residues from 2-5. If you would like to tether
all Cα atoms of a protein and the oxygen atom of explicit water molecules (with residue names ’WAT’), you would
use ::CA|:WAT:O*.

Output from NAB applications always tells how many atoms have been selected for a special treatment. If you
are not sure that your selection is correct, this number might at least be a hint. If you run a simulation with a protein
having 200 residues and want to tether all Cα carbons, ::CA should result in 200 selected atoms (provided that all
residues have a well-deﬁned CA atom, which they should).

21.3. GROUP Speciﬁcation

This section describes the format used to deﬁne groups of atoms in various Amber programs. In sander, a
group can be speciﬁed as a movable "belly" while the other atoms are ﬁxed absolutely in space (aside from scaling
caused by constant pressure simulation), and/or a group of movable atoms can independently restrained (held by

413

21. Atom and Residue Selections

a potential) at their positions. In anal, groups can be deﬁned for energy analysis. In sander and pmemd, GROUP
input comes at the end of the mdin input ﬁle, as discussed in Section 19.5.

Except in the analysis module where different groups of atoms are considered with different group numbers
for energy decomposition, in all other places the groups of atoms deﬁned are considered as marked atoms to be
included for certain types of calculations. In the case of constrained minimization or dynamics, the atoms to be
constrained are read as groups with a different weight for each group.

Reading of groups is performed by the routine RGROUP, and you are advised to consult it if there is still some

ambiguity in the documentation.

Input description:

- 1 - Title format(20a4)
ITITL Group title for identification.
Setting ITITL = ’END’ ends group input.
------------------------------------------------------------------------
- 1A - Weight format(f)
This line is only provided/read when using GROUP input to
define restrained atoms.
WT The harmonic force constants in kcal/mol-A**2 for the group
of atoms for restraining to a reference position.
------------------------------------------------------------------------
- 1B - Control to define the group
KTYPG , (IGRP(I) , JGRP(I) , I = 1,7) format(a,14i)
KTYPG Type of atom selection performed. A molecule can be
defined by using only ’ATOM’ or ’RES’, or part of the
molecule can be defined by ’ATOM’ and part by ’RES’.
’ATOM’ The group is defined in terms of atom numbers. The atom
number list is given in igrp and jgrp.
’RES’ The group is defined in terms of residue numbers. The
residue number list is given in igrp and jgrp.
’FIND’ This control is used to make additional conditions
(apart from the ’ATOM’ and ’RES’ controls) which a given
atom must satisfy to be included in the current group.
The conditions are read in the next section (1C) and are
terminated by a SEARCH card.
Note that the conditions defined by FIND filter any set(s) of atoms
defined by the following ATOM/RES instructions. For example,
-- group input: select main chain atoms --
FIND
* * M *
SEARCH
RES 1 999
END
END
’END’ End input for the current group. Followed by either another
group definition (starting again with line 1 above), or by a second
’END’ "card", which terminates all group input.
IGRP(I) , JGRP(I)
The atom or residue pointers. If ktypg .eq. ’ATOM’ all
atoms numbered from igrp(i) to jgrp(i) will be put into
the current group. If ktypg .eq. ’RES’ all atoms in the
residues numbered from igrp(i) to jgrp(i) will be put
into the current group. If igrp(i) = 0 the next control
card is read.
It is not necessary to fill groups according to the
numerical order of the residues. In other words, Group 1
could contain residues 40-95 of a protein, Group 2 could
contain residues 1-40 and Group 3 could contain residues

414

21.3. GROUP Speciﬁcation

96-105.
If ktypg .eq. ’RES’, then associating a minus sign with
igrp(i) will cause all residues igrp(i) through jgrp(i)
to be placed in separate groups.
In the analysis modules, all atoms not explicitly defined
as members of a group will be combined as a unit in the
(n + 1) group, where the (n) group in the last defined
group.
------------------------------------------------------------------------
- 1C - Section to read atom characteristics
***** Read only if KTYPG = ’FIND’ *****
JGRAPH(I) , JSYMBL(I) , JTREE(I) , JRESNM(I) format(4a)
A series of filter specifications are read. Each filter consists
of four fields (JGRAPH,JSYMBL,JTREE,JRESNM), and each filter is placed
on a separate line. Filter specification is terminated by a line with
JGRAPH = ’SEARCH’. A maximum of 10 filters may be specified for a
single ’FIND’ command.
The union of the filter specifications is applied to the atoms defined
by the following ATOM/RES cards. I.e. if an atom satisfies any of the
filters, it will be included in the current group. Otherwise, it is not
included. For example, to select all non main chain atoms from residues
1 through 999:
-- group input: select non main chain atoms --
FIND
* * S *
* * B *
* * 3 *
* * E *
SEARCH
RES 1 999
END
END
’END’ End input for the current group. Followed by either another
The four fields for each filter line are:
JGRAPH(I) The atom name of atom to be included. If this and the
following three characteristics are satisfied the atom is
included in the group. The wild card ’*’ may be used to
to indicate that any atom name will satisfy the search.
JSYMBL(I) Amber atom type of atom to be included. The wild card
’*’ may be used to indicate that any atom type will
satisfy the search.
JTREE(I) The tree name (M, S, B, 3, E) of the atom to be included.
The wild card ’*’ may be used to indicate that any tree
name will satisfy the search.
JRESNM(I) The residue name to which the atom has to belong to be
included in the group. The wild card ’*’ may be used to
indicate that any residue name will satisfy the search.
------------------------------------------------------------------------

Examples:

The molecule 18-crown-6 will be used to illustrate the group options. This molecule is composed of six repeating
(-CH2-O-CH2-) units. Let us suppose that one created three residues in the PREP unit: CRA, CRB, CRC. Each
of these is a (-CH2-O-CH2-) moiety and they differ by their dihedral angles. In order to construct 18-crown-6, the
residues CRA, CRB, CRC, CRB, CRC, CRB are linked together during the LINK module with the ring closure
being between CRA(residue 1) and CRB(residue 6).

Input 1:

Title one

415

21. Atom and Residue Selections

RES 1 5
END
Title two
RES 6
END
END

Output 1: Group 1 will contain residues 1 through 5 (CRA, CRB, CRC, CRB, CRC) and Group 2 will contain
residue 6 (CRB).

Input 2:

Title one
RES 1 5
END
Title two
ATOM 36 42
END
END

Output 2: Group 1 will contain residues 1 through 5 (CRA, CRB, CRC, CRB, CRC) and Group 2 will contain
atoms 36 through 42. Coincidentally, atoms 36 through 42 are also all the atoms in residue 6.

Input 3:

Title one
RES -1 6
END
END

Output 3: Six groups will be created; Group 1: CRA, Group 2: CRB,..., Group 6: CRB.

Input 4:

Title one
FIND
O2 OS M CRA
SEARCH
RES 1 6
END
END

Output 4: Group 1 will contain those atoms with the atom name ’O2’, atom type ’OS’, tree name ’M’ and residue
name ’CRA’.

Input 5:

Title one
FIND
O2 OS * *
SEARCH
RES 1 6
END
END

Output 5: Group 1 will contain those atoms with the atom name ’O2’, atom type ’OS’, any tree name and any
residue name.

Input 6:

Title one
RES 1 3 6 6
END
END

416

Output 6: One group is created containing residues 1 to 3 and 6. Up to seven ranges of contiguous residues can
be speciﬁed per group. (In this case there are two ranges).

Input 7:

21.3. GROUP Speciﬁcation

25 36

First restraint group
10.0
FIND
CA * * *
SEARCH
RES 1 17
END
Second restraint group, with a different restraint weight
1.0
FIND
CA * * *
SEARCH
RES 61 127
END
END

Output 7: CA atoms in residues 1-17 and 25-36 will be restrained to their initial positions with a strong weight of
10.0kcal· mol−1 · Å

−2; CA atoms in residues 61 to 127 will have a weaker restraint force constant.

417

22. Sampling conﬁguration space

The "middle" scheme [Section 19.6.10] offers an efﬁcient approach to accurately sample conﬁguration space
in standard molecular dynamics simulations. There are many instances when standard molecular dynamics sim-
ulations get “stuck” near the starting conﬁguration, and fail to adequately sample the available low-energy con-
ﬁgurational space. This chapter describes a variety of techniques that can partially overcome such problems. The
following chapter (on Free Energies) continues many of these ideas, adapting them to the calculation of alchemical
or conﬁgurational free energy differences. There is no good distinction between these two chapters, because good
sampling of the canonical distribution and estimation of free energies go hand-in-hand. But the present chapter
covers methods that are primarily devoted to enhanced or accelerated sampling, whereas the following chapter
considers methods that explicitly estimate free energy differences.

22.1. Self-Guided Langevin dynamics

Self-guided Langevin dynamics (SGLD) is designed to enhance conformational search efﬁciency in either
a molecular dynamics (MD) simulation (when gamma_ln=0) or a Langevin dynamics (LD) simulation (when
gamma_ln>0). This method accelerates low frequency motion to enhance conformational sampling. [451–454]

Overview: The input parameter, tsgavg, deﬁnes the lower limit period of the low frequency motion. Typically,
tsgavg=0.2 ps is recommended for motions like phase separation, secondary structure folding, and ligand docking,
while tsgavg=1.0 ps is recommended for protein domain motion, and protein-protein docking. The input parameter,
sgft or tempsg, deﬁnes the strength of the guiding effect. sgft=0~1 with 0 for regular LD or MD simulations. A
smaller sgft will produce results closer to a normal MD or LD simulation. tempsg deﬁnes a conformational search
ability that is comparable to a high temperature simulation at temp0=tempsg. Normally, tempsg or sgft is set
to accelerates slow events to an affordable time scale while minimizing the pertubation to the conformational
distribution. The guiding force can be applied to a part of a simulation system between atom isgsta and atom
isgend.

The conformational distribution of SGLD can be reweighted to produce canonical ensemble averages[452, 455].
The reweighting information is in the simulation output ﬁle. The force-momentum based SGLD algorithm
(SGLDfp) [456] (isgld=2) is available to allow conformational search to be accelerated while the canonical ensem-
ble distribution is maintained. However, the conformational searching abilities of SGLDfp is reduced as compared
with SGLD (isgld=1). Most recently, the generalized SGLD method [454](SGLDg) (isgld=3) is developed to en-
hance conformational search in both LD (when gamma_ln>0) and MD (when gamma_ln=0) simulations. SGLDg
is more convenient and ﬂexible and has better characterized conformational distribution and can be an replacement
of normal LD to sample the canonical ensemble by setting tempsg=temp0.

• SGLDfp (isgld=2) allows low resolution structures, such as secondary structures and tertiary structures,

and/or high resolution structures, such as bond lengths and bond angles, to be canonically sampled.

• SGLDg (isgld=3) utilizes independent low-frequency and high frequency Langevin equations to character-
ize the conformational searching and distribution. It provides options to use the force guiding factor, sgff, to
control energy barriers in low frequency space and to use the guiding temperature, tempsg, and the momen-
tum guiding factor, sgft, to enhance low frequency motion. When tempsg is set to the simulation temperature
(tempsg=temp0), SGLDg samples exactly the canonical ensemble and is an excellent replacement for regu-
lar Langevin dynamics with enhanced conformational sampling ability, especially when the friction constant
is high, for example, gamma_ln>10/ps. SGLDg is recommended when a cannonical distribution needs be
maintained (tempsg=temp0) or reweighted (tempsg>temp0).

418

SGLD can be used for replica exchange simulations (RXSGLD)[457] to achieve enhanced sampling with or with-
out elevating temperature. sgft or tempsg can be used to deﬁne different replicas. See Section 23.3.6 for a detailed
description of RXSGLD.

22.1. Self-Guided Langevin dynamics

isgld

tsgavg

sgft

sgff

tempsg

isgsta

isgend

fixcom

treflf

sgfd

SGLD algorithm index. Default isgld= 0, SGLD is diabled; isgld=1 will turn on SGMD/SGLD
method for accelerated conformational search; isgld=2 will turn on the SGLDfp method [456] to
maintain a canonical ensemble distribution. isgld=3 will enable SGLDg/SGMDg method.

Local averaging time (psec) for the guiding force calculation. Default 0.2 psec. A larger value
deﬁnes slower motion to be enhanced.

Momentum guiding factor. Deﬁnes the strength of the guiding effect. Default 1.0 when gamma_ln>0
(SGLD), 0.2 when gamma_ln=0 (SGMD), or 0 for SGLDg or 1 for SGMDg (isgld=3). When is-
gld=1 or 2, tempsg>0 will override sgft. When isgld=3 and gamma_ln=0, i.e., SGMDg, sgft repre-
sents the guiding friction constant in the unit of 1/ps and should be set to a positive value.

Force guiding factor for SGLDg or SGMDg (isgld=3). sgff is used to scale down low frequency
energy surface by a factor, (1+sgff ). sgff is suggested to take values between 0 and -0.1, with default
value of 0. sgff is effective for SGMDg (isgld=3 and gamma_ln=0) simulations .

Target guiding temperature (K). This parameter is redeﬁned since Amber 12 as a conformational
search ability which is comparable to a high temperature simulation with temp0=tempsg. For ex-
ample, by seting tempsg=500K, a SGMD/SGLD simulation will accelerate conformational search
as much as rising the simulation temperature to 500K. When isgld=1 or 2, the default is tempsg=0
K. When tempsg=0, the guiding effect will be deﬁned by sgft. tempsg>temp0 will accelerate a con-
formational search and tempsg<temp0 will slow down a conformational search. When isgld=1 or 2,
once tempsg is set, sgft will ﬂuctuate to reach the target conformational search ability. When isgld=3
(SGLDg), the default is tempsg=temp0, which allows the canonical ensemble will be sampled. When
tempsg<>temp0, the reweighting factor can be found in the SGLD output lines described below.

The ﬁrst atom index of SGLD region. Default is 1.

The last atom index of SGLD region. Default is natom.

Option to remove the net translation of the center of mass. For ﬁnite systems it is often more conve-
nient to have the center of mass ﬁxed. Default 0 when gamma_ln>0 or 1 when gamma_ln=0. When
ﬁxcom>0, the center of mass is ﬁxed.

Reference low frequency temperature. Default 0.0. treﬂf is the low frequency temperature when no
guiding force is applied to a simulation system (sgft=0). treﬂf is required for the weighting factor
calculation in SGMD/SGLD simulation (isgld=1) or for the guiding force calculation in SGMDf-
p/SGLDfp simulations (isgld=2). treﬂf is not needed in SGLDg or SGMDg (isgld=3) simulations.
When treﬂf =0, treﬂf will be estimated during a simulation. An accurate value of treﬂf can increase
the accuracy in the weighting factor calculation in SGMDfp/SGLDfp simulations.

Optional high frequency force guiding factor for SGLDfp (isgld=2). Should not be set if confor-
mational distribution in high resolution need be maintained. When not set, its instantaneous value
(printed out in simulation output ﬁles) ﬂuctuates to maintain high resolution conformational distri-
bution.

The output of SGMD/SGLD simulations contains the following properties related to the enhancement in confor-
mational search and reweighting of conformational distribution:

SGLF = SGFT TEMPSG TEMPLF TREFLF FRCLF EPOTLF SGWT
SGHF = SGFF SGFD TEMPHF TREFHF FRCHF EPOTHF VIRSG

These quantities are instantaneous values deﬁned as below:

SGFT: Momentum guiding factor,

419

22. Sampling conﬁguration space

SGFF: Force guiding factor. Adjusted in SGLDfp simulations (isgld=2)
SGFD: Force dumping factor. Adjusted in SGLDfp simulations (isgld=2)
TEMPSG: Guiding temperature.
SGWT: Weighting free energy. exp(SGWT) is the weighting factor of current frame.
VIRSG: Virial of the guiding force.
TEMPLF: low frequency temperature
TEMPHF: high frequency temperature
TREFLF: reference low frequency temperature. It is the TEMPLF at SGFT=0 and TEMPSG=0.
TREFHF: reference high frequency temperature. It is the TEMPHF at SGFT=0 and TEMPSG=0.
FRCLF: low frequency force factor
FRCHF: high frequency force factor
EPOTLF: low frequency potential energy
EPOTHF: high frequency potential energy
The weight of a conformation is calculated by

Weight=exp(SGWT) =exp(((FRCLF*TREFLF/TEMPLF-1)*EPOTLF+
(FRCHF*TREFHF/TEMPHF-1)*EPOTHF+VIRSG)/(KBOLTZ*Temp))

or:

(cid:18)

(λLF

wi = exp

T 0
LF
TLF

− 1)

ELF
kT + (λHF

T 0
HF
THF

− 1)

EHF
kT +

Wsg
kT

(cid:19)

For convenience, two scripts, sgldinfo.sh and sgldwt.sh, are provided in the AMBERHOME/bin directory to
extract SGLD properties and weighting factors from sander output ﬁles. For example, one can run:

sgldinfo.sh mdout

to examine the SGLD properties, and run:

sgldwt.sh mdout

to print weighting factors at each print time frame. One may specify TREFLF, e.g., 23.5 K, and/or TREFHF, e.g.,
278.2 K, for more accurate weighting factors:

sgldwt.sh mdout 23.5 278.2

TREFLF and TREFHF can be obtained with sgldinfo.sh from a SGLD simulation at the same condition except
SGFT=0 and TEMPSG=0. Without specifying TREFLF and TREFHF, they will be estimated for the calculation.
Ensemble average properties are calculated through reweighting:



For SGLDfp (isgld=2) and SGLDg (isgld=3) simulations, no reweighting is needed.

Here is an example of a SGLD simulation input ﬁle:

< P >=

∑N
i=N0 wiPi
∑N
i=N0 wi

Sample SGLD simulation to reach a 500K conformational search ability
&cntrl
nstlim=1000, cut=99.0, igb=1, saltcon=0.1,
ntpr=100, ntwr=100000, ntt=3, gamma_ln=10.0,
ntx=5, irest=1, ig = 256251,
ntc=2, ntf=2, tol=0.000001,
dt=0.002, ntb=0, tempi=300., temp0=300.,
isgld=1,tsgavg=0.2,tempsg=500,

/

420














/


Below is an example of a SGLDg simulation input ﬁle to sample the canonical ensemble while accelerate

conformational search:

22.2. Accelerated Molecular Dynamics

Sample SGLDg simulation for efficient conformational sampling
&cntrl
nstlim=1000, cut=99.0, igb=1, saltcon=0.1,
ntpr=100, ntwr=100000, ntt=3, gamma_ln=10.0,
ntx=5, irest=1, ig = 256251,
ntc=2, ntf=2, tol=0.000001,
dt=0.002, ntb=0, tempi=300., temp0=300.,
isgld=3,tsgavg=0.2,tempsg=300,sgft=0.5,sgff=-0.1,

Below is an example of a SGMDg simulation input ﬁle for accelerated conformational search:

Sample SGLDg simulation for efficient conformational sampling
&cntrl
nstlim=1000, cut=99.0, igb=1, saltcon=0.1,
ntpr=100, ntwr=100000, ntt=1, gamma_ln=0.0,
ntx=5, irest=1, ig = 256251,
ntc=2, ntf=2, tol=0.000001,
dt=0.002, ntb=0, tempi=300., temp0=300.,
isgld=3,tsgavg=0.2,tempsg=500,sgft=1,sgff=-0.1,

/

22.2. Accelerated Molecular Dynamics

22.2.1. Introduction

Many systems of interest in chemistry, physics and biology are characterized by the presence of a number of
metastable states separated by large barriers. Correctly sampling these systems is challenging for methods based on
Molecular Dynamics, Monte Carlo sampling or any other type of dynamic simulation. For most biological systems
of interest, the simulation time is limited to the nanosecond-microsecond time scale, so simple molecular dynamics
cannot be used to adequately explore portions of the energy landscape separated by high barriers from the initial
minimum. Furthermore, for most biological molecules, the energy landscape has multiple minima or potential
energy wells with high free energy barriers, and during a molecular dynamics simulation the system is trapped in
one or another local minimum for long periods of simulation time. Consequently, thermodynamics and many other
properties of interest for large biological systems cannot be simulated directly because of the nonergodic nature of
the present state of the molecular dynamics methodology for systems with high free energy barriers.

Accelerated Molecular Dynamics (aMD) is a bias potential introduced by the McCammon group at UCSD [458].
It is a modiﬁcation to the potential that in practice reduces the height of local barriers, allowing the calculation
to evolve much faster. A number of methods have been suggested to aid this problem, like replica exchange,
metadynamics, etc. AMD represents an interesting option as it only requires the evolution of a single copy of the
system, plus it doesn’t require any previous knowledge of the shape of the potential, i.e. aMD doesn’t require
information of where are the barriers, saddle points or even what type of conﬁguration changes are expected or
necessary to traverse through a particular barrier. Moreover, an interesting feature of aMD is that the shape of
the added potential conserves the underlying shape of the real one, such that minima are maintained as minima
and barriers are preserved as barriers. In result, adding the aMD potential in practice simply modiﬁes the relation
between energy differences, so the distribution of sampling of different structures is still related to the original
potential distribution and can be recovered exactly by reweighing.

The aMD modiﬁcation of the potential is deﬁned by the following equation:

V(r)∗ = V (r) + ∆V (r)

(22.1)

421

22. Sampling conﬁguration space

∆V (r) =

(E p−V (r))2

(αP + E p−V (r))

+

(Ed −V d(r))2

(αD + Ed −V d(r))

(22.2)

where V (r) is the normal potential and V d(r) is the normal torsion potential. Ep and Ed are average potential
and dihedral energies that serve as a reference energy from which to compare the present position of the calculation
and therefore the relationship to the boosting factor to be applied. The terms αP and αD are factors that determine
inversely the strength with which the boost is applied. For large values of alpha, the potential felt at any point
will essentially be the same as the true potential For values of alpha close to zero, the potential felt becomes
constant, in this limit, the sampling becomes a random walk. The amount of boost felt at a particular point in
the calculation, therefore, depends on the present value of the potential and dihedral energy, which is in direct
correlation to how low in the energy surface the conﬁguration is positioned at that moment. The boosting potential
will be proportionally bigger for deeper regions of the potential energy surface, while it will be smaller for higher
points, which in result conserves the underlying shape of the potential, as previously mentioned.

AMD has been applied to a vast diversity of interesting problems [459–463]. We have recently applied the
implementation of aMD in Amber to the Bovine Pancreatic Trypsin Inhibitor and compared with an unbiased
millisecond MD simulation, showing aMD is able to recover the right population distribution and shows excellent
agreement with the MD simulation as with experimental data [462].

22.2.2. AMD implementation in Amber

AMD has been implemented in both sander and pmemd by Romelia Salomon-Ferrer. The implementation
includes the possibility of boosting independently only the torsional terms of the potential (iamd=2) or the whole
potential at once (iamd=1). It also allows the possibility to boost the whole potential with an extra boost to the
torsions(iamd=3). All the information generated by aMD, necessary for reweighing is stored at each step into a
vector which is ﬂushed to a log ﬁle (amd.log by default) every time the coordinates are written to disk, i.e. every
ntwx steps. This is done for performance reasons, since writing to disk is always time consuming and it is not
advisable to do it every step. The name of the log ﬁle can be set to a user deﬁned name by using the command
line option -amdlog when running Amber. Our present implementation also allows the user to delay (or lag) the
boosting a number of steps, i.e. only boost with a particular frequency deﬁned by the variable amdlag. Additional
parameters are speciﬁed by the following variables: EthreshD (Ed), alphaD (αD), EthreshP (Ep) and alphaP (αP).
AMD output is saved the amd.log this ﬁle contains all the information needed for reweighting the results obtained
to recover the unperturbed distributions. The amd.log ﬁle gets written with the same frequency at which the
conﬁgurations are saved to disk in the trajectory ﬁle (mdcrd). Each line corresponds to the information of a
corresponding snapshot being saved on the mdcrd ﬁle. Regardless of what iamd value is used, the number of
columns in the amd.log ﬁle are always the same, they just have 0 or 1 (correspondingly) if no boost is being added
to dihedral or total energy

The amd.log ﬁle has the following header:

#All energy terms stored in units of kcal/mol
#ntwx,total_nstep,Unboosted-Potential-Energy,Unboosted-Dihedral-Energy,Total-Force-Weight,
Dihedral-Force-Weight,Boost-Energy-Potential,Boost-Energy-Dihedral

The description for the main columns is as follows:

• Unboosted-Potential-Energy: Total Potential Energy without boost added, kcal/mol.

• Unboosted-Dihedral-Energy: dihedral energy without boost added, kcal/mol.

• Total-Force-Weight: The force scaling factor calculated from the boost to the Total Potential Energy

• Dihedral-Force-Weight: The dihedral force scaling factor from dihedral boost

• Boost-Energy-Potential: The boost energy in kcal/mol

• Boost-Energy-Dihedral: The dihedral boost energy in kcal/mol

422

22.2. Accelerated Molecular Dynamics

IMPORTANT NOTE: Before Amber 14 the boost energy for the dihedral and total potential energy (last two
columns) was given in units of kT. This decision was made at the beginning with the idea that the user could read
and use these values directly for reweighting without any further work, but later it we decided it was much better
and more consistent to have all energy output in kcal/mol as the rest of AMBER’s energy output. As of AMBER
14, the last two columns of the amd.log ﬁle as given in units of kcal/mol.

Reweighting

For reweighting aMD results we would like to add the link to a great tutorial
(http://mccammon.ucsd.edu/computing/amdReweighting/) which also provides a small python script to perfom
the reweighting. The script is compatible with the newer versions of AMBER, and can be used to reweight 1D
and 2D distributions. A simple C code is also provided in the aMD tutorial that performs reweighting based on
the Kernel Density Estimation algorithm. This algorithm also performs very well and reduces the amount of noise
without using a truncated expression for the exponential and can be used as an alternative for reweighting. To
extract the energies from the amd.log ﬁle into a ﬁle, weights.dat, to use with this script, something like the
following could be done:

# Column 1: dV in units of kbT; column 2: timestep; column 3: dV in units of kcal/mol
# For AMBER14: # awk ’NR%1==0’ amd.log | awk ’{print ($8+$7)/(0.001987*300)

" " $2 " " ($8+$7)}’ > weights.dat

# For AMBER12: # awk ’NR%1==0’ amd.log | awk ’{print ($8+$7)" " $3

" " ($8+$7)*(0.001987*300)}’ > weights.dat

For reweighting a 2D distribution, for instance a Phi Psi distribution, you would need to extract the values for Phi
and Psi for each frame in the mdcrd ﬁle using AmberTools and generate the ﬁle Phi_Psi ﬁle and then use the
python tool provided in the website to get the reweighted surface.

python PyReweighting-2D.py -input Phi_Psi -Emax 100 -discX 6 -discY 6

-job amdweight_MC -order 10 -weight weights.dat | tee -a reweight_variable.log

For reweighting using a Maclaurin series expansion as an approximation for the exponential weight.

22.2.3. Preparing a system for aMD

As mentioned before, running aMD requires the deﬁnition of few parameters. AMD parameters are determined

based on previous knowledge of the system, which is easily acquirable by a short regular MD simulation, from
which the average values of the potential and torsion energy can be estimated. From there, a given amount of
energy per degree of freedom is added those values, in the form of multiples of alpha, setting the values of Ep and
Ed to be used. The following example should help clarify this procedure.

Average Dihedral : 611.5376 (based on MD simulations)
Average EPtot : -53155.3104 (based on MD simulations)
total ATOMS=16950
protein residues=64

For the dihedral potential:

Approximate energy contribution per degree of freedom.
3.5*64= 224
alphaD = (1/5)*224 = 45 The value of .2 seems to work well
EthreshD = 224+611 = 835

The value of 3.5 kcal/mol/residue seems to work well

423

22. Sampling conﬁguration space

For the total potential
alphaP = 16950*(1/5)=3390
For a lower boost you can also use a value between 0.15-0.19 instead of 0.20 (0.16 works well)
EthreshP = -53155.3104 + 3390 = -49765.3104
With these parameters, the aMD parameters in the input file should then be set to
iamd=3,EthreshD=835,alphaD=45,EthreshP=-49765,alphaP=3390,
For a higher acceleration it is common to simply add to Eb(dih) multiples of alpha. In this example, one level of acceleration higher than the base for the diedral potential would be defined by:
iamd=3,EthreshD=880,alphaD=45,EthreshP=-49765,alphaP=3390,
Two levels higher would be then defined by:
iamd=3,EthreshD=925,alphaD=45,EthreshP=-49765,

After the aMD parameters to be used are deﬁned, an MD run with aMD can be set using those parameters. De-
pending on the progress of the simulation, a higher boost can be applied as speciﬁed in the above example.

22.2.4. Sample input ﬁle for aMD

An example of an input ﬁle would be the following:

AVP dt=2.0fs with SHAKE, NPT aMD boost pot and dih

&cntrl

imin=0, irest=1, ntx=5,
dt=0.002, ntc=2, ntf=2, tol=0.000001,iwrap=1,
ntb=2, cut=12.0, ntp=1,igb=0,ntwprt = 3381,ioutfm = 1,
ntt=3, temp0=310.0, gamma_ln=1.0, ig=-1,
ntpr=1000, ntwx=1000, ntwr=2000000, nstlim=2000000,
iamd=3,EthreshD=835,
alphaD=45,EthreshP=-49765,
alphaP=3390,

/

&ewald
dsum_tol=0.000001,

/

22.2.5. Further information

Test cases have been included into the distribution of Amber, also a tutorial based on a study we performed on
BPTI [462], showing the power of aMD and its validation versus a millisecond run on the same system performed
on Anton is now present on the Amber website. We encourage the user to read the paper, as well as follow the
tutorial for more information.

22.3. Gaussian Accelerated Molecular Dynamics

22.3.1. Introduction

Gaussian Accelerated Molecular Dynamics (GaMD) is a biomolecular enhanced sampling method that works
by adding a harmonic boost potential to smooth the system potential energy surface. The boost potential fol-
lows Gaussian distribution, which allows for accurate reweighting using cumulant expansion to the second order.
GaMD has been demonstrated on simulations of alanine dipeptide, chignolin folding and ligand binding to the
T4-lysozyme [464]. GaMD enables unconstrained enhanced sampling of these biomolecules without the need to
set predeﬁned reaction coordinates. Furthermore, the free energy proﬁles obtained from reweighting of the GaMD
simulations help identify distinct low energy states of the biomolecules and characterize the protein folding and
ligand binding pathways quantitatively.

The basic theory of GaMD can be found in References [464, 465], or at http://miao.compbio.ku.edu/GaMD.

424

22.3. Gaussian Accelerated Molecular Dynamics

22.3.2. Ligand Gaussian Accelerated Molecular Dynamics (LiGaMD)

A new algorithm called ligand GaMD or “LiGaMD” has been developed to simulate ligand binding and
unbinding[466]. It works by selectively boosting the ligand non-bonded interaction potential energy. Another
boost potential could be applied to the remaining potential energy of the entire system in a dual-boost algorithm
(LiGaMD_Dual) to facilitate ligand binding. LiGaMD has been demonstrated on host-guest and protein-ligand
binding model systems. Repetitive guest binding and unbinding in the β-cyclodextrin host were observed in
hundreds-of-nanosecond LiGaMD simulations. The calculated binding free energies of guest molecules with
sufﬁcient sampling agreed excellently with experimental data (< 1.0 kcal/mol error). In comparison with pre-
vious microsecond-timescale conventional molecular dynamics simulations, accelerations of ligand kinetic rate
constants in LiGaMD simulations were properly estimated using Kramers’ rate theory. Furthermore, LiGaMD
allowed us to capture repetitive dissociation and binding of the benzamidine inhibitor in trypsin within 1 s simu-
lations. The calculated ligand binding free energy and kinetic rate constants compared well with the experimental
data. Therefore, LiGaMD provides a promising approach for characterizing ligand binding thermodynamics and
kinetics simultaneously.

Next, one can add multiple ligand molecules in the solvent to facilitate ligand binding to proteins in MD sim-
ulations. This is based on the fact that the ligand binding rate constant kon is inversely proportional to the ligand
concentration. The higher the ligand concentration, the faster the ligand binds, provided that the ligand concentra-
tion is still within its solubility limit. In addition to selectively boosting the bound ligand, another boost potential
could thus be applied on the unbound ligand molecules, protein and solvent to facilitate both ligand dissociation
and rebinding.

22.3.3. Peptide Gaussian Accelerated Molecular Dynamics (Pep-GaMD)

Peptides often undergo large conformational changes during binding to the target proteins, being distinct from
small-molecule ligand binding or protein-protein interactions. We have developed another algorithm called peptide
GaMD or “Pep-GaMD” that enhances sampling of peptide-protein interactions (manuscript in preparation). See
http://miao.compbio.ku.edu/GaMD for more information.

22.3.4. Implementations of GaMD, LiGaMD and Pep-GaMD algorithms in Amber

GaMD has been implemented in pmemd, both the serial and parallel versions on CPU (pmemd and pmemd.MPI)
and GPU (pmemd.cuda and pmemd.cuda.MPI) by Yinglong Miao. Note that GaMD is not available in Sander.
Similar to aMD, GaMD provides options about what energies to boost (see the igamd variable.) The dual-boost
simulation generally provides higher acceleration than the other single-boost simulations for enhanced sampling.
LiGaMD has been implemented by Yinglong Miao in only the serial GPU version of pmemd (pmemd.cuda). It
provides options to boost only non-bonded potential energy of the bound ligand (LiGaMD, igamd=10) and in addi-
tion the total system potential energy other than the non-bonded potential energy of bound ligand (LiGaMD_Dual,
igamd=11). LiGaMD_Dual generally provides higher acceleration than LiGaMD for enhanced sampling. The
simulation parameters comprise of settings for calculating the threshold energy values and the effective harmonic
force constants of the boost potentials.

Pep-GaMD has been implemented by Jinan Wang in only the serial GPU version of pmemd (pmemd.cuda).
It provides options to boost only the peptide potential energy (Pep-GaMD, igamd=14) and in addition the total
system potential energy other than the peptide potential energy (Pep-GaMD_Dual, igamd=15). Pep-GaMD_Dual
generally provides higher acceleration than Pep-GaMD for enhanced sampling. The simulation parameters com-
prise of settings for calculating the threshold energy values and the effective harmonic force constants of the boost
potentials.

All the information generated by GaMD, necessary for reweighing is stored at each step into a vector which
is ﬂushed to a log ﬁle (gamd.log by default) every time the coordinates are written to disk, i.e. every ntwx steps.
The name of the log ﬁle can be set to a user deﬁned name by using the command line option -gamd when running
Amber. Additional parameters are speciﬁed by the following variables:

igamd

Flag to apply boost potential

425

22. Sampling conﬁguration space

= 0 (default) no boost is applied
= 1 boost on the total potential energy only
= 2 boost on the dihedral energy only
= 3 dual boost on both dihedral and total potential energy
=4 boost on the non-bonded potential energy only
=5 dual boost on both dihedral and non-bonded potential energy
=10 boost on non-bonded potential energy of selected region (deﬁned by timask1 and scmask1) as

for a ligand (LiGaMD)

=11 dual boost on both non-bonded potential energy of the bound ligand and remaining potential

energy of the rest of the system (LiGaMD_Dual)

=14 boost on the total potential energy of selected region (deﬁned by timask1 and scmask1) as for a

peptide (Pep-GaMD)

=15 dual boost on both the peptide potential energy and the total system potential energy other than

the peptide potential energy (Pep-GaMD_Dual)

iE

Flag to set the threshold energy E

iEP

iED

= 1 (default) set the threshold energy to the lower bound E = Vmax
= 2 set the threshold energy to the upper bound E = Vmin + (Vmax −Vmin)/k0
Flag to overwrite iE and set the threshold energy E for applying the ﬁrst boost potential in dual-boost
schemes
=1 (default) set the threshold energy to the lower bound E = Vmax
=2 set the threshold energy to the upper bound E = Vmin + (Vmax - Vmin)/k0

Flag to overwrite iE and set the threshold energy E for applying the second boost potential in dual-
boost schemes
= 1 (default) set the threshold energy to the lower bound E = Vmax
= 2 set the threshold energy to the upper bound E = Vmin + (Vmax −Vmin)/k0

ntcmdprep The number of preparation conventional molecular dynamics steps. This is used for system equi-
libration and the potential energies are not collected for calculating their statistics. The default is
200,000 for a simulation with 2 fs timestep.

The number of initial conventional molecular dynamics simulation steps. Potential energies are
collected between ntcmdprep and ntcmd to calculate their maximum, minimum, average and standard
deviation (Vmax, Vmin, Vavg, σV ). The default is 1,000,000 for a simulation with 2 fs timestep.

The number of preparation biasing molecular dynamics simulation steps. This is used for system
equilibration after adding the boost potential and the potential statistics (Vmax, Vmin, Vavg, σV ) are not
updated during these steps. The default is 200,000 for a simulation with 2 fs timestep.

The number of biasing molecular dynamics simulation steps. Potential statistics (Vmax, Vmin, Vavg,
σV) are updated between the ntebprep and nteb steps and used to calculate the GaMD acceleration
parameters, particularly E and k0. The default is 1,000,000 for a simulation with 2 fs timestep. A
greater value may be needed to ensure that the potential statistics and GaMD acceleration parameters
level off before running production simulation between the nteb and nstlim (total simulation length)
steps. Moreover, nstlim can be set to ntcmd+nteb, by which the potential statistics and GaMD accel-
eration parameters are updated adaptively throughout the simulation. This in some cases provides
more appropriate acceleration.

ntcmd

ntebprep

nteb

426

22.3. Gaussian Accelerated Molecular Dynamics

ntave

The number of simulation steps used to calculate the average and standard deviation of potential
energies. This variable has already been used in Amber. The default is set to 50,000 for GaMD
simulations. It is recommended to be updated as about 4 times of the total number of atoms in the
system. Note that ntcmdprep, ntcmd, ntebprep and nteb need to be multiples of ntave.

irest_gamd Flag to restart GaMD simulation

= 0 (default) new simulation. A ﬁle "gamd-restart.dat" that stores the maximum, minimum, av-
erage and standard deviation of the potential energies neeed to calculate the boost potentials
(depending on the igamd ﬂag) will be saved automatically after GaMD equilibration stage.

= 1 restart simulation (ntcmd and nteb are set to 0 in this case). The "gamd-restart.dat" ﬁle will be

read for restart.

sigma0P

sigma0D

The upper limit of the standard deviation of the ﬁrst potential boost that allows for accurate reweight-
ing. The default is 6.0 (unit: kcal/mol).

The upper limit of the standard deviation of the second potential boost that allows for accurate
reweighting in dual-boost simulations (e.g., igamd = 2, 3, 5, 11 and 15). The default is 6.0 (unit:
kcal/mol).

timask1

Speciﬁes atoms of the bound ligand or peptide in ambmask format. The default is an empty string.

scmask1

Speciﬁes atoms of the bound ligand that will be described using soft core in ambmask format in
LiGaMD. In Pep-GaMD, this ﬂag was only used to specify atoms of peptide in ambmask format, but
the peptide atoms will be not described using soft core. The default is an empty string.

nlig

ibblig

atom_p

atom_l

dblig

The total number of ligand molecules in the system. The default is 0.

The ﬂag to boost the bound ligand selectively with nlig > 1
=0 (default) no selective boost
=1 boost the bound ligand selectively out of nlig ligand molecules in the system

Serial number of a protein atom (starting from 1 for the ﬁrst protein atom) used to calculate the
ligand distance. It is used only when ibblig = 1. The default is 0.

Serial number of a ligand atom (starting from 1 for the ﬁrst ligand atom) used to calculate the ligand
distance to the protein. It is used only when ibblig = 1. The default is 0.

The cutoff distance between atoms atom_p and atom_l for determining whether the ligand is bound
in the protein. It is used only when ibblig = 1. The default is 4.0 Å.

22.3.5. Algorithms used

The GaMD algorithm is summarized as follows:



GaMD {

If (irest_gamd == 0) then

For i = 1, ..., ntcmd // run initial conventional molecular dynamics

If (i >= ntcmdprep) Update Vmax, Vmin
If (i >= ntcmdprep && i%ntave ==0) Update Vavg, sigmaV

End
Save Vmax,Vmin,Vavg,sigmaV to gamd_restart.dat file
Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV)

For i = ntcmd+1, ..., ntcmd+nteb // Run biasing molecular dynamics

deltaV = 0.5*k0*(E-V)**2/(Vmax-Vmin)

// simulation steps



427

22. Sampling conﬁguration space

V = V + deltaV
If (i >= ntcmd+ntebprep) Update Vmax, Vmin
If (i >= ntcmd+ntebprep && i%ntave ==0) Update Vavg, sigmaV

Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV)

End
Save Vmax,Vmin,Vavg,sigmaV to gamd_restart.dat file

else if (irest_gamd == 1) then

Read Vmax,Vmin,Vavg,sigmaV from gamd_restart.dat file

End if

For i = ntcmd+nteb+1, ..., nstlim // run production simulation

deltaV = 0.5*k0*(E-V)**2/(Vmax-Vmin)
V = V + deltaV

End

}

Subroutine Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV) {

if iE = 1 :

E = Vmax
k0' = (sigma0/sigmaV) * (Vmax-Vmin)/(Vmax-Vavg)
k0 = min(1.0, k0')

else if iE = 2 :

k0'' = (1-sigma0/sigmaV) * (Vmax-Vmin)/(Vavg-Vmin)
if 0 < k0'' <= 1 :

k0 = k0''
E = Vmin + (Vmax-Vmin)/k0

else

end

end

E = Vmax
k0' = (sigma0/sigmaV) * (Vmax-Vmin)/(Vmax-Vavg)
k0 = min(1.0, k0')

The LiGaMD algorithm is summarized as the following:

}


LiGaMD {

If (irest_gamd == 0) then

For i = 1, ..., ntcmd // run initial conventional molecular dynamics

If (i >= ntcmdprep) Update Vmax, Vmin
If (i >= ntcmdprep && i%ntave ==0) Update Vavg, sigmaV

End

Save Vmax,Vmin,Vavg,sigmaV to gamd_restart.dat file
Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV)
For i = ntcmd+1, ..., ntcmd+nteb // Run biasing molecular dynamics simulation steps

deltaV = 0.5*k0*(E-V)**2/(Vmax-Vmin)
V = V + deltaV
If (i >= ntcmd+ntebprep) Update Vmax, Vmin
If (i >= ntcmd+ntebprep && i%ntave ==0) Update Vavg, sigmaV
Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV)

End
Save Vmax,Vmin,Vavg,sigmaV to gamd_restart.dat file

else if (irest_gamd == 1) then

Read Vmax,Vmin,Vavg, sigmaV from gamd_restart.dat file

End if

lig0=1 // ID of the bound ligand

428




22.3. Gaussian Accelerated Molecular Dynamics

For i = ntcmd+nteb+1, ..., nstlim // run production simulation

If (ibblig>0 && i%ntave ==0) then // swap the bound ligand with lig0 for selective boost

For ilig = 1, ..., nlig

dlig = distance(atom_p, atom_l)
If (dlig <= dblig) blig=ilig

End
If (blig != lig0) Swap atomic coordinates, forces and velocities of ligands blig with lig0

End if

deltaV = 0.5*k0*(E-V)**2/(Vmax-Vmin)
V = V + deltaV

End

The Pep-GaMD algorithm is summarized as the following:

Pep-GaMD {

If (irest_gamd == 0) then

For i = 1, ..., ntcmd // run initial conventional molecular dynamics

If (i >= ntcmdprep) Update Vmax, Vmin
If (i >= ntcmdprep && i%ntave ==0) Update Vavg, sigmaV

End

Save Vmax,Vmin,Vavg,sigmaV to gamd_restart.dat file
Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV)
For i = ntcmd+1, ..., ntcmd+nteb // Run biasing molecular dynamics simulation steps

deltaV = 0.5*k0*(E-V)**2/(Vmax-Vmin)
V = V + deltaV
If (i >= ntcmd+ntebprep) Update Vmax, Vmin
If (i >= ntcmd+ntebprep && i%ntave ==0) Update Vavg, sigmaV
Calc_E_k0(iE,sigma0,Vmax,Vmin,Vavg,sigmaV)

End
Save Vmax,Vmin,Vavg,sigmaV to gamd_restart.dat file

else if (irest_gamd == 1) then

Read Vmax,Vmin,Vavg, sigmaV from gamd_restart.dat file

End if

For i = ntcmd+nteb+1, ..., nstlim // run production simulation

deltaV = 0.5*k0*(E-V)**2/(Vmax-Vmin)
V = V + deltaV

End

}


}


22.3.6. Sample input ﬁles

Here is a sample input ﬁle for GaMD:

&cntrl

imin = 0, irest = 0, ntx = 1,
nstlim = 17000000, dt = 0.002,
ntc = 2, ntf = 2, tol = 0.000001,
iwrap = 1, ntb = 1, cut = 8.0,
ntt = 3, temp0 = 300.0, tempi = 300.0,
ntpr = 50, ntwx = 50, ntwr = 500,
ntxo = 1, ioutfm = 1, ig = -1, ntwprt = 22,

igamd = 3, iE = 1, irest_gamd = 0,







429









22. Sampling conﬁguration space

ntcmd = 1000000, nteb = 1000000, ntave = 50000,
ntcmdprep = 200000, ntebprep = 200000,
sigma0P = 6.0, sigma0D = 6.0,

Add the following for LiGaMD_Dual simulations:

&end


igamd = 11, irest_gamd = 0,
ntcmd = 700000, nteb = 27300000, ntave = 140000,
ntcmdprep = 280000, ntebprep = 280000,
sigma0P = 4.0, sigma0D = 6.0, iEP = 2, iED=1,

icfe = 1, ifsc = 1, gti_cpu_output = 0, gti_add_sc = 1,
timask1 = ':225', scmask1 = ':225',
timask2 = '', scmask2 = '',

ibblig = 1, nlig = 10, atom_p = 2472, atom_l = 4, dblig = 3.7

Add the following parameters for Pep-GaMD simulations:

icfe = 1, ifsc = 1,gti_cpu_output = 0,gti_add_sc = 1,
timask1 = ':1-3', scmask1 = ':1-3',
timask2 = '', scmask2 = '',

igamd = 15, iE = 1, iEP = 1, iED = 1, irest_gamd = 0,
ntcmd = 1000000, nteb = 1000000, ntave = 50000,
ntcmdprep = 200000, ntebprep = 200000,
sigma0P = 6.0, sigma0D = 6.0,






22.3.7. Further information

Reweighting analysis of GaMD simulations is similar to that of previous aMD simulations, except that the
amd.log ﬁle name needs to be replaced by gamd.log. Test cases have been included into the distribution
of Amber, also a tutorial based on a study we performed on alanine dipeptide [464], demonstrating the us-
age of GaMD on unconstrained enhanced sampling and free energy calculation of biomolecules is available at
http://miao.compbio.ku.edu/GaMD. We encourage the user to read the paper, as well as follow the tutorial for
more information. The PyReweighting scripts are available at: http://miao.compbio.ku.edu/PyReweighting/.

22.4. Targeted MD

The targeted MD option adds an additional term to the energy function based on the mass-weighted root mean

square deviation of a set of atoms in the current structure compared to a reference structure. The reference
structure is speciﬁed using the -ref ﬂag in the same manner as is used for Cartesian coordinate restraints
(NTR=1). Targeted MD can be used with or without positional restraints. If positional restraints are not applied
(ntr=0), sander performs a best-ﬁt of the reference structure to the simulation structure based on selection in
tgtﬁtmask and calculates the RMSD for the atoms selected by tgtrmsmask. The two masks can be identical or
different. This way, ﬁtting to one part of the structure but calculating the RMSD (and thus restraint force) for
another part of the structure is possible. If targeted MD is used in conjunction with positional restraints (ntr=1),
only tgtrmsmask should be given in the control input because the molecule is ’ﬁtted’ implicitly by applying
positional restraints to atoms speciﬁed in restraintmask.
The energy term has the form:

E = 0.5 * TGTMDFRC * NATTGTRMS * (RMSD-TGTRMSD)**2

430

22.5. Multiply-Targeted MD (MTMD)

The energy will be added to the RESTRAINT term. Note that the energy is weighted by the number of atoms
that were speciﬁed in the tgtrmsmask (NATTGTRMS). The RMSD is the root mean square deviation and is mass
weighted. The force constant is deﬁned using the tgtmdfrc variable (see below). This option can be used with
molecular dynamics or minimization. When targeted MD is used, sander will print the current values for the
actual and target RMSD to the energy summary in the output ﬁle.

itgtmd

tgtrmsd

tgtmdfrc

= 0 no targeted MD (default)
= 1 use targeted MD
= 2 use targeted MD to multiple targets (Multiply-targeted MD, or MTMD, see next section below)

Value of the target RMSD. The default value is 0. This value can be changed during the simulation
by using the weight change option.

This is the force constant for targeted MD. The default value is 0, which will result in no penalty
for structure deviations regardless of the RMSD value. Note that this value can be negative, which
would force the coordinates AWAY from the reference structure.

tgtfitmask Deﬁne the atoms that will be used for the rms superposition between the current structure and the

reference structure. Syntax is in Chapter 21.1.1.

tgtrmsmask Deﬁne the atoms that will be used for the rms difference calculation (and hence the restraint force),

as outlined above. Syntax is in Chapter 21.1.1.

One can imagine many uses for this option, but a few things should be kept in mind. In this implementation of
targeted MD, there is currently only one reference coordinate set, so there is no way to force the coordinates to any
speciﬁc structure other than the one reference. To move a structure toward a reference coordinate set, one might
use an initial tgtrmsd value corresponding to the actual RMSD between the input and reference (inpcrd and refc).
Then the weight change option could be used to decrease this value to 0 during the simulation. To move a structure
away from the reference, one can increase tgtrmsd to values larger than zero. The minimum for this energy term
will then be at structures with an RMSD value that matches tgtrmsd. Keep in mind that many different structures
may have similar RMSD values to the reference, and therefore one cannot be sure that increasing tgtrmsd to a
given value will result in a particular structure that has that RMSD value. In this case it is probably wiser to use
the ﬁnal structure, rather than the initial structure, as the reference coordinate set, and decrease tgtrmsd during the
simulation. To address this, multiply-targeted MD is now available in Amber (sander only), and is described in the
next section. As an additional note, a negative force constant tgtmdfrc can be used, but this can cause problems
since the energy will continue to decrease as the RMSD to the reference increases.

Also keep in mind that phase space for molecular systems can be quite complex, and this method does not
guarantee that a low energy path between initial and target structures will be followed.
It is possible for the
simulation to become unstable if the restraint energies become too large if a low-energy path between a simulated
structure and the reference is not accessible.

Note also that the input and reference coordinates are expected to match the prmtop ﬁle and have atoms in the
same sequence. No provision is made for symmetry; rotation of a methyl group by 120° would result in a nonzero
RMSD value.

22.5. Multiply-Targeted MD (MTMD)

In Amber (sander only), the user may perform targeted MD calculations using multiple reference structures.
Each reference may have its own associated target RMSD value and force constant, each of which can evolve
independently in time. Additionally, the masks for each deﬁned target may differ, and targeting to any given
reference structure can be activated for some or part of the simulation. The energy term for MTMD is simply the
sum of the energies that would be calculated for the molecule calculated relative to each target given the target
RMSD and force constant for that target. The energy will then be added to the RESTRAINT term.

To use MTMD, the MTMD input ﬁle is speciﬁed using the -mtmd ﬂag in the command line arguments for
sander. The MTMD input ﬁle will contain one instance of the tgt namelist (“&tgt”) for each reference structure
used. The user may specify any number of reference structures.

431

22. Sampling conﬁguration space

22.5.1. Variables in the &tgt namelist:

refin

mtmdform

The ﬁle name of the reference structure used. The input and reference coordinates are expected to
match the prmtop ﬁle and have atoms in the same sequence. Default for reﬁn is ”, no reference
structure given.

If MTMDFORM > 0, then the reference coordinate ﬁle is formatted. Otherwise, the reference co-
ordinate ﬁle is an unformatted (binary) ﬁle. Default for MTMDFORM is the value assigned to
MTMDFORM in the most recent namelist where MTMDFORM was speciﬁed. If MTMDFORM has
not been speciﬁed in any namelist, it defaults to 1.

mtmdstep1, mtmdstep2 Targeted MD for this structure is run for steps/iterations MTMDSTEP1 through MT-
MDSTEP2. If MTMDSTEP2 = 0, then TMD will be run through the end of the run, and the values
of the target RMSD and the force constant will not change with time. Note that the ﬁrst step/iteration
is considered step 0. Defaults for MTMDSTEP1 and MTMDSTEP2 are the values assigned to them
in the most recent namelist where MTMDSTEP1 and MTMDSTEP2 were speciﬁed. If MTMDSTEP1
and MTMDSTEP2 have not been speciﬁed in any namelist, they default to 0.

mtmdvari

If MTMDVARI > 0, then the force constant and target RMSD will vary with step number. Oth-
erwise, they are constant throughout the run. If MTMDVARI >0, then the values MTMDSTEP2,
MTMDRMSD2, and MTMDFORCE2 must be speciﬁed (see below). Default for MTMDVARI is
the value assigned to MTMDVARI in the most recent namelist where MTMDVARI was speciﬁed. If
MTMDVARI has not been speciﬁed in any namelist, it defaults to 0.

mtmdrmsd, mtmdrmsd2 The target RMSD for this reference. If MTMDVARI >0, then the value of MTMDRMSD
will vary between MTMDSTEP1 and MTMDSTEP2, so that, e.g. MTMDRMSD(MTMDSTEP1)
= MTMDRMSD and MTMDRMSD(MTMDSTEP2) = MTMDRMSD2. Defaults for MTMDRMSD
and MTMDRMSD2 are the values assigned to them in the most recent namelist where MTMDRMSD
and MTMDRMSD2 were speciﬁed. If MTMDRMSD and MTMDRMSD2 have not been speciﬁed in
any namelist, they default to 0.0.

mtmdforce, mtmdforce2 The force constant for this reference.

then the value of
MTMDFORCE will vary between MTMDSTEP1 and MTMDSTEP2, so that, e.g. MTMD-
FORCE(MTMDSTEP1) = MTMDFORCE and MTMDFORCE(MTMDSTEP2) = MTMDFORCE2.
Defaults for MTMDFORCE and MTMDFORCE2 are the values assigned to them in the most re-
cent namelist where MTMDFORCE and MTMDFORCE2 were speciﬁed. If MTMDFORCE and
MTMDFORCE2 have not been speciﬁed in any namelist, they default to 0.0.

If MTMDVARI >0,

mtmdninc

mtmdmult

If MTMDVARI >0 and MTMDNINC > 0, then the changes in the values of of MTMDRMSD and
MTMDFORCE are applied as a step function, with NINC steps/iterations between each change in
the target values. If MTMDNINC = 0, the change is effected continuously (at every step). Default for
MTMDNINC is the value assigned to MTMDNINC in the most recent namelist where MTMDNINC
was speciﬁed. If MTMDNINC has not been speciﬁed in any namelist, it defaults to 0.

If MTMDMULT=0, and the values of MTMDFORCE changes with step number, then the changes in
the force constant will be linearly interpolated from MTMDFORCE→MTMDFORCE2 as the step
number changes. If MTMDMULT=1 and the force constant is changing with step number, then the
changes in the force constant will be effected by a series of multiplicative scalings, using a single
factor, R, for all scalings. i.e.

MTMDFORCE2 = R**INCREMENTS * MTMDFORCE

INCREMENTS is the number of times the target value changes, which is determined by MTMD-
STEP1, MTMDSTEP2, and MTMDNINC. Default for MTMDMULT is the value assigned to MT-
MDMULT in the most recent namelist where MTMDMULT was speciﬁed. If MTMDMULT has not
been speciﬁed in any namelist, it defaults to 0.

432

22.6. Nudged elastic band calculations

mtmdmask

Deﬁne the atoms that will be used for both the rms superposition between the current structure and
the reference structure and the rms difference calculation (and hence the restraint force), as outlined
above. Syntax is in Chapter 21.1.1.Default for MTMDMASK is the value assigned to MTMDMASK in
the most recent namelist where MTMDMASK was speciﬁed. If MTMDMASK has not been speciﬁed
in any namelist, it defaults to ’*’, use all atoms in the ﬁt and force calculations. \

Namelist &tgt is read for each reference structure. Input ends when a namelist statement with reﬁn = ” (or reﬁn
not speciﬁed) is found. Note that comments can precede or follow any namelist statement, allowing comments and
reference deﬁnitions to be freely mixed.

22.6. Nudged elastic band calculations

22.6.1. Background

In the nudged elastic band method (NEB),[467, 468] the path for a conformational change is approximated with
a series of images describing the molecule at discrete points along the path. A simultaneous energy minimization
of the total system, while keeping the endpoint images ﬁxed in space, provides a minimum energy path. Each
image in-between the two endpoints, is connected to the their nearest neighbors by "springs" along the path that
serve to keep them from sliding down the energy landscape, and onto adjacent images. NEB is derived from the
plain elastic band method, pioneered by Elber and Karplus,[469] who added the spring forces to the potential of
energy surface and minimized the energy of the system. The plain elastic band method found low energy paths,
but tended to cut corners in the energy landscape. NEB prevents corner cutting by truncating the spring forces
in directions perpendicular to the tangent of the path. Furthermore, the forces from the molecular potential are
truncated along the path, for the images to remain evenly spaced. Therefore, only the perpendicular component
of the potential force (F⊥) and the parallel component of the spring force (F(cid:107)) are considered in the equations of
motion. This leads to:

F = F⊥ + F(cid:107)
F⊥ = −∇V (P) + ((∇V (P)· τ)τ
F(cid:107) = [(ki+1|Pi+1 − Pi|− ki|Pi − Pi−1)· τ]τ

(22.3)

where F is the force on image i, Pi is the 3N-dimensional position vector of image i with N atoms, ki is the
spring constant between image i − 1 and image i, V is the potential described by the force ﬁeld, and τ is the
3N-dimensional tangent unit vector that describes the path.

The simplest deﬁnition of τ is:

τ = (Pi − Pi−1)/|Pi − Pi−1|

(22.4)
This deﬁnition leads to instability in the path caused by kinks that occur where the magnitude of F(cid:107) is much larger
than the magnitude of F⊥. A more stable tangent deﬁnition was derived to prevent kinks in the path that depends
upon the energies, E, of adjacent images.[470] The spring constants can be the same between all images or they
can be scaled to move the images closer together in the regions of transition states:[471]

I f (Ei > Ere f )

then

otherwise

ki = kmax − ∆k(Emax − Ei)/(Emax − Ere f )
ki = kmax − ∆k

(22.5)

Here Emax is the energy of the replica with the highest energy along the path, Ere f is the energy of the higher
energy endpoint, and kmax and ∆k are parameters with units of force per length. Because the spring force applies
only in directions along the path and the potential of the energy surface is zeroed along the path, the calculation
is relatively insensitive to the magnitude of the spring constants. Care must be taken, however, to select a spring
constant that does not result in higher frequency motions than those found in the system of interest.[472] At each

433

22. Sampling conﬁguration space

step, before calculating the spring forces that compose F(cid:107), each image’s neighbor is rotated and translated onto the
image itself to ﬁnd the minimum RMSD, based on a subset of the system’s atoms which the user can deﬁne. In
this way, each image remains a continuous MD simulation, and the communication of coordinates can be greatly
reduced.

Energy minimization of the path is complicated because the forces are truncated according to the tangent di-
rection, making it impossible to deﬁne a Lagrangian.[472] Conjugate gradient minimization, therefore, cannot be
used to ﬁnd the minimum energy path. An algorithm for quenched molecular dynamics has been used instead.[468]
With this method, the component of the velocity parallel to the force is kept, but perpendicular components are
scaled:

I f (v· f > 0)

then

v = (v· f)f
otherwise v = x(v· f)f

(22.6)

where f is the 3N-dimensional unit force vector, v is the 3N-dimensional velocity vector, and x is a scaling fac-
tor less than one. Recently, a super-linear minimization method was described using an adopted basis Newton-
Raphson minimizer.[472]

A partial NEB (PNEB) implementation is available both in sander and pmemd, and is the only form of NEB
that is currently supported in Amber [473]. This implementation allows the NEB method to be applied to a user
deﬁned subset of the system. It is required that user deﬁnes the part of the system to which NEB force decoupling
is applied, as well as the part of the system to which an RMS ﬁt of the neighboring images is performed in order to
remove rotational and translational motion. PNEB enables the efﬁcient use of NEB in large systems where a local
transition is desired, or in explicitly solvated systems in which the solvent atoms need to be excluded from NEB
calculations. In pmemd, PNEB simulations can be performed using the GPU accelerated executables.

As with the previous implementation of NEB [474], minimization of the energies of the system along the lowest
potential energy path is achieved by simulated annealing. This requires no hypothesis for a starting path, but
careful judgment of the temperature and simulation time is necessary to populate the minimum energy path. The
initial coordinates can have multiple copies of the structure superimposed on the two endpoints. When adjacent
structures are superimposed, the tangent, τ , is 0 in every direction. This case is explicitly handled so that the
calculation is stable.

22.6.2. Preparing input ﬁles for NEB

Input prmtop and inpcrd ﬁles for NEB should be generated using LEaP. To perform NEB simulations, the
minimum requirements are a prmtop ﬁle of a single image of the molecule and two inpcrd ﬁles representing each
end of the pathway.

The following are some notes for preparing NEB input ﬁles:

1. Always check that the prmtop ﬁles generated for the endpoint coordinates are the same. This can be done by
comparing the ﬁles using the diff command. Identical prmtop ﬁles must be used to describe both endpoints’
inpcrd ﬁles.

2. If you have intermediate structures along the path, you must make sure the prmtop is appropriate for these

structures as well.

3. The endpoint images serve as coordinate reference points, and remain ﬁxed in coordinate and energy space
along the path. No simulation is performed on these replicas during NEB optimization, so they must initially
be well minimized to prevent the rest of the images from migrating to a local minimum before the conforma-
tional transition occurs. Take this into consideration when choosing the number of images to connect along
the path.

Multisander/multipmemd requires a groupﬁle input, in which each line is a sander/pmemd command for individual
image’s MD simulation. Multiple copies of each endpoint image are used for the initial simulation. When preparing
the initial groupﬁle, the ﬁrst half of the images can use copies of the initial endpoint inpcrd, while the other half

434

22.6. Nudged elastic band calculations

uses copies of the ﬁnal endpoint inpcrd. If intermediates are available and user wishes to include them, they should
be added sequentially in between the endpoint conformations in the order in which these structures are thought to
appear along the transition path.

Notes for running NEB using multisander or multipmemd:

1. If using multisander, the number of CPUs speciﬁed must be a multiple of the number of images. You can
run this on a standard desktop computer, but it will generally be more efﬁcient to run it on a minimum of
one processor per image.

2. If using multipmemd, the number of CPUs must be a multiple, and at least twice, of the number of images.

In case pmemd.cuda.MPI is used, it is best that the number of GPUs is equal to the number of images.

3. If the user has access to parallel computing resources, multiple processors per image may be used. Careful
benchmarking should be done to gauge the best balance between computational efﬁciency in calculating the
dynamics of each image and slowdown caused by communications overhead at each step.

22.6.3. Input Variables

ineb

Flag for nudged elastic band. A value of 0 (default) means that no nudged elastic band will be used.
A value of 1 means that NEB simulation is being performed.

tgtfitmask Flag which sets atoms to RMS ﬁt each image’s neighbor to itself. This mask must not include solvent
atoms, which due to diffusion, overlapping proves impossible. The more atoms you choose, the more
communication has to be done by each MPI thread. Syntax for this is here: 21.1.1

tgtrmsmask Flag which sets atoms to decouple NEB forces for PNEB. This can be set to all atoms of the solute,
or a subset of atoms which best describes the area of the system which undergoes the conformational
change you wish to see. Syntax for this is here: 21.1.1

skmax

skmin

tmode

vv

vfac

Spring constant or kmax mentioned above (100 by default).

If skmin = skmax, a ﬁxed spring constant is used. Otherwise, skmin is taken from above for scaled
spring constants (50 by default).

If 1 (default), use the revised tangent deﬁnition that prevents kinks. For any other value, use the
simple (original) tangent deﬁnition.

If this is 1, use the quenched velocity Verlet minimization; otherwise, do not.

Scaling factor for quenched velocity Verlet algorithm. (0.0 by default).

Sample input ﬁle for running initial heating along the path.

Below is an example input ﬁle that can be used to perform the initial heating step of an NEB run. Note that the
input and topology ﬁles must be identical for each replica; while the names of the output, trajectory, restart and
info ﬁles should not be the same between replicas.





Alanine NEB initial MD with small K
&cntrl

imin = 0, irest = 0,
ntc=1, ntf=1,
ntpr=1, ntwx=500,
ntb = 0, cut = 999.0, rgbmax=999.0,
igb = 1, saltcon=0.2,
nstlim = 40000, nscm=0,
dt = 0.0005, ig=42,
ntt = 3, gamma_ln=1000.0,
tempi=0.0, temp0=300.0,
tgtfitmask=":1,2,3",

435

22. Sampling conﬁguration space

tgtrmsmask=":1,2,3@N,CA,C",
ineb = 1,skmin = 10,skmax = 10,
nmropt=1,

/
&wt type='TEMP0', istep1=0,istep2=35000,

value1=0.0, value2=300.0

/
&wt type='END'

/



tgtﬁtmask variable denotes the atoms that will be used to RMS ﬁt each replica onto its neighbor images at each
step. In this case all atoms of residues 1, 2, and 3 are speciﬁed. The tgtrmsmask variable denotes the atoms that
the NEB forces will be applied to. In this case the backbone atoms of residues 1, 2, and 3 are speciﬁed. In general,
the atoms that have NEB forces applied to them should be those involved in the transition of interest. If the speciﬁc
transition is not known, or there are many degrees of freedom involved in the transition, one can simply specify
all solute atoms. It is not recommended to apply NEB forces to solvent atoms. For more examples, please refer to
the runs in the $AMBERHOME/test/neb-testcases and $AMBERHOME/test/cuda/neb-testcases directories, or see
reference [473].

22.6.4. Important Considerations for NEB Simulations

With the implementation of PNEB, it is important to understand some limitations of the method. Only part
of the system is simulated with NEB forces, indicating this part of the system is moving along the minimum
potential energy landscape of the transition path. However, the part of the system to which NEB is not applied is
not necessarily forced along this minimum potential energy path, and attention must be paid to the convergence of
this part of the system. The conformational change in this part of the system is with no doubt accelerated, since
it responds to the part of the system to which NEB forces are applied. Further equilibration of the system may be
required if the user wishes to examine changes not local to the area the NEB forces are applied to.

Careful attention must be paid to optimization methods, to assure that conformational space is explored for the
NEB part of the system, while the integrity of the non-NEB part remains intact. As in all NEB implementations,
a general caveat is that as the system size increases, the degrees of freedom increase and conformational changes
become more difﬁcult to quantify. While NEB is a method which does not necessitate a reaction coordinate, care
should be taken when analyzing the resulting minimum energy path. Statistically relevant number of simulations
must be performed to ensure reproducibility (and convergence) of the results.

22.7. Low-MODe (LMOD) methods

István Kolossváry’s LMOD methods for minimization, conformational searching, and ﬂexible docking[475–
478] are fully implemented in Amber. The centerpiece of LMOD is a conformational search algorithm based on
eigenvector following of low frequency vibrational modes. It has been applied to a spectrum of computational
chemistry domains including protein loop optimization and ﬂexible active site docking.

In the Amber 2020 release, the LMOD optimization code has been updated with major improvements and new
features including more accurate ﬂexible docking, the option to visualize normal modes, utilization of random
mixtures of low-frequency modes, and the option to work with a range of modes anywhere in the spectrum and
not just the lowest frequency modes. The latter is particularly useful for docking where the modes relevant to
binding a ligand molecule are usually not the lowest frequency modes. The interface of the new LMOD has not
changed, everything works exactly the same way as in Amber18 and earlier versions, a few parameters simply have
additional options as documented below. The new features are demonstrated with production quality examples.

Details of the LMOD procedure, and hints on getting good performance, are given Section 39.4, which should
be consulted before trying the procedures in sander. The only difference between the sander and NAB implemen-
tations is the input speciﬁcation; the same LMOD code is linked into both. The sections below give input details
for sander.

436

22.7. Low-MODe (LMOD) methods

There are four “real-life” examples of performing LMOD searches and three examples of updates in Amber20
including generating LMOD-vibration visualization: look in $AMBERHOME/AmberTools/examples/nab/lmod_*.
Each directory has a README ﬁle with more information.

22.7.1. XMIN

The XMIN methods for minimization are traditional and manifold in the ﬁeld of unconstrained optimization:
PRCG is a Polak-Ribiere nonlinear Conjugate Gradient algorithm,[479] LBFGS is a Limited-memory Broyden-
Fletcher-Goldfarb-Shanno quasi-Newton algorithm,[480] and TNCG is a Truncated Newton linear Conjugate Gra-
dient method with optional LBFGS preconditioning.[481]

Some of the &cntrl namelist variables that control Amber’s other minimization facilities also control XMIN.

Consequently, non-experts can employ the default XMIN method merely by specifying ntmin = 3.

maxcyc

The maximum number of cycles of minimization. Default is 1 to be consistent with Amber’s other
minimization facilities although it may be unrealistically short.

ntmin

The ﬂag for the method of minimization.

= 3 The XMIN method is used.
= 4 The LMOD method is used. The LMOD procedure employs XMIN for energy relaxation and

minimization.

drms

The convergence criterion for the energy gradient: minimization will halt when the root-mean-square
−1. This is
of the Cartesian elements of the gradient is less than this. Default is 10−4kcal· mol−1 · Å
consistent with Amber’s other minimization facilities. In Amber18 and earlier this default may have
been unrealistically strict. In Amber20 this criterion refers to the minimization of the input structure
for which the normal modes are computed, and to avoid unnatural vibrational modes it should be set
to even stricter values, e.g., 10−8. Compare with input parameter lmod_minimize_grms below.

Other options that control XMIN are in the scope of the &lmod namelist. These parameters enable expert control
of XMIN.

lbfgs_memory_depth The depth of the LBFGS memory for LBFGS minimization, or LBFGS preconditioning
in TNCG minimization. Default is 3. Suggested alternate value is 5. The value 0 turns off LBFGS
preconditioning in TNCG minimization.

matrix_vector_product_method The ﬁnite difference Hv matrix-vector product method: "forward" = forward

difference, "central" = central difference. Default is forward difference.

xmin_method The minimization method: "PRCG" = Polak-Ribiere Conjugate Gradient, "LBFGS" = Limited-
memory Broyden-Fletcher-Goldfarb-Shanno, and "TNCG" = Optionally LBFGS-preconditioned
Truncated Newton Conjugate Gradient. Default is LBFGS.

xmin_verbosity The verbosity of the internal status output from the XMIN package: 0 = none, 1 = minimization
details, and 2 = minimization and line search details plus CG details in TNCG. Currently, the XMIN
status output may be disordered with respect to Amber’s output. Default is 0, no output of the XMIN
package internal status. Note that XMIN is also available in AmberTools, in the NAB package.
An annotated example output corresponding to XMIN_VERBOSITY=2 can be found in the NAB
documentation.

22.7.2. LMOD

Some of the options that control LMOD have the same names as Amber’s other minimization facilities. See
the XMIN section immediately above. Other options that control LMOD are in the scope of the &lmod namelist.
These parameters enable expert control of LMOD.

437

22. Sampling conﬁguration space

arnoldi_dimension The dimension of the ARPACK Arnoldi factorization. Zero speciﬁes the whole space, that
is, three times the number of atoms. Default is 0, the whole space. Basically, the ARPACK package
used for the eigenvector calculations solves multiple "small" eigenvalue problems instead of a single
"large" problem, which is the diagonalization of the three times the number of atoms by three times
the number of atoms Hessian matrix. This parameter is the user speciﬁed dimension of the "small"
problem. The allowed range is total_low_modes + 1 <= arnoldi_dimension <= three times the
number of atoms. The default means that the "small" problem and the "large" problem are identical.
This is the preferred, i.e., fastest, calculation for small to medium size systems, because ARPACK
is guaranteed to converge in a single iteration. The ARPACK calculation scales with three times the
number of atoms times the arnoldi_dimension squared and, therefore, for larger molecules there is
an optimal arnoldi_dimension much less than three times the number of atoms that converges much
faster in multiple iterations (possibly thousands or tens of thousands of iterations). The key to good
performance is to select an arnoldi_dimension such that all the ARPACK storage ﬁts in memory. For
proteins, arnoldi_dimension=1000 is generally a good value, but often a very small 50-100 Arnoldi
dimension provides the fastest net computational cost with very many iterations.

conflib_filename The user-given ﬁlename of the LMOD conformational library. The ﬁle format is Amber
standard formatted trajectory output regardless of the value of &cntrl namelist variable ioutfm. The
conformations are stored in energetic order (global minimum energy structure ﬁrst), the number of
conformations<= conﬂib_size. The default ﬁlename is conﬂib.

conflib_size The number of conformations to store in conﬂib. Default is 3.

energy_window The energy window for conformation storage; the energy of a stored structure will be in the in-
terval [global_min, global_min + energy_window]. Default is 0, only storage of the global minimum
structure.

explored_low_modes The number of low frequency vibrational modes used per LMOD iteration. Default is 3.

frequency_eigenvector_recalc The frequency, measured in LMOD iterations, of the recalculation of eigen-

vectors. Default is 3.

frequency_ligand_rotrans The frequency, measured in LMOD iterations, of the application of rigid-body
rotational and translational motions to the ligand(s). At each frequency_ligand_rotrans-th LMOD
iteration number_ligand_rotrans rotations and translations are applied to the ligand(s). Default is 1,
ligand(s) are rotated and translated at every LMOD iteration.

lmod_job_title The user-given title for the job that goes in the ﬁrst line of the conﬂib and lmod_trajectory ﬁles.

The default job title is "job_title_goes_here".

lmod_minimize_grms In Amber18 and earlier the gradient root-mean-square convergence criterion of structure
minimization. In Amber 20 this was speciﬁed to be the criterion to minimize low-energy conforma-
tions which do not require as strict convergence as for the ﬁrst minimization whose convergence is
now controlled with input parameter drms, see above. Default is 0.1.

lmod_relax_grms The gradient RMS convergence criterion of structure relaxation. Default is 1.0.

lmod_restart_frequency The frequency, in LMOD iterations, of conﬂib updating and LMOD restarting with a

randomly chosen structure from the pool. Default is 5.

lmod_step_size_max The maximum length of a single LMOD ZIG move. Default is 5.0 Å.

lmod_step_size_min The minimum length of a single LMOD ZIG move. Default is 2.0 Å.

lmod_trajectory_filename The ﬁlename of the LMOD pseudo trajectory. The ﬁle format is standard Amber
trajectory ﬁle. The conformations in this ﬁle show the progress of the LMOD search. The number
of conformations = number_lmod_iterations + 1. The default ﬁlename is lmod_trajectory.

438

22.7. Low-MODe (LMOD) methods

lmod_verbosity The verbosity of the internal status output from the LMOD package: 0 = none, 1 = some
details, 2 = more details, 3 = everything including ARPACK information, 4 = ARPACK only, 5
= visualize normal modes. Currently, the LMOD status output may be disordered with respect to
Amber’s output. Default is 0, no output of the LMOD package internal status. Note that LMOD is
also available in AmberTools, in the NAB package. An annotated example output corresponding to
LMOD_VERBOSITY=2 can be found in the NAB documentation.

monte_carlo_method The Monte Carlo method: "Metropolis" = Metropolis Monte Carlo, "Total_Quench" = the
LMOD trajectory always proceeds towards the lowest lying neighbor of a particular energy well
found after exhaustive search along all of the low modes, and "Quick_Quench" = the LMOD trajec-
tory proceeds towards the ﬁrst neighbor found, which is lower in energy than the current point on the
path, without exploring the remaining modes. Default is Metropolis Monte Carlo.

number_free_rotrans_modes In Amber18 and earlier this was solely the number of rotational and translational
degrees of freedom (dof) which is related to the number of frozen or tethered atoms in the system:
0 atoms dof=6, 1 atom dof=3, 2 atoms dof=1, >=3 atoms dof=0. In Amber20 the input domain was
extended to any non-negative integer, and it represents the number of modes for LMOD to skip. In
this way LMOD can now explore a range of modes instead of simply modes starting with the lowest
frequency. Note that it is recommended to set this to 0 once in order to examine the ro-translational
modes. Default is 6.

number_ligand_rotrans The number of rigid-body rotational and translational motions applied to the ligand(s).
Such applications occur at each frequency_ligand_rotrans-th LMOD iteration. Default is 0, no rigid-
body motions applied to the ligand(s).

number_ligands The number of ligands for ﬂexible docking. Default is 0, no ligand(s).

number_lmod_iterations The number of LMOD iterations. Default

is 10. Note that setting num-

ber_lmod_iterations = 0 will result in a single energy minimization.

number_lmod_moves The number of LMOD ZIG-ZAG moves. Zero means that the number of ZIG-ZAG moves
is not pre-deﬁned, instead LMOD will attempt to cross the barrier in as many ZIG-ZAG moves as it
is necessary. The criterion of crossing an energy barrier is stated above in the "LMOD Procedure"
background section. number_lmod_moves > 0 means that multiple barriers may be crossed and
LMOD can carry the molecule to a large distance on the potential energy surface without severely
distorting the geometry. Default is 0, LMOD will determine automatically where to stop the ZIG-
ZAG sequence.

random_seed The seed of the random number generator. Default is 314159.

restart_pool_size The size of the pool of lowest-energy structures to be used for restarting. Default is 3.

rtemperature The value of RT in Amber energy units. This is utilized in the Metropolis criterion. Default is 1.5.

total_low_modes The total number of low frequency vibrational modes to be used. Default is the minimum of
10 and three times the number of atoms minus the number of rotational and translational degrees of
freedom (number_free_rotrans_modes).

The following commands are part of the &lmod namelist. These commands control the way LMOD applies explicit
translations and rotations to one or more ligands and take effect only if number_ligands >= 1. All commands are
lists in square brackets, separated by commas such as [1, 33, 198], however, the list is read by Sander as a string
and, therefore, it should be enclosed in single quotes.

ligstart_list, ligend_list The serial number(s) of the ﬁrst/last atom(s) of the ligand(s). Type integer. The
number(s) should correspond to the numbering in the Amber input ﬁles prmtop and inpcrd/restart.
For example, if there is only one ligand and it starts at atom 193, the command should be ligstart_list
= ’[193]’. If there are three ligands, the command should be, e.g., ’[193, 244, 1435]’. The same

439

22. Sampling conﬁguration space

format holds for all of the following commands. Note that the ligand(s) can be anywhere in the
atom list, however, a single ligand must have continuous numbering between the corresponding
ligstart_list and ligend_list values. For example, ligstar_list = ’[193, 244, 1435]’ and ligend_list =
’[217, 302, 1473]’.

ligcent_list The serial number(s) of the atom(s) of the ligand(s), which serves as the center of rotation. Type
integer. The value zero means that the center of rotation will be the geometric center of gravity of
the ligand.

rotmin_list, rotmax_list The range of random rotation of a particular ligand about the origin deﬁned by the
corresponding ligcent_list value is speciﬁed by the commands rotmin_list and rotmax_list. The angle
is given in +/- degrees. Type ﬂoat. For example, in case of a single ligand and ligcent_list = ’[0]’,
rotmin_list = ’[30.0]’ and rotmax_list = ’[180.0]’ means that random rotations by an angle +/- 30-180
degrees about the center of gravity of the ligand, will be applied. Similarly, with number_ligands =
2, ligcent_list= 120.0]’ means that the ﬁrst ligand will be rotated like in the single ligand example
in this paragraph, but a second ligand will be rotated about its atom number 201, by an angle +/-
60-120 degrees.

trmin_list, trmax_list The range of random translation(s) of ligand(s) is deﬁned by the same way as rotation.
For example, with number_ligand = 1, trmin_list = ’[0.1]’ and trmax_list = ’[1.0]’ means that a single
ligand is translated in a random direction by a random distance between 0.1 and 1.0 Angstroms.

440

23. Free energies

23.1. Thermodynamic integration

In a free energy calculation, the system evolves according to a mixed potential (such as in Eqs. 23.3 or 23.4,
below). The essence of free energy calculations is to record and analyze the ﬂuctuations in the values of V0
and V1 (that is, what the energies would have been with the endpoint potentials) as the simulation progresses.
For thermodynamic integration (which is a very straightforward form of analysis) the required averages can be
computed "on-the-ﬂy" (as the simulation progresses), and printed at the end of a run. For more complex analyses
(such as the Bennett acceptance ratio scheme), one needs to write the history of the values of V0 and V1 to a ﬁle,
and later post-process this ﬁle to obtain the ﬁnal free energy estimates.

There is not room here to discuss the theory of free energy simulations, and there are many excellent discus-
sions elsewhere.[9, 482, 483] There are also plenty of recent examples to consult.[484, 485] Such calculations are
demanding, both in terms of computer time, and in a level of sophistication to avoid pitfalls that can lead to poor
convergence. Since there is no one "best way" to estimate free energies, sander and pmemd primarily provide the
tools to collect the statistics that are needed. Assembling these into a ﬁnal answer, and assessing the accuracy
and signiﬁcance of the results, generally requires some calculations outside of what Amber provides, per se. The
discussion here will assume a certain level of familiarity with the basis of free energy calculations.

Both sander and pmemd have the capability of doing simple thermodynamic free energy calculations, using
either PME or generalized Born potentials. When icfe is set to 1, information useful for doing thermodynamic
integration estimates of free energy changes will be computed. The implementation is different between sander
and pmemd. For sander, you must use the multisander capability to create two groups, one corresponding to the
starting state, and a second corresponding to the ending state (see Section 19.11 for information); you will need
a prmtop ﬁle for each of these two endpoints. For pmemd, you use a single prmtop ﬁle which contains both the
starting and ending states. For both sander and pmemd a mixing parameter λ is used to interpolate between the
"unperturbed" and "perturbed" potential functions.

23.1.1. Thermodynamic integration using Sander

There are now two different ways to prepare a thermodynamic integration free energy calculation in Sander. The
ﬁrst is unchanged from previous versions of Amber: Here, the two prmtop ﬁles that you create must have the same
number of atoms, and the atoms must appear in the same order in the two ﬁles. This is because there is only one
set of coordinates that are propagated in the molecular dynamics algorithm. If there are more atoms in the initial
state than in the ﬁnal, "dummy" atoms must be introduced into the ﬁnal state to make up the difference. Although
there is quite a bit of ﬂexibility in choosing the initial and ﬁnal states, it is important in general that the system be
able to morph "smoothly" from the initial to the ﬁnal state. Alternatively, you can set up your system to use the
softcore potential algorithm described below. This will remove the requirement to prepare "dummy" atoms and
allows the two prmtop ﬁles to have different numbers of atoms.

The basics of the multisander functionality are given in Section 19.11, but the mechanics are really quite

simple. You start a free energy calculation as follows:

mpirun -np 4 sander.MPI -ng 2 -groupfile <filename>

Since there are 4 total cpu’s in this example, each of the two groups will run in parallel with 2 cpu’s each. The
number of processors must be a multiple of two. The groups ﬁle might look like this:

-O -i mdin -p prmtop.0 -c eq1.x -o md1.o -r md1.x -inf mdinfo
-O -i mdin -p prmtop.1 -c eq1.x -o md1b.o -r md1b.x -inf mdinfob

441

23. Free energies

The input (mdin) and starting coordinate ﬁles must be the same for the two groups. Furthermore, the two prmtop
ﬁles must have the same number number of atoms, in the same order (since one common set of coordinates
will be used for both.) The simulation will use the masses found in the ﬁrst prmtop ﬁle; in classical statistical
mechanics, the Boltzmann distribution in coordinates is independent of the masses so this should not represent any
real restriction.

On output, the two restart ﬁles should be identical, and the two output ﬁles should differ only in trivial ways
such as timings; there should be no differences in any energy-related quantities, except if energy decomposition
is turned on (idecomp > 0); then only the output ﬁle of the ﬁrst group contains the per residue contributions to
(cid:104)∂V /∂λ(cid:105). For our example, this means that one could delete the md1b.o and md1b.x ﬁles, since the information
they contain is also in md1.o and md1.x. (It is a good practice, however, to check these ﬁle identities, to make sure
that nothing has gone wrong.)

23.1.2. Thermodynamic integration using PMEMD

In pmemd, there is only a single input topology ﬁle which contains the atoms corresponding to both the start and
end states. As explained in Ref. [486] this removes redundant calculations, greatly improving the efﬁciency of the
code. In order to accommodate these changes, some input ﬂags have been modiﬁed compared to sander. These
are marked in the sections below. Also, simulations at the endpoints, λ = 0 or λ = 1, will work even for soft core
simulations.

The prmtop ﬁle needs to be carefully prepared in order to be compatible with the pmemd TI implementation. A
number of examples for setting up the prmtop ﬁle are given below in section 23.1.8. This is not a complete tutorial
on TI calculations, but explains how to prepare the new prmtop format for various types of TI calculations.

Performance of the PME TI pmemd implementation is approximately 75% that of a regular PME MD simulation
with roughly the same parallel scaling. The difference in absolute performance comes from the fact that a PME
calculation is not pairwise decomposable and therefore the reciprocal space calculation needs to be carried out
twice per time step, once for V0 and V1. For GB TI the performance difference is approximately 50% since the GB
radii calculation is not pairwise decomposable and thus two non-bond calculations are carried out per time step.

The exception to this performance difference is when one is running just vdW only soft core transformations.
In this situation there are no charges on the TI atoms and thus the charges for all of the atoms in both V0 and V1are
the same. Hence the long range electrostatics calculation only needs to be done once per step, rather than twice
(for V0 and V1) . This results in performance roughly equivalent to a standard MD simulation. This optimization
is determined automatically and can be seen in the mdout ﬁle – ’No charge on TI atoms. Skipping extra recip
sum.’ To determine the total free energy change it is necessary to carry out additional simulations to determine
the free energy of removing the charges from the molecules. It is up to the user to decide which path through the
thermodynamic cycle will be more efﬁcient for their system of interest.

23.1.3. Thermodynamic integration using PMEMD.cuda

The TI implementation of the GPU version of pmemd (pmemd.cuda) uses the same input ﬁles as the CPU
version of pmemd TI implementations, with some additional pmemd.cuda-speciﬁc input parameters (details given
below in Section 23.1.7). Performance of the pmemd.cuda TI implementation is approximately 70% that of a
regular pmemd.cuda MD simulation,[487, 488] and has been applied to a wide array of relative binding free
energy calculations for protein-ligand systems.[489] The current version of pmemd.cuda can be compiled with
MPI to perform replica exchange simulations using multiple GPUs, and the currently it does not support a single
TI simulation using multiple GPUs. The current version of pmemd.cuda TI does not support GB or PB calculations.

23.1.4. Basic inputs for thermodynamic integration

The basic ﬂag for free energy calculations. The default value of 0 skips such calculations. Setting
this ﬂag to 1 turns them on, using the mixing rules in Eq. 23.3, below.

The value of λ for this run, as in Eqs. 23.3 and 23.4, below. Zero corresponds to the unperturbed
Hamiltonian V0. λ =1 corresponds to the perturbed Hamiltonian V1.

icfe

clambda

442

23.1. Thermodynamic integration

klambda

The exponent in Eq. 23.4, below.

tishake

Flag that determines how SHAKE is handled:

= 0 Coordinates are synchronized after SHAKE, no constraints removed (default).
= 1 SHAKE is removed between bonds containing one common and one unique atom. This was the
default in previous versions of sander. Note that disabling SHAKE requires the use of a 1 fs
timestep.

23.1.4.1. Input ﬂags speciﬁc to Sander

idecomp

Flag that turns on/off decomposition of (cid:104)∂V /∂λ(cid:105) on a per-residue level. The default value of 0 turns
off energy decomposition. A value of 1 turns the decomposition on, and 1-4 nonbonded energies
are added to internal energies (bond, angle, torsional). A value of 2 turns the decomposition on,
and 1-4 nonbonded energies are added to EEL and VDW energies, respectively. The frequency by
which values of (cid:104)∂V /∂λ(cid:105) are included into the decomposition is determined by the NTPR ﬂag. This
ensures that the sum of all contributions equals the average of all total (cid:104)∂V /∂λ(cid:105) values output every
NTPR steps. All residues, including solvent molecules, have to be chosen by the RRES card to be
considered for decomposition. The RES card determines which residue information is ﬁnally output.
The output comes at the end of the mdout ﬁle. For each residue contributions of internal -, VdW-,
and electrostatic energies to (cid:104)∂V /∂λ(cid:105) are given as an average over all (NSTLIM/NTPR) steps. In a
ﬁrst section total per residue values are output followed below by further decomposed values from
backbone and sidechain atoms.

23.1.4.2. Input ﬂags speciﬁc to PMEMD

timask1

Speciﬁes the atoms unique to V0 in ambmask format.

timask2

Speciﬁes the atoms unique to V1 in ambmask format.

23.1.5. Background theory of thermodynamic integration

The sander and pmemd programs do not compute free energies; it is up to the user to combine the output of

several runs (at different values of λ ) and to numerically estimate the integral:

∆A = A(λ = 1)− A(λ = 0) =

(cid:104)∂V /∂λ(cid:105)λ dλ

(23.1)

If you understand how free energies work, this should not be at all difﬁcult. However, since the actual values of
λ that are needed, and the exact method of numerical integration, depend upon the problem and upon the precision
desired, we have not tried to pre-code these into the program.

The simplest numerical integration is to evaluate the integrand at the midpoint:

∆A (cid:39) (cid:104)∂V /∂λ(cid:105)1/2

This might be a good ﬁrst thing to do to get some picture of what is going on, but is only expected to be accurate
for very smooth or small changes, such as changing just the charges on some atoms. Gaussian quadrature formulas
of higher order are generally more useful:

∆A = ∑

i

wi(cid:104)∂V /∂λ(cid:105)i

(23.2)

Some weights and quadrature points are given in the accompanying table; other formulas are possible,[490] but
the Gaussian ones listed there are probably the most useful. The formulas are always symmetrical about λ = 0.5,
so that λ and (1−λ ) both have the same weight. For example, if you wanted to use 5-point quadrature, you would
need to run ﬁve jobs, setting λ to 0.04691, 0.23076, 0.5, 0.76923, and 0.95308 in turn. (Each value of λ should

443

(cid:90) 1

0

23. Free energies

have an equilibration period as well as a sampling period; this can be achieved by setting the ntave parameter.)
You would then multiply the values of (cid:104)∂V /∂λ(cid:105)i by the weights listed in the Table, and compute the sum.
When icfe=1 and klambda has its default value of 1, the simulation uses the mixed potential function:

V (λ ) = (1− λ )V0 + λV1

(23.3)
where V0 is the potential with the original Hamiltonian, and V1 is the potential with the perturbed Hamiltonian.
The program also computes and prints (cid:104)∂V /∂λ(cid:105) and its averages; note that in this case, (cid:104)∂V /∂λ(cid:105) = V1 −V0. This
is referred to as linear mixing, and is often what you want unless you are making atoms appear or disappear. If
some of the perturbed atoms are "dummy" atoms (with no van der Waals terms, so that you are making these atoms
"disappear" in the perturbed state), the integrand in Eq. 23.1 diverges at λ = 1; this is a mild enough divergence
that the overall integral remains ﬁnite, but it still requires special numerical integration techniques to obtain a good
estimate of the integral.[483] Sander and pmemd implement one simple way of handling this problem: if you set
klambda > 1, the mixing rules are

V (λ ) = (1− λ )kV0 + [1− (1− λ )k]V1

(23.4)
where k is given by klambda. Note that this reduces to Eq. 23.3 when k = 1, which is the default. If k ≥4,
the integrand remains ﬁnite as λ → 1.[483] We have found that setting k= 6 with disappearing groups as large as
tryptophan works, but using the softcore option (ifsc>0) instead is generally preferred.[491] Note that the behavior
of (cid:104)∂V /∂λ(cid:105) as a function of λ is not monotonic when klambda > 1. You may need a fairly ﬁne quadrature to
get converged results for the integral, and you may want to sample more carefully in regions where (cid:104)∂V /∂λ(cid:105) is
changing rapidly.

Notes:
1. This is implemented in sander by calling the force() routine independently for each multisander group and
then combining the forces on each step. For a ﬁxed number of processors this increases the cost of the
calculation compared with the pmemd code, which only calculates the differences between V0 and V1.

2. It is rather easy to make mistakes when running TI calculations. It is generally good to carry out a short run
(say 50 steps) setting ntpr=1. Then check the following; if either test fails, be sure to ﬁx the problem before
proceeding.

a) The restart ﬁles from V0 and V1 should be identical for sander (for pmemd there will only be a single

restart ﬁle).

b) If you diff the output ﬁles for sander, there should only be simple differences (for pmemd there will
only be a single combined output ﬁle). All energies, temperatures, pressures, etc. should be the same
in the two ﬁles. Simulations with sander using the QM/MM facility may show differences in the SCF
energies, but be sure that the total energies, and all the MM components, are the same.

3. Eq. 23.4 is designed for having dummy atoms in the perturbed Hamiltonian, and "real" atoms in the regular
Hamiltonian. You must ensure that this is the case when you set up the system in LEaP. (See the softcore
section, below, for a more general way to handle disappearing atoms, which does not require dummy atoms
at all.)

4. One common application of this model is to pKa calculations, where the charges are mutated from the
protonated to the deprotonated form. Since H atoms bonded to oxygen already have zero van der Waals radii
(in the Amber force ﬁelds and in TIP3P water), once their charge is removed (in the deprotonated form) they
are really then like dummy atoms. For this special situation, there is no need to use klambda > 1: since the
van der Waals terms are missing from both the perturbed and unperturbed states, the proton’s position can
never lead to the large contributions to (cid:104)∂V /∂λ(cid:105) that can occur when one is changing from a zero van der
Waals term to a ﬁnite one.

5. The implementation requires that the masses of all atoms be the same on all threads. To enforce this, the
masses found for V0 are used for V1 as well. In classical statistical mechanics, the canonical distribution of
conﬁgurations (and hence of potential energies) is unaffected by changes in the masses, so this should not
pose a limitation. Since the masses for V1 are ignored, they do not have to match those found for V0.

444

23.1. Thermodynamic integration

6. Special care needs to be taken when using SHAKE for atoms whose force ﬁeld parameters differ in the two
end points. The same bonds must be SHAKEN in both cases, and the equilibrium bond lengths must also
be the same. By default, the coordinates from V0 are synchronized with those from V1 after SHAKE. This
will work for small perturbations, but if there is a signiﬁcant change in bond length, it may be necessary to
use the noshakemask input to remove SHAKE from the regions that are being perturbed. If this is done, be
sure to set tishake=1 and to use a 1 fs timestep. Special care needs to be taken when water molecules are
part of the region that is changing. You need to make sure that the “number of 3-point waters” is the same
in both V0 and V1. This may require setting jfastw and/or building the structure so that sander or pmemd do
not think that the water molecules involved are actually rigid waters. Also, just setting noshakemask might
not be enough, since this ﬂag does not affect the settle routine that handles rigid waters.

n
1
2
3

5

7

9

12

λi
0.5

0.21132
0.1127

0.5

0.04691
0.23076

0.5

0.02544
0.12923
0.29707

0.5

0.01592
0.08198
0.19331
0.33787

0.5

0.00922
0.04794
0.11505
0.20634
0.31608
0.43738

1− λi

0.78867
0.88729

0.95308
0.76923

0.97455
0.87076
0.70292

0.98408
0.91802
0.80669
0.66213

0.99078
0.95206
0.88495
0.79366
0.68392
0.56262

wi
1.0
0.5

0.27777
0.44444
0.11846
0.23931
0.28444
0.06474
0.13985
0.19091
0.20897
0.04064
0.09032
0.13031
0.15617
0.16512
0.02359
0.05347
0.08004
0.10158
0.11675
0.12457

Table 23.1.: Abscissas and weights for Gaussian integration.

23.1.6. Softcore Potentials in Thermodynamic Integration

Softcore potentials provide an additional way to perform thermodynamic integration calculations in Amber. The
system setup has been simpliﬁed so that appearing and disappearing atoms can be present at the same time and no
dummy atoms need to be introduced. For sander, two prmtop ﬁles, corresponding to the start and end states (V0
and V1) of the desired transformation need to be used. The common atoms that are present in both states need to
appear in the same order in both prmtop ﬁles and must have identical starting positions. In addition to the common
atoms, each process can have any number of unique soft core atoms, as speciﬁed by scmask. For pmemd, a single
prmtop ﬁle is used, containing the unique atoms for both the start and end states. The soft core atoms are speciﬁed
by scmask1 and scmask2 for V0 and V1 respectively.

A modiﬁed version of the vdW equation is used to smoothly switch off non-bonded interactions of these atoms

with their common atom neighbors:

445

23. Free energies

VV0,disappearing = 4ε(1− λ )

VV1,appearing = 4ελ

1


(cid:104)
(cid:1)6(cid:105)2 −
αλ +(cid:0) ri j
(cid:104)
(cid:1)6(cid:105)2 −
α(1− λ ) +(cid:0) ri j

1

σ

σ





1
αλ + (

ri j
σ )6

1

α(1− λ ) + (

ri j
σ )6



(23.5)

(23.6)

Please refer to Ref [491] for a description of the implementation and performance testing when compared to the
TI methods described above using sander. For similar information pertaining to pmemd please see Ref [486]. Note
that the term “disappearing” is used here, but it would probably be better to say that atoms present in V0 but not
in V1 are “decoupled” from their environment: the interactions among the “disappearing” atoms are not changed,
and do not contribute to (cid:104)∂V /∂λ(cid:105). If the disappearing atoms are a separate molecule (say a non-covalently-bound
ligand), this can be viewed as a transfer to the gas-phase.

Note that a slightly different setup is required for using soft core potentials compared to older TI-
implementations. Speciﬁcally, the difference is that to add or remove atoms without soft core potentials, they
are transformed into interactionless dummy particles, so both end state prmtop ﬁles have the same number of
atoms. When using soft core potentials instead, no dummy atoms are needed and the end states should be built
without them. Therefore prmtop ﬁles for non soft core simulations may have to be adapted to be used with soft
core potentials and vice versa.

All bonded interactions of the unique atoms are recorded separately in the output ﬁle (see below). Any bond,
angle, dihedral or 1-4 term that involves at least one appearing or disappearing atom is not scaled by λ and
does not contribute to (cid:104)∂V /∂λ(cid:105). Therefore, output from both processes will not be identical when soft core
potentials are used. Softcore transformations avoid the origin singularity effect and therefore linear mixing can
(and should) always be used with them. Since the unique atoms become decoupled from their surroundings at high
or low lambdas and energy exchange between them and surrounding solvent becomes inefﬁcient, a Berendsen
type thermostat should not be used for SC calculations. Unlike in previous versions, SHAKE constraints are not
automatically removed from bonds between common and unique atoms. Instead, the coordinates corresponding to
common atoms in V0are synchronized with those of V1. The original behavior can be restored using tishake. The
icfe and klambda parameters should be set to 1 for a soft core run and the desired lambda value will be speciﬁed
by clambda. When using softcore potentials with sander, λ values should be picked so that 0.01 < clambda <
0.99. The pmemd implementation allows lambda to be set to any value between 0.0 and 1.0, thus simulations at
the endpoints are possible.

Additionally, the following parameters are available to control the TI calculation:

ifsc

Flag for soft core potentials

= 0 SC potentials are not used (default)
= 1 SC potentials are used. Be sure to use prmtop ﬁles that are suitable for this, i.e. not-containing

dummy atoms (see above)

The α parameter in 23.5 and 23.6, its default value is 0.5. Other values have not been extensively
tested

If set to .ne. 0, a summary of all ∂V /∂λ values calculated during every step of the run will be printed
out at the end of the simulation for postprocessing.

scalpha

logdvdl

dvdl_norest This option is now deprecated. Restraints involving soft core atoms are now decoupled from the

rest of the system. The energy is listed separately and does not contribute to ∂V /∂λ .

dynlmb

If set to a value .gt. zero, clambda is increased by dynlmb every ntave steps. This can be used to
perform simulations with dynamically changing lambdas.

446

23.1. Thermodynamic integration

crgmask

Speciﬁes a number of atoms (in ambmask format) that will have their atomic partial charges set to
zero. This is mainly for convenience because it removes the need to build additional prmtop ﬁles
with uncharged atoms for TI calculations involving the removal of partial charges.

23.1.6.1. Input ﬂags speciﬁc to Sander

scmask

Speciﬁes the unique (soft core) atoms for this process in ambmask format. This, along with crgmask,
is the only parameter that will frequently be different in the two mdin ﬁles for V0 and V1. It is valid
to set scmask to an empty string. A summary of the atoms in scmask is printed at the end of mdout.

23.1.6.2. Input ﬂags speciﬁc to PMEMD

scmask1

scmask2

Speciﬁes the unique (soft core) atoms for V0 in ambmask format. It is valid to set scmask1 to an
empty string.

Speciﬁes the unique (soft core) atoms for V1 in ambmask format. It is valid to set scmask2 to an
empty string.

The force ﬁeld potential energy contributions for the unique atoms in each process will be evaluated separately
during the simulation and are recorded after the complete system energy is given:

15 atoms, TEMP(K)

24.3248 SC_EKtot=
4.7723 SC_ANGLE=
4.2947 SC_14EEL=
0.0000

Softcore part of the system:
SC_Etot=
SC_BOND=
SC_14NB=
SC_EEL =
SC_RES_DIST= 0.0000 SC_RES_ANG= 0.0000
SC_RES_TORS=
SC_RES_PLPT= 0.0000 SC_RES_PLPL= 0.0000 SC_RES_GEN =
SC_EEL_DER= 0.0000 SC_VDW_DER=-11.1533 SC_DERIV

SC_EPtot
SC_DIHED
SC_VDW

11.6426
2.1411
0.0000

=
=
=
=

316.69
12.6822
1.6096
-0.1355

0.0000
0.0000
= -11.1533

The temperatures reported are calculated for the SC atoms only and ﬂuctuate strongly for small numbers of unique
atoms. The energies in the ﬁrst six lines include all terms that involve at least one unique atom, but SC_VDW
gives the vdW energy for pairs of unique atoms only which are subject to the standard 12-6 LJ potential. The vdW
potential between soft core / non soft core atoms (as given by equation 23.5) is part of the regular VDWAALS term
and is counted for dV/dl. The same applies to SC_EEL, which gives only the electrostatic interactions between
unique atoms, since electrostatics between soft core / non soft core atoms (for which equation 23.7 is used) are
part of regular EEL-energy. Note that the total potential energy, SC_EPtot, does not include contributions from the
restraint energies.
SC_EEL_DER, SC_VDW_DER, and SC_DERIV are additional λ -dependent contributions to (cid:104)∂V /∂λ(cid:105) that
arise from the form of the SC-potentials. For more information on how to perform and setup calculations, please
consult the tutorials provided at http://ambermd.org.

23.1.6.3. One step transformations using soft core electrostatics

Alternatively to the two-step process of removing charges from atoms ﬁrst and then changing the vdW parame-
ters of chargeless atoms in a second TI calculation, sander and pmemd also have a soft core version of the Coulomb
equation implemented for single step transformations under periodic boundary conditions. This is automatically
applied to all atoms in scmask and their interactions with common atoms are given by:

VV0,disappearing = (1− λ )

4πεo

(cid:113)

qiq j
βλ + r2
i j

(23.7)

for disappearing atoms. Replace λ by (1− λ ) and vice versa for the form for appearing atoms. This introduces

a new parameter β which controls the ’softness’ of the potential. This is set in the input ﬁle via:

scbeta

The parameter β in 23.7. Default value is 12A2, other values have not been extensively tested.

447

23. Free energies

With the use of soft core vdW and electrostatics interactions, arbitrary changes between systems are possible in
single TI calculations. However, due to the unusual potential function forms introduced, it is not always clear that
a single-step calculation will converge faster than one broken down into several steps. Ref. [492] contains detailed
information on the performance of such single step TI calculations.

23.1.7. pmemd.cuda-speciﬁc functionalities
23.1.7.1. Smoothstep function implementation of softcore potential and λ -scheduling

The softcore potentials theoretically can avoid the so-called “end-point catastrophe” in the cases with appearing
and/or disappearing atoms. Nevertheless, there are still some practical issues to be solved. Recently the incor-
poration of the smoothstep function into the current AMBER softcore potential has been implemented in the the
pmemd.cuda TI module. The smoothstep function Sp(x) is a function which functional values and its derivatives
up to Pthvanish at the boundaries x = 0 and x = 1. Such properties deliver much smooth and numerically inte-
grable (cid:104)∂V /∂λ(cid:105) curves. The smoothstep function implementation of the current AMBER softcore potential is
only available on GPU (pmemd.cuda). Here is a brief description:

The smoothstep functions are monotonically increasing functions that have the desirable endpoint values:

For 0 ≤ x ≤ 1 :

S0(x) = x
S1(x) = −2x3 + 3x2
S2(x) = 6x5 − 15x4 + 10x3
S3(x) = −20x7 + 70x6 − 84x5 + 35x4
S4(x) = 70x9 − 315x8 + 540x7 − 420x6 + 126x5

(23.8)

For all p, SP(x < 0) = 0;SP(x > 1) = 1 . Their derivatives, up to pth, are zero at the endpoints. The smoothstep
functions can be incorporated into the softcore potentials for the vDW and electrostatic interactions (only V0 is
shown)

V V DW
V0,

= 4ε



1

(cid:104)
αSp(λ ) +(cid:0) ri j
(cid:113)

V Elec
V0 =

σ

4πεo

(cid:1)6(cid:105)2 −

1

αSp(λ ) + (

ri j
σ )6

qiq j
β Sp(λ ) + r2
i j



and into the mixing scheme: with the weights of the two TI region to be complimentary summed to 1

or with symmetric weights

V (λ ) = (1− Sp(λ ))V0 + Sp(λ )V1

V (λ ) = (1− Sp(λ ))V0 + (1− Sp(1− λ ))V1

(23.11)
Furthermore, the boundaries of smoothstep functions can be deﬁned to be any range within [0,1]. For example,
one can utilize a smoothstep function with boundaries at [0.2, 0.5], which effectively will start the mixing at
λ = 0.2 and ﬁnish at λ = 0.5. This “ λ -scheduling” can be applied to individual interactions and gives the users a
very ﬂexible way to control the mixing of the softcore potentials.

The smoothstep function incorporation is controlled by the following extra input control parameters:

gti_lam_sch Flag for lambda-scheduling

= 1 lambda-scheduling is enabled, i.e., the alchemical parameter λ is replaced by Sp(λ ) (23.10 and
23.11) Note: when gti_lam_sch=1, the default scalpha is set to 0.2 and the default scbeta 50
Å^2.

= 0 lambda-scheduling is disabled (default)

448

(23.9)

(23.10)

23.1. Thermodynamic integration

Lambda-scheduling control ﬁle format: When lambda-scheduling is enabled, the scheduling control will be
read from the control ﬁle named by the command line option “-lambda_sch ﬁlename” or “lambda.sch” (the default
name). If the ﬁle does not exit, the default scheduling behavior will be utilized. Each line in the scheduling control
ﬁle should be in the following format

LambdaType, FunctionType, Matchtype, parameter1, parameter2

LambdaType The interaction type where the lambda-scheduling is applied. Valid values: “TypeGen” (for all gen-
eral usage), “TypeBAT” (for the bonded terms), “TypeRestBA” (for the restraint bond/angle terms),
“TypeEleRec” (for the reciprocal space terms), “TypeEleCC” (for direct space common atom terms),
“TypeEleSC“ (for the direct space SC atom terms), and “TypeVDW” (for the vdw terms)

FunctionType The smoothstep function to bused. Valid values: “linear”, “smooth_step0” (the same as linear),

“smooth_step1”, “smooth_step2”, “smooth_step3”, and “smooth_step4”

Matchtype

The mixing “matching” style, either “complementary”(23.10) or “symmetric” (23.11).

parameter1,parameter2 Real numbers: the λ range where the lambda-scheduling is applied. Much be in [0,1].

For example, an entry of “TypeVDW, smooth_step2, complementary, 0.5, 1.0” means the smoothstep function
S2will be used for the vDW interactions, starting at λ = 0.5 and ending at λ = 1.0 . When gti_lam_sch=1 but the
control ﬁle is missing, the following default will be utilized:

TypeGen, linear, complementary, 0.0, 1.0
TypeBAT, linear, symmetric, 0.0, 1.0
TypeEleRec, linear, symmetric, 0.0, 1.0
TypeEleCC, smooth_step2, symmetric, 0.0, 1.0
TypeEleSC, smooth_ step2, symmetric, 0.0, 1.0
TypeVDW, smooth_ step2, symmetric, 0.0, 1.0

Control of the softcore potentials:

gti_ele_sc Flag for the electrostatic softcore potentials

= 0 smoothstep function is not utilized (default when gti_lam_sch=0).

= 1 smoothstep function is utilized (23.9) according to the TypeEleSC type deﬁned in the lambda-

scheduling control ﬁle (default when gti_lam_sch=1).

gti_vdw_sc Flag for the vDW softcore potentials

= 0 smoothstep function is not utilized (default when gti_lam_sch=0).

= 1 smoothstep function is utilized (23.9) according to the TypeVDW type deﬁned in the lambda-

scheduling control ﬁle (default when gti_lam_sch=1).

23.1.7.2. Treatment of the interactions between the common and softcore regions and within softcore

regions

Regarding the treatment of the interactions between the common and softcore regions, no much attention has
been put on the previous versions of AMBER, including sander, pmemd, and pmemd.cuda. While most of time
such ignorance will not cause signiﬁcant deviations of the calculated free energy differences, it should be treated
in a more theoretically rigorous ways when applicable.

449

23. Free energies

interaction

Regions

SC/CC
SC/CC
SC/CC
SC/CC

vDW
ele
1-4 vDW
1-4 ele
SC internal
vDW
ele
SC internal
1-4 vDW SC internal
SC internal
1-4 ele

0

P
P
P
P
P
P

1
2
3
4
5
6
7
8

gti_add_sc

1

2

S
S

S
S
P
S
P
S

S
S
P
P
P
P

3

S
S
S
S
S
S

Table 23.2.: Summary of the effect of the gti_add_sc switch: (SC: Softcore (Dummy) region, CC: common core
part, S: Scaled with lambda: not present in the dummy state, P: Not scaled with lambda: present in
the dummy state)

The non-bonded terms between the common region and the softcore regions should be
The non-bonded terms:
always scaled with the alchemical variable λ . Nevertheless, the 1-4 non-bonded terms were not treated properly in
the previous versions of AMBER, A ﬁx has been implemented in AMBER20. The non-bonded terms within the
softcore regions can be treated in either ways, provided that the conformational sampling of the softcore regions at
the end point states are properly done. The following input control has been added:

gti_add_sc Flag to control the non-bonded interactions between the common and softcore regions, and within

the softcore regions.

= 0 the behavior of the versions prior to AMBER20
= 1 the 1-4 non-bonded terms between the common and softcore regions are scaled with the alchem-

ical variable λ . default.

= 2 the electrostatic interactions, including the 1-4 terms, within the softcore regions are scaled with

the alchemical variable λ .

= 3 In addition to the electrostatic interactions, the vDW interactions, including the 1-4 terms, within

the softcore regions are scaled with the alchemical variable λ .

The behavior is summarized in Table 23.2

It has been proved that [493–495] that only certain ways to handle the bonded terms across
The bonded terms:
the common region and the softcore regions are theoretically correct. Brieﬂy, there should be only one bond length
term involving one softcore atom, one angle term involving one softcore atom, and one torsion term involving two
softcore atoms can be not scaled with the alchemical variable λ . These terms, however, seem not having signiﬁcant
effect in most cases. The following input control has been added:

gti_bat_sc Flag to control the bonded interactions between the common and softcore regions, and within the

softcore regions.

= 0 the behavior of the versions prior to AMBER20 (default)
= 1 the program will automatically decide the terms to be and not to be scaled with the alchemical

variable λ .

= 2 the user can decide the terms not to be scaled with the alchemical variable λ , others will be

scaled. (see below)

When gti_bat_sc=2, The selection is done by the following masks. All must be in the AMBER standard mask
language. The program will automatic determine the terms involving in the selected atoms.

sc_bond_mask1: The mask to select the cross common-softcore bond length terms of the softcore region 1.

450

23.1. Thermodynamic integration

All P

gti_bat_sc

Bonded terms at the SC/CC boundary

Any terms involving any dummy atom(s)
bond

0

1

2

angle

torsion

bond
angle
torsion

R-D
R-R-D
R-D-D
R-D-R
D-R-D
R-R-D-D
R-D-D-D
R-R-R-D

Only one P; all others S
Only one P; all others S

Only one P; all others S

All P
All S
All S

All P
All S

sc_bond_mask1,2
sc_angle_mask1,2
sc_torsion_mask1,2

Select atoms to be P, all others S
Select atoms to be P, all others S
Select atoms to be P, all others S

Table 23.3.: Summary of the effect of the gti_bat_sc switch: (SC: Softcore (Dummy) region, CC: common core
part, S: Scaled with lambda: not present in the dummy state, P: Not scaled with lambda: present in
the dummy state). Here lists only the boundary terms, all internal SC bonded terms are P.

sc_bond_mask2: The mask to select the cross common-softcore bond length terms of the softcore region 2.

sc_angle_mask1: The mask to select the cross common-softcore angle terms of the softcore region 1.

sc_angle_mask2: The mask to select the cross common-softcore angle terms of the softcore region 2.

sc_torsion_mask1: The mask to select the cross common-softcore torsion terms of the softcore region 1.

sc_torsion_mask2: The mask to select the cross common-softcore torsion terms of the softcore region 2.
The behavior is summarized in Table 23.3

23.1.7.3. Extra input controls (pmemd.cuda only)

Some input controls have been implemented to more ﬂexibly control the TI simulations:

ti_vdw_mask: Mask selection to zero out vDW interactions. (In the standard AMBER mask language, similar to

crgmask)

gti_output: 0: default; 1: output the term-by-term detailed TI results.
gti_cpu_output: 1: default: the softcore λ -derivative terms will be combined and output the same result for
each TI region (to match the CPU-version output).; 0: the softcore λ -derivative terms will be output
for each TI region.

gti_cut:

1: default:
the non-bond cutoff, deﬁned by cutoff, will not have effect on the internal softcore
non-bonded terms. 0: the old behavior of the versions prior to AMBER20. Since the non-bonded
terms within the softcore regions could be scaled differently with with the alchemical variable λ .
The default non-bond cutoff cannot be applied to them. One should always use gti_cut=1 unless a
comparison with the results from a previous version is desired.

gti_chg_keep: 1: default: the charges of the softcore region atoms will not be neutralized. 0: the old behavior
of the versions prior to AMBER20: the charges of the softcore region atoms will be neutralized if
the net charge is smaller than 0.01.

23.1.8. Preparing TI simulations for use in PMEMD

Since the generation of the prmtop ﬁle required for pmemd TI calculations is slightly more complex, than the
generation of two independent prmtop ﬁles as required by sander, so we provide here a number of examples
speciﬁc to pmemd.

451

are:








23. Free energies

23.1.8.1. Free Energy using linear scaling

For this type of simulation, the molecule is perturbed between the start and end states using linear scaling (Eq.
23.3). This means that V0 and V1 must have the same number of atoms. Start by parameterizing the molecule
as usual. This may include the addition of dummy atoms as needed. Then, create a pdb which contains both
molecules separated by a TER card. Also, update the residue number for the second molecule. If the molecules are
different, be sure to use a different residue name for each one. The coordinates for corresponding atoms in the pdb
should be the same. The prmtop can then be prepared as usual, using LEaP. Note that LEaP sees both molecules,
so it may report a net charge in the prmtop, even though there is no net charge for V0 or V1, even after the addition
of neutralizing counterions. See Chapter 13 for a complete description of LEaP. The input ﬂags for this system

icfe = 1, timask1 = ':1', timask2 = ':2'

Where the ﬁrst molecule is unique to V0 and the second molecule is unique to V1. There may be any number of

other molecules, which are treated as common atoms and are part of both V0 and V1.

23.1.8.2. Absolute free energy using soft core

For this type of simulation, a molecule is decoupled from the rest of the system using soft core potentials (Eqs.
23.5,23.6). Set up the prmtop as you would to run a simulation of the system. The end state is the system with a
fully decoupled molecule, so this prmtop will also work for TI. The input ﬂags for this system are:

icfe = 1, ifsc = 1,
timask1=':1', scmask1=':1',
timask2='', scmask2='',

Where the ﬁrst molecule is the one that is decoupled from the rest of the system at the end state.

23.1.8.3. Relative free energy using soft core

For this type of simulation, a molecule is mutated from one to another using soft core potentials (Eqs. 23.5,23.6).
This can be done as a single step using soft core electrostatics (Eq. 23.7), or part of a multistep TI calculation.
The prmtop is prepared in the same way for both cases. First, parameterize both molecules as usual. Then, create
a pdb containing both molecules, separated by a TER card. Additional molecules may be present and will be
treated as common atoms. Using this pdb, prepare the system using LEaP. The resulting prmtop can be used for
TI calculations. The input ﬂags for this system are:

icfe = 1, ifsc = 1,
timask1=':1', scmask1=':1',
timask2=':2', scmask2=':2',

Where the ﬁrst molecule corresponds to the starting state, and the second molecule corresponds to the ending
state. This will set up a single step transformation using soft core electrostatics. To set up a soft core vdW
transformation, the ﬂag crgmask=’:1 | :2’ can be added.

23.1.8.4. Mutation of a protein residue

For this type of simulation, a single residue is mutated in a protein. First, take the pdb for the wildtype and the
mutant proteins and concatenate the one after the other, separating them by a TER card. This is necessary because
LEaP must deal with full molecules. The atoms in the common residues should all have the same coordinates. Any
changes to the common residues, such as the addition of disulﬁde bonds or changing the protonation of HIS, must
be done for both copies of the protein in LEaP. The output prmtop and inpcrd ﬁles now have two copies of the
protein, with one including the mutated residue. Consider a system where residues ’:1-5’ represent the wildtype
protein and residues ’:6-10’ represent the mutant protein. Furthermore, assume that residue ’:3’ in the wildtype is
mutated, so the corresponding residue in the mutant is residue ’:8’. The input ﬂags for this system are:

452













icfe = 1, ifsc = 1,
timask1=':1-5', scmask1=':3',
timask2=':6-10', scmask2=':8',

23.1. Thermodynamic integration

This will do a single step transformation from the wildtype to the mutant protein.

There are a large number of redundant bonding terms that are being calculated, since there are two proteins in the
prmtop ﬁle. These additional bonding terms can be eliminated, improving the efﬁciency of the calculation. This
is an advanced technique, which is not needed to run a TI simulation, but to have the most efﬁcient calculation.
In order to do this, a command has been added to parmed to remove these extra terms and atoms as described in
Section 14.2.

To run parmed:

parmed -p ti.prmtop -i merge.in

The input for parmed (merge.in) looks like this:

loadRestrt ti.inpcrd
setOverwrite True
tiMerge :1-5 :6-10 :3 :8
outparm ti_merged.prmtop ti_merged.inpcrd
quit

This will output ti_merged.prmtop and ti_merged.inpcrd which have had redundant bonding terms removed, as
well as the masks that should be used in the simulation. The parmed output gives:



Done!


Loaded Amber topology file ti.prmtop
Reading actions from merge.in
Loading restart file ti.inpcrd
Prmtop is overwritable
Merging molecules :1-5 and :6-10 into the same molecule.
Use softcore mask:
timask1='@41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59',
timask2='@77,78,79,80,81,82,83,84,85,86,87,88,89,90',
scmask1='@41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59',
scmask2='@77,78,79,80,81,82,83,84,85,86,87,88,89,90',
Outputting Amber topology file ti_merged.prmtop

Now the input ﬂags for pmemd are:

icfe = 1, ifsc = 1,
timask1='@41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59',
timask2='@77,78,79,80,81,82,83,84,85,86,87,88,89,90',
scmask1='@41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59',
scmask2='@77,78,79,80,81,82,83,84,85,86,87,88,89,90',



Another possible use is to remove redundant bonding terms in a non soft core simulation. The set up is very
similar to that described above, except that the number of atoms in both molecules must be the same. When using
parmed, ignore the scmask1/scmask2 output, as these are not used in non soft core simulations.

23.1.8.5. gas phase calculations using GB

alchemical free energy calculations (TI/FEP/MBAR) may now be run in gas phase in the pmemd module. This
is accomplished by using the igb=6 (no implicit solvent) option for a generalized born simulation. The only other

453











23. Free energies

unique input is cut = 9999.0, because there is particle mesh ewald to account for long range contributions for atoms
farther apart than cut. An example input ﬁle for changing the lennard-jones terms of 2-methylfuran (resname 2MF)
to methane in the gas phase using TI is shown below:



&cntrl

imin = 0, nstlim = 500000, irest = 0, ntx = 1, dt = 0.001,
ntt = 3, temp0 = 298.0, gamma_ln = 2.0, ig = -1,
ntb = 0, cut = 9999.0, igb = 6,
ioutfm = 1, iwrap = 0,
ntwe = 10000, ntwx = 10000, ntpr = 1000, ntwr = 500000, ntave = 500000,
ntc = 2, ntf = 1, tishake = 1,
noshakemask = ':1,2',
icfe = 1, ifsc = 1, clambda = 0.5, scalpha = 0.5, scbeta = 12.0,
timask1 = ':1', timask2 = ':2',
scmask1 = ':2MF@O3,C4,C5,C6,H10,H11,H12',

scmask2 = ''

/





23.1.9. Collecting potential energy differences for FEP calculations

In addition to the Thermodynamic Integration capabilities described above, sander can also collect potential
energy values during free energy simulation runs for postprocessing by e.g. the Bennett acceptance ratio scheme.
This will make sander calculate at given points during the simulation the total potential energy of the system as it
would be for different λ -values at this conformation. This functionality is controlled by:

ifmbar

If set to 1 (Default = 0), additional output is generated for later postprocessing.

mbar_states number of lambda windows considered.

mbar_lambda lambda windows simulated.

example, if you want to run mbar with 15 lambda windows at 0.00, 0.05, 0.10, 0.15, 0.20, 0.30, 0.40,
0.50, 0.60, 0.70, 0.80, 0.85, 0.90, 0.95, 1.00, you would use the following options:

ifmbar = 1,
mbar_states = 15,
mbar_lambda = 0.00, 0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.85, 0.90, 0.95, 1.00,

For







The

options below have been deprecated. They are here for anyone using AMBER 16 or older, but will
not work in AMBER 18.

bar_intervall Compute potential energies every bar_intervall steps (Default = 100)

bar_l_min Minimum λ -value (Default = 0.1)

bar_l_max Maximum λ -value (Default = 0.9)

bar_l_incr The increment to increase λ by between the minimum and maximum (Default = 0.1)

Such energy collection will normally be part of a regular free energy calculation (using icfe=1 and ifsc=1) in-
volving simulations at various λ -values. Activating this functionality will not have any inﬂuence on the simulation
trajectory which will evolve according to the preset clambda value, it is merely a bookkeeping scheme that removes
the necessity of postprocessing output ﬁles later.

454

23.2. Linear Interaction Energies

23.2. Linear Interaction Energies

sander contains rudimentary facilities to compute binding free energies using the linear interaction energy

model.

ilrt

if set to 1, turns on the computation of LIE contributions (default=0)

lrt_interval Computer LIE contributions every lrt_interval MD steps (default=50)

lrtmask

The ’solute’. Interaction Energies between the atoms in lrtmask and the remainder of the system are
computed.

The LIE facilities work by computing the system energies several times using different charge and vdW-parameter
sets. This results in reduced performance if lrt_interval is set to less than approx. 10. The LIE output at the end
of the mdout ﬁle gives the electrostatic interaction energy between the solute and rest of the system times 0.5, i.e.
in accordance with the original formulation of LIE theory. The solute SASA and vdW-interaction energy with its
surroundings is calculated unscaled.

23.3. Replica Exchange Molecular Dynamics (REMD)

Replica exchange molecular dynamics (REMD) is an expanded ensemble method—it samples from an ensemble
(signiﬁcantly) larger than a typical statistical mechanical ensemble deﬁned by the Hamiltonian governing the
system (e.g., microcanonical, canonical, grand-canonical, etc.). This section will brieﬂy describe the general
theory of REMD-based techniques, after which the later subsections will cover the details of Amber’s REMD
implementation as well as the various allowable exchange types.

23.3.1. Introduction

‘Sampling’ in expanded ensemble techniques can be broadly decomposed into two different types of sub-
sampling within the total ensemble. The ﬁrst type is the common conformational sampling that can be realized
through methods like molecular dynamics. The second type samples from thermodynamic state-space, in which
the core Hamiltonian (together with its thermodynamic constraints) that deﬁnes the ensemble is allowed to change.
Thus, expanded ensemble techniques broaden the sampling space of simulations by allowing a system to move
through both conformational space (which is typically continuous) and state space (which is typically discrete). A
point in the phase space of the expanded ensemble is deﬁned by speciﬁc value(s) of the state parameter(s) in addi-
tion to the 3N particle positions and conjugate momenta. To simplify terminology, I will refer to all of the points in
phase space that have the same value of the state parameter(s) as a ‘sub-ensemble’ since it can be interpreted as the
statistical ensemble deﬁned by that thermodynamic state, whereas ‘the ensemble’ will refer to the full, expanded
ensemble containing all state indices.

To ensure that the ensemble is constructed properly, the simulation must generate a reversible Markov chain
of states. Standard MD obeys this requirement under the (ubiquitous) assumption that the system is ergodic. For
Monte Carlo-based methods, a reversible Markov chain implies that the condition of detailed balance (Eq. 23.12)
is satisﬁed. Detailed balance is effectively an equilibrium condition, in which the probability of being in state i (πi)
multiplied by the transition probability of moving from state i to j (Pi→ j) is equal to the probability of being in state
j multiplied by the transition probability of moving from state j to i. By relating probabilities with concentrations
and transition probabilities with chemical rate constants, it is easy to see that Eq. 23.12 is a simple equilibrium
equation between two species.

πiPi→ j = π jPj→i

(23.12)
To sample from the ensemble, REMD employs a set of non-interacting replicas (i.e., the forces on the particles
are unaffected by the particles in other replicas) that attempt to swap their positions in state space during the course
of the simulation. In Amber, the conformational sampling in each replica (i.e., sub-ensemble) is peformed with MD
while replica swaps in state space are performed using Metropolis Monte Carlo in which the exchange probability
is computed from Eq. 23.12.

455

23. Free energies

The general workﬂow used by Amber for replica exchange simulations is illustrated in Figure 23.1. Each replica
runs a pre-speciﬁed number of MD steps before stopping to attempt exchanges with one of its nearest neighbor (its
exchange partner alternates every other exchange attempt). Restricting exchange attempts to pairs is not required
(exchanges can involve 3 replicas, for instance), but it greatly simpliﬁes the resulting exchange probability when
solving Eq. 23.12, and allows N/2 consecutive exchanges to be attempted independently. Furthermore, replica
exchange attempts need not be made deterministically or synchronously (i.e., each replica evaluates exchange
attempts at the same time relative to each other), but doing so signiﬁcantly simpliﬁes the programming require-
ments. The following sections will describe how REMD is implemented and performed in Amber for each of the
supported types of exchanges—temperature, solution pH, solution Redox Potential, and generalized Hamiltonian.
If you are not already familiar with the technique and its theoretical underpinnings, we recommend that you

study the literature, particularly of the type of replica exchange you plan on using.[496–502]

Figure 23.1.: Replica exchange schematic showing 5 replicas combined in an expanded ensemble. Large arrows
represent MD trajectories of sub-ensembles while the smaller arrows represent attempted swaps be-
tween replicas in state space. Question marks represent Monte Carlo exchange attempts (green for
successful, red for failed).

23.3.2. Running REMD simulations

In order to run REMD simulations, sander and pmemd use the multisander (and multipmemd) machinery that
allows multiple MD trajectories to be run in the same simulation. This mode of sander and pmemd is used slightly
differently than their normal operation, and is described in Section 19.11.

There are two new variables that must be present in the &cntrl section of the mdin ﬁles of each replica for all

REMD simulations.

numexchg This is the number of exchange attempts that will be performed between replica pairs

nstlim This is the number of MD steps that will be performed between exchange attempts

456

State Coordinate (e.g., Temperature)TimeReplica 1Replica 2Replica 4Replica 5Replica 2Replica 1Replica 4Replica 5Replica 2Replica 1Replica 5Replica 4????23.3. Replica Exchange Molecular Dynamics (REMD)

gremd_acyc (H-REMD only) When set to 1, the exchange between the ﬁrst and the last replicas will not be

considered and odd numbers of replicas are allowed. Default: 0.

There are also additional command-line ﬂags that should be placed on the command-line (with the groupﬁle),
described below:1

-rem <#> This ﬂag deﬁnes the type of replica exchange that will be run for 1-D REMD. The allowed values are 1

(T-REMD), 3 (H-REMD), 4 (pH-REMD), and 5 (E-REMD). Each approach is described in later sections.

-remlog <remlog_ﬁle> This ﬂag speciﬁes the name of the log ﬁle that contains information about each of the

replicas during each exchange attempt. The default value is rem.log.

-remtype <remtype_ﬁle> This ﬂag speciﬁes a ﬁlename for the remtype ﬁle; this ﬁle provides helpful information
about the current replica run. For reservoir REMD runs it also prints reservoir information. Default is
rem.type

Some specialized types of REMD simulations have additional command-line ﬂags that will be described in future
sections.

Note the change in the meaning of nstlim. For standard MD, nstlim is the total number of MD steps that will
be performed. For REMD simulations, on the other hand, nstlim is the number of steps between replica exchange
attempts and the total number of steps is equal to nstlim× numexchg. The nstlim variable, then, is related to the
inverse of the exchange attempt frequency (EAF) in REMD simulations. The value of numexchg must be the same
for each input ﬁle, or the program will hang indeﬁnitely as those replicas assigned more exchange attempts wait to
exchange data with replicas that have already ﬁnished. We also strongly suggest keeping nstlim the same as well
to avoid making replicas with fewer steps wait for those with more steps to ﬁnish.

REMD simulations can be run in any thermodynamic ensemble (NVE, NVT, and NPT as of AmberTools 19/Am-
ber 20). When running replica exchange simulations with explicit sovelnt in the NVE or NVT ensemble, all replicas
must have the same volume. Therefore, the equilibration stage of each replica should begin after the original sys-
tem was run at constant pressure to stabilize the density (and volume). There is no such restriction for NPT REMD
simulations.

Amber currently supports 5 types of exchange attempts: Temperature REMD (T-REMD), Hamiltonian REMD
(H-REMD), constant pH REMD (pH-REMD), constant Redox Potential REMD (E-REMD), and replica exchange
self-guided Langevin dynamics (RXSGLD). Multi-dimensional REMD simulations (deﬁned by 2 or more state
parameters) are also supported. The instructions given above apply to all REMD simulations, but instructions for
running REMD simulations in general strongly depend on the type of exchange being attempted. Additional details
for running REMD simulations are provided in the following sections for each type of exchange attempt.

23.3.3. Generating REMD input ﬁles with genremdinputs.py

Preparing all the necessary REMD input ﬁles, which are the mdin ﬁles and groupﬁle, and also the remd-ﬁle if
doing Multidimensional REMD (see Subsection 23.3.9.1), can be time consuming and in some cases confusing.
The genremdinputs.py, a Python tool written by Vinícius Cruzeiro, helps to make this task much easier [503].
This tool can be used to prepare the input ﬁles for any REMD simulation, one-dimensional or Multidimensional.
You can access a list and description of all available command-line ﬂags using the --help ﬂag, whose output is
shown below.

usage: genremdinputs.py [Options]
optional arguments:

-h, --help
-v, --version
--author
-O, --overwrite

Required Arguments:

show this help message and exit
show the program’s version and exit
show the program’s author name and exit
Allow existing outputs to be overwritten. Default:
False

1Some specialized types of REMD simulations have additional command-line ﬂags that will be described in the later sections.

457

23. Free energies

-inputs [FILE [FILE ...]]

Input files containing pH, Redox Potential,
Temperature, or Hamiltonian values. Each file must
state the type of exchange on the first line (same as
in the exch_type flag of the remd-file for M-REMD
simulations), a description in the second line, and
all variable values on the following lines (one value
per line). As the number of replicas on each REMD
dimension needs to be even, the number of values needs
to be even.

-groupfile [FILE [FILE ...]]

Reference groupfiles. Each reference groupfile must
contain only a single block referring to a single
replica. In this block the replica number must be
replaced by REPNUM (the program will replace this flag
later in order to create the whole groupfile file). If
doing a REMD simulation with the Hamiltonian
dimension, the prmtop file name may be replaced by the
same flag entered in the first line of the hamiltonian
file given in the -inputs flag. The reference
groupfiles must be given in the same order as their
corresponding reference mdin files.

-i [FILE [FILE ...]] Reference mdin files. Each reference mdin file must
contain the variable(s) being exchanged replaced by
the same flag entered in the first line of the file
given in the -inputs flag. Examples: solvph=PH,
solve=REDOX, temp0=TEMPERATURE. Also, each reference
mdin file must contain ig=RANDOMNUM. The reference
mdin files must be given in the same order as their
corresponding reference groupfiles.

Non-required Arguments:

-remd-file-out FILE

-randomseed INTEGER
-nosort

-verbose, --verbose

Name of the -remd-file output file. Default:
remd.dim.[REMD dimensions types]remd
Seed for the random number generator. Default: 10
If stated, the replica ordering per dimension will not
be sorted. If not stated, sorting will be done if the
input values are float or integer.
If stated, prints information on the screen while the
program is executed.

This program generates the input files for any REMD simulations (including
MultiD-REMD). It generates: the groupfile, mdin files, and the -remd-file.

genremdinputs.py requires one reference mdin ﬁle, one reference groupﬁle containing only a single block refer-
ring to one replica, and one simple input ﬁle for each REMD dimension. We now go over a few examples. The
ﬁrst example is more detailed and should be used as a reference before moving to the other examples.

23.3.3.1. Generating input ﬁles for T-REMD

Here is an example of an input ﬁle, that we call here temperatures.dat, to be passed to -inputs:

TEMPERATURE
Temperature Replica Exchange
260.0
280.0
300.0
320.0

458

23.3. Replica Exchange Molecular Dynamics (REMD)

The ﬁrst line in this ﬁle is an identiﬁer for genremdinputs.py and should not be changed (as of Amber18, the
allowed options are: TEMPERATURE, HAMILTONIAN, PH and REDOX). The second line is a description line
and you may enter any description you want. The following lines correspond to the temperatures to be used for each
replica, therefore in this example our T-REMD simulation would have 4 replicas. Please remember that Replica
Exchange simulations require an even number of replicas. Adding more replicas is simple and only requires one
to add more temperature values inside temperatures.dat.

The reference mdin ﬁle consist on the mdin ﬁle for a single replica with some simple adaptions. Here is an

example of a mdin.ref ﬁle:

&cntrl

imin=0, irest=1, ntx=10000, ntpr=10000,
ntwx=10000, nstlim=10, numexchg=500000,
dt=0.002, ntt=3, temp0=TEMPERATURE,
gamma_ln=1.0, ig=RANDOMNUM,
ntc=2, ntf=2, cut=8, iwrap=1, ioutfm=1,
saltcon=0.1,
/

The value of temperature in temp0 has to be replaced by the exact same string that goes into the ﬁrst line of
temperatures.dat, in this case TEMPERATURE. In Replica Exchange simulations the random seed ig should
be different for the different replicas, and by replacing the value of ig by RANDOMNUM the genremdinputs.py
tool will automatically place random numbers for this seed in each replica. Placing ig=RANDOMNUM is always
required by genremdinputs.py. The random seed used by genremdinputs.py to generate these random numbers
can be changed by the ﬂag -randomseed. In this example, as the reference mdin ﬁle ends with the sufﬁx .ref the
following mdin ﬁles would be generated: mdin.rep.001, mdin.rep.002, mdin.rep.003, and mdin.rep.004.
The sufﬁx .ref in the reference mdin ﬁle name is optional.

Here is an example of a reference groupﬁle which we call groupfile.ref:

# Replica REPNUM
-O -i mdin.rep.REPNUM -p prmtop -c min.x -o mdout.rep.REPNUM -r rst7.rep.REPNUM

You must replace the replica number by the ﬂag REPNUM every time it appears. In this example, as the reference
groupﬁle ends with the sufﬁx .ref, this sufﬁx will be removed and the output groupﬁle would be groupfile. The
sufﬁx .ref in the reference groupﬁle name is optional; if it is not provided the output ﬁle name will have the same
name as the reference group ﬁle plus a sufﬁx .final.
Here is an example of the execution of the program:

genremdinputs.py -inputs temperatures.dat -groupfile groupfile.ref -i mdin.ref -O

The options -O overwrites any existing ﬁles with the same name as any output ﬁles. The reference mdin ﬁle and
groupﬁle should not be used in your REMD simulations, only the output ﬁles generated by genremdinputs.py.
Please notice that genremdinputs.py will also generate the remd-ﬁle, however you don’t need to provide this ﬁle
in your simulation (unless you want to execute your one-dimensional REMD simulation using Amber’s multidi-
mensional REMD module, which should give equivalent results).

23.3.3.2. Generating input ﬁles for pH-REMD

The procedure here is very similar to what has been shown for T-REMD in Subsection 23.3.3.1. Here is an

example of a phs.dat input ﬁle to be passed to -inputs:

PH
pH Replica Exchange
2.0
2.5
3.0
3.5

459

23. Free energies

In your reference mdin ﬁle, in addition to ig=RANDOMNUM, the only other modiﬁcation needed is solvph=PH.

23.3.3.3. Generating input ﬁles for E-REMD

The procedure here is very similar to what has been shown for T-REMD in Subsection 23.3.3.1. Here is an

example of a redoxes.dat input ﬁle to be passed to -inputs:

REDOX
Redox Potential Replica Exchange
0.75
0.78
0.81
0.85

In your reference mdin ﬁle, in addition to ig=RANDOMNUM, the only other modiﬁcation that would have to be done
is solve=REDOX.

23.3.3.4. Generating input ﬁles for pH,T-REMD

In this Multidimensional REMD example, let’s consider the phs.dat ﬁle from Subsection 23.3.3.2 and the

temperatures.dat from Subsection 23.3.3.1. The mdin.ref ﬁle would look like this:

&cntrl

imin=0, irest=1, ntx=10000, ntpr=10000,
ntwx=10000, nstlim=200, numexchg=2500,
dt=0.002, ntt=3, temp0=TEMPERATURE,
gamma_ln=1.0, ig=RANDOMNUM,
ntc=2, ntf=2, cut=8, iwrap=1, ioutfm=1,
icnstph=2, solvph=PH, ntcnstph=100,
saltcon=0.1,
/

The example reference groupﬁle shown in Subsection 23.3.3.1 would also work here. The command would then
be:

genremdinputs.py -inputs phs.dat temperatures.dat -groupfile groupfile.ref -i mdin.ref -O

The remd-ﬁle generated will now have to be consider for your Multidimensional REMD simulation (see
Subsection 23.3.9.1 for more details about remd-ﬁle). The order of the dimensions exchanging will be the same
as the order of the input ﬁles provided to the ﬂag -inputs. For example, in order to generate input ﬁles for
T,pH-REMD the command would be:

genremdinputs.py -inputs temperatures.dat phs.dat -groupfile groupfile.ref -i mdin.ref -O

23.3.3.5. Generating input ﬁles for H-REMD

Apart from the random seed in the mdin ﬁles, in Hamiltonian REMD the replicas may differ by either their

topology ﬁles or a parameter inside their mdin ﬁles. The ﬁle hamiltonians1.dat below shows an example for
the situation in which the topology ﬁles are different for each replica:

HAMILTONIAN
Hamiltonian Replica Exchange with different topologies
prmtop.1
prmtop.2
prmtop.3
prmtop.4

460

23.3. Replica Exchange Molecular Dynamics (REMD)

In this case, your reference mdin ﬁle should still contain ig=RANDOMNUM, however the HAMILTONIAN pointer
should not be in your reference mdin ﬁle but in your reference groupﬁle, as the example ﬁle groupfile1.ref
shows below:

# Replica REPNUM
-O -i mdin.rep.REPNUM -p HAMILTONIAN -c min.x -o mdout.rep.REPNUM -r rst7.rep.REPNUM

Let’s now considering the situation in which the different replicas differ by a parameter inside their mdin ﬁles (a
parameter other than ig). An example of this situation is shown in the ﬁle hamiltonians2.dat below:

HAMILTONIAN
Hamiltonian Replica Exchange with different mdins
0.0000
0.3333
0.6667
1.0000

Similarly to what has been done for temp0 in T-REMD (see Subsection 23.3.3.1) or for solvph in pH-REMD
(see Subsection 23.3.3.2), you need to place the pointer HAMILTONIAN in the ﬂag inside the reference mdin ﬁle
corresponding to the values listed in the ﬁle hamiltonians2.dat. A reference groupﬁle like the groupfile.ref
ﬁle shown in Subsection 23.3.3.1 could be used together with this input ﬁle.

23.3.3.6. Generating input ﬁles for H,H-REMD

genremdinputs.py supports generating ﬁles for Multidimensional REMD simulations that contain two or

more different Hamiltonian dimensions. In this H,H-REMD example, we will adapt the ﬁles
hamiltonians1.dat and hamiltonians2.dat from the Subsection 23.3.3.5 to be respectively our ﬁrst and
second Hamiltonian dimensions. The changes required in these ﬁles are quite simple: the ﬁrst line in
hamiltonians1.dat need to be changed to HAMILTONIAN1 and the ﬁrst line in hamiltonians2.dat need to
be changed to HAMILTONIAN2. The reference groupﬁle is groupfile.hhremd.ref:

# Replica REPNUM
-O -i mdin.rep.REPNUM -p HAMILTONIAN1 -c min.x -o mdout.rep.REPNUM -r rst7.rep.REPNUM

You need to place the pointer HAMILTONIAN2 in the ﬂag inside the reference mdin ﬁle corresponding to the
values listed in the ﬁle hamiltonians2.dat. The genremdinputs.py tool can then be executed in the following
way:

genremdinputs.py -inputs hamiltonians1.dat hamiltonians2.dat -groupfile \
groupfile.hhremd.ref -i mdin.ref -O

If none of Hamiltonian dimensions in the H,H-REMD simulation involves changing the topology ﬁle, then the
pointers HAMILTONIAN1 and HAMILTONIAN2 should be both inside the reference mdin ﬁle.

23.3.4. Running Temperature REMD simulations

In temperature REMD (T-REMD), replicas are distinguished based on the temperature of their temperature bath.
In general, each replica should differ from each other only by their target temperature, temp0, speciﬁed in the mdin
ﬁle for each replica. The N replicas are ﬁrst sorted in an array by their target temperatures, so the ordering of the
replicas in the groupﬁle is irrelevant. Neighboring residues attempt to exchange every nstlim MD steps, with
the exchange partners alternating each replica exchange attempt. For example, if replicas 2 and 3 attempt to swap
the ﬁrst time then replicas 1 and 2 will attempt to swap the next time (as will replicas 3 and 4). Topologically,
the N temperature-sorted replicas form a loop, in which the ﬁrst and the last replicas are neighbors. Therefore,
N/2 exchanges are attempted every nstlim steps. The exchange success rate is computed via a Metropolis Monte
Carlo move shown in Eq. 23.13 that satisﬁes detailed balance for swapping temperatures.
If the exchange is
allowed between the pair, the temperature between the replicas is swapped before MD resumes. The velocities of

461

23. Free energies

each replica involved in successful exchange are then adjusted by the scaling factor(cid:112)Tnew/Told where Told is the

temperature before the exchange and Tnew is the temperature after. This velocity scaling is done to ensure that each
structure is immediately adjusted to its new target temperature. After the exchange calculation, the MD resumes
for nstlim steps until the next exchange attempt (in which the exchange partners alternated with respect to the
previous exchange attempt).

Pi, j = min(cid:8)1,exp [− (βi − β j) (E j − Ei)](cid:9)

(23.13)

Before starting a replica exchange simulation, an optimal set of temperatures should be determined so that the
exchange ratio is roughly a constant. This spacing of the replicas in temperature-space determines the probability
of exchange among the replicas, and the user is referred to the literature for a more complete description of the
inﬂuence of various factors on the exchange probability. A useful resource for generating a series of temperatures
with a speciﬁc exchange success probability has been developed by Patriksson and van der Spoel[504] and can be
found online at http://folding.bmc.uu.se/remd.

Each replica requires (for input ﬁles) or generates (for output ﬁles) its own mdin, inpcrd, mdout, mdcrd, restrt,
mdinfo, and associated ﬁles. The names are provided through the speciﬁcation of a groupﬁle on the command line
with the -groupﬁle groupﬁle option. The groupﬁle ﬁle contains a separate command line for each of the replicas or
multisander instances, as described in Section 19.11. To choose the number of replicas or multisander instances,
the -ng N command line option is used (in this case to specify N separate instances.)

For example, an 4-replica REMD job will need 4 mdin and 4 inpcrd ﬁles. Then, the groupﬁle might look like

this:

#
# multisander or replica exchange group file
#
-O -i mdin.rep1 -o mdout.rep1 -c inpcrd.rep1 -r restrt.rep1 -x mdcrd.rep1
-O -i mdin.rep2 -o mdout.rep2 -c inpcrd.rep2 -r restrt.rep2 -x mdcrd.rep2
-O -i mdin.rep3 -o mdout.rep3 -c inpcrd.rep3 -r restrt.rep3 -x mdcrd.rep3
-O -i mdin.rep4 -o mdout.rep4 -c inpcrd.rep4 -r restrt.rep4 -x mdcrd.rep4

Note that for T-REMD the mdin and inpcrd ﬁles are not required to be ordered by their target temperatures since
they will not remain sorted during the simulation. Sorting is performed automatically at each REMD iteration as
described above. Thus one can restart REMD simulations without modifying the restart ﬁles from the previous
REMD run (see below for more information about restarting REMD).

It is important when running T-REMD to ensure that each topology ﬁle is equivalent and the input ﬁles differ only
in the temperature (temp0), and that all explicit solvent calculations are run at constant volume. Because Eq. 23.13
was derived under the assumption that exchanging replicas only swapped temperatures, only the temperature can
vary between replicas. Satisfying this requirement is left to the user, and no warnings or checks are implemented
if this assumption is violated.

23.3.4.1. Restarting REMD simulations

It is recommended that each REMD run generate a new set of output ﬁles (such as mdcrd), but for convenience
one may use -A in the command line in order to append output to existing output ﬁles. This can be a useful option
when restarting REMD simulations. If -A is used, ﬁles that were present before starting the REMD simulation are
appended to throughout the new simulation. If -O is used, any ﬁles present are overwritten. The recommended
input ﬁle settings for restarting a REMD simulation are ig=-1 to use the wall clock for the pseudo-random number
generator seed, ntxo=2 to write a NetCDF restart ﬁle, ioutfm=1 to write NetCDF trajectories, irest=1 to restart, and
ntx=5 to read velocities; the ﬁrst three should be used in the initial calculation.

At the end of a REMD simulation, the target temperature of each replica is most likely not the same as it was
at the start of the simulation (due to successful exchanges). If one wishes to continue this simulation, sander or
pmemd will need to know how the target temperature has changed. Since the target value is normally speciﬁed
in the mdin ﬁle (via temp0), the previous mdin ﬁles would all need to be modiﬁed to reﬂect changes in target
temperature of each replica. In order to simplify this process, sander and pmemd write the ﬁnal target temperature

462

23.3. Replica Exchange Molecular Dynamics (REMD)

as additional information in the restart ﬁles during a T-REMD simulation. When a T-REMD simulation is started,
the program will check to see if the target temperature is present in the restart ﬁle. If it is present, this value will
override the value in the mdin ﬁle. In this manner, one can restart the simulation from the set of restart ﬁles and
sander or pmemd will automatically update the target temperature of each replica to correspond to the ﬁnal value
from the previous run. If the target temperature is not present (as would be the case for the ﬁrst REMD run), the
correct values must be present in the mdin ﬁles.

23.3.4.2. Content of the output ﬁles

It is important to note that in the current implementation of T-REMD all output is by replica only, not by

temperature! To facilitate post processing of trajectory data by temperature, the temperature must be speciﬁed for
each snapshot. For NetCDF trajectories, adding this information is simple because NetCDF is an extensible
format. We strongly recommend that you always use NetCDF trajectories, especially for REMD simulations. For
ASCII formatted trajectories, a header line is written to each frame just before the coordinates. This header line
has the format:

REMD <replica#> <exchange#> <step#> <Temperature>

PTRAJ and CPPTRAJ are able to read trajectories with this format.

The rem.log ﬁle for T-REMD simulations has the following format:

5

# Replica Exchange log file
# numexchg is
# REMD filenames:
#
#
# Rep#, Velocity Scaling, T, Eptot, Temp0, NewTemp0, Success rate (i,i+1), ResStruct#
# exchange

remlog= rem.log
remtype= rem.type

1
2
3
4

1.15
1.04
0.96
0.87

# exchange

1
2
3
4

0.94
1.07
-1.00
-1.00

# exchange

1
2
3
4

0.96
0.87
1.04
1.15

1
0.00
0.00
0.00
0.00
2

312.03
280.77
247.11
271.12

3

305.31
288.89
290.99
256.19

-10.46
-10.46
-10.46
-10.46

-6.81
-3.95
-10.58
-14.15

-11.02
-12.45
-13.30
-12.83

300.00
325.00
350.00
400.00

400.00
350.00
325.00
300.00

350.00
400.00
325.00
300.00

400.00
350.00
325.00
300.00

350.00
400.00
325.00
300.00

325.00
300.00
350.00
400.00

0.00
2.00
0.00
2.00

1.00
1.00
1.00
0.00

0.67
1.33
1.33
0.00

-1
-1
-1
-1

-1
-1
-1
-1

-1
-1
-1
-1

The columns, listed in order, are the replica number, velocity scaling factor, the instantaneous temperature, the
potential energy of the structure, the target temperature before the exchange attempt, the target temperature after
the exchange attempt, the average success rate, and the reservoir structure number. The replica number never
changes since replicas swap target temperatures. When the velocity scaling factor is -1, the exchange attempt
failed and velocities are not altered. For successful exchange attempts, velocities are either scaled up (when the
new target temperature is higher than the old one) or down (when the new target temperature is lower than the old
one). Success rates are calculated as #successes/#tries× 2, where the factor of 2 is used because each pair of
neighboring replicas attempts to exchange every other exchange attempt. In the beginning of the log ﬁle, this may
lead to unusual success rates, but after a large number of exchange attempts the values will normalize. Success
rates are computed as the exchange success rate between the original temperature (Temp0 column) and the next
highest temperature in the temperature ladder (not necessarily the temperature it just attempted to exchange with).
The success rate for the highest temperature is often 0 since it reﬂects the success rate between the highest and
lowest temperatures.

All temperatures are reported in Kelvin and all energies in kcal/mol.

463

23. Free energies

23.3.4.3. Cautions when using replica exchange

While many variations of replica exchange have been tested with sander, all possible variations have not been
tested and the option is intended for use by advanced researchers that already have a comprehensive understanding
of standard molecular dynamics simulations. Caution should be used when creating REMD input ﬁles. Amber
will check for the most obvious errors but due to the nature of the multiple output ﬁles the reason for the error may
not be readily apparent. The following is only a subset of things that users should keep in mind:

1. The number of replicas must be an even number (so that all replicas have a partner for exchange), except the

case when running H-REMD with gremd_acyc set to 1.

2. Temp0 values for each replica must be unique for Temperature-based REMD.

3. REMD-related namelist variables (numexchg, nstlim) should be identical in the mdin ﬁles.

4. Temp0 values should not be changed in the nmropt=1 weight change section.

5. A groupﬁle is required.

6. If high temperatures are used, it may be necessary to use a smaller time step and possibly restraints to prevent

cis/trans isomerization or chirality inversion.

7. Due to increased diffusion rates at high temperature, it may be good to use iwrap=1 to prevent coordinates
from becoming too large to ﬁt in the restart format. An alternative to this is to use the default NetCDF restart
ﬁles (ntxo=2) which are far less likely to overﬂow.

8. Note that the optimal temperature range and spacing will depend on the system. The user is strongly recom-

mended to read the literature in this area.

9. As of AmberTools 19/Amber 20, constant pressure (NPT) REMD is supported.

10. pmemd.MPI requires at least 2 threads per replica, whereas sander.MPI will work with just 1.

23.3.4.4. Replica exchange example

Below is an example of an 8-replica REMD run on 16 processors, (note that launching a MPI program varies

from computer to computer).

mpirun -np 16 sander.MPI -ng 8 -groupfile groupfile -rem 1

Here is the groupﬁle:

#
# multisander or replica exchange group file
#
-O -i mdin.rep1 -o mdout.rep1 -c inpcrd.rep1 -r restrt.rep1 -x mdcrd.rep1
-O -i mdin.rep2 -o mdout.rep2 -c inpcrd.rep2 -r restrt.rep2 -x mdcrd.rep2
-O -i mdin.rep3 -o mdout.rep3 -c inpcrd.rep3 -r restrt.rep3 -x mdcrd.rep3
-O -i mdin.rep4 -o mdout.rep4 -c inpcrd.rep4 -r restrt.rep4 -x mdcrd.rep4
-O -i mdin.rep5 -o mdout.rep5 -c inpcrd.rep5 -r restrt.rep5 -x mdcrd.rep5
-O -i mdin.rep6 -o mdout.rep6 -c inpcrd.rep6 -r restrt.rep6 -x mdcrd.rep6
-O -i mdin.rep7 -o mdout.rep7 -c inpcrd.rep7 -r restrt.rep7 -x mdcrd.rep7
-O -i mdin.rep8 -o mdout.rep8 -c inpcrd.rep8 -r restrt.rep8 -x mdcrd.rep8

This input speciﬁes that T-REMD should be used (-rem 1), with 8 replicas (-ng 8) and 2 processors per replica (-np
16). Note that the total number of processors should always be a multiple of the number of replicas.

464

23.3.4.5. Replica exchange using a hybrid solvent model

23.3. Replica Exchange Molecular Dynamics (REMD)

This section describes an advanced feature of Amber.[190, 191] Users that are not already comfortable with stan-
dard replica exchange simulations should likely get more experience with them before attempting hybrid solvent
REMD calculations.

For large systems, REMD becomes intractable since the number of replicas needed to span a given temperature
range increases roughly with the square root of the number of degrees of freedom in the system. Recognizing that
the main difﬁculty in applying REMD with explicit solvent lies in the number of simulations required, rather than
just the complexity of each simulation, we recently developed a new approach in which each replica is simulated
in explicit solvent using standard methods such as periodic boundary conditions and inclusion of long-range elec-
trostatic interactions using PME. However, the calculation of exchange probabilities (which determines the tem-
perature spacing and thus the number of replicas) is handled differently. Only a subset of closest water molecules
is retained, with the remainder temporarily replaced by a continuum representation. The energy is calculated using
the hybrid model, and the exchange probability is determined. The original solvent coordinates are then restored
and the simulation proceeds as a continuous trajectory with fully explicit solvation. This way the perceived system
size for evaluation of exchange probability is dramatically reduced and fewer replicas are needed.

An important difference from existing hybrid solvent models is that the system is fully solvated throughout
the entire MD simulation, and thus the distribution functions and solvent properties should not be affected by the
use of the hybrid model in the exchange calculation. In addition, no restraints of any type are needed for the
solvent, and the solute shape and volume may change since the solvation shells are generated for each replica
on the ﬂy at every exchange calculation. Nearly no computational overhead is involved since the calculation
is performed infrequently as compared to the normal force evaluations. Thus the hybrid REMD approach can
employ more accurate continuum models that are too computationally demanding for use in each time step of a
standard molecular dynamics simulation. However, since the Hamiltonian used for the exchange differs from that
employed during dynamics, these simulations are approximate and are not guaranteed to provide correct canonical
ensembles.

At each exchange calculation sander will create the hybrid system based on the current coordinates for the fully
solvated system. This is done by calculating the distance of each water oxygen to the nearest solute atom, and
sorting the water by increasing shortest distance. The closest numwatkeep are retained and the potential energy
is calculated using the GB model speciﬁed by hybridgb. After the energy calculation the fully solvated system is
restored.

For a more complete example, users are directed to the hybridREMD test case (in the rem_hybrid subdirectory)

in the Amber test directory.

numwatkeep The number of explicit waters that should be retained for the calculation of potential energy to be
used for the exchange calculation. Before each exchange attempt, the closest numwatkeep waters
will be retained (closest to the solute) and the rest will be temporarily removed and then replaced
after the exchange probability has been calculated. The default value is -1, indicating that all waters
should be retained (standard REMD). A value of 0 would direct Amber to remove all of the explicit
water (as in MM-PBSA) while a nonzero value will result in some water close to the solute being
retained while the rest is removed. Currently it is not possible to select a subset of solute atoms
for determining which waters are "close". Determining the optimal numwatkeep value is a topic of
current research.

hybridgb

Speciﬁes which GB model should be used for calculating the PE of the stripped coordinates, equiv-
alent to the igb variable. Currently hybridgb values of 1, 2, 5, 7 and 8 are supported.

Cautions: Hybrid-REMD has not been extensively tested. The following would not be expected to work without
further modiﬁcation of the code:

1. Only the water is imaged for the creation of the stripped system. Care should be taken with dimers (such as

DNA duplexes) to ensure that the imaging is correct.

2. Explicit counterions should probably not be used.

3. The choice of implicit solvent model will likely have a large effect on the resulting ensemble.

465

23. Free energies

23.3.4.6. Reservoir REMD

The ability to perform REMD with a structure reservoir [505, 506] has been implemented in Amber as of version
10. Although REMD can signiﬁcantly increase the efﬁciency of conformational sampling, obtaining converged
data can still be challenging. This is particularly true for larger systems, as the number of replicas needed to span a
given temperature range increases with the square root of the number of degrees of freedom in the system. Another
consideration is that the folding rate of a peptide tends not to be as dependent on temperature as the unfolding rate,
making the search for native peptide structures in higher temperature replicas more problematic; in the case where
a native-like structure is found it will almost always be exchanged to a lower temperature replica, requiring a repeat
of the search process. In addition, the exchange criterion in REMD assumes a Boltzmann-weighted ensemble of
structures, which is typically not the case at the start of a REMD simulation. Although the exchange criterion
will eventually drive each replica toward a Boltzmann-weighted ensemble of structures, this essentially means that
until all of the replicas are converged, none of the replicas are converged.

Reservoir REMD is a method which can signiﬁcantly enhance the rate of convergence and reduce the high
computational expense of standard REMD simulations. An ensemble of structures (or reservoir) is generated
at high temperature, then linked to lower temperatures via REMD. Periodic exchanges are attempted between
randomly chosen structures in the reservoir and the highest temperature replica. If the structure reservoir is already
Boltzmann-weighted,[505] convergence is signiﬁcantly enhanced as the lower temperature replicas simply act to
re-weight the reservoir ensemble - in essence all of the searching has been accomplished from the start. This is
in contrast to standard REMD where all the replicas are run simultaneously, and the computational expense for
running long simulations must be paid for each of the replicas even though only a few high-temperature ones may
be contributing to sampling of new basins.

One major advantage of this approach is that a converged ensemble of conformations needs to be generated
only once and only for one temperature. Typically this temperature should be high enough to facilitate crossing
of energy barriers, but low enough that there is still a measurable fraction of native structure present. Another
advantage is that exchanges with the reservoir do not need to be time-correlated with the replica simulations;
folding events sampled during reservoir generation can provide multiple native structures for the other replicas.

It may not always be possible however to generate a Boltzmann-weighted ensemble of structures (e.g. for a
large molecule in explicit solvent). In such cases it is possible to use a non-Boltzmann weighted reservoir by
modifying only the exchange criterion between the reservoir and the highest temperature replica. If the weight of
all structures in the reservoir is set to 1, this corresponds to a completely ﬂat distribution across the free energy
landscape. Alternatively, weights can be assigned to structures based on various structural properties. In the current
implementation, weights are assigned to structures via dihedral bin clustering, wherein clusters are identiﬁed by
unique conﬁgurations of user-deﬁned dihedral angles.

There are several new command line arguments that pertain to Reservoir REMD:

-rremd Type of reservoir to use.

= 0 No reservoir (Default)
= 1 Boltzmann-weighted reservoir
= 2 Non-Boltzmann weighted reservoir where the weight of each structure in the reservoir is assumed to be

1/N

= 3 Non-Boltzmann weighted reservoir with weights deﬁned by dihedral angle binning.

-reservoir Speciﬁes the ﬁle name preﬁx for reservoir structures. Reservoir structure ﬁles should be in the restart
ﬁle format MDRESTRT, and are expected to be named according to the format <name>.XXXXXX, where
XXXXXX is a 6 digit integer, e.g. frame.000001. Default is "reserv/frame". IMPORTANT NOTE: Struc-
ture numbering should begin at 1. Reservoirs can be created using the cpptraj command createreservoir.

-saveene speciﬁes the ﬁle containing energies of the structures in the reservoir (default ﬁlename is "saveene").

This ﬁle must contain a header line with format:

<# reservoir structures> <reservoir T> <#atoms> <random seed>
<velocity flag>

466

23.3. Replica Exchange Molecular Dynamics (REMD)

If the velocity ﬂag =1 then velocity information will be read from the reservoir structure ﬁles, otherwise
(if velocity ﬂag =0) velocities will be assigned to the structure based on the reservoir temperature. After
the header line there should be a line containing the potential energy of each reservoir structure. IMPOR-
TANT NOTE: For reservoir REMD with dihedral bin clustering (rremd==3) each potential energy should
be followed by the cluster # that reservoir structure belongs to.

-clusterinfo For reservoir REMD with dihedral bin clustering (rremd==3) this ﬁle speciﬁes what dihedrals are
used and the binsize, as well as what cluster each reservoir structure belongs to. Default is "cluster.info".
File has the following format:

<# Dihedral Angles>
<atom# 1> <atom# 2> <atom# 3> <atom# 4> [Dihedral 1]
. .
. .
. .
<atom# 1> <atom# 2> <atom# 3> <atom# 4> [# Dihedral Angles]
<Total # Clusters>
<Cluster #> <Weight>
<Bin1><Bin2>...<Bin #Dihedral Angles> [Cluster 1]
. .
. .
. .
<Cluster #> <Weight>
<Bin1><Bin2>...<Bin #Dihedral Angles> [# Clusters]

The ﬁrst line is the number of dihedral angles that will be binned, following the deﬁnition of those dihedral
angles (4 atoms using sander atom #s, starting from 1) and the bin size for each dihedral angle. Next is the
total # of clusters followed by lines providing information about each cluster: the cluster number, weight
and ID as deﬁned by dihedral binning. The ID is composed of consecutive 3 digit integers, 1 for each
dihedral angle. For example, a structure belonging to cluster 7 with a weight of 2 with 2 dihedral angles
that fall in bins 3 and 8 would look like:

7 2 003008

23.3.5. Hamiltonian replica exchange

Instead of spacing replicas throughout temperature space, you can also space replicas throughout “Hamiltonian
space.” That is, every replica has a different Hamiltonian, or energy function, and exchange attempts occur between
adjacent Hamiltonians. With sander and pmemd, Hamiltonian replica exchange is implemented by exchanging
coordinates between replicas and evaluating the energy of that new structure. The corresponding detailed balance
equation that is used to compute the exchange probability is shown in Eq. 23.14. This option is enabled by using
-rem 3 on the command-lines in the groupﬁle.

Pi→ j = min{1,exp (−β1 [H1(x2)− H1(x1)]− β2 [H2(x1)− H2(x2)])

(23.14)
Here, state i refers to the replica combination [β1H1(x1), β2H2(x2)] and state j refers to the replica combination
[β1H1(x2), β2H2(x1)]. Eq. 23.14 assumes that only coordinates are traded between exchanging replicas, but allows
for the temperatures to differ. The temperature does not exchange upon a successful attempt, but velocities are

swapped following successful exchange attempts and scaled by(cid:112)Tnew/Told to match the target temperature of

their new replica.

23.3.5.1. Free Energy Perturbation

Upon closer inspection of Eq. 23.14, we can see a close resemblance to Free Energy Perturbation[499, 507]

∆Ga→b = −kBT ln [exp (−β (Eb − Ea))]

(23.15)

467

23. Free energies

We can see that for every exchange attempt, the required ∆E is calculated in both directions. The value for the
free energy (in both directions) is accumulated and reported in the rem.log ﬁle each time an exchange is attempted.
For replica exchange free energy perturbation (REFEP), multiple topology ﬁles are often needed that correspond
to a value of an alchemical parameter, λ , similar to thermodynamic integration. The ParmEd program included
with AmberTools can be used to generate the intermediate topology ﬁles by scaling charges and/or van der Waals
parameters. In this case, because coordinates are exchanged, each replica tracks a particular Hamiltonian and set
of control variables, rather than a sequence of conﬁguations. Note this is the opposite behavior of T-REMD in
which replicas change temperatures but keep the same sequence of conﬁgurations.

23.3.5.2. Umbrella Sampling

Hamiltonian exchange can be used to perform replica exchange umbrella sampling [508] using the NMR ﬂat
well restraints.
In this case, every line of the group ﬁle needs a different restraint ﬁle in which the center of
the biasing umbrella changes. Each replica tracks a particular umbrella location rather than a replica trajectory.
Note this is the opposite behavior of T-REMD in which replicas change temperatures but keeps the same replica
trajectory.

23.3.5.3. Steps for running H-REMD simulations

Note: before running Hamiltonian replica exchange (H-REMD), you should be familiar with Temperature
replica exchange (T-REMD) simulations. H-REMD simulations are set up similarly to T-REMD simulations. Each
replica is speciﬁed on a line of a groupﬁle and is run with multisander. Each replica differs either by simulation
control parameters in the input ﬁle (e.g., for umbrella sampling replica exchange[508] or REXAMD [509, 510]) or
parameters in the topology ﬁle (e.g., REFEP).

• The majority of H-REMD settings are similar to T-REMD. A groupﬁle is needed. The number of replicas
must be an even number (so that all replicas have a partner for exchange). Constant pressure is not supported
for REMD simulations. This means ntp must be 0.

• Depending on the type of H-REMD, all replicas may have different force ﬁelds/control variables (if the

differences are too large, the exchange probability may suffer)

• The order of the replicas in the groupﬁle is very important. As a general rule in all H-REMD simulations, the
least different Hamiltonians (replicas) should be neighbors. Because this method is relatively new, there are
very limited discussions in the literature about the optimum positions of replicas in the Hamiltonian ladder
[511, 512]. Exchange neighbors are deﬁned by adjacent lines in the groupﬁle (i.e., each replica exchanges
‘right’ or ‘up’ with the replica deﬁned by the line above and exchanges ‘left’ or ‘down’ with the replica
deﬁned by the line below in the groupﬁle).

• For editing the prmtop, e.g., in the case of REFEP, there is a python script in AmberTools, parmed, which

facilitates the modiﬁcations of Amber topology ﬁles. See Section 14.2 for details.

• In H-REMD, each replica has a different Hamiltonian. In contrast to T-REMD, neighbor replicas exchange
their conformations, which means each replica keeps its initial Hamiltonian and there is no need for post-
processing (i.e., using ptraj or cpptraj) to extract sub-ensembles. However, you will have to post-process in
order to reconstruct replica-based time series.

To enable H-REMD the -rem ﬂag on the command-line must be given the value 3. H-REMD simulations require
the same input ﬁles as T-REMD simulations and generates the same output ﬁles. The output printed in the remlog
ﬁle differs signiﬁcantly from that found in the remlog ﬁle for T-REMD, however. Example remlog output for
H-REMD is shown below:

# Replica Exchange log file
# numexchg is 10000
# REMD filenames:
#
#

remlog= remlog
remtype= rem.type

468

23.3. Replica Exchange Molecular Dynamics (REMD)

# Rep#, Neibr#, Temp0, PotE(x_1), PotE(x_2), left_fe, right_fe, Success, Success rate (i,i+1)
# exchange

1

1
2
3
4
5
6
7
8

# exchange

1
2
3
4
5
6
7
8

...

8
3
2
5
4
7
6
1

2
1
4
3
6
5
8
7

300.00 -12783.23 -12755.40
300.00 -12839.84 -12802.56
300.00 -12802.60 -12839.79
300.00 -12847.41 -12858.37
300.00 -12858.19 -12846.63
300.00 -12859.65 -12833.42
300.00 -12833.63 -12859.95
300.00 -12771.63 -12766.84

2

300.00 -12825.03 -13147.73
300.00 -13148.20 -12824.42
300.00 -13136.97 -12823.77
300.00 -12823.32 -13137.59
300.00 -12919.25 -13181.18
300.00 -13180.48 -12918.84
300.00 -13162.39 -12775.37
300.00 -12775.59 -13162.55

-16.39
0.00
-0.04
0.00
0.18
0.00
-0.21
0.00

0.00
-0.47
0.00
0.44
0.00
0.70
0.00
-0.22

0.00
-0.05
0.00
-0.78
0.00
0.30
0.00
-16.23

-0.62
0.00
0.62
0.00
-0.41
0.00
0.16
0.00

F
T
T
F
F
T
T
F

F
F
T
T
T
T
T
T

0.00
2.00
0.00
0.00
0.00
2.00
0.00
0.00

0.00
1.00
1.00
0.00
1.00
1.00
1.00
0.00

The columns, in order, are the replica number, the exchange partner for this attempt, the target temperature, the
potential energy of the current structure, the potential energy of the proposed structure, the free energy difference
calculated via Eq. 23.15 for all exchanges to the ‘left’ (or ‘up’ in the Hamiltonian ladder), all free energies for
exchanges to the ‘right’ (or ‘down’ in the Hamiltonian ladder), whether the exchange attempt succeeded (T) or not
(F), and the average success rate. For each step, the only free energy values printed are those between replicas that
attempted to exchange. All free energies between non-exchanging pairs are set to 0 for that step. Therefore, the
‘ﬁnal’ free energies can be found by summing the respective terms from the last two exchanges in the remlog ﬁle.
All energies have units of kcal/mol, and temperatures have units of Kelvin.

23.3.5.4. An example

When running H-REMD, the format of the groupﬁle is very similar to that in T-REMD, but speciﬁc details

depend on the type of simulation being performed (see Subsection 23.3.3 for information about how you can use
the genremdinputs.py tool to prepare your input ﬁles). In the case of REFEP, the groupﬁle may look like the
following:

-O -i mdin -p prmtop.0 -c inpcrd.0 -suffix 000
-O -i mdin -p prmtop.1 -c inpcrd.1 -suffix 001
-O -i mdin -p prmtop.2 -c inpcrd.2 -suffix 002
-O -i mdin -p prmtop.3 -c inpcrd.3 -suffix 003
-O -i mdin -p prmtop.4 -c inpcrd.4 -suffix 004
-O -i mdin -p prmtop.5 -c inpcrd.5 -suffix 005
-O -i mdin -p prmtop.6 -c inpcrd.6 -suffix 006
-O -i mdin -p prmtop.7 -c inpcrd.7 -suffix 007

Notice how the topology ﬁle differs in each case, but the input ﬁle remains the same. An example groupﬁle for
umbrella sampling may look like the following:

-O -i mdin.0 -p prmtop -c inpcrd.0 -suffix 000
-O -i mdin.1 -p prmtop -c inpcrd.1 -suffix 001
-O -i mdin.2 -p prmtop -c inpcrd.2 -suffix 002
-O -i mdin.3 -p prmtop -c inpcrd.3 -suffix 003
-O -i mdin.4 -p prmtop -c inpcrd.4 -suffix 004
-O -i mdin.5 -p prmtop -c inpcrd.5 -suffix 005
-O -i mdin.6 -p prmtop -c inpcrd.6 -suffix 006
-O -i mdin.7 -p prmtop -c inpcrd.7 -suffix 007

469

23. Free energies

Notice in this case how the topology ﬁle is the same but the input ﬁle differs in each case (which is where the
center of the umbrella is deﬁned). Like T-REMD, sander.MPI (or pmemd.MPI) are executed via the following
command:

mpirun -np 16 sander.MPI -ng 8 -groupfile groupfile -rem 3

Note that the particular method for launching an MPI program may depend on your MPI implementation. Also,
pmemd requires at least 2 threads per replica, whereas sander will work with just 1.

23.3.6. RXSGLD: Replica exchange using Self-Guided Langevin Dynamics

RXSGLD utilizes the guiding force, sgft or tempsg, to deﬁne replicas. SGLD simulations are performed for
replicas[457]. Please refer to Section 22.1 about how to set up SGLD simulations. When temperature is the same
for all replicas, the replica exchange ratios are high and so is the conformational search efﬁciency. RXSGLD is an
alternative to SGLD, SGLDfp, or SGLDg to achieve efﬁcient conformational search while being able to obtain the
canonical ensemble distribution. RXSGLD is turned on if isgld is set to 1 or 3 in the sander or pmemd input ﬁle
when performing replica exchange simulations (i.e., rem > 0).

For the convenience of reference, we deﬁne replicas as non-interacting identical simulation systems and deﬁne
stages as simulation conditions between which replicas transit. In T-REMD, stages are different by temperatures,
while in RXSGLD, stages are different by the strength of guiding forces, as deﬁned by sgld or tempsg. For
example, we can set tempsg=300, 310, 325, 345, 370, 400, 440, and 500K for stages 1 to 8, respectively, while
temp0=300K for all stages. In RXSGLD, temperatures in different stages can be the same or different from each
other; however, it is prefered to keep all temperatures the same to achieve high replica exchange efﬁciency.

Because the temperatures of different stages may be the same, the stages are given a ID from 1 to Nrep. Like

T-REMD, each RXSGLD trajectory ﬁle is for each replica. Unlike T-REMD, the frames of RXSGLD trajectories
are proceeded by the following information:

RXSGLD <replica#> <exchange#> <step#> <stage ID>

The output from RXSGLD contains the following lines:

TEMP0= <temp0> SGFT= <sgft> TEMPSG= <tempsg> STAGE= <stag ID> REPNUM= <rep#> EXCHANGE= <exchange#>

RXSGLD trajectories can be processed with PTRAJ analogously to T-REMD trajectories: merely replace
temperatures with stage IDs. For example, to extract the trajectory on stage 1, we can use the following
command:

ptraj rxsgld.top <<EOF
trajin rxsgld.trj.000 rxsgldtraj rxsgldid 1
trajout rxsgld.trj.stag 1
EOF

23.3.7. pH-REMD

In constant pH REMD, replicas attempt to exchange their solution pH values in much the same way as tem-
peratures are exchanged in T-REMD. The idea of swapping pH in the discrete protonation state implementation
(described in Section 24) was proposed by [Itoh et al. 500] and later implemented and evaluated in Amber. [501]
The implementation here works very similarly to T-REMD, except each replica is given a different value of solvph
in the mdin ﬁle instead of temp0. The exchange probability, shown in Eq. 23.16, is derived under the assumption
that all replicas have the same temperature.

(cid:110)

(cid:104)

(cid:16)

(cid:17)

Pi→ j = min

1,exp

ln10

i − NH+
NH+

j

(pHi − pHj)

(cid:105)(cid:111)

(23.16)

Where NH+

i

is the number of titratable protons currently ‘active’ in state i.

470

23.3. Replica Exchange Molecular Dynamics (REMD)

Before running pH-REMD simulations, you should ﬁrst be familiar with running constant pH MD described
in Section 24, since it will help you set up each replica. Aside from the changes required to run at constant pH,
setting up pH-REMD simulations is quite similar to setting up T-REMD simulations. Each replica should have the
same topology ﬁle, and all mdin ﬁles should be identical except for the value of solvph and the random seed ig.
Furthermore, each replica should be titrating the same residues (this is very important). For instance, you cannot
turn ‘off’ carboxylate titrations at basic pH if your pH-REMD spans both acidic and basic conditions.

23.3.7.1. Analyzing Output

The output from pH-REMD simulations is analyzed in the same way as standard constant pH simulations, with
some preprocessing required. Because the pH of each replica changes upon successful replica exchange attempts,
each replica trajectory contains members from ensembles at all pHs. Therefore, you must use ptraj or cpptraj
to extract ensembles at each pH. To simplify the coding required, the pH is stored as the ‘temperature’ in each
trajectory, so the T-REMD machinery should be used in ptraj/cpptraj to extract desired ensembles. Please refer to
Subsection 32.10.4 and make use of the remdtrajtemp command replacing temperature by pH values.

The cpout ﬁles have additional information added to them to indicate which protonation states belong to which

target pH ensembles. This is done by printing the pH next to each record, as shown below.

Solvent pH: 3.00000
Monte Carlo step size:
Time step:
Time:
Residue

10.008

5

0 State: 3 pH:

5

3.000

Residue

0 State: 3 pH:

3.000

Residue

0 State: 3 pH:

3.500

Residue

0 State: 3 pH:

3.500

Residue

0 State: 3 pH:

2.000

Residue

0 State: 3 pH:

2.000

Residue

0 State: 3 pH:

2.500

You can see that the pH is changing between snapshots. In addition to generating pH-based trajectories, you also
must generate pH-based cpout information that is stored in each cpout ﬁle. The replica pH is identiﬁed on each
line of the cpout ﬁle to aid in constructing the pH-speciﬁc protonation state ensembles. To aid with this, the
cphstats program, described in Subsection 24.7.5, has an option to provide a “preﬁx” that deﬁnes the new ﬁle
names for the pH-speciﬁc cpout ﬁles that it builds from a list of each cpout ﬁle from a single pH-REMD
simulation. For example:

cphstats --fix-remd 1AKI.cpout 1AKI.cpout.000 1AKI.cpout.001 \

1AKI.cpout.002 1AKI.cpout.003

this will generate ﬁles 1AKI.cpout.pH_2.00,
Assuming you ran replicas at pH 2.0, 2.5, 3.0, and 3.5,
1AKI.cpout.pH_2.50, 1AKI.cpout.pH_3.00, and 1AKI.cpout.pH_3.50, with their respective ensembles.
If you
ran, for instance, 20 ns of simulation in chunks of 5 ns (so you ran 4 “chunks” after 3 restarts), you will need to
run this command 4 times—once for each simulation segment. You should analyze the resulting protonation state
distribution using these newly-generated cpout ﬁles.

23.3.7.2. A pH-REMD Example

Below is an example in which 4 replicas are run at pH values of 2.0, 2.5, 3.0, and 3.5 (see Subsection 23.3.3 for

information about how you can use the genremdinputs.py tool to prepare your input ﬁles). The command

471

23. Free energies

below shows an example of running this simulation on 8 processors (2 processors for each replica). Note that the
command to run MPI programs may vary from computer to computer.

mpirun -np 8 sander.MPI -ng 4 -groupfile groupfile -rem 4 -remlog rem.log

Please notice that pH-REMD uses the option -rem 4. The groupﬁle in this example is shown below:

-O -i phremd.pH2.0.mdin -cpin cpin -p ASPREF.top -c ASPREF.rst7
-O -i phremd.pH2.5.mdin -cpin cpin -p ASPREF.top -c ASPREF.rst7
-O -i phremd.pH3.0.mdin -cpin cpin -p ASPREF.top -c ASPREF.rst7
-O -i phremd.pH3.5.mdin -cpin cpin -p ASPREF.top -c ASPREF.rst7

The sufﬁxes “.000”, “.001”, “.002”, and “.003” will be added to the output ﬁles from each of the replicas in order
to distinguish them from each other by default. This sufﬁx can be changed using the “-sufﬁx” ﬂag for that replica.
Any sufﬁx provided this way will be applied to ALL output ﬁles, regardless of whether or not they are speciﬁed.
This is only true for multi-sander and multi-pmemd simulations.

The resulting rem.log ﬁle looks like the following:

50

# Replica Exchange log file
# numexchg is
# REMD filenames:
#
#
# Rep#, N_prot, old_pH, new_pH, Success rate (i,i+1)
# exchange

remlog= rem.log
remtype= rem.type

1

1
2
3
4

# exchange

1
2
3
4

# exchange

1
2
3
4

# exchange

1
2
3
4

1
1
1
1

1
1
1
1

1
1
1
1

1
1
1
1

2.000 3.500
2.500 3.000
3.000 2.500
3.500 2.000

2

3.500 3.000
3.000 3.500
2.500 2.000
2.000 2.500

3

3.000 2.500
3.500 2.000
2.000 3.500
2.500 3.000

4

2.500 2.000
2.000 2.500
3.500 3.000
3.000 3.500

0.0000
2.0000
0.0000
2.0000

1.0000
1.0000
1.0000
1.0000

0.6667
1.3333
0.6667
1.3333

1.0000
1.0000
1.0000
1.0000

The columns are the current replica number (which never changes because pH is swapped between replicas), the
total number of protons “active” on all of the titratable sites, the original solution pH, the new solution pH after
exchange, and the success ratio (multiplied by 2 to account for swapping neighbors on each exchange attempt).

23.3.8. Redox Potential REMD

In Redox Potential Rreplica Exchange MD (E-REMD) [502], replicas attempt to exchange their Redox Potential
values in a similar way as temperatures are exchanged in T-REMD or pH values are exchanged in pH-REMD. In
E-REMD each replica has a different value of Redox Potential, given by solve in the mdin ﬁle. The exchange
probability, shown in Eq. 23.17, is derived under the assumption that all replicas have the same temperature:

472

23.3. Replica Exchange Molecular Dynamics (REMD)

(cid:26)

1,exp

(cid:20) F

kbT

Pi→ j = min

(cid:16)

(cid:17)

(cid:21)(cid:27)

i − Ne−
Ne−

j

(Ei − E j)

(23.17)

Where F if the Faraday constant, and Ne−
i
electrons and the Redox Potential of replica i.

and Ei are respectively the current number of ‘active’ titratable

Before running E-REMD simulations, you should ﬁrst be familiar with running constant Redox Potential MD
described in Section 25, since it will help you set up each replica. Each replica should have the same topology
ﬁle, and all mdin ﬁles should be identical except for the value of solve and the random seed ig, and each replica
should be titrating the same residues.

23.3.8.1. Analyzing Output

Similarly to T-REMD and pH-REMD, some preprocessing is required before analysing E-REMD data. As the
target Redox Potential of a single replica keeps changing when an exchange attempt is accepted, the trajectory
of each replica contains chunks from the ensembles at all Redox Potential values. Therefore, ptraj or cpptraj
must be used to extract the ensemble at a given Redox Potential.The T-REMD functionalities should be used in
ptraj/cpptraj to extract desired ensembles. Please refer to Subsection 32.10.4 and make use of the remdtrajtemp
command replacing temperature by Redox Potential values.

The ceout ﬁles have additional information added to them to indicate which redox states belong to which target

Redox Potential ensembles. This is done by printing the Redox Potential next to each record, as shown below.

0.8100000 V Temperature: 300.00 K

Redox potential:
Monte Carlo step size:
Time step:
Time:
Residue

1000.008

5

0 State: 1 E:

5

0.8100000 V

Residue

0 State: 1 E:

0.8100000 V

Residue

0 State: 1 E:

0.8400000 V

Residue

0 State: 0 E:

0.8400000 V

Residue

0 State: 1 E:

0.7500000 V

Residue

0 State: 1 E:

0.7500000 V

Residue

0 State: 0 E:

0.7800000 V

The cestats program can be used to construct Redox Potential-based ceout ﬁles (see Section 25.6 and
Subsection 24.7.5 for more details). One ceout ﬁle is generated for each target Redox Potential value. This is an
example command to generate Redox Potential-based ceout ﬁles:

cestats --fix-remd reordered.ceout ceout.000 ceout.001 \

ceout.002 ceout.003

Assuming your E-REMD simulation had the following target Redox Potential values 0.75, 0.78, 0.81
and 0.84 V,
this will generate the ﬁles reordered.ceout.E_0.75000, reordered.ceout.E_0.78000,
reordered.ceout.E_0.81000, and reordered.ceout.E_0.84000. If you restarted your E-REMD simulation,
you will need to run this command for each simulation segment. Also, you should only analyze the resulting redox
state distribution using these newly-generated ceout ﬁles.

473

23. Free energies

23.3.8.2. A E-REMD Example

Below is an example in which 4 replicas are run at Redox Potential values 0.75, 0.78, 0.81 and 0.84 V (see
Subsection 23.3.3 for information about how you can use the genremdinputs.py tool to prepare your input
ﬁles). The command below shows an example of running this simulation on 8 processors (2 processors for each
replica). Note that the command to run MPI programs may vary from computer to computer depending on your
MPI settings.

mpirun -np 8 sander.MPI -ng 4 -groupfile groupfile -rem 5 -remlog rem.log

Please notice that E-REMD uses the option -rem 5. The groupﬁle in this example is shown below:

-O -i eremd.E0.75.mdin -cein cein -p prmtop -c rst7
-O -i eremd.E0.78.mdin -cein cein -p prmtop -c rst7
-O -i eremd.E0.81.mdin -cein cein -p prmtop -c rst7
-O -i eremd.E0.84.mdin -cein cein -p prmtop -c rst7

The sufﬁxes “.000”, “.001”, “.002”, and “.003” will be added to the output ﬁles not speciﬁed in the groupﬁle for
each replica in order to distinguish them from each other. This sufﬁx can be changed using the “-sufﬁx” ﬂag for
that replica. Any sufﬁx provided this way will be applied to ALL output ﬁles, regardless of whether or not they are
speciﬁed. This is only true for multi-sander and multi-pmemd simulations.

The resulting rem.log ﬁle looks like the following:

50

# Replica Exchange log file
# numexchg is
# REMD filenames:
#
#
# Rep#, N_elec, old_E, new_E, Success rate (i,i+1)
# exchange

remlog= rem.log
remtype= rem.type

1

1
2
3
4

# exchange

1
2
3
4

# exchange

1
2
3
4

# exchange

1
2
3
4

0
0
0
0

0
0
0
1

0
0
0
1

1
0
0
1

0.750 0.840
0.780 0.810
0.810 0.780
0.840 0.750

2

0.840 0.810
0.810 0.840
0.780 0.780
0.750 0.750

3

0.810 0.780
0.840 0.840
0.780 0.810
0.750 0.750

4

0.780 0.750
0.840 0.810
0.810 0.840
0.750 0.780

0.0000
2.0000
0.0000
2.0000

1.0000
1.0000
1.0000
0.0000

0.6667
0.6667
1.3333
0.0000

1.0000
0.5000
1.0000
0.5000

The different columns contain information for the different replicas (as only Redox Potential values are swapped
between replicas, the replica number always remains the same). Each column also contains the total number of
“active” electrons on all of the titratable sites, the original Redox Potential, the new Redox Potential after exchange
(if the exchange is rejected, the Redox Potential remains the same), and the success ratio (multiplied by 2 to account
for swapping neighbors on each exchange attempt).

474

23.3.9. Multi-dimensional Replica Exchange

23.3. Replica Exchange Molecular Dynamics (REMD)

Multi-dimensional replica exchange [382, 503] refers to an expanded ensemble technique in which each
subensemble (i.e., each replica) is deﬁned by multiple state parameters such as the temperature of the heat bath or
the Hamiltonian. For such systems, an exchange attempt between two arbitrary replicas yields a complex equa-
tion for the exchange probability that must be derived and speciﬁed for each type of multi-dimensional exchange
scheme. However, if exchange attempts between replica pairs are restricted to pairs that only differ in one state
parameter, such as the temperature, then the exchange probability equation reduces to the one used for that par-
ticular type of replica exchange. Such an approach allows the existing exchange routines to be used in complex,
multi-dimensional replica exchange simulations.

To implement the scheme described above, the entire expanded ensemble is subdivided into dimensions which
are further divided into groups. Each dimension is deﬁned by a particular type of exchange attempt—namely tem-
perature exchange, Hamiltonian exchange, pH exchange, or Redox Potential exchange—and assigns every replica
in the simulation to a particular group. Each group is like a one-dimensional REMD simulation by itself—replicas
differ only by the one state parameter used to deﬁne that particular dimension. Exchange attempts occur only
between nearest neighbors of a single replica group.

No two replicas should be in the same group in more than one dimension since, by deﬁnition, that would require
the state parameters of those two replicas to differ in more than one dimension (which would preclude them from
being part of the same group in any dimension according to the scheme described previously). It is easiest to
understand this scheme in the context of a 2-dimensional replica exchange ensemble with replicas represented by
elements of a matrix, as in Fig. 23.2.

23.3.9.1. Running multi-dimensional replica exchange simulations

Multi-dimensional REMD simulations require an extra input ﬁle provided on the command-line (not in the
groupﬁle) that deﬁnes each replica group in each dimension (see Subsection 23.3.3 for information about how you
can use the genremdinputs.py tool to prepare your input ﬁles). Every replica must be assigned to one and only
one group in each dimension (failure to do so results in an error message). Furthermore, each group must consist of
an even number of replicas. Dimensions are deﬁned in the &multirem namelist in the Multi-dimensional REMD
input ﬁle. Each &multirem namelist adds another dimension. The following variables may be speciﬁed in the
&multirem namelist:

exch_type Deﬁnes the type of exchange that will be performed. Supported values (case-insensitive) are “temper-

ature” (or “temp”), “Hamiltonian” (or “HREMD”), “pH”, and “Redox”.

group(:, :) 2-dimensional (Fortran-style) array deﬁning the group (ﬁrst dimension) and the position within that
group (second dimension). See the description of the exchange routines above to see if the ordering within
each group is important (for example, the ordering deﬁnes exchange partners in H-REMD while replicas
are automatically sorted by target temperature in T-REMD). Indexes in this array start from 1, and index n
corresponds to the nth replica deﬁned in the groupﬁle. The suggested syntax for assigning to this variable is
shown in the example below.

desc Description that will be printed in the rem.log ﬁles. This is for documentation purposes only, and will have

no effect on the simulation.

A sample Multi-dimensional REMD input ﬁle that performs alchemical Hamiltonian-REMD in one dimension
and Temperature-REMD in another dimension is shown below. In this example, replicas 1 and 2 have the same
Hamiltonian, and replicas 1 and 3 have the same temperature.





Temperature REMD
&multirem

exch_type = 'TEMPERATURE',
group(1,:) = 1,2,
group(2,:) = 3,4,
desc = 'Temperature exchange from 300K to 400K'

/

475

23. Free energies

Figure 23.2.: Schematic showing exchange attempts (EAs) in multi-dimensional REMD simulations. Exchange
attempts are indicated by the colored arrows, where red arrows indicate exchange attempts between
replicas in a group of the dimension deﬁned by the j state parameters. Blue arrows indicate exchange
attempts between replicas in the dimension deﬁned by the state parameter i. Figure taken from ref.
513.

476

H(x1, i1, j1)H(x2, i1, j2)H(x3, i1, j3)H(x4, i1, j4)H(x5, i2, j1)H(x6, i2, j2)H(x7, i2, j3)H(x8, i2, j4)H(x9, i3, j1)H(x10, i3, j2)H(x11, i3, j3)H(x12, i3, j4)H(x13, i4, j1)H(x14, i4, j2)H(x15, i4, j3)H(x16, i4, j4)State Index i changesState Index j changesEAs in j spaceEAs in i space23.3. Replica Exchange Molecular Dynamics (REMD)

Hamiltonian REMD
&multirem

exch_type='HAMILTONIAN',
group(1,:) = 1,3,
group(2,:) = 2,4,
desc = 'Protonated ASP to Deprotonated ASP mutation'

/



Running multi-dimensional REMD simulations differs from running them in a single dimension. First, restarts
and trajectories must be written in the NetCDF format (ntxo=2 for restarts and ioutfm=1 for trajectories). These
changes are applied by default for multi-dimensional REMD simulations. Next, the REMD input ﬁle is taken
following the -remd-file ﬂag, and -rem should not be speciﬁed (it is set to -1 internally when -remd-file is
read). An example command-line corresponding to the 4-replica example input ﬁle is shown below:

mpirun -np 4 sander.MPI -ng 4 -groupfile groupfile \

-remd-file remd.dim -remlog rem.log

The ﬁle just shown above is an example of the remd.dim ﬁle. The replica exchange information is stored in the
remlog ﬁles written during the simulation. A separate remlog ﬁle is written for each dimension with the name
<preﬁx>.n where n is the nth dimension read from the REMD input ﬁle and <preﬁx> is the ﬁle name given on the
command-line for the -remlog switch.

23.3.9.2. Restarting multi-dimensional replica exchange simulations

Some exchange types swap state parameters (e.g., temperature, pH and Redox Potential) while others swap
coordinates (Hamiltonian), meaning that the ordering of the groupﬁle may change for restarts (see Fig. 23.3). To
prevent requiring you to rewrite a new REMD ﬁle or groupﬁle each restart, the group number and replica position
for each dimension is stored in the restart ﬁle. When irest=1 (see page 341) and the restart ﬁles contain the replica
position information, the position of each replica in each dimension is set to the values stored in the restart ﬁle.
This allows the same groupﬁle and REMD ﬁle to be used for every subsequent restart. For general information on
restarting a REMD simulation seeSubsection 23.3.4.1.

Note, if the REMD index information is not present in the restart ﬁle or the REMD dimension information in the
restart does not match what is deﬁned in the REMD input ﬁle, the replica ordering will be assigned as it is deﬁned
in the REMD input ﬁle.

23.3.9.3. Analyzing multi-dimensional replica exchange simulations

The REMD log ﬁle for each dimension is further divided into the log messages for each group, as shown below.

1 of

100
2

# Replica Exchange log file
# numexchg is
# Dimension
# Description: Temperature exchange from 300K to 400K
# exchange_type = TEMPERATURE
# REMD filenames:
# remlog= rem.log.1
# remd dimension file= remd.dim
# Rep#, Velocity Scaling, T, Eptot, Temp0, NewTemp0, Success rate (i,i+1), ResStruct#
# exchange

1

1
2

-1.00
-1.00

# exchange

1
2

-1.00
-1.00

# exchange

-40.69
-19.77

1 REMD group
0.00
0.00
1 REMD group
0.00
0.00
3 REMD group

-66.78
-46.06

300.00
400.00

2

300.00
400.00

1

300.00
400.00

300.00
400.00

0.00
0.00

0.00
0.00

1

-1.00

221.66

-34.00

300.00

300.00

0.00

0
0

0
0

0

477

23. Free energies

Figure 23.3.: Replica arrangement in multi-dimensional REMD simulations at multiple exchange steps following
some successful state parameter exchanges. A large gray number in the background is the original
placement in the REMD input ﬁle. A blue and red number pair is the group number and position in
the group, respectively. Replicas with the same color are part of the same group. Figure taken from
ref. 513.

478

1,11,21,31,42,12,22,32,43,13,23,33,44,14,24,34,4State 1 changes2,11,21,31,41,12,22,32,43,13,23,33,44,14,24,34,4State 2 changes2,11,21,31,41,12,22,32,43,13,23,43,34,14,24,34,4State 1 changes2,11,21,31,41,12,22,32,43,13,23,44,34,14,23,34,4State 2 changes23.3. Replica Exchange Molecular Dynamics (REMD)

2

-1.00

347.52

-29.09

400.00

400.00

0.00

# exchange

3 REMD group

1
2

-1.00
-1.00

257.14
332.76

-63.10
-26.73

2

300.00
400.00

300.00
400.00

0.00
0.00

0

0
0

The above example is shown for the ﬁrst dimension (temperature) of the example REMD ﬁle shown in Sec.
23.3.9.1. The columns are the same as those used in the corresponding 1-dimensional REMD simulation for that
exchange type.

To analyze structural properties, you must use cpptraj to properly snapshots into the appropriate replicas. For

example, for a T,pH-REMD simulation the command inside cpptraj would be like:

trajin mdcrd.000 remdtraj remdtrajvalues 300.0,7.0

In this example, we would be reconstructing the trajectory for temperature 300 K and pH 7.0 See Chapter 32 and
more speciﬁcally Subsection 32.10.4 for more details.

23.3.9.4. Reconstructing cpout and ceout ﬁles with ﬁxremdcouts.py

If you perform any type of REMD simulation that contains the constant pH and/or constant Redox Potential
options active, it becomes a problem to reconstruct your cpout or ceout ﬁles. This obviously happen in Multi-
dimensional REMD simulations [382, 503] but this could even happen with one-dimensional REMD simulations,
like, for example, T-REMD with constant pH active. In this example one would need to reconstruct the cpout ﬁles
by temperature, in order to properly analyze the protonation states during the simulation.

fixremdcouts.py is a Python tool written by Vinícius Cruzeiro that allows the cpout or ceout ﬁles from any

REMD to be reconstructed for posterior analysis in cphstats or cestats [503]. This tool generalizes for any
REMD simulation what the --fix-remd option does in cphstats for pH-REMD or in cestats for E-REMD.
You can access a list and description of all available command-line ﬂags using the --help ﬂag, whose output is
shown below.

usage: fixremdcouts.py [Options]
optional arguments:

-h, --help
-v, --version
--author
-O, --overwrite

show this help message and exit
show the program’s version and exit
show the program’s author name and exit
Allow existing outputs to be overwritten. Default:
False

Required Arguments:

-couts [FILE [FILE ...]]

Non-required Arguments:

AMBER CPOUT and/or CEOUT files

-prefix STRING

Prefix of the reordered file names. Default: reordered
This program will reorder Replica Exchange CPOUT and/or CEOUT files. It can be
used even when pH or Redox Potential REMD are not used, for example to
reconstruct CPOUT files per temperature on a T-REMD simulation with constant
pH on. This tool can also be used with Multidimensional REMD CPOUT and/or
CEOUT files.

An example of the execution of the program is given below:

fixremdcouts.py -prefix reordered -couts [list all cpout and/or ceout files]

if you performed a
You may provide cpout and ceout ﬁles together to -couts.
the generated ﬁles would be
T-REMD with CpHMD whose temperature replicas are 300 and 320 K,
if you performed a
reordered.cpout.T_300.00 and reordered.cpout.T_320.00. Another example,
the gener-
pH,T-REMD whose replicas values are pH 7.0 and 7.5 and temperatures 300 and 320 K,
ated ﬁles would be reordered.cpout.pH_7.000000.T_300.00, reordered.cpout.pH_7.000000.T_320.00,
reordered.cpout.pH_7.500000.T_300.00, and reordered.cpout.pH_7.500000.T_320.00.

As an example,

479

23. Free energies

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD

and String Method

23.4.1. Overview

The following describes a suite of modules useful for the calculation of the free energy associated with a reaction

coordinate σ (r1, . . . ,rN) (which is deﬁned as a smooth function of the atomic positions r1, . . . ,rN):

f (ξ ) = −kBT ln(cid:10)δ [ξ − σ (r1, . . . ,rN)](cid:11),

(the angular brackets denote an ensemble average, kB is the Boltzmann constant and T is the temperature) that is
also frequently referred to as the potential of mean force.

Speciﬁcally, new frameworks are provided for equilibrium umbrella sampling and steered molecular dynamics
that enhance the functionality delivered by earlier implementations (described earlier in this manual), along with a
new Adaptively Biased Molecular Dynamics (ABMD) method [514] that belongs to the general category of umbrella
sampling methods with a time-dependent potential. Such methods were ﬁrst introduced by Huber, Torda and van
Gunsteren (the Local Elevation Method [515]) in the molecular dynamics (MD) context, and by Wang and Landau
in the context of Monte Carlo simulations [516]. More recent approaches include the metadynamics method [517,
518]. All these methods estimate the free energy of a reaction coordinate from an evolving ensemble of realizations,
and use that estimate to bias the system dynamics to ﬂatten an effective free energy surface. Collectively, these
methods may all be considered to be umbrella sampling methods with an evolving potential. The algorithms
discussed here were developed by the group of Prof. Celeste Sagui (sagui@ncsu.edu) and Prof. Christopher
Roland (cmroland@ncsu.edu); the current version was implemented by Dr. Volodymyr Babin.

The ABMD method grew out of attempts to speed up and streamline the metadynamics method for free energy
calculations with a controllable accuracy. It is characterized by a favorable scaling in time, and only a few (two)
control parameters. It is formulated in terms of the following equations:

∂
∂ra

U(cid:2)t|σ (r1, . . . ,rN)(cid:3),
G(cid:2)ξ − σ (r1, . . . ,rN)(cid:3),

ma

d2ra
dt2 = Fa +

∂U(t|ξ )

∂t

=

kBT
τF

where the ﬁrst equation represents Newton’s law that governs ordinary MD (temperature and pressure regulation
terms are not shown) augmented with an additional force coming from the time dependent biasing potential U(t|ξ )
[U(t = 0|ξ ) = 0], whose time evolution is given by the second equation. G(ξ ) is a positive deﬁnite and symmetric
kernel, which may be thought of as a smoothed Dirac delta function. For large enough τF (the ﬂooding timescale)
and small kernel width, the biasing potential U(t|ξ ) converges towards − f (ξ ) as t → ∞.
Our numerical implementation of the ABMD method involves the use of a bi-weight kernel along with the use of
cubic B-splines (or products thereof) to discretize the biasing potential U(t|ξ ) w.r.t. ξ , and an Euler-like scheme for
time integration. ABMD admits two important extensions, which lead to a more uniform ﬂattening of U(t|ξ ) + f (ξ )
due to an improved sampling of the “evolving” canonical distribution. The ﬁrst extension is identical in spirit to
the multiple walkers metadynamics [519, 520]. It amounts to carrying out several different MD simulations biased
by the same U(t|ξ ), which evolves via:

∂U(t|ξ )

∂t

=

kBT
τF ∑

α

G(cid:2)ξ − σ (rα

N)(cid:3) ,

1 , . . . ,rα

where α labels different MD trajectories. A second extension is to gather several different MD trajectories, each
bearing its own biasing potential and, if desired, its own distinct collective variable, into a generalized ensemble
for “replica exchange” with modiﬁed “exchange” rules [521–523]. Both extensions are advantageous and lead to
a more uniform ﬂattening of U(t|ξ ) + f (ξ ).
In order to assess and improve the accuracy of the free energies, the ABMD accumulations may need to be followed
up with equilibrium umbrella sampling runs, which make use of the biasing potential U(t|ξ ) as is. Such a procedure

480

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

is very much in the spirit of adaptive umbrella sampling. With these runs, one calculates the biased probability
density:

pB(ξ ) =(cid:10)δ [ξ − σ (r1, . . . ,rN)](cid:11)

B.

The idea here is that if, as a result of an ABMD run, f (ξ ) +U(t|ξ ) = 0 exactly, then the biased probability density
pB(ξ ) would be ﬂat (constant). In practice, this is typically not the case, but one can use pB(ξ ) to “correct” the
free energy via:

f (ξ ) = −U(ξ )− kBT ln pB(ξ ).

With the ABMD procedure, one can obtain accurate free energy curves and equilibrium properties. We note that
to obtain ABMD free energies requires a (minor) amount of post-processing by means of the nfe-umbrella-slice
utility freely available in AmberTools as described in Subsection 23.4.8. This methodology has been applied to a
variety of biomolecular systems, including small peptides [514, 524, 525], sugar puckering [526], polyproline sys-
tems [527–529], guest-host systems [530, 531], polyglutamine systems [532, 533], and DNA systems [534–538].
In addition, SMD simulations (discussed below) have been used to examine transition pathways and mechanisms,
to estimate free energy differences [528, 539], and to calculate transition rates [540–542].

While the above represents the basic ABMD implementation, AMBER20 introduced three additional algorithms
– the Well-Tempered (WT) ABMD, a selection mechanism for multiple walker ABMD and Driven ABMD (D-
ABMD)[543] – all of which enhance the stability and convergence of an ABMD simulation. Also implemented
is the Swarms-of-Trajectories String Method (STSM) [544], which gives a way of exploring the Minimum Free
Energy Path (MFEP) on free energy lansdscape. Current version of these codes were inplemented by Dr. Mahmoud
Moradi (moradi@uark.edu), Dr. Feng Pan (fpan3@ncsu.edu) and Ashkan Fakharzadeh (afakhar@ncsu.edu).

The Well-Tempered ABMD: An alternative to the follow-up equilibrium simulations for increased ABMD
accuracy is provided by the WT-ABMD, which is implemented in the spirit of the WT-metadynamics [545]. In the
original ABMD implementation, the history dependent biasing potential is built up at a ﬁxed rate:

U(ξ ,t) = U 0(ξ ) +

dt(cid:48) ω G(ξ − ξ t(cid:48)

),

(23.18)

unbiased rate. As the simulation proceeds and reaches convergence, then(cid:10)U(ξ ,t → ∞)(cid:11)
in which U(ξ ,t) is the biasing potential at time t, U 0 is an arbitrary function that typically represents the initial
(cid:10).(cid:11)
guess for the biasing potential (in the absence of a guess, this is assumed to be ﬂat) and ω = kBT /τF is a constant,
a ≈ U s(ξ ) +u(t), in which
a is the ensemble-average over the adaptive trajectories, the stationary term is U s ≈ −F(ξ ), and u(t) is an
additive time-dependent constant [545]. Unfortunately, updating the biasing potential at the same rate throughout
the simulation may lead to a poorly converged result, since the biasing potential ends up ﬂuctuating around −F(ξ )
with an amplitude that depends on ω.

One way to resolve this problem is to update the kernel at a non-uniform rate by means of a "well-tempered" ω:

U(ξ ,t) = U 0(ξ ) +

dt(cid:48) ω(ξ t(cid:48)

,t(cid:48))G(ξ − ξ t(cid:48)

),

(23.19)

With this choice, one can show that(cid:10)U(ξ ,t → ∞)(cid:11)

in which ω(ξ ,t) is a time-dependent, non-uniform rate chosen to be ω0 e−β(cid:48)U(ξ ,t) (1/β(cid:48) = kBT(cid:48) where T(cid:48) is a
pseudo-temperature) that reduces to a constant ω0 in the β(cid:48) → 0 limit (i.e., resulting in conventional ABMD).
a ≈ U s(ξ ) + u(t), (u(t) is an additive constant) in which U s(ξ )
and F(ξ ) are related via U s(ξ ) = −(1 + β(cid:48)
T(cid:48) )U s(ξ ). This way of updating the bi-
asing potential leads to a considerably smoother convergence to the desired free energy and more stable ABMD
simulations.

β )−1F(ξ ) or F(ξ ) = −(1 + T

Multiple walker selection algorithm: The ABMD multiple walker algorithm can be improved by allowing for
periodic interactions between the different walkers and "resampling" on-the-ﬂy. The rationale behind this is that
not all walkers are equally effective in sampling the conﬁguration space. A situation that is all too common is
that different walkers end up being “bunched up" or clustered together in some local metastable region, because of
hidden barriers that are oriented along orthogonal degrees of freedom to the reaction coordinate. To improve this
situation, one would like to facilitate walkers that are sampling the undersampled regions of phase space, and force
the walkers in the oversampled regions to move away and explore regions not yet covered. Such an algorithm has

481

(cid:90) t

0

(cid:90) t

0

23. Free energies

previously been implemented via scripts in the NAMD code for the adaptive biasing force algorithm [546].

A resampling or selection algorithms for interacting multiple walkers requires a continual monitoring of the
walkers by means of a periodic evaluation of a ﬁtness function and a resampling of the walkers according to their
ﬁtness efﬁciency[546]. Efﬁcient walkers that are wandering in the undersampled regions are enhanced by being
cloned, while inefﬁcient walkers found in the oversampled regions of phase space are correspondingly killed. This
procedure is then repeated periodically during the simulation, thereby accelerating convergence to a more uniform
distribution of walkers and ﬂattening of the free energy landscape.

Our speciﬁc interacting/resampling/selection multiple-walker algorithm is implemented as follows. Each walker
n is assigned a weight wn, which is evaluated at the end of each resampling period of time τ. At the ith resampling
period, i.e., from time t(i−1) = (i− 1)τ to ti = iτ, walker n moves through conﬁguration space building up its own
trajectory (rn
N). The weights are then tested and updated every ﬁxed time interval of length τ. Speciﬁcally,
after the ith time interval, weights are estimated by:

1, . . . ,rn

(cid:18)(cid:90) ti

(cid:19)

wn = K−1 exp

S(ξ t

n)dt

,

ti−1

where ξ t
factor, and

n represents the collective variable evaluated at time t for trajectory n, K = ∑Nw

n=1 wn is the normalization

S(ξ ) = C∇2(ρ(ξ ))/ρ(ξ ),

with ρ(ξ ) representing the density of microstates in the collective variable space and C a constant. The quantity
S(ξ ) will be positive typically if the walker is found in the undersampled regions, which have a convex density
function. Similarly, a negative S(ξ ) value indicates that the system is in the concave region of the density function,
which typically is oversampled. In the context of ABMD implementation, the biasing potential is approximately
proportional to the histogram of the collective variable by construction, and represents a good estimate for ρ. The
implementation is therefore straightforward; the integral above is estimated for each trajectory independently by
summing over S(ξ t
n) at every step from t = ti−1 to t = ti, in which ∆t is the MD timestep. At the end of each period
the walkers send their unnormalized weight estimates to the "master processor" to normalize them. A stochastic
resampling method is then used to clone/kill the replicas based on their weight factors [546]. The number of copies
present in the next period for walker n is determined by the integer number:

W1 = (cid:98)η1 + Nww1(cid:99),
Wn = (cid:98)ηn + Nw
∑

n

m=1

wm(cid:99)−(cid:98)ηn + Nw

n−1
∑

m=1

wm(cid:99),

for n > 1.

in which 0 < ηn < 1 is drawn from a uniform distribution (using a random number generator). The atomic co-
ordinates and velocities of the walkers with Nn > 0 are "sent" to Nn walkers. The resampling algorithm above
guarantees ∑nWn = Nw.

In terms of an ABMD simulation, the selection algorithm is most beneﬁcial during the initial and middle parts
of the simulation when there are large variations in the biasing potential. In the latter parts, when the effective free
energy is almost ﬂat, the distribution of walkers should be roughly uniform. In that case, the selection mechanism
is unnecessary and, if one wishes to continue the simulation, it is best to proceed with the non interacting multiple
walker algorithm. It has been found that a convenient stopping mechanism may be based on the entropy of the
weights. Deﬁning H = ∑n wnlog(wn), the selection mechanism will be stopped if Ew = H −log(1/Nw) goes below
-εlog(1/Nw). Here, log(1/Nw) represents the entropy of uniform weights, and the stopping parameter ε varies
between 0 ≤ ε ≤ 1. When ε = 0, the algorithm never stops, while ε = 1 forces a stop irrespective of the values of
the weights.

In addition to ε, there are also two other user-deﬁned variables in the selection algorithm, including the constant
C and the interval time τ. While the physical interpretation of τ is straightforward, C represents a pseudo diffusion
constant. One may think of the selection algorithm as an induced diffusion in the reaction coordinate space; The
larger the value of C, the faster the system will diffuse along the reaction coordinate space. Therefore C determines
the strength or aggressiveness of the resampling algorithm. The most efﬁcient value for C is dependent on the

482

(cid:90) t

0

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

nature of the collective variable and the shape of its density ρ. Since the best choice of C for a given problem is
somewhat of an art, we refer the interested reader to the ABMD tutorials on the AMBER webpage for insight into
choosing this variable. Finally, we also note that the multiple walker selection mechanism can be invoked as is or
in conjunction with the WT-ABMD for enhanced stability and convergence.

Driven ABMD: ABMD and SMD schemes are both powerful nonequilibrium sampling methods; however, each
comes with its own practical limitations. For instance, SMD is often associated with a very slow convergence if
used for free energy calculations. However it can be used to explore the transition paths, at least qualitatively; an
advantage over ABMD, in which the system starting from one end of the conﬁguration space (the reactant) may
take a long time to visit the other end (the product). SMD and ABMD schemes, however can be integrated into
a novel driven adaptive-bias 3 scheme, termed driven ABMD (D-ABMD) that takes advantage of both its driven
and adaptive-bias components and is advantageous over both components in isolation. D-ABMD has an advantage
over conventional (or well-tempered) ABMD in that it ensures the exploration of the transition pathway (from one
end to the other) in the early stages of the simulation and gradually improves the estimate of the free energies
almost uniformly along the reaction coordinate. D-ABMD has also an advantage over the conventional SMD in
that the effective free energy surface gradually becomes smooth and ﬂat such that the system can move along the
reaction coordinate with progressively less amount of work. The D-ABMD method is similar to D-MetaD method,
which was recently introduced in Ref.[543] as an example of driven, adaptive-bias schemes.

In order to combine the two schemes described above, we have developed a driven adaptive-bias scheme that
adds an adaptive Ua(ξ ,t) and a driving Ud(ξ ,t) potential to the Hamiltonian. We use an iterative approach in
which an independent simulation is performed from time t = 0 to t = T in the nth iteration (n = 1, 2, . . .), biased
2 (ξ − η(t))2 for all n (η(t) is moving center of the SMD
by the potential Ud(ξ ,t) +U n
harmonic potential in the ξ space), and:

a (ξ ,t) in which Ud(ξ ,t) = k

a (ξ ,t) = U n−1(ξ ) +
U n

dt(cid:48)ω(ξ t(cid:48)

,t(cid:48))K(ξ − ξ t(cid:48)

)e−βωt(cid:48)

ac =(cid:82) t

0 dt(cid:48) ∂

∂t(cid:48) Ud(ξ t(cid:48)

,t(cid:48)) and ωt

in which ωt is either deﬁned as the accumulated work or the transferred work. The accumulated and transferred
works are deﬁned as ωt
tr factor or “con-
stant weight” is more accurate but for practical reasons the e−βωt(cid:48)
ac factor or “pulling wight” is preferred. Par-
ticularly, in our algorithm, the constant weight e−βωt(cid:48)
,t(cid:48)) may become instable for large biasing
potentials. To avoid the instability in either case a cutoff for ωt is used (i.e., the algorithm will not be applied
if ωt is smaller than the cutoff). At the moment, Driven ABMD is only applicable to one-dimensional reaction
coordinate.

ac −Ud(ξ t ,t). Theoretically the e−βωt(cid:48)

tr = ωt
tr = e−βωt(cid:48)

aceβUd (ξ t(cid:48)

If any of these modules prove to be useful, please consider quoting the following papers: V. Babin, C. Roland
and C. Sagui, "Adaptively biased molecular dynamics for free energy calculations", J. Chem. Phys. 128, 134101
(2008); V. Babin, V. Karpusenka, M. Moradi, C. Roland and C. Sagui, "Adaptively biased molecular dynamics: an
umbrella sampling method with a time-dependent potential", Int. J. Quant. Chem. 109, 3666 (2009).

From Amber16, we implement these modules from SANDER to PMEMD and the modules are GPU compatible.
To keep the consistency in format, we do a series of changes and updates to the usage of these modules. One big
change is that you must set infe = 1 in &cntrl to activate these modules. Also, the input format has been changed
to namelist style and reaction coordinate variables will be read from separate ﬁles. For the details, please read
Subsection 23.4.7

infe

This variable controls the usage of the non-equilibrium free energy method. When infe=0, the
ABMD and related methods are turned off; when infe=1, they are turned on and the blocks &smd,
&pmd, &abmd, &bbmd and &stsm will be recognized. The default value is 0. Note that use of these al-
gorithms may require a (minor) amount of post-processing by means of the nfe-umbrella-slice utility
freely available in AmberTools described in Subsection 23.4.8.

23.4.2. Reaction Coordinates

A reaction coordinate is deﬁned in the colvar namelist in a separate ﬁle. (see Fig. 23.4). This section must
contain a cv_type keyword along with a value of type STRING and a list of integers cv_i (the number of integers

483

23. Free energies



&colvar

cv_type = STRING
cv_ni = N, cv_nr = M
cv_i = i1, i2, ..., iN
cv_r = r1, r2, ..., rM

/





Figure 23.4.: Syntax of reaction coordinate deﬁnition: cv_type is a STRING, cv_i is a list of integer numbers and

cv_r is a list of real numbers.

is deﬁned by cv_ni). For some types of reaction coordinates the colvar section must also contain a list of real
numbers, cv_r, whose length is deﬁned by cv_nr.

The following reaction coordinates (specﬁed by cv_type) are currently implemented:

DISTANCE: distance (in Å) between two atoms whose indexes are read from the list cv_i.

COM_DISTANCE: distance between the center of mass of two atom groups. The cv_i list is interpreted as a
list of indexes of participating atoms. Zeros separate the groups, the last zero is optional. eg: cv_i =
a1,...,aN,0,b1,...,bM,0.

DF_COM_DISTANCE: difference

distances
and second two atom groups.
of

groups
dexes
eg:
COM_DISTANCE(a1,...,aN,0,b1,...,bM) - COM_DISTANCE(c1,...cL,0,d1,...,dK).

the
cv_i = a1,...,aN,0,b1,...bM,0,c1,...cL,0,d1,...,dK,0,

of mass
interpreted as

of ﬁrst
a
zero

The cv_i list

is
groups,

participating

between

separate

atoms.

center

Zeros

the

the

of

last
DF_COM_DISTANCE

two
list of
is

atom
in-
optional.
is

LCOD: linear combination of distances (in Å) between pairs of atoms listed in cv_i with the coefﬁcients read
from cv_r list. For example, i = 1,2,3,4 and r = 1.0,-1.0 deﬁne the difference between 1-2 and 3-4
distances, i.e. LCOD = r1*distance(1, 2) + r2*distance(3,4).

ANGLE: angle (in radians) between the lines joining atoms with indexes i1 and i2 and atoms with indexes i2 and

i3.

COM_ANGLE: angle (in radians) formed by the center of mass of three atom groups. The cv_i list is interpreted
as a list of indexes of participating atoms. Zeros separate the groups, the last zero is optional. eg: cv_i =
a1,...,aN,0,b1,...bM,0,c1,...,cK,0.

TORSION: dihedral angle (in radians) formed by atoms with indexes i1, i2, i3 and i4.

COM_TORSION: dihedral angle (in radians) formed by the center of mass of four atom groups. The cv_i list is
interpreted as a list of indexes of participating atoms. Zeros separate the groups, the last zero is optional. eg:
cv_i = a1,...,aN,0,b1,...bM,0,c1,...,CK,0,d1,...,dL,0.

COS_OF_DIHEDRAL: sum of cosines of dihedral angles formed by atoms with indexes in the list cv_i. The

number of atoms must be a multiple of four.

SIN_OF_DIHEDRAL: sum of sines of dihedral angles formed by atoms with indexes in the list cv_i. The number

of atoms must be a multiple of four.

PAIR_DIHEDRAL: sum of cosines of a list of angles each formed by summing two neighboring dihedral angles
from a list formed by atoms with indices cv_i. The number of atoms must be a multiple of four. For a list
of dihedral angles such as {α1, . . . ,αN}, PAIR_DIHEDRAL is ∑N−1
i=1 cos(αi +αi+1) which ranges between
−N + 1 and N − 1.

484

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

PATTERN_DIHEDRAL: a particular pattern-recognizing function deﬁned on a list of dihedral angles formed by
atoms with indices cv_i. The number of atoms must be a multiple of four. The deﬁnition is particularly
relevant for the dihedral angles with a binary-like behavior of being either around 0 or 180 (e.g., ω back-
bone dihedral angle). For a list of dihedral angles such as {α1, .
,αN }, PATTERN_DIHEDRAL is
i=1cos2(αi/2)2i−1 which ranges between 0 and 2N − 1.
∑N

.

.

R_OF_GYRATION: radius of gyration (in Å) of atoms with indexes given in the cv_i list (mass weighted).



&colvar

cv_type = 'MULTI_RMSD'
cv_ni = 9, cv_nr = 21,
cv_i = 1, 2, 3, 4, 0, 3, 4, 5, 0 ! the last zero is optional
cv_r = 1.0, 1.0, 1.0, ! group #1, atom 1

2.0, 2.0, 2.0, ! group #1, atom 2
3.0, 3.0, 3.0, ! group #1, atom 3
4.0, 4.0, 4.0, ! group #1, atom 4

23.0, 23.0, 23.0, ! group #2, atom 3
4.0, 4.0, 4.0, ! group #2, atom 4
5.0, 5.0, 5.0 ! group #2, atom 5

/

Figure 23.5.: An example of MULTI_RMSD variable deﬁnition.





MULTI_RMSD: RMS (in Å, mass weighted) of RMSDs of several groups of atoms w.r.t. reference positions provided
in the cv_r list. The cv_i list is interpreted as a list of indexes of participating atoms. Zeros separate
the groups. An atom may enter several groups simultaneously. The cv_r array is expected to contain the
reference positions (without zero sentinels). The implementation uses the method (and the code) introduced
in Ref. [547]. An example of variable of this type is presented in Fig. 23.5. Two groups are deﬁned here:
one comprises the atoms with indexes 1, 2, 3, 4 (line 3 in Fig. 23.5, numbers prior to the ﬁrst zero) and
another one of atoms with indexes 3, 4, 5. The code will ﬁrst compute the (mass weighted) RMSD (R1) of
atoms belonging to the ﬁrst group w.r.t. reference coordinates provided in the cv_r array (ﬁrst 12 = 4× 3
real numbers of it; lines 4, 5, 6, 7 in Fig. 23.5). Next, the (mass weighted) RMSD (R2) of atoms of the second
group w.r.t. the corresponding reference coordinates (last 9 = 3× 3 elements of the cv_r array in Fig. 23.5)
will be computed. Finally, the code will compute the value of the variable as follows:

(cid:114) M1

value =

R2
1 +

M2

M1 + M2

R2
2 ,

M1 + M2

where M1 and M2 are the total masses of atoms in the corresponding groups.

N_OF_BONDS:

value = ∑

p

1−(cid:16)
1−(cid:16)

rp

rp

(cid:46)
(cid:46)

r0

r0

(cid:17)6
(cid:17)12 ,

where the sum runs over pairs of atoms p, rp denotes distance between the atoms of pair p and r0 is a
parameter measured in Å. The cv_r array must contain exactly one element that is interpreted as r0. The
cv_i array is expected to contain pairs of indexes of participating atoms. For example, if 1 and 2 are the
indexes of Oxygen atoms and 3, 4, 5 are the indexes of Hydrogen atoms and one intents to count all possible
O-H bonds, the cv_i list must be (1, 3, 1, 4, 1, 5, 2, 3, 2, 4, 2, 5), that is, it must explicitly list all the pairs
to be counted.

485

23. Free energies



&colvar

cv_type = 'N_OF_STRUCTURES'
cv_ni = 9, cv_nr = 23,
cv_i = 1, 2, 3, 4, 0, 3, 4, 5, 0 ! the last zero is optional
cv_r = 1.0, 1.0, 1.0, ! group #1, atom 1

2.0, 2.0, 2.0, ! group #1, atom 2
3.0, 3.0, 3.0, ! group #1, atom 3
4.0, 4.0, 4.0, ! group #1, atom 4
1.0,

! R0 for group #1

23.0, 23.0, 23.0, ! group #2, atom 3
4.0, 4.0, 4.0, ! group #2, atom 4
5.0, 5.0, 5.0, ! group #2, atom 5
2.0

! R0 for group #2

/

HANDEDNESS:

where

Figure 23.6.: An example of N_OF_STRUCTURES variable.

value = ∑

a

ua,3 · [ua,1 × ua,2]
|ua,1||ua,2||ua,3| ,

ua,1 = ra+1 − ra
ua,2 = ra+3 − ra+2
ua,3 = (1− w)(ra+2 − ra+1) + w(ra+3 − ra) ,





and ra denote the positions of participating atoms. The cv_i array is supposed to contain indexes of the
atoms and the cv_r array may provide the value of w (0 ≤ w ≤ 1, the default is zero).

N_OF_STRUCTURES:

value = ∑

g

1−(cid:16)
1−(cid:16)

(cid:46)
(cid:46)

Rg

Rg

R0,g

R0,g

(cid:17)6
(cid:17)12 ,

where the sum runs over groups of atoms, Rg denotes the RMSD of the group g w.r.t. some reference coor-
dinates and R0,g are positive parameters measured in Å. The cv_i array is expected to contain indexes of
participating atoms with zeros separating different groups. The elements of the cv_r array are interpreted
as the reference coordinates of the ﬁrst group followed by their corresponding R0; then followed by the ref-
erence coordinates of the atoms of the second group, followed by the second R0, and so forth. To make the
presentation clearer, let us consider the example presented in Fig. 23.6. The atomic groups and reference
coordinates are the same as the ones shown in Fig. 23.5. Lines 7 and 11 in Fig. 23.6 contain additional
entries that set the values of the threshold distances R0,1 and R0,2. To compute the variable, the code ﬁrst
computes the mass weighted RMSD values R1 and R2 for both groups –much like in the MULTI_RMSD case–
and then combines those in a manner similar to that used in the N_OF_BONDS variable.

1−(cid:16)
1−(cid:16)

(cid:46)
(cid:46)

R1

R1

R0,1

R0,1

(cid:17)6
(cid:17)12 +

1−(cid:16)
1−(cid:16)

(cid:46)
(cid:46)

R2

R2

R0,2

R0,2

(cid:17)6
(cid:17)12 .

value =

In other words, the variable “counts” the number of structures that match (stay close in RMSD sense) with the
reference structures.

QUATERNIONS: Describing large-scale atomistic conformational changes in biomolecular systems requires one

486

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

to deal with orientational changes of atomistic domains with large numbers of atoms. While there are
several ways of deﬁning a collective variable that quantiﬁes an orientation based conformational change,
the orientation quaternion technique[548–551] has proven successful as a well-behaved, ﬂexible method for
deﬁning system-speciﬁc CVs, speciﬁcally aimed at inducing interdomain orientational changes or restraining
the orientation of certain domains. The CVs in the orientation quaternion class, are all derived from an
‘optimal rotation’ between a set of reference coordinates Xk (1 ≤ k ≤ N; where N is the number of atoms
involved) and the set of target coordinates Yk. A ‘quaternion’ is introduced as a four-component vector
that can be expressed as q0 + q1ˆi + q2 ˆj + q3ˆk where q0 and q1ˆi + q2 ˆj + q3ˆk are called scalar and vector
parts respectively. The optimal rotation can be parametrized2 by a unit quaternion, ˆq = (q0,q1,q2,q3), that
minimize < || ˆqXk ˆq∗−Yk||2 > in which < . > denotes an average over k,q∗ is the conjugate of q and ||q||2 =
q∗q (see Ref.[548] for more details). The optimal rotation unit quaternion (or orientation quaternion) ˆq can

be written as(cid:0)cos(θ /2),sin(θ /2) ˆu(cid:1), where θ is the optimal rotation angle and ˆu is a unit vector associated

with the optimal axis of rotation. To deal with large atomistic conformational changes, a set of quaternion-
based CVs has implemented in AMBER20. For the details of usage, send emails to Ashkan Fakharzadeh
(afakhar@ncsu.edu), Dr. Feng Pan (fpan3@ncsu.edu), and Prof. Mahmoud Moradi (moradi@uark.edu).
The speciﬁc quaternion-based CVs implemented are: ORIENTATION_ANGLE, ORIENTATION_PROJ,
TILT, SPINANGLE, QUATERNION0, QUATERNION1, QUATERNION2, and QUATERNION3.

quaternion ˆq = (q0,q1,q2,q3) can be written as(cid:0)cos(θ /2),sin(θ /2) ˆu(cid:1), where θ is the rotation angle and ˆu

Orientation (QUATERNION0,...,QUATERNION3): These deﬁne the orientation of several atoms with respect
to a set of reference coordinates in terms of a unit quaternion vector ˆq = (q0,q1,q2,q3) according to the
method introduced in Ref.[548, 549]. These variables return the best-ﬁt rotation, also used in best-ﬁt RMSD
calculation procedures, to superimpose the coordinates X onto a set of reference coordinates X0. The unit
is a unit vector associated with the axis of rotation; for example, a rotation of 90◦ around the z axis (0,0,1) is
√
√
expressed as(cos(90◦/2),0.0,0.0,sin(90◦/2)) = (
2/2). The components of the unit quaternion
2/2,0,0,
(q0,q1,q2,q3) were implemented separately as QUATERNION0, QUATERNION1, QUATERNION2, and
QUATERNION3 CVs. To ﬁnd the orientation, all four CVs QUATERNION0,...,QUATERNION3 are being
used. To calculate the quaternion CVs one needs to specify a list of participating atoms and also their
reference coordinates. The reference coordinates may be passed to AMBER either via direct speciﬁcation
inside the CV call, or by passing the name of a reference coordinates ﬁle. It is recommended that if the set
of participating atoms is small (say no larger than 15), then these are speciﬁed directly inside the CV call.
Otherwise, the passing of information via ﬁlename is recommended since these lists may contain hundreds if
not thousands of atoms. Relevant parameters pertaining to the input of this information are: cv_ni represents
the number of participating atoms; cv_i represents the list of the indices of all participating atoms; cv_r
represents the reference coordinates (when passed directly) and re f crd_ f ile is the ﬁlename for the reference
coordinates when they are to be read from ﬁle. The ﬁle re f crd_ f ile should be an AMBER coordinates/restart
ﬁle containing coordinates, velocities, etc. of all atoms. The list participating atoms, cv_i, and their reference
coordinates (cv_r and or re f crd_ f ile ) must be the same for all QUATERNION0,...,QUATERNION3. The
CVs are linked together using an attribute‘q_index’. The‘q_index’ accepts an integer between 1, ...,100,
where its default value is one. The Fig. 23.7 is an example of Quaternion CVs syntax. An example this
type of CVs is presented in the Fig. 23.8. Two set of orientations are deﬁned here: each set consists of
QUATERNION0,.., QUATERNION3. The ﬁrst set comprises 18 atoms with indexes 11,41,48,74,104, . . .
and another one of 24 atoms with indexes 12,16,46,55,75, . . .. A ﬁle, ‘inpcrd’ is used as an AMBER
coordinate/restart ﬁle to read reference coordinates. There is no need to set ‘q_index’ for the ﬁrst four
quaternions since the default value is one, but it is set to be 2 for all quaternion CVs in the second set
to link and normalize them. The returned value of each QUATERNION0,...,QUATERNION3 CVs is the
corresponding component of the unit orientation vector ˆq = (q0,q1,q2,q3).

ORIENTATION_ANGLE: The angle of rotation θ = 2cos−1(q0) between the current and the reference positions.

This angle is between 0◦ to 180◦. The cv_i list is interpreted as a list of indexes of participating atoms.

2Assuming both sets have been already shifted to bring their barycenters to the origin (optimum translation).

orientation angle: θ = 2cos−1(q0)

487

23. Free energies



&colvar

cv_type = 'QUATERNION0'

! number of participating atoms
cv_ni = ni

! index of participating atoms
cv_i = a1, a2,..., aN

! AMBER coordinate/restart file to read reference coordinates
refcrd_file = 'refcrd_file'

! number of references which must be 3*ni; Should not be set if
! refcrd_file is being used
cv_nr = nr

! reference coordinates of participating atoms; Should not be set if
! refcrd_file is being used
cv_r = a1x, a1y, a1z, a2x, a2y, a2z, a3x, a3y, a3z, ...

! an arbitrary integer between 1 to 100
q_index = n

/

Figure 23.7.: Syntax of Quaternion reaction coordinates.





ORIENTATION_PROJ: The cosine of the angle of rotation θ between the current and the reference positions.
While ORIENTATION_ANGLE diverges near θ = 0, because of ∇Xθ, ORIENTATION_PROJ might be
used instead to apply forces. The range of ORIENTATION_PROJ is [−1,1]. The cv_i array is supposed to
contain indexes of the atoms.

orientation proj: 2q2

0 − 1

SPINANGLE: Angle of rotation φ around a given unit axis ˆe. The axis ˆe is being used to decompose a complete
orientation rotation in two sub-rotations, spin φ and tilt ω. An advantage of this decomposition is φ and
ω have the same values, regardless of which one is applied ﬁrst (in comparison to Euler angles methods).
The participating atoms with indexes are given in the cv_i. The‘axis’ must provide three components of the
axis3ˆe in A◦. The default axis of rotation is (0.0,0.0,1.0). The range of SPINANGLE is between[−180 : 180]
degrees. The reference coordinates are speciﬁed either via cv_r or re f crd_ f ile.

spin angle: φ = 2tan−1(q.e/q0)

where q is the vector part of quaternion, namely (q1,q2,q3). An example of SPINANGLE cv is presented
in Fig. 23.9. The same atoms as example one are used, but the axis of rotation is set to be ‘x-axis’. The
reference coordinates are given by cv_nr, cv_r options.

TILT: Cosine of the rotation orthogonal to an unit given axis. The tilt angle ω, shows a rotation away from the
direction ˆe. The tilt combined with the ‘spin’ sub-rotation provides the complete orientation rotation of a
group of atoms. Similar to ORIENTATION_PROJ, to avoid the discontinuity around 0◦ and 180◦, the cosine
of the tilt is implemented instead of the tilt angle itself, so that derivatives are continuous almost everywhere.
The cv_i and ‘axis’ are the participating atoms with indexes and the given axis, respectively. The reference
coordinates are speciﬁed either via cv_r or re f crd_ f ile. The value of TILT is between −1 to 1, where the
value 1 represents an orientation fully parallel to ˆe (ω = 0◦), and the value −1 represents an anti-parallel

3The axis is from the origin(0.0,0.0,0.0) to that point.

488

orientation.

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

tilt: t = cos(ω) = 2(cid:0)

(cid:1)2 − 1

q0

cos( tan−1q.e

)

q0

23.4.3. Steered Molecular Dynamics

The &smd namelist, if present in the MDIN ﬁle, activates the steered MD code (the method itself is extensively
described in the literature: see for example Ref. [552] and references therein). The preﬁx NFE appears in several
switches to do with steered MD: this stands for “Non-equilibrium Free Energy”.

The following is recognized within the &smd namelist:

output_file sets the output ﬁle name. Default is ’nfe-smd.txt’.

output_freq sets the output frequency (in MD steps). Default is 50.

cv_file

sets the collective variable ﬁle name. Default is ’nfe-smd-cv’.

There must be at least one reaction coordinate deﬁned (that is, there must be at least one &colvar namelist in the
cv_file). The steered MD code requires that additional entries be present in the &colvar namelist:

path

the steering path whose elements must be real numbers. The path must include at least two elements.
The upper limit on the number of entries is 20000. The elements deﬁne Catmull-Rom spline used
for steering.

npath

sets the number of elements in path. Default is 0.

path_mode The way steering paths are constructed. There are two modes available. In SPLINE mode (default)
the path is approximated by a spline that passes through the given points; in LINES mode the path is
represented by the line segments joining the control points.

harm

speciﬁes the harmonic constant. If a single number is provided, e.g., harm = 10.0, then it is constant
throughout the run.
If two or more numbers are provided, e.g., harm = 10.0, 20.0, then the
harmonic constant follows a Catmull-Rom spline built upon the provided values.

nharm

sets the number of elements in harm. Default is 0.

harm_mode The way harmonical paths are constructed, similar with path_mode.

An example of MDIN ﬁle and CV.IN ﬁle for steered MD is shown in Fig. 23.10. The reaction coordinate is deﬁned in
cv.in. The spring constant is set constant throughout the run and the steering path is conﬁgured from 5.0 to 3.0.
The values of the reaction coordinate, harmonic constant and the work performed on the system are requested to
be dumped to the smd.txt ﬁle every 50 MD steps.

23.4.4. Umbrella sampling

To activate the umbrella sampling code, the &pmd namlist must be present in the MDIN ﬁle.&pmd is currently
available to both SANDER and PMEMD, and also can be fully applied in GPU accelerated PMEMD. The
output_file, output_freq and cv_file entries are recognized just as in the steered MD case presented earlier.
The cv_file must contain at least one &colvar namelist section. For umbrella sampling, the &colvar section(s)
must contain two additional entries:

anchor_position: this consists of four real numbers (r1,r2,r3,r4) that determine the rectangle of the umbrella

(harmonic) potential. The default value is that all of the r(cid:48)s is set to zero.

anchor_strength: two non-negative real numbers (k1,k2) that set the harmonic constant for the umbrella (har-

monic) potential. The default value is zero.

The umbrella (harmonic) potential U is determined by (supposing R is the value of reaction coordinate)

489

23. Free energies

• U = k1∗ (r1− r2)∗ R
• U = 0.5∗ k1∗ (R− r2)2
• U = 0
• U = 0.5∗ k2∗ (R− r3)2
• U = k2∗ (r4− r3)∗ R

(R (cid:54) r1)
(r1 < R (cid:54) r2)

(r2 < R (cid:54) r3)

(r3 < R (cid:54) r4)
(R > r4)

A plot of the umbrella potential is shown below

eg1: if r2 = r3, r1 (cid:28) r2 and r4 (cid:29) r3, then the generated U is simply the traditional harmonic potential.
eg2: if r1 is slightly less than r2 and r4 is slightly larger than r3, also with very large k1, k2, the reaction coordinate

is restrained in the range (r2, r3) with no potential added.

An example of an MDIN ﬁle and CV.IN ﬁle for an umbrella sampling simulation is shown in Fig. 23.11. The ﬁrst
reaction coordinate here is the angle formed by the lines joining the 5th with 9th and 9th with 15th atoms. It is to be
harmonically restrained near 1.0 rad (anchor_position entry) using the spring of strength 10.0 kcal/mol/rad2
(anchor_strength entry). The second reaction coordinate requested in Fig. 23.11 is a dihedral angle (type =
’TORSION’) formed by the 1st, 2nd, 3rd and 4th atoms (the cv_i array). It is to be restrained near zero with
strength 23.8 kcal/mol/rad2. The values of the reaction coordinate(s) are to be dumped every 50 MD steps to
the pmd.txt ﬁle. Another example of restraining reaction coordinate in a speciﬁc range is shown in Fig. 23.12.
The reaction coordinates here are φ and ψ angles of dialanine. φ is restrained between -2.0 rad and 2.0 rad, ψ is
restrained between -1.8 rad and 1.8 rad.

The NFE implementation of umbrella sampling works correctly with the Amber standard replica-exchange MD
described earlier in this manual (compatible with different types of REMD for different values of -rem ﬂag in both
SANDER and PMEMD). For example, the typical umbrella sampling with Hamiltonian Replica Exchange can be
performed by setting -rem to 3. In this case, both anchor_position and anchor_strength may be different for
different temperatures. Even the number and type of reaction coordinate(s) could vary for different replicas. The
output ﬁles (set by the output_file keyword on a per-replica basis) are MDIN-bound, consistent with -rem.

23.4.5. Adaptively Biased Molecular Dynamics

The implementation has a very simple and intuitive interface: the code is activated if either an &abmd (both
SANDER and PMEMD) or an &bbmd (both SANDER and PMEMD) namelist is present in the MDIN ﬁle (the
difference between those “ﬂavors” is purely technical and will become clear later). Unlike in the &smd and &pmd
cases, the dimensionality of a reaction coordinate (the number of &colvar namelists in the cv_file) cannot exceed
ﬁve (though three is already hardly useful due to statistical reasons).

As previously noted, in order to activate the ABMD and related algorithm, the variable infe in &cntrl must be

set to unity (i.e. infe = 1; default value infe = 0).

In addition to the cv_file entry, the following entries are recognized within the &abmd (or &bbmd) namelist:

490

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

mode

There are three modes available: ’ANALYSIS’ | ’UMBRELLA’ |
sets the execution mode.
’FLOODING’. In ANALYSIS mode the dynamics is not altered. The only effect of this mode is that
the value(s) of the reaction coordinate(s) is(are) dumped every monitor_freq to monitor_file. In
UMBRELLA mode, biasing potential from the umbrella_file is used to bias the simulation (τF = ∞,
biasing potential does not change). In FLOODING mode the adaptive biasing is enabled.

monitor_file sets the name of the ﬁle to which value(s) of reaction coordinate(s) (along with the magnitude of

biasing potential in FLOODING mode) are dumped.

monitor_freq the frequency of the output to the monitor_file.

timescale τF, the ﬂooding timescale in picoseconds (only required in FLOODING mode).

umbrella_file biasing potential ﬁle name (the ﬁle must exist for the UMBRELLA mode).

In FLOODING mode, the following two entries are optional:

snapshots_basename sets the name of the ﬁle to which the biasing potential is dumped during the simulation for

snapshot.

snapshots_freq the frequency of dumping snapshot biasing potential (in MD steps). If snapshots_freq is not

speciﬁed, the snapshot biasing potential will not be dumped.

and the &colvar namelist for &abmd method must also contain the following entries:

cv_min

cv_max

smallest desired value of the reaction coordinate (required, unless the reaction coordinate is limited
from below).

largest desired value of the reaction coordinate (required, unless the reaction coordinate is limited
from above).

resolution the “spatial” resolution for the reaction coordinate.

To access the biasing potential ﬁles created in the course of FLOODING simulations, the nfe-umbrella-slice
utility is provided (it prints a short description of itself if invoked with --help option).

The multiple-walker selection algorithm can improve the simulation by resampling between different walkers.
The well-tempered ABMD can lead to a smoother convergence to the desired free energy. These two algorithm
are implemented to SANDER and PMEMD from Amber16 onwards.

The multiple-walker selection algorithm currently works with &abmd only. The algorithm should be used only
within the multiple-walker scheme (i.e., when command-line -rem ﬂag is set to zero). The following entries are
recognized regarding with the selection algorithm (selection algorithm can work with FLOODING and UMBRELLA
mode):

selection_freq positive integer number that sets the frequency of the resampling algorithm (in MD steps). If

selection_freq is not speciﬁed, the selection algorithm will not be used.

selection_constant positive real number that sets the parameter C. if selection_freq is speciﬁed, specifying
selection_constant is required (no default value). Parameter C is to determine how strong the
selection mechanism is. If C is too large, all the walkers will be replaced with the most dominant
one. If C is too small, there will be no killing/duplicating of walkers.

selection_epsilon positive real number (typically less than unity) that sets the stopping criterion parameter ε .
Parameter ε determines the threshold for stopping the selection algorithm. If selection_epsilon
is not speciﬁed, there will be no stop to the algorithm. If selection_epsilon is equal or larger than
one, the algorithm will be stopped after the ﬁrst attempt.

The well-tempered ﬂavor can be used within either &abmd or &bbmd namelist. There are two entries relevant to the
well-tempered feature:

491

23. Free energies

wt_temperature positive real number that sets the pseudo-temperature T’. If this ﬂag is not speciﬁed, conven-
tional ABMD will be used (i.e., T’ → ∞ or β’ → 0). The smaller the T’; the smoother/slower the
convergence.

wt_umbrella_file the ﬁle name of true biasing potential after modiﬁcation by 1 + ( T /T’ ) in which T is the

reference temperature of the system (temp0).

An example MDIN ﬁle and CV.IN ﬁle for the &abmd ﬂavor of ABMD is shown in the Fig. 23.13.

In this example, the reaction coordinate is deﬁned as the distance between the 5th and 9th atoms (more than one
reaction coordinates might be requested by mere inclusion of additional &colvar subsections). The mode is set
to FLOODING thus enabling the adaptive biasing with ﬂooding timescale τF = 100ps. The region of interest of the
reaction coordinate is speciﬁed to be between -1 Å and 10 Å and the resolution is set to 0.5 Å. The lower bound (-1
Å) could have been omitted for DISTANCE variable: the default value of zero would be used in such case. The code
will try to load the biasing potential from the umbrella.nc ﬁle and use it as the value of U(t|ξ ) at the beginning
of the run. The biasing potential built in the course of simulation will be saved to the same ﬁle (umbrella.nc)
every time the RESTRT ﬁle is written. The selection algorithm is used with the frequency of selection deﬁned
as 10000 MD steps and selection constant deﬁned as 0.001. The well-tempered algorithm is also used, with the
pseudo-temperature deﬁned as 10000 K in and the true biasing potential will be dumped as wt_umbrella.nc ﬁle.
The nfe-umbrella-slice utility can then be used to access its content. An MDIN ﬁle for the follow up biased run
at equilibrium would look much like the one shown in the Fig. 23.13, but with mode changed from FLOODING to
UMBRELLA.

Driven ABMD can be performed using &smd block (for the SMD part of the algorithm) along with &abmd block
(for the ABMD part of the algorithm). There is no additional ﬂag for the &smd block relevant to the algorithm;
however, there are two additional ﬂags to ABMD relevant to the “driven” feature.

driven_weight string that sets the weighting scheme. The default option (i.e., not using the ﬂag) is NONE which
indicates no reweighting is used (NOT RECOMMENDED if SMD is performed along ABMD).
Other options include CONSTANT and PULLING for constant and pulling reweighting protocols.

driven_cutoff positive real number that sets a cutoff for work for applying the reweighting algorithm (default:
0.0). If the work (accumulated or transferred depending on the scheme) at any given time is lower
than the cutoff, no reweighting is done at that particular time. If the cutoff is too small, it may result
in instability of the algorithm.

For both SANDER and PMEMD since Amber18, the &abmd code works correctly with Amber replica-exchange
similar with &pmd (that is, for -rem ﬂag set to different values). If-rem is set to 3, ABMD with replica-exchange is
carried out. In such case different replicas can have different temperatures, collective variables and even different
mode.The monitor and umbrella ﬁles are MDIN-bound. If number of sander groups exceeds one (the ﬂag -ng is
greater than one) and -rem ﬂag is set to zero, the code runs multiple walkers ABMD. In both cases the number and
type(s) of variable(s) must be the same across all replicas.

Finally, the &bbmd ﬂavor allows one to run replica-exchange (AB)MD with different reaction coordinates and
different modes (ANALYSIS, UMBRELLA or FLOODING) in different replicas (along with different temperatures, if
desired). This module is outdated since &abmd has been compatible with -rem equals 3. The only advantage of
&bbmd is that the number of replicas can be odd numbers if desired by runs, while this cannot be achieved in any
-rem types. To applying &bbmd module, the -rem ﬂag must be set to zero and the &bbmd sections must be present in
all MDIN ﬁles. The MDIN ﬁle for the replica of rank zero (ﬁrst line in the group ﬁle) is expected to contain additional
information as compared to &abmd case (an example of such MDIN ﬁle for replica zero is shown in Fig. 23.14). The
MDIN ﬁles for all other replicas except zero do not need any additional information, and therefore take the same
form as in the &abmd ﬂavor (except that the namelist is changed from &abmd to &bbmd, thus activating a slightly
different code path). Each MDIN ﬁle may deﬁne its own reaction coordinates, have different mode and temperature
if desired.

Within the ﬁrst replica &bbmd namelist the following additional entries are recognized:

exchange_freq number of MD steps between the exchange attempts.

exchange_log_file the name of the ﬁle to which exchange statistics is to be reported.

492

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

exchange_log_freq frequency of exchange_log_file updates.

mt19937_seed seed for the random generator (Mersenne twister [553]).

mt19937_file the name of the ﬁle to which the state of the Mersenne twister is dumped periodically (for restarts).

The MDOUT, MDCRD, RESTRT, umbrella_file and monitor_file ﬁles are MDIN-bound in course of the bbmd-
enabled run. An example that uses this kind of replica exchange is presented in Ref.526.

23.4.6. Swarms-of-Trajectories String Method

ABMD is a robust method for calculating free energy landscapes as a function of a small number of collective
variables. Since the required computer time grows enormously with the number of collective variables, ABMD is
best for exploring one- or two-dimensional phase spaces. However, rather than calculating full n-dimensional free
energy maps, it is often fruitful to focus on the so-called Minimum Free Energy Path (MFEP) which the system is
likely to take when transitioning between two minima. Calculating a MFEP in a complicated phase space is often
difﬁcult, and so-called ”string methods"[554][544] represent one of the best approaches for ﬁnding the MFEP.
Since sampling in string methods is essentially limited to regions around the MFEP, the cost of the method scales
linearly with the length of the string or path, but only weakly on the number of collective variables. This results in
considerable computational savings since the full free energy landscape is not calculated.

The swarms-of-trajectories string method (STSM)[544] is one of the most popular versions of the string method
and has been implemented here by Dr. Moradi (moradi@uark.edu). The module is available in both SANDER
and PMEMD from Amber18 onwards. It is a path-ﬁnding algorithm that reﬁnes a putative transition pathway
iteratively until the path is deemed to have been converged. The string is deﬁned by a number of nodes or images
parameterized in a high-dimensional space of collective variables, whose position is updated iteratively. The
center of each image is ﬁrst used as a restraining center to generate representative conformations at the current
center before allowing of a small change in this center for the next iteration. The change in the center of each
image is estimated by averaging over the drifts of a swarm of short unbiased trajectories all starting at the current
image position (generated using the constrained simulations. Thus, each iteration consists of a series of restrained
and free simulations. In the current serial version of the code, these simulations are performed independently. In
parallel versions -- which are more efﬁcient -- a very large number of replicas is required which are run in parallel;
this method is particularly efﬁcient on large supercomputers.
To invoke the swarms-of-trajectories string method, the &stsm must be invoked in the MDIN ﬁle. For a string
consisting of Ns nodes each requiring M copies Ns × M replicas will be required. The parallel implemention of
the STSM method is based on iterative restrained and free MD simulations followed by a reparametrization of the
image centers deﬁned in a multidimensional collective variable space ξ . For the ith iteration, ﬁrst M copies of the
nth image are generated around the old center ξ i−1
by MD equilibration lasting τE timesteps. The generated M
copies of the nth image are expected to be close to ξ i−1
for time τE, assuming that the invoked harmonic constant k
n
for the restraining potential is large enough. The parameters τE and k thus need to be appropriately chosen in order
to ensure that all copies of each image will be close to the image center. The restraint is then released, and each
n for the nth image is then determined
copy (swarm) is allowed to drift for τR timesteps. The newly shifted center ξ i
by averaging over all drifted copies ξ t
n,m at time t = τE +τR. The resulting string of images is then smoothed using
a linear interpolation protocol. A smoothing parameter ε with 0 ≤ ε ≤ 1 determines the smoothness of the curve;
it is recommended that ε be of the order of 1/(Ns − 1). The last setep is a reparameterization, which gain follows
a linear interpolation protocol in order to generate Ns equidistant centers along the string. The two key parameters
of the method are M and τR. Generally, the large the M and the shorter τR, the smoother (but slower) the evolution
of the MFEP will be. These variables must be optimized empirically, but typically 10 - 30 copies and 5 - 20 ps are
reasonable values. It is often advantageous to set τE = τR.

An improved sequential repeat version of the algorithm has also been implemented, which avoids the large
number of copies and does not require a large number of processors to run. Here a new variable NR is introduced,
as the number of repeat runs for each replica. Now for each copy, it will run around the old center ξ i−1
for NR times
sequentially. And each repeat run can be equally considered as a parallel run of a new copy around the old center.
Namely, the new shifted center will be determined by averaging on NR × M copies. So the number of processors
needed will be reduced to 1/NR, while the running time will be multipled by NR.

n

n

493

23. Free energies

The following is recognized within the &stsm namelist:

image

positive integer number that sets the image id (between 1 and N). Default is 0.

repeats

positive integer number that sets the number of repeat runs, should be the same for each image and
each copy. Equal to parallel implementation when not set. Default is 1.

equilibration non-negative integer number that sets the number of MD steps speciﬁed for biased equlibration

(restraining) at each iteration. Default is 0.

release

Number of MD steps speciﬁed for the release (drift) at each iteration. Note: the total number of
iterations is determined by the total simulation time (nstlim ﬂag in mdin ﬁle) divided by total time
for each iteration given by equilibration+release.

smoothing positive number that sets the smoothing parameter for reparametrization (between 0 and 1). Smooth-
ing parameter should be, preferably, on the order of 1/(Ns−1). If this ﬂag is not used, no smoothing
will be performed.

report_centers a string that determines if drifted and/or smoothed and/or reparametrized centers will be
reported. The default value is NONE and other available options include ALL,DRIFT,SMOOTHED,
REPARAMETRIZED, NO_DRIFT, NO_SMOOTHED, NO_REPARAMETRIZED.

The output_file, output_freq and cv_file entries are recognized just as &smd and &pmd, the information of
reaction coordinates will be read from cv_file. The number of collective variables can not exceed ﬁve. (here
be attention that the anchor_postion and anchor_strength will be deﬁned using the traditional harmonical
potential, different with &pmd!). An example of MDIN ﬁle and CV.IN ﬁle for STSM in parallel case is shown in Fig.
23.15. Here we run 8 images along the path, with I deﬁning the image ID. We run 980 MD steps for equlibration
and 20 MD steps release at each iteration, so there are totally 1000 MD steps for each iteration. With nstlim set to
10000, 10 iterations will be carried out. The smoothing parameter is set to 0.1 and all the centers will be reported.
For each image, 16 copies will be run in parallel, with J deﬁning the copy ID. The evolution of reaction coordinate
will recorded in the ﬁle stsm.00I.J.txt. For this run, at least 128(8 × 16) processors are needed. Another
example of MDIN ﬁle of equivalent sampling level in sequential case is shown in Fig. 23.16. Here we still have 8
images to run. We set the number of repeats to be 16, namely 16 repeat runs for each image to get the new drifted
center. Therefore, 16000 MD steps are needed for one iteration, and so we set nstlim to 160000 to complete 10
iterations. For this run, 8 processors are needed at least.

Part of sample MDOUT ﬁle is shown in Fig. 23.17. The restoring restraint part will be only in sequential run, since
the restraint needs to be restored after each repeat. The values of reaction coordinates before reporting centers are
the averaged value over repeats for this copy and the instantaneous value. All the centers will be reported only
in the MDOUT ﬁle of ﬁrst copy of ﬁrst image. The drifted centers are the averaged value over copies, and also the
smoothed ans reparametrized centers can be reported. Always the reparametrized centers will be extracted to draw
the MFEP in the phase space.

23.4.7. Implementation in PMEMD

From Amber16 and onwards, the above features have been implemented in PMEMD. Thus, users can now
apply GPUs to substantially improve the speed of free energy sampling calculations with pmemd.cuda and
pmem.cuda.MPI. This is very important for studying systems in explicit solvent. With pmemd and pmemd.MPI the
option to use CPUs is also kept, and the whole method has been tested successfully in both implicit and explicit
enviroments. If you have questions with regards to the PMEMD implementation of ABMD and related algorithms,
please contact Dr. Feng Pan <fpan3@ncsu.edu> and Dr. M. Moradi <moradi@uark.edu>.

Several changes have been made compared with the previous version before Amber16 in order to make the

modules easier and more friendly to use, and some functionality has been modiﬁed. Here are all the changes:

• Naming was changed, all the input format is changed to namelist style. The reaction coordinate (collective

variable) information is read from a separate ﬁle so it can be reusable by different runs.

494

23.4. Adaptively Biased MD, Steered MD, Umbrella Sampling with REMD and String Method

• A new variable infe is added within the namelist &cntrl, to control the usage of the NFE method in a friendly

way. To disable the NFE method, set infe to 0; to enable it, set infe to 1.

• The restraint potential contributions from different modules are shown in MDOUT ﬁle. And Amber replica-

exchange methods with -rem set to different values are compatible. (through update.8 of Amber18)

• Two new entries have been added to the blocks &abmd and &bbmd to give snapshots of the biasing potential

during the simulation:

snapshots_basename = STRING : sets the snapshots ﬁle name.
snapshots_freq = INTEGER : sets the snapshot frequency. (in MD steps)

• Two new algorithms have been added to both SANDER and PMEMD: (1) a selection algorithm for multiple-

walker ABMD; (2) the well-tempered ABMD (WT-ABMD).

• The swarms-of-trajectories string method (STSM) has been added to SANDER and PMEMD (GPU com-

patible).

• Several new reaction coordinates are added, which include

– type = SIN_OF_DIHEDRAL
– type = PAIR_DIHEDRAL
– type = PATTERN_DIHEDRAL
– type = DF_COM_DISTANCE

• For customizing your own reaction coordinate (collective variable), please check the online tutorial

http://ambermd.org/tutorials/advanced/tutorial31/index.html.

23.4.8. Post-processing of biasing potential

When you get the biasing potential (*.nc ﬁle), you can always use the nfe-umbrella-slice utility to ac-
cess its content and get a friendly-written ASCII ﬁle from which one can obtain the free energy map. The out-
put is the free energy value, which is the opposite of the biasing potential ( f = −U (units kcal/mol)). The
nfe-umbrella-slice utility has been included in AmberTools.

Usage: nfe-umbrella-slice [options] bias_potential.nc

Options:

-h,--help Print out a usage summary

-p,--pretend Only print out the basic properties of source without biasing potential data (off by default)

-g,--gradient Print out the gradients (off by default)

-r,--reset Set the value of minimum to zero (off by default)

-t,--translate Translate the numerical value of biasing potential by a real number (0 by default)

-d,--dimensions Set the way of slice in different dimensions. The format is “D1:D2:...:Dn”, where n is the
number of dimensions. Each D can only be set with one number or three numbers separated by commas. If
only one number is set, the variable will be ﬁxed at that value. If three numbers are set, the ﬁrst two deﬁne
the boundary of the slice and the last one deﬁnes the number of points.

Example:

495

23. Free energies

• nfe-umbrella-slice -r -d “-5.0,5.0,50” 1d-bias.nc > FE.dat

This processes the 1-dimensional biasing potential ﬁle 1d-bias.nc and prints out the results to FE.dat. The
minimum of free energy will be set to zero. The variable will be taken from -5.0 to 5.0 using 50 points.

• nfe-umbrella-slice -g -t 50.0 -d “1.0:-2.0,2.0,20” 2d-bias.nc > FE.dat

This processes the 2-dimensional biasing potential ﬁle 2d-bias.nc and prints out the results to FE.dat. All the
free energy will be incremented by a constant 50.0. The gradients in both dimensions will be printed out. For the
ﬁrst dimension, the variable will be ﬁxed at 1.0; for the second dimension, the variable will be taken from -2.0 to
2.0 using 20 points.

• nfe-umbrella-slice wt_umbrella.nc > wt_FE.dat

This processes the biasing potential after WT-ABMD and prints out the results to wt_FE.dat. The default dimen-
sional information is obtained and used by the program from the biasing potential ﬁle.

23.5. Steered Molecular Dynamics (SMD) and the Jarzynski Relationship

23.5.1. Background

SMD applies an external force onto a physical system, and drives a change in coordinates within a certain time.
Several applications have come from Klaus Schulten’s group.[555] An implementation where the coordinate in
question changes in time at constant velocity is coded in this version of Amber. The present implementation
has been done by the group of Prof. Dario Estrin in Buenos Aires <dario@q1.fcen.uba.ar> by Marcelo Marti
<marcelomarti@yahoo.com> and Alejandro Crespo <alec@qi.fcen.uba.ar>, and in the group of Prof. Adrian
Roitberg at the University of Florida <roitberg@uﬂ.edu>.[556]

The method should be thought of as an umbrella sampling where the center of the restraint is time-dependent as

in:

Vrest (t) = (1/2)k[x− x0(t)]2

where x could be a distance, an angle, or a torsion between atoms or groups of atoms.

This methodology can be used then to drive a physical process such as ion diffusion, conformational changes and
many other applications. By integrating the force over time (or distance), a generalized work can be computed.
This work can be used to compute free energy differences using the so-called Jarzynski relationship.[557–559]
This method states that the free energy difference between two states A and B (differing in their values of the
generalized coordinate x) can be calculated as

exp (−∆G/kBT ) = (cid:104)exp (−W /kBT )(cid:105)A

(23.20)

This means that by computing the work between the two states in question, and averaging over the initial state,
equilibrium free energies can be extracted from non-equilibrium calculations. In order to make use of this feature,
SMD calculations should be done, with different starting coordinates taken from equilibrium simulations. This can
be done by running sander multiple times, or by running multisander (Section 19.11). There are examples of the
various modes of action under the test/jar directories in the Amber distribution.

23.5.2. Implementation and usage

To set up a SMD run, set the jar variable in the &cntrl namelist to 1. The change in coordinates is performed

from a starting to an end value in nstlim steps.

To specify the type and conditions of the restraint an additional ".RST" ﬁle is used as in nmropt=1. (Note that

jar=1 internally sets nmropt=1.) The restraint ﬁle is similar to that of NMR restraints (see Section 27.1), but
fewer parameters are required. For instance, the following RST ﬁle could be used:

496





23.5. Steered Molecular Dynamics (SMD) and the Jarzynski Relationship

# Change distance between atoms 485 and 134 from 15 A to 20 A
&rst iat=485,134, r2=15., rk2 = 5000., r2a=20. /

Note that only r2,r2a and rk2 are required; rk3 and r3 are set equal to these so that the harmonic restraint is always
symmetric, and r1 and r4 are internally set so that the restrain is always operative. An SMD run changing an angle,
would use three iat entries, and one changing a torsion needs four. As in the case of NMR restraints, group inputs
can also be used, using iat<0 and deﬁning the corresponding groups using the igr ﬂag.

The output ﬁle differs substantially from that used in the case of nmr restraints. It contains 4 columns: x0(t), x,
force, work. Here work is computed as the integrated force over distances (or angle, or torsion). These ﬁles can be
used for later processing in order to obtain the free energy along the selected reaction coordinate using Jarzynski’s
equality.

Example
The following example changes the distance between two atoms along 1000 steps:



Sample pulling input
&cntrl
nstlim=1000, cut=99.0, igb=1, saltcon=0.1,
ntpr=100, ntwr=100000, ntt=3, gamma_ln=5.0,
ntx=5, irest=1, ig = 256251,
ntc=2, ntf=2, tol=0.000001,
dt=0.002, ntb=0, tempi=300., temp0=300.,
jar=1,
/
&wt type='DUMPFREQ', istep1=1, /
&wt type='END', /
DISANG=dist.RST
DUMPAVE=dist_vs_t
LISTIN=POUT
LISTOUT=POUT



Note that the ﬂag jar is set to 1, and redirections to the dist.RST ﬁle are given. In this example the values in the

output ﬁle dist_vs_t are written every istep=1 steps.

The restraint ﬁle dist.RST in this example is:

# Change distance between atoms 485 and 134 from 15 A to 20.0 A
&rst iat=485,134, r2=15., rk2 = 5000., r2a=20.0, /

and the output dist_vs_t ﬁle might contain:

15.00000 15.12396 -1239.55482 0.00000
15.00500 14.75768 2470.68119 3.07782
15.01000 15.13490 -1246.46571 6.13835
15.01500 15.15041 -1350.03026 -0.35289
15.02000 14.77085 2481.56731 2.47596
15.02500 15.12423 -987.34073 6.21152
15.03000 15.18296 -1520.41603 -0.05787
15.03500 14.79016 2431.22399 2.21915
.......
19.97000 19.89329 4.60255 67.01305
19.97500 19.87926 4.78696 67.03652
19.98000 19.86629 4.54839 67.05986
19.98500 19.85980 3.75589 67.08062
19.99000 19.86077 2.58457 67.09647
19.99500 19.86732 1.27678 67.10612

In this example, the work of pulling from 15.0 to 20.0 (over 2 ps) was 67.1 kcal/mol. One would need to repeat
this calculation many times, starting from different snapshots from an equilibrium trajectory constrained at the

497

23. Free energies

initial distance value. This could be done with a long MD or a REMD simulation, and postprocessing with ptraj
to extract snapshots. Once the work is computed, it should be averaged using Eq. 23.20 to get the ﬁnal estimate of
the free energy difference. The number of simulations, the strenght of the constraint, and the rate of change are all
important factors. The user should read the appropriate literature before using this method. It is recommended that
the width of the work distribution do not exceed 5-10% for faster convergence. In many cases, umbrella sampling
may be a better way to estimate the free energy of a conformational change.

23.6. Absolute Free Energies using EMIL

As well as comparing two similar systems to ﬁnd a free energy difference, thermodynamic integration techniques
can be used to ﬁnd the absolute free energy, integrating between an all-atom AMBER model and a simpliﬁed model
for which the free energy can be directly written down. To ﬁnd a chemical equilibrium, pairs or sets of absolute
free energies must of course be compared to ﬁnd free energy differences, but taking this “long way around” can
be better if the direct integration path between the systems would involve a sharp energetic barrier or a large
conformational change. The basic equation of EMIL is thus:

(cid:90) 1

0

(cid:28)∂ H

(cid:29)

∂λ

|λ

A = Are f −

dλ

where A is the total free energy of a system, Are f is the (analytically calculated) free energy of the associated
EMIL Hamiltonian and H is the mixed Hamiltonian, which has the value of the normal AMBER Hamiltonian at
λ = 0 and the EMIL Hamiltonian at λ = 1.

The method was introduced in the literature with demonstrations for example systems with short-range interac-
tions [560, 561], and an example AMBER calculation for the B-Z conformational equilibrium of DNA also exists
[562]. Some further discussion of accuracy and convergence of EMIL calculations using AMBER has also been
made [563]. To call EMIL, set “emil_do_calc” = 1 in the main input ﬁle, and also prepare an EMIL-speciﬁc input
ﬁle (by default called “emilParameters.in”).

It is advised to use a Langevin thermostat (ntt=3) (section 19.6.7) with a fairly high value of gamma_ln, (e.g. 1.0)
because dynamics under the EMIL Hamiltonian can have little coupling between particles, therefore an external
source of randomness is desirable in order to drive sampling. Use of generalized-Langevin thermostats (section
22.1) is consistent with EMIL, however no study has been made to ascertain the beneﬁts of this approach. Use of
SHAKE with EMIL can give unphysical results, so it is advised to turn this off (ntc = 1, ntf = 1, dt = 0.001).

The letters “EM” in EMIL refer to “Einstein Molecule”, the name given in the literature [564, 565] to this
type of calculation. The use of EMIL is an alternative to other AMBER methods of ﬁnding the absolute free
energy of molecules in implicit solvent, such as by combining a normal modes analysis (see section 32.12.11) and
MM(PB/GB)SA (see Chapter 34). EMIL is quite likely to be more computationally expensive than this type of
post-hoc estimate of the free energy carried out after a normal MD simulation, but is also in some ways simpler
and is likely to be more accurate in the limit of a large amount of computation being available.
Periodic boundaries can be applied, although EMIL does not support non-rectilinear boxes.
When carrying out an EMIL integration, the AMBER part of the Hamiltonian is gradually turned off with
increasing lambda. To help achieve this without artifacts, the emil_sc option is available (pmemd only) which
allows mutual softcoring of all interatomic forces (see section 23.1 , eqn 23.5). For EMIL softcoring there is no
need to specify a softcoring mask or modiﬁed topology ﬁle, as all atoms are included in the process, however
icfe = 1 and ifsc = 1 must be set if emil_sc = 1. The value of clambda must also be set, to whatever lambda is
also speciﬁed in the emil_paramﬁle. When using emil_sc with the default value of klambda (=1) (eqn 23.4), there
may be sharp changes in the generalized force near to lambda=clambda=1. In this case it is advised to have an
integration point at lambda=clambda=0.99 or a similar value so that the endpoint behaviour is not over-weighted
in the total calculation.

When emil_sc=0 (the default), a less sophisticated approach to the problem of discontinuities in the Lennard-
Jones and Coulomb potentials is taken: a short-range repulsion is automatically added to the Hamiltonian for
the intermediate stages of the integration 0<lambda<1 in order to prevent atoms from approaching within the
problematic regions of the scaled LJ and Coulomb interactions. This method is not always entirely effective,
especially in explicit solvent calculations, and may require a cut in the timestep for some values of lambda.

498

23.6. Absolute Free Energies using EMIL

EMIL is compatible with multisander and multipmemd (section 19.11), however the only beneﬁt currently is to
collect together runs at multiple values of lambda for submission as a single job: H-REMD methods (sec 23.3.5)
and other advanced uses of multisander and multipmemd have not yet been implemented.

Based on benchmarking studies it is now recommended for explicit water calculations to use pmemd with ifsc=1.
Optimal parameters were found in this case to be: epsilonWell 1., epsilonTrap 0.5, rWell 0.5, rTrap 5.0 in emilPa-
rameters.in, and scalpha=0.3, scbeta=16.0 in the mdin. Optimal parameters may be different for other systems, so
if you are planning a large calculation you should ﬁrst carry out short runs (1ps) with different parameter values
comparing the variance and apparent smoothness of the generalised force measurements for a small change up and
down of each free parameter. The EMIL calculations in the test set can be used as a starting point when setting up
a new calculation, although real runs will be much longer and require many more lambda points.

23.6.1. EMIL Namelist Input

An EMIL-speciﬁc namelist of input and output ﬁlenames for EMIL should be provided in the main input ﬁle,

of the form:

&emil_cntrl
emil_paramfile = "emilParameters.in",
emil_logfile
emil_model_infile = "wellsIn.dat",
emil_model_outfile = "wellsOut.dat",
/

= "emil.log",

The variables emil_paramﬁle and emil_logﬁle are paths to ﬁles for control data and logging speciﬁc to the EMIL
calculation. The variable emil_model_inﬁle gives the path to an initial speciﬁcation for an analytically tractable
model and emil_model_outﬁle points to a saved model state. If these variables are not set then an initial model will
be automatically generated, and no output model will be saved.

23.6.2. EMIL parameter input

The “emilParameters.in” ﬁle contains setup info speciﬁc to the EMIL calculation. The ﬁle is formatted as a list of
key-value pairs, one per line. Blank lines or those beginning with a “#” are ignored. The keys are case-insensitive.
Providing that you are running at 300K with a fairly standard forceﬁeld, only the seed, lambda, liquidRes and
solidRes values should need to be changed.

The input keys which can be used are:

seed integer seed for EMIL’s random number generator

lambda real mixing parameter for the alchemical transformation. Must be equal to sclambda if emil_sc=1.

epsilonWell real Depth of harmonic restraints. This is in units of kBT , so that the wells are automatically deeper if
the temperature increases. The value of β = 1/kBT at the start of the simulation is printed in the emil_logﬁle.
Harmonic restraints are assigned to atoms of residues in the solidRes list and have a potential of the form

V (r) = ε(r2/r2

well − 1).

rWell real The radius of a harmonic restraint, such that the potential is zero.

epsilonTrap real Depth of ’trap’ restraints (in units of kBT ). Trap restraints are assigned to atoms of residues
in the liquidRes lists (if any) and have a potential which is harmonic on 0 ≤ r ≤ reqTrap and then has a
constant force on reqTrap < r < rTrap. Beyond rTrap the force exerted by a trap well is zero.

reqTrap real The radius of the harmonic region of a trap well. Trap wells need to have (at least) a small harmonic

region in order to increase the stability of the dynamics near to the bottom of the well.

499

23. Free energies

rTrap real The total radius of a trap well.

wingForce real The force in the constant-force region of a trap well (in units of kBT / ˚A).

solidRes string The list of residues for which each atom is permanently assigned to a speciﬁc harmonic well.

liquidRes string A list of residues which are part of a ﬂuid of chemically identical molecules, for which the
chain-well assignment can be adjusted at each timestep by Monte Carlo sampling. Multiple liquids can be
deﬁned, in the case that different sets of indistinguishable chains are present in liquid or dissolved phases.
Chains whose residues are in these lists are assigned to trap wells, but chains can exchange wells with their
neighbours based on a Metropolis acceptance criterion. In each liquid chain only one atom (the heaviest
atom is chosen automatically, so this would be the the oxygen of a TIP3P water) interacts directly with the
trap well; the remainder of the atoms in the chain have a harmonic well generated for them which holds them
in an approximately constant relative position to the ’root’ atom of the chain.

swapTriesPerChain ﬂoat Monte Carlo attempt rate for moves that exchange the trap wells between particles in
the liquidRes lists. The use of swap moves can greatly accelerate convergence, but can also create problems
if the acceptance rate (printed in the emil_logﬁle) is zero or close to zero for any value of lambda.

relocTriesPerChain ﬂoat Monte Carlo attempt rate for moves that move particles in the liquidRes lists (typically
solvent or salt molecules) into or out of their wells. Even if this value is nonzero, relocation moves are only
applied if the AMBER Hamiltonian is fully mixed out.

saveWellsEvery integer Period with which to write the well positions.

printEvery integer Period with which to log the generalized force. The average over the previous non-printed

timesteps is output.



Here is an example input ﬁle for a fairly standard EMIL run using pmemd and emil_sc:

##EMIL input configuration: this is a comment.

##emil has its own RNG
seed

2325

##set the Mixing parameter:
## you will need several values on the interval [0,1].
lambda

0.0

##Residue names associated with wells.
##This is the list of residues needed for duplex DNA
##you will have to extend/change it for your own system
solidRes
liquidRes WAT
liquidRes NA
liquidRes CL

DC,DG,DA,DT,DA5,DT5,DA3,DT3,DG5,DG3,DC5,DC3

swapTriesPerChain 0.1

##timesteps between writing well positions
saveWellsEvery 100000

##timesteps between output of generalized force
printEvery

1000



500





23.6. Absolute Free Energies using EMIL

23.6.3. EMIL generalized-force output

EMIL writes its output to the emil_logﬁle. This logﬁle contains some header information, and data to monitor

the progress of the run, but the important lines are of the following format:

nstep: 25 soft_dHdL: 2.06419354e+04 molec_dHdL:...

...6.13140526e+04 abstr_dHdL:

-5.34856062e+02

The step number, nstep, indicates the timestep at which the printout was made. The soft_dHdL is the generalized
force due to the weak and short-range repulsive term which is present in the mixed Hamiltonian for values of
0 < λ < 1, but only if emil_sc=0. The molec_dHdL is the generalized force due to the AMBER Hamiltonian,
and the abstr_dHdL is the generalized force due to the EMIL Hamiltonian. The gradient of the total Hamiltonian
with respect to lambda is just the sum of these three terms. In order to make the most efﬁcient use of information,
EMIL accumulates a mean value of each generalized force term between printouts, so the value written is not an
instantaneous “snapshot” but the average over a time window printEvery steps in length.

Although the EMIL Hamiltonian is speciﬁed in units of kBT , the generalized force is output in units kcal/mol,

so the strength of the restraints (and the size of the generalized force) will increase with temperature.

23.6.4. EMIL tractable model deﬁnition

The model deﬁned by EMIL is currently very simple. Each atom of any residues in the list solidRes from
“emilParameters.in” is restrained to a ﬁxed position using a harmonic well of depth epsilonSolid, with the zero
of the potential at distance rWellSolid. The position of the harmonic well minimum is ﬁxed at whatever the atom
position at the start of the run might be, unless the option readStartWellFileName is provided, in which case the
positions are read in from the ﬁle.

Atoms deﬁned by the liquidRes lists have wells with a ﬁnite range, and in order to have faster convergence for
simulations including explicit solvent (where the particle-well distance can otheriwise be very large at small λ ) the
particle-well assignment is shufﬂed at each timestep by Monte Carlo sampling. The MC method is not currently
implemented in parallel, which can create limitations for EMIL calculations using large numbers of cores per value
of λ : the optimal parallelisation strategy in this case is to make many runs on few cores each, at different values of
λ .

Derivations and formulae for the free energy associated with each well type are available in the supplementary

data of [562], however the calculated totals are also printed out at the start of the emil_logﬁle.

Use of thermostat synchronisation to reduce errorbars

A feature of the Langevin thermostat which can cause serious problems in other circumstances (discussed in
[409]) is that simulations run with the same seed will come to resemble each other, even if the Hamiltonians and
initial conﬁgurations are somewhat different. A surprising beneﬁt of this is that, if EMIL is used to compare two
or more dissimilar systems then the variance of the difference in the generalized forces at a given value of λ can
be less than the sum of the variances of the individual measurements:

(cid:20)∂ H (x1,λ )

∂λ

VAR

(cid:21)

(cid:20)∂ H (x1,λ )

(cid:21)

∂λ

(cid:20)∂ H (x2,λ )

(cid:21)

∂λ

+VAR

− ∂ H (x2,λ )

∂λ

< VAR

(23.21)

which is to say that, although the means of the two generalized forces are estimated correctly, the covariance of
the two generalized forces is greater than zero. Using this phenomenon it is possible to estimate the difference in
free energies between two (or N) systems more cheaply than the free energies themselves [562, 563, 566].

While it is therefore beneﬁcial to use the same seeds for a given value of λ across all systems, it is still necessary
to use a new seed for each restart of the same trajectory, and to use different seeds for different values of λ . To
maintain thermostat synchronization, the number of atoms in the different systems must be the same. This can
be achieved if necessary by the addition of non-interacting dummy atoms to the smaller topology ﬁles using the
parmed (sec. 14.2) utility.

501

23. Free energies

Brief instructions for an EMIL calculation

To run an EMIL calculation, ﬁrst equilibrate a single simulation of the system in question then follow the steps

below:

1. If you started off at constant pressure, ﬁnd the average box-size and scale the system to this size.

2. Prepare multiple “emilParameters.in” ﬁles (see section 23.6.2) which differ from each other only in the

parameters seed and lambda. The values of lambda should be spread over the interval 0 ≤ λ ≤ 1.

3. Put your “emilParameters.in” ﬁles into one directory each and run pmemd in each of the directories, setting
ntt = 3, ntp = 0, emil_do_calc=1, emil_sc=1. If runs ﬁnish and are restarted, then the saved well positions
written at the end of the old run will need to be loaded into the new one, as well as the normal AMBER
restart ﬁles.

4. It may be necessary to set up restraints of some kind from within pmemd or sander if the free energy to be
calculated is for only a subset of the available conformations of the molecule(s), or to speed up convergence
at low values of λ , by preventing the solute molecule from drifting away from its restraint system (this drift
is a particular problem for small systems, where the cumulative effect of the EMIL solute restraints, even
over all atoms, is still weak at small λ ).

5. Collect the converged time-average values of the generalized forces (or the differences in generalized forces
if you are comparing several systems) at each value of λ . It is often worth looking at the different time series
individually, in order to make the most efﬁcient use of data by only throwing away the minimum number of
equilibration points, and in order to target simulation effort to those values of λ which are taking the longest
to give a small errorbar [562]).

6. Do a numerical integration of each of the three dHdL terms from the EMIL logﬁles with respect to λ then
subtract these totals from the free energy of the EMIL Hamiltonian, which is printed in the headers of the
EMIL logﬁles, to get the free energy of the system under the AMBER Hamiltonian. As well as taking time-
averages of the (delta) generalized forces and then integrating these values, it may also be valuable to collect
a time-series of the (delta) free energy values and examine this total for convergence.

A longer tutorial on the use of EMIL is available on the AMBER website, also the examples in the test suite might
provide some help to get started.

502



&colvar

23.6. Absolute Free Energies using EMIL



cv_type = 'QUATERNION0'
cv_ni = 18,
cv_i = 11 , 41 , 48 , 74 , 104 , 111 , 137 , 167 , 174 , 199 , 229 , 236, 262 ,

292 , 299 , 325 , 355 , 362 ,

refcrd_file = 'inpcrd'

/
&colvar

cv_type = 'QUATERNION1'
cv_ni = 18,
cv_i = 11 , 41 , 48 , 74 , 104 , 111 , 137 , 167 , 174 , 199 , 229 , 236, 262 ,

292 , 299 , 325 , 355 , 362 ,

refcrd_file = 'inpcrd'

/
&colvar

cv_type = 'QUATERNION2'
cv_ni = 18,
cv_i = 11 , 41 , 48 , 74 , 104 , 111 , 137 , 167 , 174 , 199 , 229 , 236, 262 ,

292 , 299 , 325 , 355 , 362 ,

refcrd_file = 'inpcrd'

/
&colvar

cv_type = 'QUATERNION3'
cv_ni = 18,
cv_i = 11 , 41 , 48 , 74 , 104 , 111 , 137 , 167 , 174 , 199 , 229 , 236, 262 ,

292 , 299 , 325 , 355 , 362 ,

refcrd_file = 'inpcrd'

/
&colvar

cv_type = 'QUATERNION0'
cv_ni = 24,
cv_i = 12 , 16 , 46 , 55 , 75 , 79 , 109 , 118 , 138 , 142 , 172 , 181 , 200 ,

204 , 234 , 243 , 263 , 267 , 297 , 306 , 326 , 330 , 360 , 369 ,

refcrd_file = 'inpcrd',
q_index = 2

/
&colvar

cv_type = 'QUATERNION1'
cv_ni = 24,
cv_i = 12 , 16 , 46 , 55 , 75 , 79 , 109 , 118 , 138 , 142 , 172 , 181 , 200 ,

204 , 234 , 243 , 263 , 267 , 297 , 306 , 326 , 330 , 360 , 369 ,

refcrd_file = 'inpcrd',
q_index = 2

/
&colvar

cv_type = 'QUATERNION2'
cv_ni = 24,
cv_i = 12 , 16 , 46 , 55 , 75 , 79 , 109 , 118 , 138 , 142 , 172 , 181 , 200 ,

204 , 234 , 243 , 263 , 267 , 297 , 306 , 326 , 330 , 360 , 369 ,

refcrd_file = 'inpcrd',
q_index = 2

/
&colvar

cv_type = 'QUATERNION3'
cv_ni = 24,
cv_i = 12 , 16 , 46 , 55 , 75 , 79 , 109 , 118 , 138 , 142 , 172 , 181 , 200 ,

204 , 234 , 243 , 263 , 267 , 297 , 306 , 326 , 330 , 360 , 369 ,

refcrd_file = 'inpcrd',
q_index = 2

/

Figure 23.8.: An example of Orientation variable.



503

23. Free energies



&colvar

cv_type = 'SPINANGLE'
cv_ni = 18, cv_nr = 54,
cv_i = 11 , 41 , 48 , 74 , 104 , 111 , 137 , 167 , 174 , 199 , 229 ,

236, 262 , 292 , 299 , 325 , 355 , 362 ,

cv_r = 0.96 , -4.47 , -0.31 , 3.48 , -3.00 , 3.06 , 0.88 , 0.01 ,

3.36 ,4.55 , -0.51 , 6.46 , 3.93 , 2.38 , 9.81 , 0.26 ,
0.84 , 10.12 , 1.90 , 4.16 , 13.21 , -1.06 , 4.47 , 16.58 ,

-0.71 , 0.52 , 16.88 , -0.96 , -4.47 , 17.21 , -3.48 ,
-3.00 , 13.84 , -0.88 , 0.01 , 13.54 , -4.55 , -0.51 , 10.44 ,
-3.93 , 2.38 , 7.09 , -0.26 , 0.84, 6.78 , -1.90 , 4.16 ,

3.69 , 1.06 , 4.47 , 0.32 , 0.71 , 0.52 , 0.02 ,

axis = 1.0, 0.0, 0.0

Figure 23.9.: An example of SPINANGLE variable.

/



title line
&cntrl
..., infe = 1
/

&smd

output_file = 'smd.txt'
output_freq = 50
cv_file = 'cv.in'

/


cv_file
&colvar

cv_type = 'DISTANCE'
cv_ni = 2
cv_i = 5, 9
npath = 2, path = 5.0, 3.0, path_mode = 'LINES',
nharm = 1, harm = 10.0

/

Figure 23.10.: An example MDIN ﬁle and CV.IN ﬁle for steered MD. Only the relevant part is shown.

504












23.6. Absolute Free Energies using EMIL



title line
&cntrl
..., infe = 1
/

&pmd

output_file = 'pmd.txt'
output_freq = 50
cv_file = 'cv.in'

/


cv_file
&colvar ! first

cv_type = 'ANGLE'
cv_ni = 3, cv_i = 5, 9, 15
anchor_position = -10.0,1.0,1.0,10.0
anchor_strength = 10.0,10.0

/
&colvar ! second

cv_type = 'TORSION'
cv_ni = 4, cv_i = 1, 2, 3, 4
anchor_position = -10.0,0.0,0.0,10.0
anchor_strength = 23.8,23.8

/

Figure 23.11.: An example MDIN ﬁle and CV.IN ﬁle for umbrella sampling (only relevant part is presented in full).



cv_file
&colvar ! phi

cv_type = 'TORSION'
cv_ni = 4, cv_i = 5, 7, 9, 15
anchor_position = -2.05,-2.0,2.0,2.05
anchor_strength = 500.0,500.0

/
&colvar ! psi

cv_type = 'TORSION'
cv_ni = 4, cv_i = 7, 9, 15, 17
anchor_position = -1.85,-1.8,1.8,1.85
anchor_strength = 500.0,500.0

/

Figure 23.12.: An example CV.IN ﬁle to restrain the φ and ψ of dialanine.

505












23. Free energies



title line
&cntrl
..., infe = 1
/

&abmd

mode = 'FLOODING'

monitor_file = 'abmd.txt'
monitor_freq = 33
cv_file = 'cv.in'

umbrella_file = 'umbrella.nc'

timescale = 100.0 ! in ps

selection_freq = 10000
selection_constant = 0.001

wt_temperature = 10000.0
wt_umbrella_file = 'wt_umbrella.nc'

/


cv_file
&colvar

cv_type = 'DISTANCE'
cv_ni = 2, cv_i = 5, 9
cv_min = -1.0, cv_max = 10.0 ! min is not needed for DISTANCE
resolution = 0.5 ! required for mode = FLOODING

/

Figure 23.13.: An example MDIN ﬁle and CV.IN ﬁle for ABMD (only the relevant part is presented in full).

506








23.6. Absolute Free Energies using EMIL










title line
&cntrl
..., infe = 1
/

&bbmd

! 0th replica only

exchange_freq = 100 ! try for exchange every 100 steps

exchange_log_file = 'bbmd.log'
exchange_log_freq = 25

mt19937_seed = 123455 ! random generator seed
mt19937_file = 'mt19937.nc' ! file to store/load the PRG

! not specific for 0th replica

mode = 'ANALYSIS'

monitorfile = 'bbmd.01.txt' ! it is wise to have different

! names in different replicas

monitor_freq = 123
cv_file = 'cv.in'

/


cv_file
&colvar

/

cv_type = 'DISTANCE'
cv_ni = 2, cv_i = 5, 9

Figure 23.14.: An example MDIN ﬁle and CV.IN ﬁle for &bbmd ﬂavor of ABMD (only the relevant part is presented

in full).

507

23. Free energies



title line
&cntrl
..., nstlim = 10000
..., infe = 1
/

&stsm

! parallel case, I from 1 to 8, J from 1 to 16

image = I
equilibration = 980
release = 20
smoothing = 0.1
report_centers = 'ALL'

output_file = 'stsm.00I.J.txt'
output_freq = 10
cv_file = 'cv.I'

/


cv_file
&colvar ! phi

cv_type = 'TORSION'
cv_ni = 4, cv_i = 5, 7, 9, 15
anchor_position = -3.00
anchor_strength = 20.0

/
&colvar ! psi

cv_type = 'TORSION'
cv_ni = 4, cv_i = 7, 9, 15, 17
anchor_position = 3.00
anchor_strength = 20.0

/








Figure 23.15.: An example MDIN ﬁle and CV.IN ﬁle for &stsm in parallel case (only the relevant part is presented

in full)

508

23.6. Absolute Free Energies using EMIL



title line
&cntrl
..., nstlim = 160000
..., infe = 1
/

&stsm

! sequential case, I from 1 to 8

image = I
repeats = 16
equilibration = 980
release = 20
smoothing = 0.1
report_centers = 'ALL'

output_file = 'stsm.00I.txt'
output_freq = 10
cv_file = 'cv.I'

Figure 23.16.: An example MDIN ﬁle for &stsm in sequential case (only the relevant part is presented in full)

/



NFE : #
NFE : #
NFE : #
NFE : #
......
NFE : #
NFE : #
NFE : #
NFE : #
......
NFE : #
NFE : #
NFE : #
......
NFE : #
NFE : #
NFE : #
......
NFE : #



restoring restraint:
<< colvar(1) = -3.000000 >>
<< colvar(2) = 3.000000 >>
equilibration begins...

<< colvar(1) = -2.500688 -2.586429 >>
<< colvar(2) = 2.782725 3.082205 >>

drifted center of image 1 :
drifted center of image 2 :

drifted center of image 8 :
smoothed center of image 1 :
smoothed center of image 2 :

smoothed center of image 8 :
reparametrized center of image 1 :
reparametrized center of image 2 :

reparametrized center of image 8 :

8
8

8

8
8

8

-2.54041796
-2.54963153

2.70644813
2.71715138

1.02191205
-2.54041796
-2.60416697

0.16837852

2.70644813
2.75924174

1.02191205

0.16837852

-2.54041796
-2.06027108

2.70644813
2.47738701

1.02191205

0.16837852

8
8

8

Figure 23.17.: An example of MDOUT ﬁle for STSM run (only part is presented, and some centers are also omitted)

509









24. Constant pH calculations

A constant pH molecular dynamics method was developed by John Mongan for simulations run with the Gener-
alized Born implicit solvent model [567] and Jason Swails for simulations with explicit solvent [568]. Using either
constant pH method requires minor modiﬁcations to the process of generating the prmtop ﬁle and also requires a
second input ﬁle describing the titrating residues.

24.1. Background

Traditionally, molecular dynamics simulations have employed constant protonation states for titratable residues.
This approach has many drawbacks. First, assigning protonation states requires knowledge of pKa values for
the protein’s titratable groups. Second, if any of these pKa values are near the solvent pH there may be no single
protonation state that adequately represents the ensemble of protonation states appropriate at that pH. Finally, since
protonation states are constant, this approach decouples the dynamic dependence of pKa and protonation state on
conformation.

The constant pH method implemented in sander and pmemd addresses these issues through Monte Carlo sam-
pling of the Boltzmann distribution of discrete protonation states concurrent with the molecular dynamics simula-
tion. The protonation state distribution is affected by solvent pH, which is set as an external parameter. Residue
protonation states are changed by changing the partial charges on the atoms of the protonable residue.

24.2. Preparing a system for constant pH simulation

Amber provides deﬁnitions for titrating side chains of ASP, GLU, HIS, LYS, TYR, and CYS. See below if you

need other titrating groups.

Begin by preparing your PDB ﬁle as you normally would for use with LEaP. Edit the PDB ﬁle, replacing all
histidine residue names (HIS, HID, or HIE) with HIP. Change all ASP and ASH to AS4 and all GLU and GLH
to GL4. The others—LYS, TYR, and CYS—have the same name. This ensures that the prmtop ﬁle will have a
hydrogen deﬁned at every possible point of protonation. Note that these changes should only be applied to residues
that you wish to titrate.

Run LEaP with the leaprc.constph command ﬁle. This ﬁle loads all parameters that were used for the reference

compounds. You can load this ﬁle with the following command:

source leaprc.constph

This loads the ff10 force ﬁeld. In addition, it loads the special carboxylate residue libraries and force ﬁeld mod-
iﬁcations—constph.lib and frcmod.constph—that deﬁnes a hydrogen atom at each protonable location (syn- and
anti- for both oxygens) along with improper torsions to prevent them from rotating into each other. It also sets the
GB solvation radii (PBradii) to mbondi2, which was the set used to parameterize the reference compounds. Now
load your edited PDB ﬁle and proceed as usual to create the topology and coordinates ﬁles. Changing any of the
above parameters should be closely checked by titrating the reference compounds and ensuring the predicted pKa
matches.

Once you have the prmtop (topology) ﬁle, you need to generate a cpin ﬁle. The cpin ﬁle describes which

residues should titrate, and deﬁnes the possible protonation states and their relative energies. A python script,
cpinutil.py, is provided to generate this ﬁle. It takes a prmtop ﬁle as input, on the command line along with the
GB model you wish to evaluate protonation transitions in, and writes the cpin ﬁle. Here is an example of
generating the cpin ﬁle from your prmtop ﬁle, ’prmtop’ using the igb=2 GB model:

cpinutil.py -p prmtop -igb 2 -o cpin

510

24.2. Preparing a system for constant pH simulation

The cpinutil.py program accepts a number of ﬂags that modify its behavior. By default, all residues start in
protonation state 0: deprotonated for ASP and GLU, protonated for LYS, TYR, and CYS, and doubly protonated
for HIS (i.e. HIP). Initial protonation states can be speciﬁed using the -states ﬂag followed by a comma and/or
whitespace-delimited list of initial protonation states (see below for more about protonation state deﬁnitions) as
follows:

cpinutil.py -p prmtop -igb 2 -states 1 3 0 0 0 1 -o cpin

Note that if a list of states is provided, it must match exactly the number of residues that cpinutil has found to
titrate based on the restrictions put on the command line. The -system ﬂag can be used to provide a name for the
titrating system. This is purely cosmetic and has no effect on your simulations.

cpinutil.py -p prmtop -igb 2 -system HEWL -o cpin

A number of ﬂags are available for ﬁltering which residues are included in the cpin ﬁle. All residues in the cpin
ﬁle, and only the residues in the cpin ﬁle, will be titrated. In general it is safe to exclude TYR and LYS for acidic
simulations and GL4 and AS4 for basic simulations. HIP should be included in all except very acidic simulations.
Note that there is currently no support for titrating N or C terminal residues. If you have an N or C terminal residue
with a titratable sidechain, you should explicitly exclude it from the cpin ﬁle. The -resnum ﬂag may be used to
specify which residue numbers should be retained; all others are deleted. Conversely, the -notresnum ﬂag can be
used to specify which residue numbers are deleted; all others are retained. Residue number refers to the numbering
in the PDB ﬁle, not the index number among titrating residues. Similarly, -resname and -notresname can be
used to ﬁlter by residue type. For instance, -notresname TYR,LYS would eliminate basic residues from the cpin
ﬁle. The -minpKa and -maxpKa ﬂags can be used to ﬁlter out residues whose reference pKas do not satisfy that
criteria. For example, -minpKa 5.0 will exclude all AS4 and GL4 residues from titrating.

The cpin format has changed in Amber 18, but cpin ﬁles in the older format compatible with Amber 16 and
older versions can still be generated using the --old-format argument. However, simulations with temp0 other
than 300 Kelvins will not work.

You can get a full list of all available titratable residues using the --list argument to cpinutil.py, and you can

get a full description of reference energies and charge vectors for any residue using the --describe argument.
The full usage statement for cpinutil.py (accessible via -h/--help) is shown on the next page.

511

24. Constant pH calculations

usage: cpinutil.py [Options]
optional arguments:

-h, --help
-v, --version
-d, --debug
-oldfmt, --old-format

show this help message and exit
show program’s version number and exit
Enable verbose tracebacks to debug this program

Print output file in a format compatible with AMBER 16
and older versions

Output files:

-o FILE, --output FILE

-op FILE, --output-prmtop FILE

Output file. Defaults to standard output

For explicit solvent simulations, a custom set of
radii are necessary to obtain reasonable results for
carboxylate pKas (e.g., AS4 and GL4 residues). If
specified, this file will be the prmtop compatible
with the reference energies in the printed cpin file.

Required Arguments:

-p FILE

Topology file to be used in constant pH simulation

Simulation Options:

-igb IGB

-intdiel DIEL

Generalized Born model which you intend to use to
evaluate dynamics (or protonation state swaps).
Default is 2.
Internal dielectric constant to use in the evaluation
of the GB potential. Default 1.0.

Residue Selection Options:

-resnames [RES [RES ...]]

Residue names to include in CPIN file

-notresnames [RES [RES ...]]

Residue names to exclude from CPIN file

-resnums [NUM [NUM ...]]

Residue numbers to include in CPIN file

-notresnums [NUM [NUM ...]]

-minpKa pKa
-maxpKa pKa

Residue numbers to exclude from CPIN file
Minimum reference pKa to include in CPIN file
Maximum reference pKa to include in CPIN file

System Information:

-states [NUM [NUM ...]]

-system <system name>

Residue Information:

List of default states to assign to titratable
residues

Name of system to titrate. No effect on simulation.

If any options here are used, no CPIN file will be written. These
arguments take precedence and are mutually exclusive with each other.
--describe [RESNAME [RESNAME ...]]

-l, --list

Print out the details of given residues
List all titratable residues

This program will read a topology file and generate a cpin file for constant
pH simulations with sander or pmemd

512

24.3. Running at constant pH

24.3.1. Running at constant pH in implicit solvent

24.3. Running at constant pH

Running constant pH simulations in either sander or pmemd has few differences from normal operation. In the
mdin ﬁle, you must set icnstph=1 to turn on constant pH in implicit solvent. solvph is used to set the solvent pH
value. You must also specify the period for Monte Carlo steps, ntcnstph (the number of steps between protonation
state change attempts). Note that only one residue is examined on each step, so you should decrease the step period
as the number of titrating residues increases to maintain a constant effective step period for each residue. We have
seen good results with fairly short periods, in the neighborhood of 100 fs effective period for each residue (e.g.
ntcnstph=5, dt=0.002 with about 10 residues titrating).

Constant pH MD techniques employ a reference (model) compound to compute relative free energy differences
between the various protonation states through a thermodynamic cycle (see Figure 24.1). The free energy of the
protonation state change in the model compound that is necessary to yield the correct pKa prediction. This quantity
is pre-computed for each protonation state change. This so-called reference energy is printed to the cpin ﬁle by
cpinutil.py. In order to obtain sensible results, you must run your simulations with the same potential energy
function for your system that was used to derive these reference energies (or alternatively rederive the reference
energies with the potential you wish to use).

The reference energies were derived using the following parameters:

cut=30.0, igb=#, saltcon=0.1, nrespa=1,
temp0=300.0, ntc=2, ntf=2

where # is the value passed to the cpinutil.py program. In particular, care should be taken when modifying the igb,
saltcon, nrespa, or temp0 parameters (nrespa should never be changed). The cutoff, 30 Å, is effectively inﬁnite
for the (very small) model compounds, so using any reasonable cutoff—including an inﬁnite cutoff—is valid. The
ff99SB force ﬁeld was used to parametrize the model compounds. Using other force ﬁelds should be validated
before you run simulations. If the charge scheme is the same as ff99SB (e.g., ff14SB), chances are good that the
reference energies will still be valid. Other force ﬁelds (e.g., ff03 and ff13) that have different charge deﬁnitions
require recalculating the reference energies.

The model compounds have the sequence ACE-X-NME, where ACE is a neutral acetyl capping group, X is the
titratable residue, and NME is a neutral methylamine capping group. Both ACE and NME are provided in the
standard Amber residue libraries.

Additional command line ﬂags have been added to sander and pmemd to support constant pH operation. The
cpin ﬁle must be speciﬁed using the -cpin option. Additionally, a history of the protonation states sampled is
written to the ﬁlename speciﬁed by -cpout. Finally, a constant pH restart ﬁle is written to the ﬁlename speciﬁed
by -cprestrt. This is used to ensure that titrating residues retain the same protonation state when the simulation
is restarted. The constant pH restart ﬁle is a cpin-format ﬁle, and should be used as the cpin ﬁle when restarting the
simulation. It will generally be longer than the original cpin ﬁle, as it contains some amount of zeroed data. The
only difference between the cprestrt ﬁle created at the end of a simulation and the cpin ﬁle used to start it will be
the RESSTATES array. Note that due to compiler-dependence of the namelist implementation, cprestrt ﬁles may
differ from computer to computer.

513

24. Constant pH calculations

Figure 24.1.: Thermodynamic cycle used in CpHMD simulations. The energy difference between the two proto-
nation states computed by sander is equal to the difference ∆G1 − ∆G2 and ∆GMC = ∆G2 − ∆G1 −
∆Gre f erence is used to evaluate the Metropolis Monte Carlo criteria for the proposed change in pro-
tonation state(s).

24.3.2. Running at constant pH in explicit solvent

The hybrid molecular dynamics/Monte Carlo technique used in the implicit solvent calculations will not work in
explicit solvent because all protonation state changes will be opposed by the solvent orientation around the existing
protonation states. To work around this limitation while allowing MD to be propagated in explicit solvent, protona-
tion state changes are still attempted using a Generalized Born implicit solvent model. [568] The workﬂow, shown
in Figure 24.2, involves running MD for ntcnstph steps, stripping the solvent and ions, attempting protonation
state changes for each titratable residue in random order, and restoring the solvent for running solvent relaxation
dynamics for ntrelax steps if any protonation states have changed before resuming MD.

The modiﬁcations needed to run explicit solvent simulations at constant pH are similar to the modiﬁcations

needed to run implicit solvent simulations at constant pH, with some small differences highlighted here. We
found that the existing GB radii deﬁned for carboxylate oxygens is too large for the titratable residues AS4 and
GL4. The reason is that the 4 hydrogen atoms in the carboxylate groups are all assigned an intrinsic solvent radius
that contributes signiﬁcantly to the effective radii of the carboxylate oxygens. To compensate, the intrinsic GB
radii of AS4 and GL4 carboxylate oxygens must be reduced such that the effective radius is closer to the
carboxylate oxygen atoms of an ASP or GLU residue. The cpinutil.py script that generates the cpin ﬁle has been
modiﬁed to make the necessary changes to the topology ﬁle (which can be written with the new “-op” ﬂag that
was added for this purpose). An example command-line used to set up a constant pH simulation in explicit
solvent for carboxylates is:

cpinutil.py -igb 2 -resnames AS4 GL4 -p <tleap_prmtop> -op <new_radii_prmtop>

514

24.3. Running at constant pH

Figure 24.2.: Workﬂow for constant pH MD simulations in explicit solvent.

In the above command, new_radii_prmtop is generated and must be used for constant pH simulations. In addition
to the modiﬁed topology ﬁle you need for CpHMD in explicit solvent, there is an additional parameter, ntrelax,
that deﬁnes the number of solvent relaxation steps that will be performed following successful protonation state
changes. In general, we’ve found that while ca. 4 ps is required to generate a truly relaxed solvent distribution,
200 fs is sufﬁcient to account for the bulk of the solvent relaxation.

Another difference with respect to implicit CpHMD simulations is that a protonation state change attempt is
carried out for each residue in random order. This is done to allow protonation state change attempts to be done
far less frequently to limit the amount of MD time that is consumed by the solvent relaxation dynamics. Here is
an example of input variables to be used in your sander or pmemd input ﬁle.

icnstph=2, ntcnstph=100, ntrelax=200,
solvph=6.4, saltcon=0.1, temp0=300.0,
ntc=2, ntf=2

Notice that the value of icnstph is 2, which indicates that CpHMD should be run in explicit solvent. The ntrelax
ﬂag will run solvent relaxation dynamics (in which the non-solvent is held ﬁxed) for 200 steps. The saltcon
variable controls the salt concentration for the GB calculations. It has no effect on the dynamics, but is required
for consistency with the reference energy of the model compound.

515

24. Constant pH calculations

24.4. Analyzing constant pH simulations

As the simulation progresses, the protonation states that are sampled are written to the cpout ﬁle. A section of a

cpout ﬁle from an implicit solvent simulation is included here:

Solvent pH: 2.00000
Monte Carlo step size: 2
Time step: 0
Time: 0.000
Residue 0 State: 1
Residue 1 State: 0
Residue 2 State: 1
Residue 3 State: 0
Residue 4 State: 1
Residue 5 State: 0

Residue 2 State: 0

Residue 4 State: 0

Residue 0 State: 3

Residue 1 State: 0

Residue 0 State: 0

One record is written on each Monte Carlo step. Each record is terminated by a blank line. There are two types
of records: full records and delta records. Full records, like the one shown above, lists the solvent pH, MC step
size, current time step, and current time before listing every residue in the system. Full records are written on the
ﬁrst step and every ntwx steps afterwards so as to coincide with the frames written to the trajectory. Delta records
list only those residues that were titrated (single or double lines for implicit solvent or a list of every residue for
explicit solvent). Note that in some cases, the protonation state for a delta record may be the same as that in an
earlier record: this indicates that the Monte Carlo protonation move was rejected for that residue. The residue
numbers in cpout are indices over the titrating residues included in the cpin ﬁle; cpout ﬁles must be analyzed in
conjunction with the cpin to map these indices back to the original system.

The cphstats program can be used to perform several different analyses on the cpout ﬁles. It prints the fraction
of protonated species, which can be used to compute the pKa values of each titratable residue. The cphstats usage
is described in Section 24.7.

24.5. Extending constant pH to additional titratable groups

There are two major components to deﬁning a new titrating group for constant pH. First you must deﬁne the
partial charges for each atom in the residue for each protonation state. Then you must set the relative energies of
each state (this can be done using TI calculations or the ﬁnddgref.py tool, see below).

Deﬁning charge sets

Partial charges can be, in most cases, easily calculated using Antechamber and Gaussian. You must set up a
model to calculate charges for each protonation state. If the titrating group you are deﬁning is a polymer subunit
(e.g. amino acid residue), you must adjust the charges on atoms that have bonded interactions (including 1-4) with
atoms in neighboring residues. The charges on these atoms must be changed so they are the same in all protonation
states - otherwise relative energies of protonation states become sequence dependent. For an amino acid, this
means that all backbone atoms must have the same charges. For the residues deﬁned here, we arbitrarily selected

516

24.5. Extending constant pH to additional titratable groups

the backbone charges of the protonated state to be used across all protonation states. The total charge difference
between a protonated and a deprotonated state should remain 1.

Calculating relative energies

Relative energies are used to calibrate the method such that when a model compound is titrated at pH equal
to its pKa, the population of the protonated and deprotonated states are equal (e.g. fraction of protonated species
equal to 50%). Relative energies of the different protonation states of a model compound can be computed using
thermodynamic integration or the ﬁnddgref.py tool (see Subsection 24.5.1 below). The model compound should be
a small molecule that mimics the bonded environment of the titratable group of interest, and for which the exper-
imental pKa data is available. For instance, the model compound for an amino acid X is generally ACE-X-NME;
the model compound for a ligand might be the free ligand. The thermodynamic integration or the ﬁnddgref.py cal-
culations must be performed using exactly the same parameters and force ﬁeld as you plan to use in your constant
pH simulations.

Testing the titratable group deﬁnitions

Prior to large scale use of your new titratable group deﬁnition, it’s a good idea to test it by performing a
constant pH simulation of your model compound, with pH set equal to the model pKa. Doing this requires
generation of a cpin ﬁle, and for this you need to deﬁne your titratable residue in cpinutil.py. These deﬁnitions are
found in $AMBERHOME/AmberTools/src/parmed/parmed/amber/titratable_residues.py. Your residue name
must be added to the list titratable_residues at the top of this ﬁle. Add your residue deﬁnition to the bottom
of the ﬁle, following the examples of the other residues (and make sure to execute the “check” function on that
residue at the end as a way of checking your input). Don’t forget to recompile parmed (or the whole AmberTools)
so that your changes may take effect. It is also a good idea to use cpinutil.py with --describe to check that the
charge vectors match what you meant to input—the output format using --describe is much easier to check than
the input in titratable_residues.py. The deﬁnition of CYS is shown below as an example.

# Cysteine
refene1 = _ReferenceEnergy(igb2=77.4666763, igb5=76.2588331, igb8=71.5804519)
refene1.solvent_energies(igb2=77.6041407, igb5=76.2827217)
refene1.dielc2_energies(igb2=38.090523, igb5=37.454637)
refene1.dielc2.solvent_energies(igb2=38.489170)
# Copying the reference energy to be printed on the old CPIN format
refene1_old = _ReferenceEnergy(igb2=77.4666763, igb5=76.2588331, igb8=71.5804519)
refene1_old.solvent_energies(igb2=77.6041407, igb5=76.2827217)
refene1_old.dielc2_energies(igb2=38.090523, igb5=37.454637)
refene1_old.dielc2.solvent_energies(igb2=38.489170)
refene1_old.set_pKa(8.5, deprotonated=False)
refene2 = _ReferenceEnergy(igb2=0, igb5=0, igb8=0)
refene2.solvent_energies(igb1=0, igb2=0, igb5=0, igb7=0, igb8=0)
refene2.dielc2_energies(igb2=0, igb5=0, igb8=0)
refene2.dielc2.solvent_energies(igb1=0, igb2=0, igb5=0, igb7=0, igb8=0)

CYS = TitratableResidue(’CYS’, [’N’, ’H’, ’CA’, ’HA’, ’CB’, ’HB2’, ’HB3’, ’SG’,

’HG’, ’C’, ’O’], pka=8.5, typ="ph")

CYS.add_state(protcnt=1, refene=refene1, refene_old=refene1_old, pka_corr=8.5, # protonated

charges=[-0.4157, 0.2719, 0.0213, 0.1124, -0.1231, 0.1112, 0.1112,

CYS.add_state(protcnt=0, refene=refene2, refene_old=refene2, pka_corr=0.0, # deprotonated

charges=[-0.4157, 0.2719, 0.0213, 0.1124, -0.3593, 0.1122, 0.1122,

-0.3119, 0.1933, 0.5973, -0.5679])

CYS.check()

-0.8844, 0.0, 0.5973, -0.5679])

517

24. Constant pH calculations

Reference energies are those calculated from either TI (and adjusted if necessary to reproduce experimental pKas)
or ﬁnddgref.py. The reference energies should be calculated for all GB models you plan to support. If you use
TI, you should always titrate your model compound to make sure that the calculated pKas match experiment. The
reference energies obtained are typically sufﬁcient, but some residues may require adjustments.

24.5.1. Finding reference energies with ﬁnddgref.py

finddgref.py is a Python tool written by Vinícius Cruzeiro that allows one to automatically compute the

reference energy of a titratable residue for constant pH simulations. This is an alternative approach to TI
calculations and works by directly titrating the model compound using CpHMD and making adjustments to the
reference energy until a 50% fraction of protonated species is obtained at pH equal to the pKa of the model
compound. The script has two modes of execution: serial and parallel. The serial mode consists of a simple
CpHMD simulation. The parallel mode consists of a pH-REMD simulation, therefore a short number of MD
steps should be necessary to run the simulation. You can access a list and description of all available
command-line ﬂags using the --help ﬂag, whose output is shown below.

usage: finddgref.py [Options]
optional arguments:

-h, --help
-v, --version
--author

Required Arguments:

-mdexec FILE

show this help message and exit
show the program’s version and exit
show the program’s author information and exit

Path to the AMBER executable file. Example:
$AMBERHOME/bin/pmemd

Required Arguments - With Replica Exchange:

-target FLOAT

Not-required Arguments:

-do_parallel STRING

-log FILE

-resnum INT

-dgrefest FLOAT

Value of pH or Redox Potential (in Volts) that we
expect to obtain a converged fraction of protonated or
reduced species close to 50%. This is the target value
of the pKa or Standard Redox Potential (Eo) of the
system at the end of the execution. Default: None

Command preciding mdexec for parallel execution. Used
only with Replica Exchange. Default: mpirun -np [-ng]
When set, prints the log of the program execution to
an external file (-log FILENAME). If not set, print it
at the screen. Default: None
Number of the residue in which the fraction of
protonated or reduced species will be monitored.
(REQUIRED if the number of pH or Redox titratable
residues is larger than 1)
Estimated value of Delta G reference. When this flag
is given, the program starts in the last phase of
execution, that is, on the phase of making more
accurate estimatives of Delta G reference. Note: if
the value of -dgrefest is not close enough to the true
value of Delta G reference, the execution will fail.
Default: None

-dgrefrange FLOAT FLOAT

Range of values for Delta G reference. The desired
Delta G reference value has to be inside this range.
If -dgrefest and -dgrefrange are not given, the
program will try to find a range automatically.
Suggestion: choose one value in which the fraction of
protonated or reduced species is ~ 0 and the other
value in which it is ~ 1. Default: None
When the values of the argument -dgrefrange are to be
found automatically, dginterval is the interval of

-dginterval FLOAT

518

24.5. Extending constant pH to additional titratable groups

-maxsteps INT
-fracthreshold FLOAT Fraction threshold. The fraction convergence criterium

trial values. Default: 100.0 kcal/mol
Maximum number of AMBER executions. Default: 100

-noequi

-rmouts

-bin-path FILE

is: 0.5-fracthreshold/2 >= frac >=
0.5+fracthreshold/2. Default: 0.03
If stated, the equilibration simulation for a new
DELTAGREF value will not be performed. Equilibration
runs for 10% the number of steps of the production
simulation. Default: False
If stated, at the end of the execution of the program,
erases all output files generated by AMBER (all files
not stated as REQUIRED at "AMBER Arguments" below).
Default: False
Path to the AMBER bin directory. Used to locate
cphstats, cestats or fitpkaeo.py (Example:
$AMBERHOME/bin ; Default: not set).

AMBER Arguments - Without Replica Exchange:

These are the arguments to be executed together with mdexec.
-i FILE
-p FILE
-c FILE
-x FILE
-inf FILE
-o FILE
-r FILE
-cpin FILE
-cpout FILE
-cprestrt FILE
-cein FILE
-ceout FILE
-cerestrt FILE
-ref FILE

AMBER mdin file (REQUIRED)
AMBER parmtop file (REQUIRED)
AMBER inpcrd (input coordinates) file (REQUIRED)
AMBER mdcrd (output coordinates) file
AMBER mdinfo file
AMBER mdout (log) file
AMBER mdout file
AMBER cpin file (REQUIRED if cein file is not given)
AMBER cpout file
AMBER cprestrt file
AMBER cein file (REQUIRED if cpin file is not given)
AMBER ceout file
AMBER cerestrt file
AMBER ref file

AMBER Arguments - With Replica Exchange:

These are the arguments to be executed together with do_parallel and
mdexec.
-ng INT
-groupfile FILE

Number of groups/replicas (REQUIRED)
AMBER groupfile file (REQUIRED)

This program will perform constant pH or constant redox potential simulations
in order to find the value of Delta G reference (DELTAGREF) that gives around
50% fraction of protonated or reduced species for a given residue at a given
target pH or redox potential. In order to run the program, you need to replace
at least one of the values at the STATENE flag by DELTAGREF on your cpin or
cein file.

Serial mode (CpHMD)

The ﬁrst step the input ﬁles as if you were to run a regular constant pH MD simulation of your model

compound. In your input ﬁles, make sure of two things: 1) that the solvph variable inside your mdin ﬁle is equal
to the pKa of your model compound; 2) that the total number of MD steps is long enough to ensure convergence.
This includes preparing a cpin ﬁle. For that, even without having the reference energies yet, you do need to
change the source code so cpinutil.py in order to generate your cpin ﬁle (see Section 24.5 for instructions). At this
point, the values you chose for the reference energies for your residue inside the source code are irrelevant. Once
your cpin ﬁle is generated, you need to change the STATENE ﬂag inside it. The STATENE ﬂag contains
information about the reference energies of each state. The PROTCNT ﬂag contains the proton count for each
state and will look something like this:

PROTCNT=0,1,1,1,1,

519

24. Constant pH calculations

In this example, there are 5 different protonation states. The ﬁrst one is a deprotonated state, and the other four
are protonated states. Assuming the is only one titratable residue in your cpin ﬁle and that the protonated states
are all equivalent (which is true for a GL4 residue for example), this is how the STATENE ﬂag needs to look like
for ﬁnddgref.py:

STATENE=0.0,DELTAGREF,DELTAGREF,DELTAGREF,DELTAGREF,

ﬁnddgref.py will return at the end of its execution the value of DELTAGREF that gives 50% fraction of protonated
species for the pH you set in your mdin ﬁle (which should be equal to the pKa of your titratable residue). The
absolute values that appear on STATENE are irrelevant for constant pH simulations; it is only the energy
differences between the different states that matters. The execution of ﬁnddgref.py is very similar to the execution
of pmemd or sander. This is an example of how a simple execution looks like:

finddgref.py -mdexec pmemd.cuda -i mdin -p prmtop -c restrt -cpin cpin

Additional options are available (see the command description the --help ﬂag). The -mdexec ﬂag contains the
location of the executable to be used for the constant pH simulation (in this example, pmemd.cuda). ﬁnddgref.py
will keep repeating automatically different simulations (the input ﬁles you provided will not be overwritten) for
different values of DELTAGREF until the fraction of protonated species is equal to 50% within a convergence
criterion. By default, ﬁnddgref.py will ﬁnish its execution when it ﬁnds a fraction between 48.50% and 51.50%.
This range can be changed by altering the -fracthreshold ﬂag. After each CpHMD execution ﬁnddgref.py will
print an output message that looks like this:

AMBER execution #8: running 250000 MD steps of equilibration for DELTAGREF =

-14.887694 kcal/mol

AMBER execution #8: running 2500000 MD steps of production

for DELTAGREF =

-14.887694 kcal/mol

The fraction of protonated species is 66.10% for the Residue ’GL4 2’

At the begging of ﬁnddgref.py’s execution, unless a estimation of DELTAGREF is provided by the user, the total
number of MD steps in each CpHMD execution will be reduced to a very small number just in order to ﬁnd a
rough estimation of DELTAGREF. When this rough estimation is found, ﬁnddgref.py starts to perform more
reﬁned and accurate estimations of DELTAGREF with each CpHMD simulation having the total number of MD
steps that was set by the user. Then, when a good value of DELTAGREF is found, ﬁnddgref.py will print an
output message like this:

The value of DELTAGREF that gives a converged fraction of protonated species for 9500000 MD
steps and for solvent pH =
The execution of finddgref.py ended with success.

4.400 equals to 49.40% is: DELTAGREF = -15.285781 kcal/mol

At this point, the only thing left to do is to update Amber’s source code (see Section 24.5 for instructions) with
this value of DELTAGREF so that cpinutil.py can generate cpin ﬁles that contain your titratable residue with the
correct reference energies.

Parallel mode (pH-REMD)

The ﬁrst step is to prepare your input ﬁles as if you were to run a pH-REMD simulation of your model

compound. You need to make sure that the total number of MD steps is long enough to ensure convergence,
however it is not necessary that any of the solvph variables inside the mdin ﬁle of each replica to be equal to the
pKa of your model compound. The fractions of protonated species for each replica (therefore, different pH
values) can be used to extrapolate, from a ﬁt based on the Henderson-Hasselbalch equation, the fraction of
protonated species at the target pH (which should be set equal to the pKa of your model compound). The cpin ﬁle
should be prepared following the same instructions given above for the serial mode. The execution of ﬁnddgref.py
is very similar to the execution of pmemd or sander for replica exchange simulations. This is an example of how a
it looks like:

520

24.6. pH Replica Exchange MD

finddgref.py -do_parallel "mpirun -np 4" -mdexec pmemd.cuda.MPI -ng 4
-groupfile groupfile -target 4.4

Additional options are available (see the command description using the --help ﬂag). After each pH-REMD
execution ﬁnddgref.py will print an output message that looks like this:

AMBER execution #8: running 50000
equilibration for DELTAGREF = -15.134900 kcal/mol

MD steps (500 replica exchange attempts) of

AMBER execution #8: running 500000 MD steps (5000 replica exchange attempts) of

production

for DELTAGREF = -15.134900 kcal/mol

The fraction of protonated species for pH =
The fraction of protonated species for pH =
The fraction of protonated species for pH =
The fraction of protonated species for pH =
Fitted values for Residue ’GL4 2’: pKa =
The computed fraction of protonated species at the target pH =

3.500 is
4.000 is
4.500 is
5.000 is

89.30% for the Residue ’GL4 2’
73.30% for the Residue ’GL4 2’
44.30% for the Residue ’GL4 2’
19.30% for the Residue ’GL4 2’

4.408 and Hill coefficient = 1.047

4.400 is

50.47% for

the Residue ’GL4 2’

Similarly to the serial mode, at the begging of ﬁnddgref.py’s execution a rough estimation of DELTAGREF is
done with a small total number of MD steps. Afterwards, more accurate DELTAGREF estimations are performed
with each pH-REMD simulation having the total number of MD steps that was set by the user. Finally, when a
good value of DELTAGREF is found, ﬁnddgref.py will print an output message that looks like this:

The value of DELTAGREF that gives a converged fraction of protonated species for 500000 MD
steps and for target solvent pH =
The execution of finddgref.py ended with success.

4.400 equals to 50.47% is: DELTAGREF = -15.134900 kcal/mol

Don’t forget to update Amber’s source code (see Section 24.5 for instructions) with this value of DELTAGREF so
that cpinutil.py can generate cpin ﬁles that contain your titratable residue with the correct reference energies.

24.6. pH Replica Exchange MD

Running constant pH replica exchange simulations can be performed in either implicit or explicit solvent. There
is no difference in the replica exchange setup between running in implicit or explicit solvent. This method is
described in Section 23.3.7 above. We have found that pH-REMD dramatically improves protonation state and
conformational state sampling, so we suggest using it whenever possible.

24.7. cphstats

cphstats is a C++ command-line program written by Jason Swails to compute protonation state statistics from

constant pH simulations (in both implicit and explicit solvent). You can access a list and description of all
available command-line ﬂags using the --help ﬂag, whose output is shown below.

Usage: cphstats [-O] [-V] [-h] [-i <cpin>] [-t] [-o FILE] [-R FILE -r INT]

[--chunk INT --chunk-out FILE] [--cumulative --cumulative-out FILE]
[-v INT] [-n INT] [-p|-d] [--calcpka|--no-calcpka] [--fix-remd]
[--population FILE] [-c CONDITION -c CONDITION -c ...]
[--conditional-output FILE] [--chunk-conditional FILE]
cpout1 [cpout2 [cpout3 ...] ]

General Options:

-h, --help
-V, --version Print the version number and exit.
-O, --overwrite

Print this help and exit.

521

24. Constant pH calculations

--debug

--expert

--novice

Allow existing outputs to be overwritten.
Print out information about the files that are
being read in and used for the calculations.
I will consider you an expert user and NOT warn
you if you try to compute statistics from REMD-based
files before using --fix-remd [NOT default behavior]
I will warn you if you try to use REMD-based files
to compute statistics. [Default behavior]

Input Files and Options:
-i FILE, --cpin FILE

Input cpin file (from sander) with titrating residue
information.
-t FLOAT, --time-step FLOAT

This is the time step in ps you used in your simulations.
It will be used to print data as a function of time.
Default is 2 fs (0.002)

Output Files:

-o FILE, --calcpka-output FILE

File to which the standard ‘calcpka’-type statistics
are written. Default is stdout

-R FILE, --running-avg-out FILE

Output file where the running averages of time series
data for each residue is printed (see [Output Options]
below for details). Default is [running_avgs.dat]

--chunk-out FILE

Output file where the time series data calculated
over chunks of the simulation are printed (see
[Output Options] below for details).
Default is [chunk.dat]

--cumulative-out FILE

Output file where the cumulative time series data
is printed (see [Output Options] below for details).
Default is [cumulative.dat]

--population FILE

Output file where protonation state populations are
printed for every state of every residue.

--conditional-output FILE

Output file with requested conditional probabilities.
Default is [conditional_prob.dat].

--chunk-conditional FILE

Prints a time series of the conditional probabilities over
a trajectory split up into chunks.

Output Options:

These options modify how the output files will appear

-v INT, --verbose INT

Controls how much information is printed to the
calcpka-style output file. Options are:

(0) Just print fraction protonated. [Default]
(1) Print everything calcpka prints.

-n INT, --interval INT

An interval between which to print out time series data
like ‘chunks’, ‘cumulative’ data, and running averages.
It is also used as the ’window’ of the conditional
probability time series (--chunk-conditional).
Default [1000]

-p, --protonated

Print out protonation fraction instead of deprotonation

522

24.7. cphstats

-d, --deprotonated

fraction in time series data (Default behavior).

Print out deprotonation fraction instead of protonation
fraction in time series data.
Print predicted pKas (via Henderson-Hasselbalch) in place
of fraction (de)protonated. NOT default behavior.

-a, --pKa

Analysis Options:

These options control which analyses are done. By default, only
the original, calcpka-style analysis is done.

--calcpka
--no-calcpka
-r WINDOW, --running-avg WINDOW

Triggers the calcpka-style output [On by default]
Turns off the calcpka-style output

Defines a window size for a moving, running average
time series. <WINDOW> is the number of MD steps (NOT
the number of MC exchange attempts).

--chunk WINDOW

--cumulative

Computes the time series data over a chunk of the
simulation of size <WINDOW> time steps. See above for
details.
Computes the cumulative average time series data (see above
for options) over the course of the trajectory.

--fix-remd PREFIX

This option will trigger cphstats to reassemble the
titration data into pH-specific ensembles. This
is an exclusive mode of the program---no other
analyses will be done.

-c CONDITIONAL, --conditional CONDITIONAL

Evaluates conditional probabilities. CONDITIONAL should be a
string of the format:

<resid>:<state>,<resid>:<state>,...

or

or

<resid>:PROT,<resid>:DEPROT,...

<resid>:<state1>;<state2>,<resid>:PROT,...

Where <resid> is the residue number in the prmtop (NOT the
cpin) and <state> is either the state number or (p)rotonated
or (d)eprotonated, case-insensitive

This program analyzes constant pH output files (cpout) from Amber.
These output files can be compressed using gzip compression. The
compression will be detected automatically by the file name extension.
You must have the gzip headers for this functionality to work.

24.7.1. Standard statistics

The standard output of cphstats is the same as that for the calcpka and calcpka.pl programs that came

before. An example from a protein with 10 titratable residues is shown below.

4.000

Solvent pH is
: Offset -0.448 Pred
GL4 7
: Offset 2.036
Pred
HIP 15
: Offset -1.063 Pred
AS4 18
: Offset 2.113
Pred
GL4 35
: Offset -1.365 Pred
AS4 48
: Offset -1.123 Pred
AS4 52
: Offset -1.689 Pred
AS4 66
: Offset -1.757 Pred
AS4 87
AS4 101 : Offset 0.342
Pred
AS4 119 : Offset -1.894 Pred

3.552
6.036
2.937
6.113
2.635
2.877
2.311
2.243
4.342
2.106

Frac Prot 0.263 Transitions
Frac Prot 0.991 Transitions
Frac Prot 0.080 Transitions
Frac Prot 0.992 Transitions
Frac Prot 0.041 Transitions
Frac Prot 0.070 Transitions
Frac Prot 0.020 Transitions
Frac Prot 0.017 Transitions
Frac Prot 0.687 Transitions
Frac Prot 0.013 Transitions

91163
6194
41490
5458
17596
25306
7334
8976
105377
6700

523

24. Constant pH calculations

Average total molecular protonation:

4.174

The external pH that was set in sander or pmemd is shown at the top, followed by each of the residues with their
name and number as they appear in the topology ﬁle. The computed pKa values printed by cphstats are computed
by ﬁtting to the Hendersen-Hasselbalch equation (Eq. 24.1). The values printed in the standard output are deﬁned
below:

Offset Difference in pK units that the predicted pKa is from the solvent pH.
Pred The predicted pKa computed from the fraction protonated and the pH in Eq. 24.1.

Frac Prot The total fraction of the simulation that the residue spent in its ‘protonated’ form.

Transitions The number of times that the total number of ‘active’ protons on the titratable residue changed fol-
lowing a protonation state change attempt. This does not count when the protonation state changed between
two tautomers or protomers with the same number of protons. For instance, the switching from the HID
to the HIE tautomers of histidine does not count. Nor does switching from the syn-O1-protonated to the
syn-O2-protonated forms of any carboxylate residues.
pKa = pH − log

(cid:18)1− fp

(24.1)

(cid:19)

fp

In Eq. 24.1, fp is the total fraction protonated for a given residue. A more rigorous way of computing the pKa
of a titratable residue is to ﬁt Eq. 24.2—the Hill equation—to the pHs and protonation fractions collected over
a full titration curve to compute the best-ﬁt values of the Hill coefﬁcient (n) and computed pKa. This requires
post-processing the output from cphstats with your own script or program.

fd = 1− fp =

1

1 + 10n(pKa−pH)

(24.2)

Example You can analyze as many cpout ﬁles as you would like, provided that each cpout ﬁle was generated
from a simulation run at the same pH as the others. For pH-REMD simulations, a pre-processing stage is initially
required, as described in a section 24.7.5. You can direct cphstats to print the output to a ﬁle with the -o ﬂag or
have it printed to the screen (stdout) by default. You must provide a cpin ﬁle with the -i ﬂag to calculate any
protonation state statistics.

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout \

-o pH_4.dat

24.7.2. Cumulative, running, and “chunk” averages

These options provide a way of monitoring how the ensemble of protonation states evolve during the course of

a simulation. Because MD yields insights into the dynamical behavior of molecules, it’s often advantageous to
monitor the evolution of the protonation state fractions with geometric measurements of the system coordinates.
Each option—cumulative, running, and “chunk” averages—can be output as a time series of fraction protonated,
fraction deprotonated, or predicted pKa using the -p, -d, and -a ﬂags, respectively. The details of calculating
each of these properties is described in the next sections. The output is printed to a ﬁle in the following format:

#Time step

GL4 7

HIP 15

AS4 18

1000 0.30693 0.99505 0.00000 0.99505
2000 0.24378 0.99751 0.00000 0.99751
3000 0.23754 0.99834 0.05150 0.99834

GL4 35 Total Avg. Prot.
3.900498
3.962594
4.014975

...

The ﬁnal column is always the total average protonation (note, a protonated histidine counts as ‘2’ protons and a
protonated lysine counts as ‘3’, so only differences in total protonation fraction are meaningful). The time step
corresponds to the actual MD time step, not the interval between protonation state changes.

524

Cumulative averages

24.7. cphstats

A cumulative average is a time series whose values at time t are calculated according to

(cid:82) t

(cid:104)A(cid:105)t =

0 A(t)dt

t

such that it represents the average value from time 0 to t. The ﬁnal average should match the output printed in
the standard statistics output of the previous section, which is an average over the entire ensemble. Cumulative
averages can be misleading, however, as (cid:104)A(cid:105)t changes rapidly when t is small and very slowly as t becomes large.
It can give the impression that a property is converging to a particular value when in fact that property is ﬂuctuating
a lot.

Example To compute a cumulative average, you must use the --cumulative ﬂag to indicate you wish to
compute this value. You can control how frequently this quantity is sampled by setting the interval, in MD time
steps (not protonation state change attempts), using the -n ﬂag. The default interval is to print values every 1000
time steps. The longer your simulation is, the less frequently you have to sample points. Data is written to the ﬁle
cumulative.dat unless a different name is provided with the --cumulative-out ﬂag. An example usage is:

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout -n 10000 -p \

--no-calcpka --cumulative --cumulative-out pH_4_cumulative.dat

The --no-calcpka ﬂag prevents the standard statistics (previous section) from being computed and printed. The
cumulative protonated fraction will be printed to the ﬁle pH_4_cumulative.dat with values dumped every 10000
steps.

Running averages

A running average is a time series whose values at time t are calculated according to

(cid:82) t+σ

(cid:104)A(cid:105)t =

t−σ A(t)dt

2σ

such that it represents the average value from t −σ to t +σ—the value 2σ is referred to as the window size. The
advantage of a running average over a cumulative average is that the shape of the curve at large values of t do not
depend on the values near t = 0. If the interval is smaller than the window size, then adjacent values of (cid:104)A(cid:105)t will
be comprised of overlapping data points.

Example To compute a running average, you must specify a window size, in MD time steps, with the -r ﬂag.
The interval—speciﬁed with the -n ﬂag—controls how frequently samples from the time series are saved to the
output ﬁle. An example usage is

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout \

-n 2000 -r 10000 -R pH_4_runningavg.dat -d

This command will compute the running average of the deprotonation fraction (because of the -d ﬂag) every 2000
time steps with a window size of 10000 time steps—the average will be computed from the 5000 steps before
time t to 5000 steps after time t every 2000 steps. It may be important to note that any portion of the window that
extends before t = 0 or after the last time step of the simulation is simply truncated. In this example, the running
average data is printed to the ﬁle pH_4_runningavg.dat and the standard statistical output is printed to the screen.

“Chunk” averages

A “chunk” average is a time series in which the trajectory is segmented into separate chunks of speciﬁed size

2σ time steps. The average value is then calculated according to

525

24. Constant pH calculations

(cid:104)A(cid:105)t =

(cid:82) t+σ

t−σ A(t)dt

2σ

Indeed, “chunk” averages are simply a special case of running averages in which the times for which (cid:104)A(cid:105)t are
computed are the center points of the time chunks. In this analysis, every point of the simulation is uniquely
assigned to a single chunk (so no overlap is possible like there is for running averages with a window size larger
than twice the interval).

Example Unlike the cumulative and running average analyses, the interval is not used for “chunk” averaging.
The chunk size, in MD time steps, simultaneously speciﬁes the size of the simulation to use in the average as well
as the positions of the points in the generated time series. An example chunk analysis is

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout --pKa \

--no-calcpka --chunk 100000 --chunk-out pH_4_chunks.dat

This command will break the trajectory into 100,000 time step-chunks and compute the pKa of each residue for
each chunk according to Eq. 24.1. In this example, the “chunk” pKas are printed to the ﬁle pH_4_chunks.dat.

24.7.3. Populations

If you specify a ﬁle with the --populations ﬂag, the population of every residue in every state computed over

the whole trajectory will be printed to the speciﬁed ﬁle. An example command is shown below

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout \

--populations populations.dat

The populations.dat ﬁle will look something like the following:

Residue Number

State

0

State

1

State

2

State

3

State

4

-----------------------------------------------------------------------------------
0.642697 (0) 0.182143 (1) 0.003043 (1) 0.168653 (1) 0.003465 (1)
Residue: GL4 7
0.982722 (2) 0.017278 (1) 0.000000 (1)
Residue: HIP 15
0.986247 (0) 0.006043 (1) 0.000075 (1) 0.007635 (1) 0.000000 (1)
Residue: AS4 18
0.052398 (0) 0.437664 (1) 0.025815 (1) 0.476629 (1) 0.007495 (1)
Residue: GL4 35
0.995087 (0) 0.001435 (1) 0.000085 (1) 0.003393 (1) 0.000000 (1)
Residue: AS4 48
0.973672 (0) 0.007520 (1) 0.002705 (1) 0.015465 (1) 0.000638 (1)
Residue: AS4 52
0.999612 (0) 0.000165 (1) 0.000000 (1) 0.000223 (1) 0.000000 (1)
Residue: AS4 66
Residue: AS4 87
0.948970 (0) 0.023918 (1) 0.001240 (1) 0.025235 (1) 0.000638 (1)
Residue: AS4 101 0.678859 (0) 0.160313 (1) 0.002295 (1) 0.153793 (1) 0.004740 (1)
Residue: AS4 119 0.971682 (0) 0.015043 (1) 0.000623 (1) 0.011888 (1) 0.000765 (1)

In the example output, each residue except for histidine 15 is a carboxylate that has 5 available states: deprotonated
and protonated on the syn- or anti- positions of either carboxylate oxygen. You can use the --describe ﬂag for
cpinutil.py to get a detailed description of what each state is. The decimal numbers shown are the fraction of
the time that the residue spent in the speciﬁed protonation state. The integer in parentheses next to the protonation
state population is the number of titratable protons that are present in that state. Notice that histidine 15 has only 3
states. The ﬁrst is the doubly-protonated state whereas the other two states are singly-protonated at the Nδ and Nε
positions, respectively. This output gives a more detailed view of where the protons are during the simulation.

24.7.4. Conditional probabilities

It is frequently the case that an enzyme’s or ribozyme’s catalytic mechanism depends on two titratable residues
having speciﬁc protonation states to fulﬁll their role as either a proton donor or acceptor in the mechanism. When
one residue is a proton acceptor and the other a proton donor, there is an ‘optimum’ pH at which the fraction of
proteins that have the correct set of protonation states will be a maximum and the catalytic rate is lowered when the
pH is either raised or reduced from this optimum value, since we typically assume that the only catalytically active
state is the one with the catalytically ‘correct’ set of protonation states. By assuming that each residue titrates

526

24.7. cphstats

independently—that is that the protonation state of one does not affect the protonation state of the other—we can
derive a pH-rate proﬁle for the enzyme or ribozyme by using the pKa of each residue to compute fraction of time
each residue spends in its catalytically active protonation state and simply multiply those fractions for each residue
to arrive at the conditional probability.

If, however, the catalytic residues titrate cooperatively or anticooperatively, the conditional probabilities cannot
be computed as a simple product of the individual probabilities. By directly capturing the coupling between
dynamics and titration of all titratable residues, CpHMD and pH-REMD are capable of probing this cooperativity.
This section describes how to use cphstats to compute conditional probabilities directly from the protonation
state data.

Conditional Probability Expressions

This section describes the syntax of the conditional probability expressions that you must use for cphstats.

The format of the expression is a comma-delimited list of residue:state speciﬁcations shown below.

<residue 1>:<state specification>,<residue 2>:<state specification>

You can list as many residues as you want. A snapshot satisﬁes the conditional probability criteria if each of the
speciﬁed residues is in the list of allowable states within the state speciﬁcations—unspeciﬁed residues can be in
any state. The residue speciﬁers are the residue numbers in the topology ﬁle. The state speciﬁcation can be either
a semicolon-delimited list of state numbers or the description “protonated” or “deprotonated.” The parser is
case-insensitive and you only have to type up to one letter of either word to trigger recognition of “protonated” or
“deprotonated.” Example conditional probability expressions are shown below with accompanying descriptions
of what conditional probabilities they deﬁne. Individual residue:state speciﬁcations are indicated by color.

“35:P,52:D”

This expression is satisﬁed if residue 35 is protonated at the same time that residue 52 is deprotonated.

“35:Prot,52:1;3,15:1”

This expression is satisifed if residue 35 is protonated and residue 52 is in either state 1 or 3 and residue 15 is in
state 1. Other residues can be in any state.

Examples

You can specify conditional probability expressions following the -c ﬂag on the command-line. You can

specify as many expressions as you want, as long as each one is preceded by -c or --conditional. The fraction
of states that satisfy each conditional probability is written to the conditional probability output ﬁle speciﬁed by
--conditional-output (or conditional_prob.dat by default). An example command-line is shown below

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout \

-c “35:P,52:D” -c “35:prot,52:1;3,15:1” \
--conditional-output conditional.dat

Example output from conditional.dat is shown below.

Conditional Probabilities
35:P,52:D
35:prot,52:1;3,15:1

Fraction
0.982922
0.000290

For the sake of comparison, the standard statistics are shown below.

4.000

Solvent pH is
: Offset -0.167 Pred
GL4 7
HIP 15 : Offset 1.391 Pred
AS4 18 : Offset -1.851 Pred

3.833
5.391
2.149

Frac Prot 0.405 Transitions
Frac Prot 0.961 Transitions
Frac Prot 0.014 Transitions

31378
5578
1910

527

24. Constant pH calculations

: Offset 2.432
GL4 35
: Offset -2.282
AS4 48
: Offset -1.855
AS4 52
: Offset -1.998
AS4 66
: Offset -1.489
AS4 87
AS4 101 : Offset -0.478
AS4 119 : Offset -1.516

Pred 6.432
Pred 1.718
Pred 2.145
Pred 2.002
Pred 2.511
Pred 3.522
Pred 2.484

Frac Prot 0.996 Transitions
Frac Prot 0.005 Transitions
Frac Prot 0.014 Transitions
Frac Prot 0.010 Transitions
Frac Prot 0.031 Transitions
Frac Prot 0.250 Transitions
Frac Prot 0.030 Transitions

391
570
438
698
1239
19924
2408

Average total molecular protonation:

3.716

In this example, residue 35 is protonated while residue 52 is deprotonated 98.2922% of the time. Assuming that
the two residues titrate independently, we would calculate this conditional probability to be 0.996× (1− 0.014)×
100% = 98.2056%. This indicates that these residues titrate independently at pH 4.

Conditional probability “chunks”

cphstats currently supports creating time series of conditional probabilities by breaking the trajectory into

equal-sized “chunks” and computing the conditional probability over that chunk (see Sec. 24.7.2 for details). To
perform this analysis, specify a conditional “chunk” output ﬁle with the --chunk-conditional ﬂag. The -n ﬂag
is used to deﬁne the size of the chunk (the same ﬂag used to deﬁne the time series interval for cumulative and
running averages). The format of the output ﬁle is the same as that shown in Sec. 24.7.2 for the other time series,
but the columns are labeled with the conditional probability expression instead of the residue name and number.
An example usage is shown below.

cphstats -i cpin pH_4.md1.cpout pH_4.md2.cpout pH_4.md3.cpout \

-c “35:P,52:D” -c “35:prot,52:1;3,15:1” -n 100000 \
--chunk-conditional chunk_conditional.dat

This example will break the simulation into 100,000-time-step chunks and compute the two conditional probabili-
ties over each chunk, writing the results to chunk_conditional.dat.

24.7.5. Processing pH-REMD cpout ﬁles

Replica exchange in pH-space is performed by attempting to exchange solution pH between replicas. Like
with temperature-based REMD, this means that individual replicas do not keep the same pH throughout the entire
simulation. Since many of the analyses described in the previous sections pertain to ensembles at one pH, they
are not readily applicable to the raw output from pH-REMD simulations and must often be pre-processed before
being analyzed. This section describes only how to do the preprocessing. You are expected to be familiar with the
content of Subsection 23.3.7 above.

Re-ordering cpout ﬁles

You can use cphstats to generate pH-speciﬁc cpout ﬁles from pH-REMD replica cpout ﬁles using the

--fix-remd ﬂag. To do so, you must provide a ﬁle name preﬁx to which the sufﬁx .pH_X will be appended as
well as the cpout ﬁles from every replica for a single simulation (and only a single simulation). If you ran the
simulation in multiple steps, using restarts from the previous simulation to start the next, you will have to run the
command described here for each segment of the total simulation separately. No cpin ﬁle is needed for this step.
An example usage is shown below:

cphstats --fix-remd cpout pH_1.md1.cpout pH_2.md1.cpout pH_3.md1.cpout \

pH_4.md1.cpout pH_5.md1.cpout pH_6.md1.cpout

This command will create the ﬁles cpout.pH_1.00, cpout.pH_2.00, cpout.pH_3.00, cpout.pH_4.00, cpout.pH_5.00,
and cpout.pH_6.00 that can subsequently be used for the analyses described in the previous section.

If you attempt to use REMD cpout ﬁles without ﬁxing them in the previous analyses, you will receive an error.

528

Analyzing replica statistics

There are times when you may want to analyze statistics, such as fraction protonated or deprotonated, from a
single replica when looking at things like correlation times, for instance. You can disable the REMD ﬁle protection
using the --expert ﬂag, but note that any computed pKa is based on Eq. 24.1 with a single pH, so they will be
meaningless for REMD-based trajectories.

24.7. cphstats

529

25. Constant Redox Potential calculations

The constant Redox Potential molecular dynamics method was developed in Amber by Vinícius Cruzeiro for
both implicit and explicit solvent simulations [502]. Its implementation is based on the constant pH molecular
dynamics method (see chapter 24), and the procedure to generate the input ﬁles and run simulations is also similar
to CpHMD. This chapter assumes the reader already has some familiarity with constant pH simulations. Constant
Redox Potential simulations require minor modiﬁcations to the regular process of generating the prmtop ﬁle and
also require an additional input ﬁle (cein) describing the redox-active titrating residues.

The constant Redox Potential method is implemented in both sander and pmemd, and, likewise the constant pH
method, makes use of Monte Carlo sampling of the Boltzmann distribution of discrete redox states concurrent with
the molecular dynamics simulation. The redox states distribution is affected by the solvent Redox Potential, which
is set as an external parameter in the simulation. The redox states of a redox-active titrable residue are changed by
changing the partial charges on the atoms of this residue.

The code in sander and pmemd was adapted to allow constant Redox Potential simulations to be executed
simultaneously with constant pH simulations. In this case, the simulation then becomes constant pH and Redox
Potential MD.

25.1. Preparing a system for constant Redox Potential simulation

Currently, Amber provides deﬁnitions for titrating a bis-histidine heme group, like the heme group in N-
acetylmicroperoxidase-8 (NAcMP8) or in the horse heart cytochrome c (PDB code 1HRC). The iron atom, the
porphyrin ring, together with the side chains of two histidines and two cysteines (that are attached to the heme)
are considered as a single residue called HEH. HEH is the redox-active residue that changes its atomic charge
distribution when a redox state change attempt is successful. Therefore, a redox state change affects the charge
distribution of the histidines and cysteines as well. The two heme propionates are called PRN and are separate
residues from HEH.

Begin by preparing your PDB ﬁle as you normally would for use with LEaP. Then the PDB ﬁle must be edited
to replace the heme, the histidines and cysteines attached to it by the standards deﬁned in Amber. For example,
the side chains of the two histidines and the two cysteines have to be part of the same HEH residue, thus the atom
names of each side chain have to be unique and match the names deﬁned inside the force ﬁeld. The backbone
atoms have to be reassigned to new residues called HIO and CYO. Please refer to the constant Redox Potential
tutorial at http://ambermd.org/tutorials for more information on how to prepare your PDB ﬁle.

Then, you should run LEaP with the leaprc.conste command ﬁle. This ﬁle loads all parameters to be used for

HEH, PRN, HIO and CYO. Inside LEaP you can load this ﬁle with the following command:

source leaprc.conste

This loads the ff14SB force ﬁeld. In addition, it loads the residue libraries and force ﬁeld modiﬁcations—conste.lib
and frcmod.conste. It also sets the GB solvation radii (PBradii) to mbondi2, which was the set used to parame-
terize the reference compounds. Now load your edited PDB ﬁle and proceed as usual to create the topology and
coordinates ﬁles.

Once you have the prmtop (topology) ﬁle, you need to generate a cein ﬁle. The cein ﬁle describes which

redox-active residues should be titrated, and deﬁnes the possible redox states and their relative energies. A python
tool, ceinutil.py, is provided to generate this input ﬁle. It takes a prmtop ﬁle as input, on the command line along
with the GB model you wish to evaluate redox transitions in, and writes the cein ﬁle. Here is an example of
generating the cein ﬁle from your prmtop ﬁle using the igb=2 GB model:

ceinutil.py -p prmtop -igb 2 -o cein

530

25.1. Preparing a system for constant Redox Potential simulation

The ceinutil.py program accepts a number of ﬂags that modify its behavior. This program is equivalent to cpinu-
til.py used for constant pH simulations and has similar functionalities to it. Please refer to Section 24.2 for more
details on how to use it. As the heme propionates are pH-active residues, their information need to be present at
the cpin ﬁle, so the cpinutil.py must be used for it.

You can get a full list of all available titratable residues using the --list argument to ceinutil.py, and you can

get a full description of reference energies and charge vectors for any residue using the --describe argument.
The full usage statement for ceinutil.py (accessible via -h/--help) is shown below.

usage: ceinutil.py [Options]
optional arguments:

-h, --help
-v, --version
-d, --debug
Output files:

-o FILE, --output FILE

Required Arguments:

-p FILE

Simulation Options:

-igb IGB

-intdiel DIEL

show this help message and exit
show program’s version number and exit
Enable verbose tracebacks to debug this program

Output file. Defaults to standard output

Topology file to be used in constant Redox Potential
simulation

Generalized Born model which you intend to use to
evaluate dynamics (or protonation state swaps).
Default is 2.
Internal dielectric constant to use in the evaluation
of the GB potential. Default 1.0.

Residue Selection Options:

-resnames [RES [RES ...]]

-notresnames [RES [RES ...]]

Residue names to include in CEIN file

Residue names to exclude from CEIN file

-resnums [NUM [NUM ...]]

Residue numbers to include in CEIN file

-notresnums [NUM [NUM ...]]

-mineo Eo

-maxeo Eo

Residue numbers to exclude from CEIN file
Minimum reference standard Redox Potential (given in
Volts) to include in CEIN file
Maximum reference standard Redox Potential (given in
Volts) to include in CEIN file

System Information:

-states [NUM [NUM ...]]

-system <system name>

Residue Information:

List of default states to assign to titratable
residues

Name of system to titrate. No effect on simulation.

If any options here are used, no CEIN file will be written. These
arguments take precedence and are mutually exclusive with each other.
--describe [RESNAME [RESNAME ...]]

-l, --list

Print out the details of given residues
List all titratable residues

This program will read a topology file and generate a cein file for constant
Redox Potential simulations with sander or pmemd

531

25. Constant Redox Potential calculations

25.2. Running at constant Redox Potential

25.2.1. Running at constant Redox Potential in implicit solvent

In the mdin ﬁle, you must set icnste=1 to turn on constant Redox Potential in implicit solvent. solve is the
variable used to set the solvent Redox Potential and should be given in units of Volts. You must also specify the
period for Monte Carlo redox state change attempts, ntcnste. In the implicit solvent implementation only one
residue is examined on each MC step, so you should decrease the step period as the number of titrating residues
increases to maintain a constant effective step period for each residue.

The constant Redox Potential approach makes use of a reference compound. The standard Redox Potential Eo

for this compound is known and the relative free energy differences between the various redox states are
computed through a thermodynamic cycle equivalent to the one used for constant pH MD shown in Figure 24.1.
The free energy of the redox state change in the reference compound is necessary to yield the correct Eo
prediction. This quantity is pre-computed for each redox state change. This reference energy is printed to the cein
ﬁle by ceinutil.py. The reference energies in ceinutil.py were derived using the following parameters:

cut=1000.0, igb=#, saltcon=0.1, nrespa=1,
temp0=300.0, ntc=2, ntf=2

where # is the igb value passed to ceinutil.py. Changes in these parameters, specially igb, saltcon, nrespa, or
temp0, might require a new reference energy computation. The ff99SB force ﬁeld was used in the reference
energy calculations. Using other force ﬁelds should be validated before you run simulations and might require
recalculating the reference energies.

Additional command line ﬂags are available in sander and pmemd to support constant Redox Potential operation.
The cein ﬁle must be speciﬁed using the -cein ﬂag. Additionally, a history of the redox states sampled is written to
the ﬁlename speciﬁed by -ceout. Finally, a constant Redox Potential restart ﬁle is written to the ﬁlename speciﬁed
by -cerestrt. This is used to ensure that titrating residues retain the same redox state when the simulation is
restarted.

25.2.2. Running at constant Redox Potential in explicit solvent

Likewise constant pH MD, in the explicit solvent implementation redox state changes are attempted using a
Generalized Born implicit solvent model [502]. The procedure works as follows: MD is executed for ntcnstph
steps and the simulation is halted. Then, the solvent and any eventual ions are stripped. After that, one redox state
change attempt is performed for each redox-active residue in random order. The solvent is restored, and if any
redox state have changed then a solvent relaxation dynamics is executed during ntrelaxe steps (200 fs are generally
enough). This cycle is repeated until the end of the simulation is reached.

As each residue is visited in random order when the MD is halted, this allows redox state change attempts to be
done far less frequently than in implicit solvent simulations. This is a good strategy because it reduces the amount
of MD time that is consumed by the solvent relaxation dynamics, which then improves the computational
performance of the calculation. Here is an example of input variables to be used in your sander or pmemd input
ﬁle for explicit solvent constant Redox Potential simulations.

icnste=2, ntcnste=100, ntrelaxe=200,
solve=-0.203, saltcon=0.1, temp0=300.0,
ntc=2, ntf=2

Notice that the value of icnste is 2, which indicates that constant Redox Potential MD should be run in explicit
solvent. The ntrelaxe ﬂag will run solvent relaxation dynamics (in which the non-solvent is held ﬁxed) for
200 steps. The saltcon variable controls the salt concentration for the GB calculations. It has no effect on the
dynamics, but is required for consistency with the reference energy of the model compound.

532

25.3. Analyzing constant Redox Potential simulations

25.3. Analyzing constant Redox Potential simulations

As the simulation progresses, the redox states that are sampled are written to the ceout ﬁle. A section of a ceout

ﬁle for an implicit solvent simulation is shown here:

-0.2800000 V Temperature:

300.00 K

2

Redox potential:
Monte Carlo step size:
Time step:
Time:
Residue
Residue

0.000
0 State: 0
1 State: 0

0

Residue

0 State: 1

Residue

1 State: 1

Residue

1 State: 0

Residue

1 State: 1

Residue

0 State: 0

Residue

1 State: 1

One record is written on each Monte Carlo step. Each record is terminated by a blank line. There are two types of
records: full records and delta records. Full records list the Redox Potential, Temperature, MC step size, current
time step, and current time before listing every residue in the system. Full records are written on the ﬁrst step
and every ntwx steps afterwards so as to coincide with the frames written to the trajectory. Delta records list only
those redox-active residues that were titrated (single line for implicit solvent or a list of every residue for explicit
solvent). Note that in some cases, the redox state for a delta record may be the same as that in an earlier record:
this indicates that the Monte Carlo reduction move was rejected for that residue. The residue numbers in ceout
are indices over the titrating residues included in the cein ﬁle; ceout ﬁles must be analyzed in conjunction with the
cein to map these indices back to the original system.

The cestats program can be used to perform several different analyses on the ceout ﬁles. It prints the fraction of
reduced species, which can be used to compute the Eo values of each redox-active titratable residue. The cestats
usage is described in Section 25.6.

25.4. Extending constant Redox Potential to additional titratable groups

In order to do this, you must ﬁrst deﬁne the partial charges of each atom in the redox-active residue for each
redox state. Afterwards, you must set the relative energies of each redox state. This procedure is similar to the one
described in Section 24.5 for CpHMD. Therefore, please refer to it for more information. The reference energies
of redox-active titratable residues can be found by using TI calculations and also by using the ﬁnddgref.py tool
(see Subsection 24.5.1 having in mind that in the cein ﬁle you should be looking to the ELECCNT ﬂag instead of
PROTCNT). To see an example of how a redox-active titratable residue is deﬁned inside $AMBERHOME/Amber-
Tools/src/parmed/parmed/amber/titratable_residues.py look for the deﬁnitions of the residue HEH inside this ﬁle.
Please notice that the pka and pka_corr values actually correspond to standard redox potential values.

25.5. Redox Potential Replica Exchange MD

Redox Potential Replica Exchange simulations can be performed in both implicit or explicit solvent. The pro-
cedure to setup the replica exchange simulation is the same in implicit or explicit solvent. The Redox Potential

533

25. Constant Redox Potential calculations

Replica Exchange MD method (E-REMD) is described in Section 23.3.8, thus please refer to this section for fur-
ther information. E-REMD dramatically improves redox state and conformational state sampling, so we suggest
using it whenever possible.

25.6. cestats

cestats was adapted by Vinícius Cruzeiro from the cphstats program written by Jason Swails in order to
allow the computation of redox state statistics from constant Redox Potential simulations (in both implicit and
explicit solvent). cestats contains all functionalities from cphstats and a very similar usage (a few ﬂag names
differ). Therefore, please refer to Section 24.7 for more information on how to use it. You can access a list and
description of all available command-line ﬂags using the --help ﬂag, whose output is shown below.

Usage: cestats [-O] [-V] [-h] [-i <cein>] [-t] [-o FILE] [-R FILE -r INT]

[--chunk INT --chunk-out FILE] [--cumulative --cumulative-out FILE]
[-v INT] [-n INT] [-p|-d] [--calceo|--no-calceo] [--fix-remd]
[--population FILE] [-c CONDITION -c CONDITION -c ...]
[--conditional-output FILE] [--chunk-conditional FILE]
ceout1 [ceout2 [ceout3 ...] ]

General Options:

Print this help and exit.

-h, --help
-V, --version Print the version number and exit.
-O, --overwrite
--debug

Allow existing outputs to be overwritten.

--expert

--novice

Print out information about the files that are
being read in and used for the calculations.
I will consider you an expert user and NOT warn
you if you try to compute statistics from REMD-based
files before using --fix-remd [NOT default behavior]
I will warn you if you try to use REMD-based files
to compute statistics. [Default behavior]

Input Files and Options:
-i FILE, --cein FILE

Input cein file (from pmemd or sander) with titrating residue
information.
-t FLOAT, --time-step FLOAT

This is the time step in ps you used in your simulations.
It will be used to print data as a function of time.
Default is 2 fs (0.002)

Output Files:

-o FILE, --calceo-output FILE

File to which the standard ‘calceo’-type statistics
are written. Default is stdout

-R FILE, --running-avg-out FILE

Output file where the running averages of time series
data for each residue is printed (see [Output Options]
below for details). Default is [running_avgs.dat]

--chunk-out FILE

Output file where the time series data calculated
over chunks of the simulation are printed (see
[Output Options] below for details).
Default is [chunk.dat]

--cumulative-out FILE

Output file where the cumulative time series data
is printed (see [Output Options] below for details).
Default is [cumulative.dat]

--population FILE

Output file where reduction state populations are

534

--conditional-output FILE

printed for every state of every residue.

Output file with requested conditional probabilities.
Default is [conditional_prob.dat].

--chunk-conditional FILE

Prints a time series of the conditional probabilities over
a trajectory split up into chunks.

Output Options:

These options modify how the output files will appear

-v INT, --verbose INT

Controls how much information is printed to the
calceo-style output file. Options are:

(0) Just print fraction reduced. [Default]
(1) Print everything calceo prints.

-n INT, --interval INT

An interval between which to print out time series data
like ‘chunks’, ‘cumulative’ data, and running averages.
It is also used as the ’window’ of the conditional
probability time series (--chunk-conditional).
Default [1000]

Print out reduction fraction instead of oxidation
fraction in time series data (Default behavior).

Print out oxidation fraction instead of reduction
fraction in time series data.
Print predicted Eos (via Nernst equation) in place
of fraction reduced or oxidized. NOT default behavior.

-p, --reduced

-d, --oxidized

-a, --Eo

Analysis Options:

These options control which analyses are done. By default, only
the original, calceo-style analysis is done.

--calceo
--no-calceo
-r WINDOW, --running-avg WINDOW

Triggers the calceo-style output [On by default]
Turns off the calceo-style output

Defines a window size for a moving, running average
time series. <WINDOW> is the number of MD steps (NOT
the number of MC exchange attempts).

--chunk WINDOW

--cumulative

Computes the time series data over a chunk of the
simulation of size <WINDOW> time steps. See above for
details.
Computes the cumulative average time series data (see above
for options) over the course of the trajectory.

--fix-remd PREFIX

This option will trigger cestats to reassemble the

titration data into Redox potential specific ensembles. This

is an exclusive mode of the program---no other
analyses will be done.

-c CONDITIONAL, --conditional CONDITIONAL

Evaluates conditional probabilities. CONDITIONAL should be a
string of the format:

<resid>:<state>,<resid>:<state>,...

or

or

<resid>:REDU,<resid>:OXID,...

<resid>:<state1>;<state2>,<resid>:REDU,...

Where <resid> is the residue number in the prmtop (NOT the

25.6. cestats

535

25. Constant Redox Potential calculations

cein) and <state> is either the state number or p (reduced)
or d (oxidized), case-insensitive

This program analyzes constant Redox potential output files (ceout) from Amber.
These output files can be compressed using gzip compression. The
compression will be detected automatically by the file name extension.
You must have the gzip headers for this functionality to work.

536

26. Continuous constant pH molecular dynamics

Continous constant pH molecular dynamics based on λ dynamics is an alternative to the Monte Carlo based
constant pH molecular dynamics methods described in section 24. Titration variables (λ particles) are added to the
system to control the protonation states of titratable molecules, and these variables are integrated with a Langevin
integrator in an extended-Lagrangian fashion. Titratable groups with two competitive protonation sites (e.g., His,
Asp and Glu) are treated by adding an additional variable x to control the tautomeric states. These variables are
integrated in the same fashion as the normal titration variables.

Continuous constant pH MD can be performed in three modes: implicit solvent (iphmd=1), [569–571]hybrid
solvent (iphmd=2),[572]and all-atom (iphmd=3).[573–575] In the implicit-solvent mode, both conformational and
protonation state sampling is performed using a generalized Born (GB) model. In the hybrid-solvent mode, con-
formational sampling is performed in explicit solvent, while protonation state sampling is performed using the GB
model (i.e., forces on λ particles are derived using the GB model). A similar scheme is adopted in the explicit-
solvent mode of the Monte-Carlo based CpHMD. In the all-atom mode, both conformational and protonation state
sampling is performed in the explicit solvent. We note, currently, the code runs only in the implicit solvent mode,
employing the GB-Neck2 model. [570]We also note that the current code is for CPU’s.

In order to obtain accurate/precise pKa values within a few ns of simulation time, we recommend the users to
adopt the temperature [576]or pH replica exchange protocol.[572] Due to the direct coupling between protona-
tion/deprotonation and conformational dynamics, ﬂuctuation in the protonation states is very large, resulting in
large noise in the associated pKa’s. It has been shown that the use of temperature or pH replica exchange protocol
can accelerate the convergence of pKa values by at least ten fold. Often times, without the use of replica exchange,
simulations would not be converged at all. The pH replica exchange protocol is an efﬁcient way to enhance sam-
pling, as it is often desirable to simulate at different pH conditions and using pH replica exchange would not add
extra computational cost.

26.1. Implementation notes

To account for the changing protonation states, we attach variables (λ and X if double site is applicable) to each
titratable group. After giving them mass, these variables can be treated as ﬁctitious particles and propagated with
a Langevin integrator in an extended Lagrangian approach. For residues with a single titration site (eg. lysine),
λ = 0 when the proton is present and 1 when it is absent. For residues with two different deprotonated states and a
single protonated state (eg. His) X = 0 corresponds to one of the deprotonated states and 1 the other. Once again,
λ = 0 means that the system is protonated and 1 means that it is deprotonated. Similarly, for residues with one
deprotonated and two protonated states (eg. Asp and Glu), X = 1 and λ = 0 corresponds to one of the protonated
states, X = 0 and λ = 0 to the other, and λ = 1 to the deprotonated state. We then interpolate between these
different states by linearly scaling the charge on the titrating hydrogens and their van der Waals interactions with
the surrounding atoms.

Since X and λ have should vary between 0 and 1, direct integration is tricky. To circumvent this problem, we
introduce auxiliary variables θ and θx, where λ = sin2 (θ ) and x = sin2 (θx). These variables do not have hard
barriers and can adopt any real value. Therefore, rather than computing ∂U/∂λ and ∂U/∂ x , we compute ∂U/∂θ
and ∂U/∂θx and integrate θ and θx.

Because the method does not describe bond breakage and formation, the absolute pKa cannot be computed.
Instead, the difference between the pKa of the residue in the solute relative to its pKa in solution (by using a model
compound) is computed. Typically, blocked single amino acids are used as the reference compounds. Reference
potentials of mean force (PMF) in λ and if necessary X (U mod(λ ,X)) are computed, and these PMF’s are subtracted
from the potential energy, leading to an approximately ﬂat PMF for the residue at its reference pKa. To ensure the
pH dependence of the protonation state, we add a pH-dependent free energy (UpH), and to ensure that the system

537

26. Continuous constant pH molecular dynamics

remains near the endpoints of λ and X we add a quadratic penalty potential centered in the middle point of lambda
(Ubar) to the potential energy.

For the GB calculations, the intrinsic Born radius is, in principle, dependent on λ . However, the implementation
would become very complicated. Thus, we made the following compromises. For Lys and His, the contributions
from the dummy hydrogens are present in both the protonated and deprotonated state. For Asp and Glu, the
contributions of the dummy hydrogens to the Born radii calculations are excluded for both the protonated and
deprotonated states. Additionally, the intrinsic Born radius of the His hydrogens was reduced from the GB-Neck2
default value of 1.3 to 1.17 Å to reduce the salt-bridge formation involving His.

For Asp and Glu, only one proton is ever present on the side chain. Therefore, to avoid the interactions between

the two dummy hydrogens, we used the parmed utility to add an explicit exclusion between these atoms.

26.2. Usage description

When generating a structure for a continuous CpHMD run in leap, the ff14SB force ﬁeld should be loaded, and
the PBradii should be set to mbondi3. Next, phmd.lib should be loaded to load the deﬁnitions of AS2 and GL2,
variants of ASP and GLU with dummy hydrogens on the titration sites. Finally, frcmod.phmd should be loaded
to add some dihedrals necessary for these new residue types and to increase the barrier between the syn- and anti-
conformations of AS2 and GL2. syn- has been demonstratd to be more favorable in quantum and other studies;
however, anti- might be stabilized in a particular protein environment; this is a topic of future study. If desired,
other force ﬁelds or PBradii could be used, but new parameters for the model compounds would need to be derived.
ASP and GLU residues should be identiﬁed as AS2 and GL2, and HIS residues as HIP so that the proper number
of dummy hydrogens will be added. Next, the intrinsic GB radii of the oxygens bound to the titrating hydrogens in
ASP and GLU should be adjusted to 1.4 Å, and the titrating hydrogens in HIS should have their radii adjusted to
1.17 Å. Finally, exclusions should be added with parmed between the titrating hydrogens in AS2 and GL2. These
atoms should not interact during the simulation.

To use the GB-Neck2 based continous CpHMD, set iphmd=1 in the mdin ﬁle. The solution pH is set by solvph.
When iphmd=1 pmemd takes several additional command line ﬂags. First, a phmd input ﬁle with the namelist
&phmdin as described below should provided with the command-line ﬂag -phmdin. Second, a phmd parameter
ﬁle with the namelist &phmdparm should be provided with the command-line ﬂag -phmdparm. Third, a phmd
restart ﬁle with the namelist &phmdrst will be written to the path speciﬁed by the command-line ﬂag -phmdrstrt.
Fourth, a phmd λ ﬁle will be output to the path speciﬁed by the command-line ﬂag -phmdout, and ﬁnally an
optional restart ﬁle can be provided with the command-line ﬂag -phmdstrt, which can be used to restart a previous
run or to set the titration variables during model potential calculations.

The deﬁnitions and default values of the variables set in these namelists follow:

26.2.1. Variables in the &phmdin namelist

phmdcut

The cutoff distance in angstroms to use in GB calculations in the constant pH simulation. This should
in general be very large, if not large enough to encompass the whole system. Default is 1000 Å.

qmass_phmd The mass of the virtual particles associated with the titration coordinates in amu. In general, this

should be roughly as large as the largest masses in the system. Default is 10 amu.

temp_phmd The temperature of the virtual particles associated with the titration coordinates in Kelvin. Default

is 300 K.

phbeta

iphfrq

The friction constant for the Langevin integrator in ps-1. Default is 5.0 ps-1.

The number of steps between updates of the titration coordinates. Default is 1.

qphmdstart Should the velocities of the virtual particles be regenerated? If true, these velocities are sampled

from the Boltzmann distribution. Otherwise, they are read in from the start ﬁle. Default is true.

nprint_phmd How many steps there should be between prints to the λ ﬁle. Default is 10.

538

26.2. Usage description

prlam

Should the λ values be printed to the λ ﬁle? Default is false.

prderiv

prnlev

outu

phtest

Should the θ and ∂U/∂θ information be output to the output ﬁle? Used for parameterization of new
residues. Default is false.

Determines what gets printed during contiuous CpHMD. If it greater than or equal to 0, the header
information in the output ﬁle is printed. If it is greater than 2, the full output ﬁle is generated. If it is
greater than or equal to 5 more diagnostic data is printed to the mdout ﬁle. Default is 6.

The unit for printing continuous CpHMD diagnostic information. Default is 6.

If equal to 1, θ and θx are ﬁxed. Used for parameterization. Default is 0.

masktitrres The names of the titratable residues.

masktitrrestypes The number of entries in masktitrres.

26.2.2. Variables in the &phmdparm namelist

ngt

numch

The number of titratable residues deﬁned in the parm ﬁle.

An array of the numbers of atoms in the titratable residues deﬁned in the parm ﬁle.

res_name

An array of the names of the titratable residues in the parm ﬁle.

res_type

An array deﬁning the residue types of the titratable residues in the parm ﬁle.

• -2 – coions titrating with linked titratable residues to maintain constant charge, not currently

used.

• 0 – residues with a single titratable hydrogen (eg. lysine).
• 2 – residues with two deprotonated states and a single protonated state with the two deproto-

nated states having different pKa’s (eg. histidine)

• 4 – residues with two protonated states and a single deprotonated state where the two states

have the same pKa (eg. aspartic and glutamic acids).

atom_name A two-dimensional array containing an array for each residue in res_name containing the names of

the atoms in the force ﬁeld.

ch

ch_md

rad

A two dimensional array containing an array for each residue in res_name containing the charges
used in the dynamics of the titration coordinates. For residues of types 0 and -2 the charges of the
protonated state are listed followed by the charges of the deprotonated state. For residues of type 2
the charges of the protonated state are followed by the charges of the two deprotonated states. For
residues of type 4 the charges of the two protonated states are listed followed by the charges of the
deprotonated state.

The same as ch except that it contains the charges used for the calculation of the spatial forces.

A two dimensional array containing an array for each residue in res_name containing ﬂags iden-
tifying which atoms are disappearing during the calculation. Atoms which are going to disappear
are identiﬁed with 1.0 in the deprotonated ﬂags and 0.0 in the protonated ﬂags. Atoms which are
always present are identiﬁed as 0.0 in both sets of ﬂags. For residues of type -2 or 0, ﬁrst the ﬂags
corresponding to the protonated state are listed followed by those for the deprotonated state. For
residues of type 2 the ﬂags of the protonated state are followed by the ﬂags for the two deprotonated
states. For residues of type 4 the ﬂags for the two protonated states are followed by those for the
deprotonated state.

539

26. Continuous constant pH molecular dynamics

model_pka A two dimensional array containing an array for each residue in res_name. For residues of type -2
or 0, the ﬁrst entry in the array is the target pKa of the residue. For residues of type 2 the two entries
of the array correspond to the 2 pKa’s of the two tautomers. For residues of type 4 the target pKa is
the ﬁrst entry in the array.

parameters A two dimensional array containing an array for each residue in res_name containing the parameters
of the model potential for each residue. The ﬁrst two entries in each array are A and B. For residues
of types 2 and 4 the third, fourth, ﬁfth, and sixth entries are A0, B0, A10, and B10. For residues of
type 4 entries 7-12 are R1-R6.

bar

A two dimensional array containing an array for each residue in res_name containing the heights of
the barriers in the model potentials. For residues of types -2 and 0 the ﬁrst entry in this array is the
barrier height in λ . For residues of type 2 and 4 the ﬁrst entry in this array is the barrier height in X,
and the second entry is the barrier height in λ .

26.2.3. Variables in the &phmdstrt namelist

ph_theta

The θ and θX values of the titration coordinates.

vph_theta The velocities of the titration coordinates.

26.2.4. Example phmdin and phmdparm ﬁles

Here is an example of a phmdin ﬁle,

&phmdin

NPrint_PHMD = 250,
PrLam = .true.,
MaskTitrRes(:) = ’AS2’,’GL2’,’HIP’,
MaskTitrResTypes = 4,

/

This ﬁle instructs the code to write λ to the λ ﬁles (prlam=true) every 250 steps. Residues named AS2, GL2, HIP,
and CYS will be titrating.

Here is an example of a phmdparm ﬁle built for the systems set up with the procedure described above,

&phmdparm

NGT = 5,
NUMCH(:) = 14,17,18,22,11,
RES_NAME(:) = ’AS2’,’GL2’,’HIP’,’LYS’,’CYS’,
RES_TYPE(:) = 4,4,2,0,0
ATOM_NAME(1,:) = ’N’,’H’,’CA’,’HA’,’CB’,’HB2’,’HB3’,’CG’,’OD1’,’OD2’,
’HD2’,’C’,’O’,’HD1’,
ATOM_NAME(2,:) = ’N’,’H’,’CA’,’HA’,’CB’,’HB2’,’HB3’,’CG’,’HG2’,’HG3’,
’CD’,’OE1’,’OE2’,’HE2’,’C’,’O’,’HE1’,
ATOM_NAME(3,:) = ’N’,’H’,’CA’,’HA’,’CB’,’HB2’,’HB3’,’CG’,’ND1’,’HD1’,
’CE1’,’HE1’,’NE2’,’HE2’,’CD2’,’HD2’,’C’,’O’,
ATOM_NAME(4,:) = ’N’,’H’,’CA’,’HA’,’CB’,’HB2’,’HB3’,’CG’,’HG2’,’HG3’,
’CD’,’HD2’,’HD3’,’CE’,’HE2’,’HE3’,’NZ’,’HZ1’,’HZ2’,’HZ3’,’C’,’O’,
ATOM_NAME(5,:) = ’N’,’H’,’CA’,’HA’,’CB’,’HB2’,’HB3’,’SG’,’HG’,’C’,’O’
CH(1,:) = -0.415700,0.271900,0.034100,0.086400,-0.031600,0.048800,
0.048800,0.646200,-0.637600,-0.555400,0.00,0.597300,-0.567900,
0.4747,-0.415700,0.271900,0.034100,0.086400,-0.031600,0.048800,
0.048800,0.646200,-0.555400,-0.637600,0.474700,0.597300,-0.567900,
0.00,-0.415700,0.271900,0.034100,0.086400,-0.178200,-0.012200,

540

26.2. Usage description

-0.012200,0.799400,-0.801400,-0.801400,0.00,0.597300,-0.567900,0.00,

CH(2,:) = -0.415700,0.271900,0.014500,0.077900,-0.007100,0.025600,
0.025600,-0.017400,0.043000,0.043000,0.680100,-0.651100,-0.583800,
0.00,0.597300,-0.567900,0.4641,-0.415700,0.271900,0.014500,
0.077900,-0.007100,0.025600,0.025600,-0.017400,0.043000,0.043000,
0.680100,-0.583800,-0.651100,0.464100,0.597300,-0.567900,0.00,

-0.415700,0.271900,0.014500,0.077900,-0.039800,-0.017300,-0.017300,

0.013600,-0.042500,-0.042500,0.805400,-0.818800,-0.818800,0.00,0.597300,

-0.567900,0.00,

CH(3,:) = -0.347900,0.274700,-0.135400,0.121200,-0.041400,0.081000,
0.081000,-0.001200,-0.151300,0.386600,-0.017000,0.268100,

-0.171800,0.391100,-0.114100,0.231700,0.734100,-0.589400,-0.347900,
0.274700,-0.135400,0.121200,-0.111000,0.040200,0.040200,-0.026600,

-0.381100,0.364900,0.205700,0.139200,-0.572700,0.00,0.129200,

0.114700,0.734100,-0.589400,-0.347900,0.274700,-0.135400,0.121200,

-0.101200,0.036700,0.036700,0.18680,-0.543200,0.00,0.163500,0.143500,
-0.279500,0.333900,-0.220700,0.186200,0.734100,-0.589400,

CH(4,:) = -0.347900,0.274700,-0.240000,0.142600,-0.009400,0.036200,
0.036200,0.018700,0.010300,0.010300,-0.047900,0.062100,0.062100,

-0.014300,0.113500,0.113500,-0.38540,0.340000,0.340000,0.340000,

0.734100,-0.589400,-0.347900,0.274700,-0.240000,0.142600,-0.109600,
0.034000,0.034000,0.066120,0.010410,0.010410,-0.037680,0.011550,
0.011550,0.326040,-0.033580,-0.033580,-1.035810,0.00,0.386040,
0.386040,0.734100,-0.589400,
CH(5,:) = -0.415700,0.271900,0.021300,0.112400,-0.123100,0.111200,
0.111200,-0.311900,0.193300,0.597300,-0.567900,-0.415700,0.271900,
0.021300,0.112400,-0.3593,0.112200,0.112200,-0.884400,0.00,0.597300,

-0.567900

CH_MD(1,:) = -0.415700,0.271900,0.034100,0.086400,-0.031600,0.048800,
0.048800,0.646200,-0.637600,-0.555400,0.00,0.597300,-0.567900,0.4747,

-0.415700,0.271900,0.034100,0.086400,-0.031600,0.048800,0.048800,0.646200,
-0.555400,-0.637600,0.474700,0.597300,-0.567900,0.00,-0.516300,0.293600,

0.038100,0.088000,-0.030300,-0.012200,-0.012200,0.799400,-0.801400,

-0.801400,0.00,0.536600,-0.581900,0.00,

CH_MD(2,:) = -0.415700,0.271900,0.014500,0.077900,-0.007100,0.025600,
0.025600,-0.017400,0.043000,0.043000,0.680100,-0.651100,-0.583800,
0.00,0.597300,-0.567900,0.4641,-0.415700,0.271900,0.014500,0.077900,

-0.007100,0.025600,0.025600,-0.017400,0.043000,0.043000,0.680100,
-0.583800,-0.651100,0.464100,0.597300,-0.567900,0.00,-0.516300,

0.293600,0.039700,0.110500,0.056000,-0.017300,-0.017300,0.013600,

-0.042500,-0.042500,0.805400,-0.818800,-0.818800,0.00,0.536600,-0.581900,

0.00,
CH_MD(3,:) = -0.347900,0.274700,-0.135400,0.121200,-0.041400,0.081000,
0.081000,-0.001200,-0.151300,0.386600,-0.017000,0.268100,-0.171800,
0.391100,-0.114100,0.231700,0.734100,-0.589400,-0.415700,0.271900,
0.018800,0.088100,-0.046200,0.040200,0.040200,-0.026600,-0.381100,
0.364900,0.205700,0.139200,-0.572700,0.00,0.129200,0.114700,0.597300,

-0.567900,-0.415700,0.271900,-0.058100,0.136000,-0.007400,0.036700,

0.036700,0.18680,-0.543200,0.00,0.163500,0.143500,-0.279500,0.333900,

-0.220700,0.186200,0.597300,-0.567900,

CH_MD(4,:) = -0.347900,0.274700,-0.240000,0.142600,-0.009400,0.036200,
0.036200,0.018700,0.010300,0.010300,-0.047900,0.062100,0.062100,

-0.014300,0.113500,0.113500,-0.38540,0.340000,0.340000,0.340000,

541

26. Continuous constant pH molecular dynamics

0.734100,-0.589400,-0.415700,0.271900,-0.072060,0.099400,-0.048450,
0.034000,0.034000,0.066120,0.010410,0.010410,-0.037680,0.011550,
0.011550,0.326040,-0.033580,-0.033580,-1.035810,0.00,0.386040,
0.386040,0.597300,-0.567900,
CH_MD(5,:) = -0.415700,0.271900,0.021300,0.112400,-0.123100,0.111200,
0.111200,-0.311900,0.193300,0.597300,-0.567900,-0.415700,0.271900,

-0.035100,0.050800,-0.241300,0.112200,0.112200,-0.884400,0.00,0.597300,
-0.567900

RAD(1,:) = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,
0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
RAD(2,:) = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,0.0,0.0,
RAD(3,:) = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,
RAD(4,:) = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
RAD(5,:) = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,
0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
MODEL_PKA(1,:) = 3.5,
MODEL_PKA(2,:) = 4.2,
MODEL_PKA(3,:) = 6.1,6.6,
MODEL_PKA(4,:) = 10.4,
MODEL_PKA(5,:) = 8.5,
BAR(1,:) = 2.5,2.5,
BAR(2,:) = 2.5,2.5,
BAR(3,:) = 2.5,2.5,
BAR(4,:) = 2.5,
BAR(5,:) = 2.5,
PARAMETERS(1,:) = -60.0334,0.305108,-59.876,0.304068,-21.555,
0.497647,-19.9303,41.6005,-21.5678,0.51803,-59.8132,0.304052,
PARAMETERS(2,:) = -52.4396,0.447635,-52.1586,0.447125,-23.1202,
0.499933,-21.5247,44.8027,-23.166,0.50406,-52.1457,0.447245,
PARAMETERS(3,:) = -47.5760265552,0.487738121,-45.3526708755,
0.4528747997,-38.6267713735,0.5382055867,
PARAMETERS(4,:) = -55.665,0.6655,
PARAMETERS(5,:) = -80.3161983,0.053018419,

/

26.3. Continuous constant pH MD with pH replica exchange

The basic procedure of running a pH replica exchange simulation with continuous CpHMD is identical to that
used with the other constant pH methods in Amber except that the groupﬁle needs to be modiﬁed to include the
appropriate command-line ﬂags and the phmdin and phmdparm input ﬁles must be supplied. After running the
replica exchange simulation trajectories with the frames sorted by pH can be extracted in the same manner using
cpptraj. Analyzing the results of the simulations is different, however, as cphstats does not work with the output
ﬁles from continuous CpHMD, a different method of analyzing the λ ﬁles must be used. First, the replica

542

26.3. Continuous constant pH MD with pH replica exchange

exchange log should be reformatted in a simpler form with the code walker_extraction. This program takes three
arguments, the path to the replica exchange log ﬁle, the number of steps between replica exchange attempts, and
the total number of replica swaps attempted. For example, if the replica exchange log ﬁle were saved as rem.log,
swaps were attempted every 250 steps, and the total simulation length was 500000 steps (4000 swaps), the
command to process the log ﬁle would be

walker_extraction rem.log 250 4000

After the output of this command is saved to a ﬁle, the λ ﬁles produced from the replica exchange simulation have
to be sorted into new λ ﬁles containing the results from a single pH. This sorting is performed by the program
wrap_traj. It takes six arguments:

1. The path to the simpliﬁed replica exchange log produced in the previous step.

2. The path to a list of the pH values used in the replica exchange simulation. Eg., if the simulation were run

with pH’s ranging from 4-7 in increments of 0.5 units, this ﬁle would look like

4
4.5
5
5.5
6
6.5
7

3. The path to a ﬁle containing a list of the λ ﬁles produced by the replica exchange simulation arranged in

order by pH.

4. The number of steps in the simulation (Eg. for a 2 fs time step 1 ns would correspond to 500000 steps).

5. The number of steps between replica exchange attempts.
6. The number of steps between prints to the λ ﬁles.

For example, if the simpliﬁed replica exchange log were saved as repwalk.dat, the list of pH’s were saved as
ph_list.dat, the list of λ ﬁles were saved as ﬁle_list.dat, the simulation was run for 1 ns with a 2 fs time step,
replica exchanges were attempted every 250 steps, and the λ values were printed every 250 steps, the command
would be

wrap_traj repwalk.txt ph_list.dat file_list.dat 500000 250 250

This command will produce a set of ﬁles called out.phPH.lambda, where PH is the pH of the λ ﬁle. These ﬁles
now have to be processed to extract the pKa’s of the residues. First, remove all ﬁles ending in .lambda from the
directory except these out.phPH.lambda ﬁles. Now, call the script renameLamb.sh. This script takes two
arguments, the ﬁrst lambda value that you want to consider, and the ﬁnal lambda value that you want to consider.
For example, for the run described above there will be 2000 lambda values in each ﬁle. If you wanted to include
all of these values in your analysis you would run

renameLamb.sh 0 2000

This script will rename the ﬁles as phPH.lambda and produce .sx ﬁles needed for the next step.

Finally, you need to ﬁt the data to the Henderson–Hasselbalch equation to obtain the pKa’s. This is done with

the script getS_ﬁtpKa_plot_taut.sh. This script calls xmgrace and gnuplot, which must be installed on the
machine to perform the ﬁt and plot the titration curves. It takes the string pH, a name string that will be used to
name the resulting ﬁles, the lowest pH you used, the highest pH you used, an initial guess for the pKa (6 tends to
work well), and an initial guess for the Hill coefﬁcient (1 works well). Eg.,

getS_fitpKa_plot_taut.sh ph BBL 4 7 6 1

This script will create several ﬁles, including a ﬁle NAME_all_pka.dat, which contains the pKa values for all
titratable residues in the protein and .png ﬁles showing the titration curves for all of the titratable residues.

543

26. Continuous constant pH molecular dynamics

26.4. Obtaining parameters for a novel titratable group

The ﬁrst step to obtaining parameters for a novel residue is to construct a model compound whose pKa is known.
For the standard protein residues, the residue in question blocked with ACE and NHE caps is sufﬁcient. Next, a
phmdparm ﬁle must be created with entries containing the atom names, charges, and ﬂags for identifying which
atoms are present in the van der Waals calculations in each state. The parameters for the residue do not need to be
reasonable, as you will be running simulations with ﬁxed values of λ and possibly X, where the model potentials
are not calculated. Next, a series of simulations need to be run to obtain ∂U/∂λ and if necessary ∂U/∂ X at a
series of values of λ and X. The values of the titration coordinates should be set in the phmdstrt ﬁle, and the
phmdin ﬁle should have the phtest and printderiv ﬂags set to true and the printlam ﬂag set to false. The resulting
simulations will yield estimates of ∂U/∂λ and if necessary ∂U/∂ X that should be ﬁt to the forms of the energy
function described in earlier publications. The resulting parameters can then be added to the phmdparm ﬁle and a
normal simulation can be run.

544

27. NMR reﬁnement

We ﬁnd the sander module to be a ﬂexible way of incorporating a variety of restraints into a optimization
procedure that includes energy minimization and dynamical simulated annealing. The "standard" sorts of NMR
restraints, derived from NOE and J-coupling data, can be entered in a way very similar to that of programs like
DISGEO, DIANA or X-PLOR; an aliasing syntax allows for deﬁnitions of pseudo-atoms, connections with peak
numbers in spectra, and the use of "ambiguous" constraints from incompletely-assigned spectra. More "advanced"
features include the use of time-averaged constraints, use of multiple copies (LES) in conjunction with NMR
reﬁnement, and direct reﬁnement against NOESY intensities, paramagnetic and diamagnetic chemical shifts, or
residual dipolar couplings. In addition, a key strength of the program is its ability to carry out the reﬁnements
(usually near the ﬁnal stages) using an explicit-solvent representation that incorporates force ﬁelds and simulation
protocols that are known to give pretty accurate results in many cases for unconstrained simulations; this ability
should improve predictions in regions of low constraint density and should help reduce the number of places where
the force ﬁeld and the NMR constraints are in "competition" with one another.

Since there is no generally-accepted "recipe" for obtaining solution structures from NMR data, the comments
below are intended to provide a guide to some commonly-used procedures. Generally speaking, the programs that
need to be run to obtain NMR structures can be divided into three parts:

1. front-end modules, which interact with NMR databases that provide information about assignments, chem-
ical shifts, coupling constants, NOESY intensities, and so on. We have tried to make the general format of
the input straightforward enough so that it could be interfaced to a variety of programs. We generally use
the FELIX and NMRView codes, but the principles should be similar for other ways of keeping track of a
database of NMR spectral information. As the ﬂow-chart in Section 27.7 indicates, there are only a few
ﬁles that need to be created for NMR restraints; these are indicated by the solid rectangles. The primary
distance and torsion angle ﬁles have a fairly simple format that is largely compatible with the DIANA pro-
grams; if one wishes to use information from ambiguous or overlapped peaks, there is an additional "MAP"
ﬁle that makes a translation from peak identiﬁers to ambiguous (or partial) assignments. Finally, there are
some specialized (but still pretty straightforward) ﬁle formats for chemical shift or residual dipolar coupling
restraints.
There are a variety of tools, besides the ones described below, that can assist in preparing input for structure
reﬁnement in Amber.

• The SANE (Structure Assisted NOE Evaluation) package, http://ambermd.org/sane.zip, is widely used

at The Scripps Research Institute.[577]

• If you use Bruce Johnson’s NmrView package, you might also want to look at the additions to
that: http://garbanzo.scripps.edu/nmrgrp/wisdom/pipe/tips_scripts.html. In particular, the xpkTOupl
and starTOupl scripts there convert NmrView peak lists into the "7-column" needed for input to
makeDIST_RST.

• Users of the MARDIGRAS programs from UCSF can use the mardi2amber program to do conversion

to Amber format: http://picasso.ucsf.edu/mardihome.html

2. restrained molecular dynamics, which is at the heart of the conformational searching procedures. This is the

part that sander itself handles.

3. back-end routines that do things like compare families of structures, generate statistics, simulate spectra,
and the like. For many purposes, such as visualization, or the running of procheck-NMR, the "interface"
to such programs is just the set of PDB ﬁles that contain the family of structures to be analyzed. These
general-purpose structure analysis programs are available in many locations and are not discussed here. The

545

27. NMR reﬁnement

principal sander-speciﬁc tool is sviol, which prepares tables and statistics of energies, restraint violations,
and the like.

27.1. Distance, angle and torsional restraints

Distance, angle, and other restraints are read from the DISANG ﬁle if nmropt > 0. Namelist rst ("&rst")
contains the following variables; it is read repeatedly until a namelist &rst statement is found with IAT(1)=0, or
until reaching the end of the DISANG ﬁle.

[In many cases, the user will nkot prepare this section of the input by hand, but will use the auxiliary programs
makeDIST_RST, makeANG_RST and makeCHIR_RST to prepare input from simpler ﬁles. See also the programs
cyanarest_to_amberRST and nef_to_RST if you have restraints in Cyana or NEF (NMR Exchange Format) for-
mats.]

27.1.1. Variables in the &rst namelist:
iat(1)→iat(8)

• If IRESID = 0 (normal operation): The atoms deﬁning the restraint. Type of restraint is determined (in

order) by:

1. If IAT(3) = 0, this is a distance restraint.
2. If IAT(4) = 0, this is an angle restraint.
3. If IAT(5) = 0, this is a torsional (or J-coupling, if desired) restraint or a genereralized distance restraint

of 4 atoms, a type of restraint new as of Amber 10 (sander only, see below).

4. If IAT(6) = 0, this is a plane-point angle restraint, a second restraint new as of Amber 10 (sander only).
The angle is measured between the normal of a plane deﬁned by IAT(1)..IAT(4) and the vector from
the center of mass of atoms IAT(1)..IAT(4) to the position of IAT(5). The normal is deﬁned by (r1 - r2)
× (r3 - r4), where rn is the position of IAT(n).

5. If IAT(7) = 0, this is a generalized distance restraint of 6 atoms (see below).
6. Otherwise, if IAT(1)..IAT(8) are all nonzero, this is a plane- plane angle restraint, a third new restraint
type as of Amber 10 (sander only, or a generalized distance restraint of 8 atoms (see below). For the
plane-plane restraint, the angle is measured between the two normals of the two planes, which are
deﬁned by (r1 - r2) × (r3 - r4) and (r5 - r6) × (r7 - r8). In the case of either planar restraint, the plane
may be deﬁned using three atoms instead of four simply by using one atom twice.

If any of IAT(n) are < 0, then a corresponding group of atoms is deﬁned below, and the coordinate- averaged
position of this group will be used in place of atom IAT(n). A new feature as of Amber 10, atom groups
may be used not only in distance restraints, but also in angle, torsion, the new plane restraints, or the new
generalized restraints. If this is a distance restraint, and IAT1 <0, then a group of atoms is deﬁned below, and
the coordinate-averaged position of this group will be used in place of the coordinates of atom 1 [IAT(1)].
Similarly, if IAT(2) < 0, a group of atoms will be deﬁned below whose coordinate-averaged position will be
used in place of the coordinates for atom 2 [IAT(2)].

• If IRESID=1: IAT(1)..IAT(8) point to the *residues* containing the atoms comprising the internal. Residue
numbers are the absolute in the entire system. In this case, the variables ATNAM(1)..ATNAM(8) must be
speciﬁed and give the character names of the atoms within the respective residues. If any of IAT(n) are less
than zero, then group input will still be read in place of the corresponding atom, as described below.
• Defaults for IAT(1)→IAT(8) are 0.

rstwt(1)→rstwt(4) New as of Amber 10 (sander only), users may now deﬁne a single restraint that is a func-
tion of multiple distance restraints, called a "generalized distance coordinate" restraint. The energy
of such a restraint has the following form:

546

27.1. Distance, angle and torsional restraints

U = k(w1|r1 − r2| + w2|r3 − r4| + w3|r5 − r6| + w4|r7 − r8|− r0)2
where the weights wnare given in rstwt(1)..rstwt(4) and the positions rnare the positions of the atoms
in iat(1)..iat(8).
Generalized distance coordinate restraints must be deﬁned with either 4, 6, or 8 atoms and 2, 3, or
4 corresponding nonzero weights in rstwt(1)..rstwt(4). Weights may be any positive or negative real
number.
If all the weights in rstwt(1)..rstwt(4) are zero and four atoms are given in iat(1)..iat(4) for the re-
straint, the restraint is a torsional or J-coupling restraint. If eight atoms are given in iat(1)..iat(8)
and all weights are zero, the restraint is a plane-plane angle restraint. However, if the weights are
nonzero, the restraint will be a generalized distance coordinate restraint.
Default for rstwt(1)..rstwt(4) is 0.0

restraint New as of Amber 10 (sander only), users may now use a "natural language" system to deﬁne
restraints by using the RESTRAINT character variable. Valid restraints deﬁned in this manner will
begin with a "distance( )" "angle( )" "torsion( )" or "coordinate( )" keyword. Within the parentheses,
the atoms that make up the restraint are speciﬁed. Atoms may be deﬁned either with an explicit atom
number or by using ambmask format, namely :(residue#)@(atom name). Atoms may be separated
by commas, spaces, or parentheses. Additionally, negative integers may be used if atom groupings
are deﬁned in other variables in the namelist as described below. In addition to the principle distance,
angle, torsion, and coordinate keywords, Some keywords may be used within the principle keywords
to deﬁne more complicated restraints. The keyword "plane( )" may be used once or twice within the
parentheses of the "angle( ) keyword to deﬁne a planar restraint. Deﬁning one plane grouping plus
one other atom in this manner will create a plane-point angle restraint as described above. Deﬁning
two plane groupings will create a plane-plane angle restraint. The keyword "plane( )" may only be
used inside of "angle( )," and is necessary to deﬁne either a plane-point or plane-plane restraint.
Within the "coordinate( )" keyword, the user must use 2 to 4 "distance( )" keywords to deﬁne a
generalized distance coordinate restraint. The "distance( )" keyword functions just like it does when
used to deﬁne a traditional distance restraint. The user may specify any two atom numbers, masks,
or negative numbers corresponding to atom groups deﬁned outside of RESTRAINT. Additionally,
following each "distance( )" keyword inside "coordinate( )" the user must specify a real-number
weight to be applied to each distance making up the generalized coordinate.
The "com( )" keyword may be used within any other keyword to deﬁne a center of mass grouping
of atoms. Within the parenthesis, the user will enter a list of atom numbers or masks. Negative
numbers, which correspond to externally-deﬁned groups, may not be used.
Any type of parenthetical character, i.e., ( ), [ ], or { }, may be used wherever parentheses have been
used above.

The following are all examples of valid restraint deﬁnitions:

restraint = "distance( (45) (49) )"
= "angle (:21@C5’ :21@C4’ 108)"
= "torsion[-1,-1,-1, com(67, 68, 69)]"
= "angle( -1, plane(81, 85, 87, 90) )"
= "angle(plane(com(9,10),:5@CA,31,32),plane(14,15,15,16))"
= "coordinate(distance(:5@C3’,:6@O5’),-1.0,distance(134,-1),1.0)"

There is a 256 character limit on RESTRAINT, so if a particularly large atom grouping is desired,
it is necessary to specify a negative number instead of "com( )" and deﬁne the group as described
below. RESTRAINT will only be parsed if IAT(1) = 0, otherwise the information in IAT(1) .. IAT(8)
will deﬁne the restraint. Default for restraint is ’ ’.

atnam

If IRESID = 1, then the character names of the atoms deﬁning the internal are contained in
ATNAM(1)→ATNAM(8). Residue IAT(1) is searched for atom name ATNAM(1); residue IAT(2) is
searched for atom name ATNAM(2); etc. Defaults for ATNAM(1)→ATNAM(8) are ’ ’.

547

27. NMR reﬁnement

iresid

Indicates whether IAT(I) points to an atom # or a residue #. See descriptions of IAT() and ATNAM()
above. If RESTRAINT is used to deﬁne the internal instead of IAT(), IRESID has no effect on how
RESTRAINT is parsed. However, it will affect the behavior of atom group deﬁnitions as described
below if negative numbers are speciﬁed within RESTRAINT. Default = 0.

irstyp

nstep1, nstep2 This restraint is applied for steps/iterations NSTEP1 through NSTEP2. If NSTEP2 = 0, the
restraint will be applied from NSTEP1 through the end of the run. Note that the ﬁrst step/iteration is
considered step zero (0). Defaults for NSTEP1, NSTEP2 are both 0.
Normally, the restraint target values deﬁned below (R1→R4) are used directly. If IRSTYP = 1, the
values given for R1→R4 deﬁne relative displacements from the current value (value determined from
the starting coordinates) of the restrained internal. For example, if IRSTYP=1, the current value of a
restrained distance is 1.25, and R1 (below) is -0.20, then a value of R1=1.05 will be used. Default is
IRSTYP=0.

ialtd

ifvari

ninc

imult

Determines what happens when a distance restraint gets very large. If IALTD=1, then the potential
"ﬂattens out", and there is no force for large violations; this allows for errors in constraint lists, but
might tend to ignore constraints that should be included to pull a bad initial structure towards a more
correct one. When IALTD=0 the penalty energy continues to rise for large violations. See below
for the detailed functional forms that are used for distance restraints. Set IALTD=0 to recover the
behavior of earlier versions of sander. Default value is 0, or the last value that was explicitly set in a
previous restraint. This value is set to 1 if makeDIST_RST is called with the -altdis ﬂag.

If IFVARI > 0, then the force constants/positions of the restraint will vary with step number. Other-
wise, they are constant throughout the run. If IFVARI >0, then the values R1A→R4A, RK2A, and
RK3A must be speciﬁed (see below). Default is IFVARI=0.
If IFVARI > and NINC > 0, then the change in the target values of of R1→R4 and K2,K3 is applied
as a step function, with NINC steps/ iterations between each change in the target values. If NINC
= 0, the change is effected continuously (at every step). Default for NINC is the value assigned to
NINC in the most recent namelist where NINC was speciﬁed. If NINC has not been speciﬁed in any
namelist, it defaults to 0.

If IMULT=0, and the values of force constants RK2 and RK3 are changing with step number, then
the changes in the force constants will be linearly interpolated from rk2→rk2a and rk3→rk3a as the
step number changes. If IMULT=1 and the force constants are changing with step number, then the
changes in the force constants will be effected by a series of multiplicative scalings, using a single
factor, R, for all scalings. i.e.

rk2a = R**INCREMENTS * rk2
rk3a = R**INCREMENTS * rk3.

INCREMENTS is the number of times the target value changes, which is determined by NSTEP1,
NSTEP2, and NINC. Default for IMULT is the value assigned to IMULT in the most recent namelist
where IMULT was speciﬁed. If IMULT has not been speciﬁed in any namelist, it defaults to 0.

r1→r4, rk2, rk3, r1a→r4a, rk2a, rk3a If IALTD=0, the restraint is a well with a square bottom with
parabolic sides out to a deﬁned distance, and then linear sides beyond that. If R is the value of the
restraint in question:

• R < r1 Linear, with the slope of the "left-hand" parabola at the point R=r1.
• r1 <= R < r2 Parabolic, with restraint energy k2(R− r2)2.
• r2 <= R < r3 E = 0.
• r3 <= R < r4 Parabolic, with restraint energy k3(R− r3)2.
• r4 <= R Linear, with the slope of the "right-hand" parabola at the point R=r4.

548

27.1. Distance, angle and torsional restraints

For torsional restraints, the value of the torsion is translated by +-n*360, if necessary, so that it falls
closest to the mean of r2 and r3. Speciﬁed distances are in Angstroms. Speciﬁed angles are in de-
grees. Force constants for distances are in kcal/mol-Å2 Force constants for angles are in kcal/mol-rad
2 . (Note that angle positions are speciﬁed in degrees, but force constants are in radians, consistent
with typical reporting procedures in the literature).
If IALTD=1, distance restraints are interpreted in a slightly different fashion. Again, If R is the value
of the restraint in question:

• R < r2 Parabolic, with restraint energy k2(R− r2)2.
• r2 <= R < r3 E = 0.
• r3 <= R < r4 Parabolic, with restraint energy k3(R− r3)2.
• r4 <= R Hyperbolic, with energy k3[b/(R− r3) + a], where a = 3(r4 − r3)2 and b = −2(r4 −
r3)3. This function matches smoothly to the parabola at R = r4, and tends to an asymptote of
ak3at large R. The functional form is adapted from that suggested by Michael Nilges, Prot.
Eng. 2, 27-38 (1988). Note that if ialtd=1, the value of r1 is ignored.

= 0 The values of r1→r4, rk2, and rk3 will remain constant throughout the run.
> 0 The values r1a, r2a, r3a, r4a, r2ka and r3ka are also used. These variables are deﬁned as for
r1→r4 and rk2, rk3, but correspond to the values appropriate for NSTEP = NSTEP2: e.g.,
if IVARI >0, then the value of r1 will vary between NSTEP1 and NSTEP2, so that, e.g.
r1(NSTEP1) = r1 and r1(NSTEP2) = r1a. Note that you must specify an explicit value for
nstep1 and nstep2 if you use this option. Defaults for r1→r4,rk2,rk3,r1a→r4a,rk2a and rk3a
are the values assigned to them in the most recent namelist where they were speciﬁed. They
should always be speciﬁed in the ﬁrst &rst namelist.

ifvari

r0, k0, r0a, k0a New as of Amber 10 (sander only), the user may more easily specify a large parabolic well
if desired by using R0 and K0, and then R0A and K0A if IFVARI > 0. The parabolic well will have
its zero at R = R0 and a force constant of K0. These variables simply map the disired parabolic well
into r1→r4, rk2, rk3, r1a→r4a, rk2a, and rk3a in the following manner:

• R1 = 0 for distance, angle, and planar restraints, R1 = R0 - 180 for torsion restraints
• R1A = 0 for distance, angle, and planar restraints, R1A = R0A - 180 for torsion restraints
• R2 = R0; R3 = R0
• R2A = R0A; R3A = R0A
• R4 = R0 + 500 for distance restraints, R4 = 180 for angle and planar restraints, R4 = R0 + 180

for torsion restraints

• RK2 = K0; RK3 = K0
• RK2A = K0A; RK3A = K0A

rjcoef(1)→rjcoef(3) By default, 4-atom sequences specify torsional restraints. It is also possible to impose
restraints on the vicinal 3 J-coupling value related to the underlying torsion. J is related to the torsion
τ by the approximate Karplus relationship: J = Acos2(τ) + Bcos(τ) +C. If you specify a nonzero
value for either RJCOEF(1) or RJCOEF(2), then a J-coupling restraint, rather than a torsional re-
straint, will be imposed. At every MD step, J will be calculated from the Karplus relationship with
A = RJCOEF(1), B = RJCOEF(2) and C = RJCOEF(3). In this case, the target values (R1->R4,
R1A->R4A) and force constants (RK2, RK3, RK2A, RK3A) refer to J-values for this restraint.
RJCOEF(1)->RJCOEF(3) must be set individually for each torsion for which you wish to apply a
J-coupling restraint, and RJCOEF(1)->RJCOEF(3) may be different for each J-coupling restraint.
With respect to other options and reporting, J-coupling restraints are treated identically to torsional
restraints. This means that if time-averaging is requested for torsional restraints, it will apply to
J-coupling restraints as well. The J-coupling restraint contribution to the energy is included in the
"torsional" total. And changes in the relative weights of the torsional force constants also change

549

27. NMR reﬁnement

the relative weights of the J-coupling restraint terms. Setting RJCOEF has no effect for distance and
angle restraints. Defaults for RJCOEF(1)->RJCOEF(3) are 0.0.

igr1(i),i=1→200, igr2(i),i=1→200, ... igr8(i),i..1=1→200 If IAT(n) < 0, then IGRn() gives the atoms deﬁning the
group whose coordinate averaged position is used to deﬁne "atom n" in a restraint. Alternatively, if RESTRAINT
is used to deﬁne the internal, then if the nth atom speciﬁed is a number less than zero, IGRn() gives the atoms
deﬁning the group whose coordinate averaged position is used to deﬁne "atom n" in a restraint. If IRESID = 0,
absolute atom numbers are speciﬁed by the elements of IGRn(). If IRESID = 1, then IGRn(I) speciﬁes the number
of the residue containing atom I, and the name of atom I must be speciﬁed using GRNAMn(I). A maximum of 200
atoms (N # of atoms if using pmemd) are allowed in any group. Only specify those atoms that are needed. Default
value for any unspeciﬁed element of IGRn(i) is 0.

fxyz

If iat(3)=0 and igr1 and/or igr2 is deﬁned then it is possible to weight the x, y, z components of
the force in the restraint to 0 (no force) or 1 (full restraint force). Ex: fxyz=0, 0, 1. This sets
no additional restraint force on the x component or y-component of the restraint force, and full z-
component restraint force. Default fxyz=1,1,1. Note: When setting fxyz, the r1, r2, r3, r4 values
(wx ∗ dx)2 + (wy ∗ dy)2 + (wz ∗ dz)2, so if fxyz=0,0,1
should be set relative to a weighted distance
then the only distance taken into account when comparing to r1,r2,r3,r4 is the z distance between
the molecule and the center of mass. Note that the DUMPAVE value when outxyz=0 is also just the
weighted distance.

(cid:113)

outxyz

If iat(3)=0 and igr1 and/or igr2 is deﬁned then it is possible to output the x, y, z components of the
force in the restraint if outxyz is set to 1. Default outyz=0. When outxyz is set to 1, the components
of the distance and total distance are outputed in DUMPAVE in the order of the x-component, y-
component, z-component, total distance.

grnam1(i),i=1→200, grnam2(i),i=1→200, ... grnam8(i),i=1→200 If group input is being speciﬁed (IGRn(1)
> 0), and IRESID = 1, then the character names of the atoms deﬁning the group are contained in
GRNAMn(i), as described above. In the case IAT(1) < 0, each residue IGR1(i) is searched for an
atom name GRNAM1(i) and added to the ﬁrst group list.
In the case IAT(2) < 0, each residue
IGR2(i) is searched for an atom name GRNAM2(i) and added to the second group list. Defaults for
GRNAMn(i) are ’

’.

ir6

ifntyp

If a group coordinate-averaged position is being used (see IGR1 and IGR2 above), the average posi-
tion can be calculated in either of two manners: If IR6 = 0, center-of-mass averaging will be used. If

IR6=1, the(cid:10)r−6(cid:11)−1/6 average of all interaction distances to atoms of the group will be used. Default

for IR6 is the value assigned to IR6 in the most recent namelist where IR6 was speciﬁed. If IR6 has
not been speciﬁed in any namelist, it defaults to 0.

If time-averaged restraints have been requested (see DISAVE/ANGAVE/TORAVE above), they are,
by default, applied to all restraints of the class speciﬁed. Time-averaging can be overridden for
speciﬁc internals of that class by setting IFNTYP for that internal to 1. IFNTYP has no effect if
time-averaged restraint are not being used. Default value is IFNTYP=0.

ixpk, nxpk These are user-deﬁned integers than can be set for each constraint. They are typically the "peak
number" and "spectrum number" associated with the cross-peak that led to this particular distance
restraint. Nothing is ever done with them except to print them out in the "violation summaries", so
that NMR people can more easily go from a constraint violation to the corresponding peak in their
spectral database. Default values are zero.

iconstr

If iconstr > 0, (default is 0) a Lagrangian multiplier is also applied to the two-center internal co-
ordinate deﬁned by IAT(1) and IAT(2). The effect of this Lagrangian multiplier is to maintain the
initial orientation of the internal coordinate. The rotation of the vector IAT(1)->IAT(2) is prohibited,
though translation is allowed. For each deﬁned two-center internal coordinate, a separate Lagrangian
multiplier is used. Therefore, although one can use as many multipliers as needed, deﬁning centers

550

27.2. NOESY volume restraints

should NOT appear in more than one multiplier. This option is compatible with mass centers (i.e.,
negative IAT(1) or IAT(2)). ICONSTR can be used together with harmonic restraints. RK2 and
RK3 should be set to 0.0 if the two-center internal coordinate is a simple Lagrangian multiplier. An
example has been included in $AMBERHOME/example/lagmul.

Namelist &rst is read for each restraint. Restraint input ends when a namelist statement with iat(1) = 0 (or iat(1)
not speciﬁed) is found. Note that comments can precede or follow any namelist statement, allowing comments and
restraint deﬁnitions to be freely mixed.

27.2. NOESY volume restraints

After the previous section, NOESY volume restraints may be read. This data described in this section is only
read if NMROPT = 2. The molecule may be broken in overlapping submolecules, in order to reduce time and
space requirements. Input for each submolecule consists of namelist "&noeexp", followed immediately by standard
Amber "group" cards deﬁning the atoms in the submolecule. In addition to the submolecule input ("&noeexp"),
you may also need to specify some additional variables in the cntrl namelist; see the "NMR variables" description
in that section.

In many cases, the user will not prepare this section of the input by hand, but will use the auxiliary program

makeDIST_RST to prepare input from simpler ﬁles.

Variables in the &noeexp namelist:

For each submolecule, the namelist "&noeexp" is read (either from stdin or from the NOESY redirection ﬁle)
which contains the following variables. There are no effective defaults for npeak, emix, ihp, jhp, and aexp: you
must specify these.

npeak(imix) Number of peaks for each of the "imix" mixing times; if the last mixing time is mxmix, set

NPEAK(mxmix+1) = -1. End the input when NPEAK(1) < 0.

emix(imix) Mixing times (in seconds) for each mixing time.

ihp(imix,ipeak), jhp(imix,ipeak) Atom numbers for the atoms involved in cross-peak "ipeak" at mixing

time "imix"

aexp(imix,ipeak) Experimental target integrated intensity for this cross peak. If AEXP is negative, this cross
peak is part of a set of overlapped peaks. The computed intensity is added to the peak that follows;
the next time a peak with AEXP > 0 is encountered, the running sum for the calculated peaks will
be compared to the value of AEXP for that last peak in the list. In other words, a set of overlapped
peaks is represented by one or more peaks with AEXP < 0 followed by a peak with AEXP > 0. The
computed total intensity for these peaks will be compared to the value of AEXP for the ﬁnal peak.
arange(imix,ipeak) "Uncertainty" range for this peak: if the calculated value is within ±ARANGE of AEXP,

then no penalty will be assessed. Default uncertainties are all zero.

awt(imix,ipeak) Relative weight for this cross peak. Note that this will be multiplied by the overall weight
given by the NOESY weight change cards in the weight changes section (Section 1). Default values
are 1.0, unless INVWT1,INVWT2 are set (see below), in which case the input values of AWT are
ignored.

invwt1,invwt2 Lower and upper bounds on the weights for the peaks respectively, such that the relative weight
for each peak is 1/intensity if 1/intensity lies between the lower and upper bounds. This is the
intensity after being scaled by oscale. The inverse weighing scheme adopted by this option prevents
placing too much inﬂuence on the strong peaks at the expense of weaker peaks and was previously
invoked using the compilation ﬂag "INVWGT". Default values are INVWT1=INVWT2=1.0, placing
equal weights on all peaks.

551

27. NMR reﬁnement

omega

taurot

taumet

id2o

Spectrometer frequency, in Mhz. Default is 500. It is possible for different sub-molecules to have
different frequencies, but omega will only change when it is explicitly re-set. Hence, if all of your
data is at 600 Mhz, you need only set omega to 600. in the ﬁrst submolecule.

Rotational tumbling time of the molecule, in nsec. Default is 1.0 nsec. Like omega, this value is
"sticky", so that a value set in one submolecule will remain until it is explicitly reset.

Correlation time for methyl jump motion, in ns. This is only used in computing the intra-methyl
contribution to the rate matrix. The ideas of Woessner are used, speciﬁcally as recommended by
Kalk & Berendsen.[578] Default is 0.0001 ns, which is effectively the fast motion limit. The default
is consistent with the way the rest of the rate matrix elements are determined (also in the fast motion
limit,) but probably is not the best value to use, since methyl groups appear to have T1 values that
are systematically shorter than other protons, and this is likely to arise from the fact that the methyl
correlation time can be near to the inverse of the spectrometer frequency. A value of 0.02 - 0.05 ns
is probably better than 0.0001, but this is still an active research area, and you are on your own here,
and should consult the literature for further discussion.[579] As with omega, taumet can be different
for different sub-molecules, but will only change when it is explicitly re-set.

Flag for determining if exchangeable protons are to be included in the spin-diffusion calculation.
If ID2O=0 (default) then all protons are included. If ID2O=1, then all protons bonded to nitrogen
or oxygen are assumed to not be present for the purposes of computing the relaxation matrix. No
other options exist at present, but they could easily be added to the subroutine indexn. Alternatively,
you can manually rename hydrogens in the prmtop ﬁle so that they do not begin with "H": such
protons will not be included in the relaxation matrix. (Note: for technical reasons, the HOH proton
of tyrosine must always be present, so setting ID2O=1 will not remove it; we hope that this limitation
will be of minor importance to most users.) The id2o variable retains its value across namelist reads,
i.e. its value will only change if it is explicitly reset.

oscale

overall scaling factor between experimental and computed volume units. The experimental intensi-
ties are multiplied by oscale before being compared to calculated intensities. This means that the
weights WNOESY and AWT always refer to "theoretical" intensity scales rather than to the (arbi-
trary) experimental units. The oscale variable retains its value across namelist reads, i.e. its value
will only change if it is explicitly reset. The initial (default) value is 1.0.

The atom numbers ihp and jhp are the absolute atom numbers. For methyl groups, use the number of the last
proton of the group; for the delta and epsilon protons of aromatic rings, use the delta-2 or epsilon-2 atom numbers.
Since this input requires you to know the absolute atom numbers assigned by Amber to each of the protons, you
may wish to use the separate makeDIST_RST program which provides a facility for more turning human-readable
input into the required ﬁle for sander.

Following the &noeexp namelist, give the Amber "group" cards that identify this submolecule. This combination
of "&noeexp" and "group" cards can be repeated as often as needed for many submolecules, subject to the limits
described in the nmr.h ﬁle. As mentioned above, this input section ends when NPEAK(1) < 0, or when and
end-of-ﬁle is reached.

27.3. Chemical shift restraints

After reading NOESY restraints above (if any), read the chemical shift restraints in namelist &shf, or the pseu-
docontact restraints in namelist &pcshift. Reading this input is triggered by the presence of a SHIFTS line in the
I/O redirection section. In many cases, the user will not prepare this section of the input by hand, but will use the
auxiliary programs shifts or fantasian to prepare input from simpler ﬁles.

Variables in the &shf namelist.

(Defaults are only available for shrang, wt, nter, and shcut; you must specify the rest.)

552

27.4. Pseudocontact shift restraints

nring

natr(i)

Number of rings in the system.

Number of atoms in the i-th ring.

iatr( j,i)

Absolute atom number for the j-th atom of the i-th ring.

namr(i)

str(i)

nprot

iprot(i)

obs(i)

shrang(i)

wt(i)

shcut

nter

cter

Eight-character string that labels the i-th ring. The ﬁrst three characters give the residue name (in
caps); the next three characters contain the residue number (right justiﬁed); column 7 is blank;
column 8 may optionally contain an extra letter to distinguish the two rings of trp, or the 5 or 8 rings
of the heme group.

Ring current intensity factor for the i-th ring. Older values are summarized by Cross and
Wright;[580] more recent empirical parametrizations seem to give improved results.[581, 582]

Number of protons for which penalty functions are to be set up.

Absolute atom number of the i-th proton whose shifts are to be evaluated. For equivalent protons,
such as methyl groups or rapidly ﬂipping phenylalanine rings, enter all two or three atom numbers
in sequence; averaging will be controlled by the wt parameter, described below.

Observed secondary shift for the i-th proton. This is typically calculated as the observed value minus
a random coil reference value.
"Uncertainty" range for the observed shift: if the calculated shift is within ±SHRANG of the ob-
served shift, then no penalty will be imposed. The default value is zero for all shifts.

Weight to be assigned to this penalty function. Note that this value will be multiplied by the overall
weight (if any) given by the SHIFTS command in the assignment of weights (above). Default values
are 1.0. For sets of equivalent protons, give a negative weight for all but the last proton in the
group; the last proton gets a normal, positive value. The average computed shift of the group will be
compared to obs entered for the last proton.

Values of calculated shifts will be printed only if the absolute error between calculated and observed
shifts is greater than this value. Default = 0.3 ppm.

Residue number of the N-terminus, for protein shift calculations; default = 1.

Residue number of the C-terminus, for protein shift calculations. Believe it or not, the current code
cannot ﬁgure this out for itself.

In typical usage, the shifts program (http://casegroup.rutgers.edu/shifts.html) would be used to create
this ﬁle, with a typical command line:

shifts -readobs -sander ’::H*’ gcg10

Sample input and output ﬁles are in $AMBERHOME/test/rdc.

27.4. Pseudocontact shift restraints

The PCSHIFT module allows the inclusion of pseudocontact shifts as constraints in energy minimization and
molecular dynamics calculations on paramagnetic molecules. The pseudocontact shift depends on the magnetic
susceptibility anisotropy of the metal ion and on the location of the resonating nucleus with respect to the axes of
the magnetic susceptibility tensor. For the nucleus i, it is given by:

(cid:104)

pc = ∑
δ i

j

1

12πr3
i j

∆χ j

ax(3n2

i j − 1) + (3/2)∆χ j

i j − m2
i j)

rh(l2

(cid:105)

where li j, mi j, and ni j are the direction cosines of the position vector of atom i with respect to the j-th magnetic
susceptibility tensor coordinate system, ri j is the distance between the j-th paramagnetic center and the proton i,

553

27. NMR reﬁnement

∆χax and ∆χrh are the axial and the equatorial (rhombic) anisotropies of the magnetic susceptibility tensor of the
j-th paramagnetic center. For a discussion, see Ref. [583].

The PCSHIFT module to be used needs a namelist ﬁle which includes information on the magnetic susceptibility
tensor and on the paramagnetic center, and a line of information for each nucleus. This module allows to include
more than one paramagnetic center in the calculations. To include pseudocontact shifts as constraints in energy
minimization and molecular dynamics calculations the NMROPT ﬂag should be set to 2, and a PCSHIFT=ﬁlename
statement entered in the I/O redirection section.

To perform molecular dynamics calculations it is necessary to eliminate the rotational and translational degree
of freedom about the center of mass (this because during molecular dynamics calculations the relative orientation
between the external reference coordinate system and the magnetic anisotropy tensor coordinate system has to be
ﬁxed).This option can be obtained with the NSCM ﬂag of sander.

Variables in the pcshift namelist

nprot

nme

nmpmc

number of pseudocontact shift constraints.

number of paramagnetic centers.

name of the paramagnetic atom

optphi(n), opttet(n), optomg(n), opta1(n), opta2(n) the ﬁve parameters of the magnetic anisotropy

tensor for each paramagnetic center.

optkon

force constant for the pseudocontact shift constraints

Following this, there is a line for each nucleus for which the pseudocontact shift information is given has to be
added. Each line contains :

iprot(i)

atom number of the i-th proton whose shift is to be used as constraint.

obs(i)

wt(i)

observed pseudocontact shift value, in ppm

relative weight

tolpro(i) relative tolerance ix mltpro

mltpro(i) multiplicity of the NMR signal (for example the protons of a methyl group have mltprot(i)=3)

Example

constraints.



Here is a &pcshf namelist example: a molecule with three paramagnetic centers and 205 pseudocontact shift



&pcshf
nprot=205,
nme=3,
nmpmc='FE ',
optphi(1)=-0.315416,
opttet(1)=0.407499,
optomg(1)=0.0251676,
opta1(1)=-71.233,
opta2(1)=1214.511,
optphi(2)=0.567127,
opttet(2)=-0.750526,
optomg(2)=0.355576,
opta1(2)=-60.390,
opta2(2)=377.459,
optphi(3)=0.451203,

554

27.5. Direct dipolar coupling restraints

opttet(3)=-0.0113097,
optomg(3)=0.334824,
opta1(3)=-8.657,
opta2(3)=704.786,
optkon=30,
iprot(1)=26, obs(1)=1.140, wt(1)=1.000, tolpro(1)=1.00, mltpro(1)=1,
iprot(2)=28, obs(2)=2.740, wt(2)=1.000, tolpro(2)=.500, mltpro(2)=1,
iprot(3)=30, obs(3)=1.170, wt(3)=1.000, tolpro(3)=.500, mltpro(3)=1,
iprot(4)=32, obs(4)=1.060, wt(4)=1.000, tolpro(4)=.500, mltpro(4)=3,
iprot(5)=33, obs(5)=1.060, wt(5)=1.000, tolpro(5)=.500, mltpro(5)=3,
iprot(6)=34, obs(6)=1.060, wt(6)=1.000, tolpro(6)=.500, mltpro(6)=3,
...
...
iprot(205)=1215, obs(205)=.730, wt(205)=1.000, tolpro(205)=.500,
mltpro(205)=1,

/


An mdin ﬁle that might go along with this, to perform a maximum of 5000 minimization cycles, starting with
500 cycles of steepest descent. PCSHIFT=./pcs.in redirects the input from the namelist "pcs.in" which contains
the pseudocontact shift information.

Example of minimization including pseudocontact shift constraints
&cntrl
ibelly=0,imin=1,ntpr=100,
ntr=0,maxcyc=500,
ncyc=50,ntmin=1,dx0=0.0001,
drms=.1,cut=10.,
nmropt=2,pencut=0.1, ipnlty=2,
/
&wt type='REST', istep1=0,istep2=1,value1=0.,
value2=1.0, /
&wt type='END' /
DISANG=./noe.in
PCSHIFT=./pcs.in
LISTOUT=POUT



27.5. Direct dipolar coupling restraints

Energy restraints based on direct dipolar coupling constants are entered in this section. All variables are in
the namelist &align; reading of this section is triggered by the presence of a DIPOLE line in the I/O redirection
section.

When dipolar coupling restraints are turned on, the ﬁve unique elements of the alignment tensor are treated
as additional variables, and are optimized along with the structural parameters. Their effective masses are deter-
mined by the scalm parameter entered in the &cntrl namelist. Unlike some other programs, the variables used
are the Cartesian components of the alignment tensor in the axis system deﬁned by the molecule itself: e.g.
Smn ≡ (cid:104)(3cosθm cosθn − δmn)/2(cid:105), where m,n = x,y,z, and θx is the angle between the x axis and the spectrometer
ﬁeld.[584] The factor of 105 is just to make the values commensurate with atomic coordinates, since both the
coordinates and the alignment tensor values will be updated during the reﬁnement. The calculated dipolar splitting
is then

(cid:32)

(cid:33)

Dcalc = −

10−5γiγ jh
2π2r3
i j

cosφm · Smn · cosφn

∑

m,n=xyz

where φx is the angle between the internuclear vector and the x axis. Geometrically, the splitting is proportional to
the transformation of the alignment tensor onto the internuclear axis. This is just Eqs. (5) and (13) of the above

555






27. NMR reﬁnement

reference, with any internal motion corrections (which might be a part of Ssystem) set to unity. If there is an internal
motion correction which is the same for all observations, this can be assimilated into the alignment tensor. The
current code does not allow for variable corrections for internal motion. See Ref. [585] for a fuller discussion of
these issues.

At the end of the calculation, the alignment tensor is diagonalized to obtain information about its principal
components. This allows the alignment tensor to be written in terms of the "axial" and "rhombic" components that
are often used to describe alignment.

Variables in the &align namelist.

ndip

id,jd

Number of observed dipolar couplings to be used as restraints.

Atom numbers of the two atoms involved in the dipolar coupling.

dobsl, dobsu Limiting values for the observed dipolar splitting, in Hz. If the calculated coupling is less than
dobsl, the energy penalty is proportional to (Dcalc − Dobs,l)2; if it is larger than dobsu, the penalty
is proportional to (Dcalc − Dobs,lu)2. Calculated values between dobsl and dobsu are not penalized.
Note that dobsl must be less than dobsu; for example, if the observed coupling is -6 Hz, and a 1 Hz
"buffer" is desired, you could set dobsl to -7 and dobsu to -5.

dwt

The relative weight of each observed value. Default is 1.0. The penalty function is thus:
align = Di
Ei
where Dwt may vary from one observed value to the next. Note that the default value is arbitrary, and
a smaller value may be required to avoid overﬁtting the dipolar coupling data.[585]

calc − Di

obs(u,l))2

wt (Di

dataset

Each dipolar peak can be associated with a "dataset", and a separate alignment tensor will be com-
puted for each dataset. This is generally used if there are several sets of experiments, each with a
different sample or temperature, etc., that would imply a different value for the alignment tensor. By
default, there is one dataset to which each observed value is assigned.

num_datasets The number of datasets in the constraint list. Default is 1.

s11,s12,s13,s22,s23 Initial values for the Cartesian components of the alignment tensor. The tensor is trace-
less, so S33 is calculated as -(S11+S22). In order to have the order of magnitude of the S values be
roughly commensurate with coordinates in Angstroms, the alignment tensor values must be multi-
plied by 105.

gigj

dij

dcut

Product of the nuclear "g" factors for this dipolar coupling restraint. These are related to the nuclear
gyromagnetic rations by γN = gNβN/¯h. Common values are 1H = 5.5856, 13C = 1.4048, 15N =
-0.5663, 31P = 2.2632.

The internuclear distance for observed dipolar coupling. If a nonzero value is given, the distance
is considered to be ﬁxed at the given value. If a dij value is zero, its value is computed from the
structure, and it is assumed to be a variable distance. For one-bond couplings, it is usually best to
treat the bond distance as "ﬁxed" to an effective zero-point vibration value.[586]

Controls printing of calculated and observed dipolar couplings. Only values where abs(dobs(u,l) -
dcalc) is greater than dcut will be printed. Default is 0.1 Hz. Set to a negative value to print all
dipolar restraint information.

freezemol If this is set to .true., the molecular coordinates are not allowed to vary during dynamics or minimiza-
tion: only the elements of the alignment tensor will change. This is useful to ﬁt just an alignment
tensor to a given structure. Default is .false..

556

27.6. Residual CSA or pseudo-CSA restraints

27.6. Residual CSA or pseudo-CSA restraints

Resonance positions in partially aligned media will be shifted from their positions in isotropic media, and this
can provide information that is very similar to residual dipolar coupling constriants. This section shows how to
input these sorts of restraints. The entry of the alignment tensor is done as in Section 27.5, so you must have a
DIPOLE ﬁle (with an &align namelist) even if you don’t have any RDC restraints. Then, if there is a CSA line in
I/O redirection section, that ﬁle will be read with the following inputs:

Variables in the &csa namelist.

ncsa

Number of observed residual CSA peaks to be used as restraints.

icsa,jcsa,kcsa Atom numbers for the csa of interest: jcsa is the atom whose ∆σ value has been measured; icsa
and kcsa are two atoms bonded to it, used to deﬁne the local axis frame for the CSA tensor. See
amber12/test/pcsa/RST.csa for examples of how to set these.

cobsl, cobsu Limiting values for the observed residual CSA, in Hz (not ppm or ppb!). If the calculated value
of ∆σ is less than cobsl, the energy penalty is proportional to (∆σcalc − ∆σobs,l)2; if it is larger than
cobsu, the penalty is proportional to (∆σcalc −∆σobs,u)2. Calculated values between cobsl and cobsu
are not penalized. Note that cobsl must be less than cobsu.

cwt

datasetc

wt (∆σ i

The relative weight of each observed value. Default is 1.0. The penalty function is thus:
Ei
csa = Ci
where Cwt may vary from one observed value to the next. Note that the default value is arbitrary, and
a smaller value may be required to avoid overﬁtting the data.

calc − ∆σ i

obs(u,l))2

Each residual CSA can be associated with a "dataset", and a separate alignment tensor will be com-
puted for each dataset. This is generally used if there are several sets of experiments, each with a
different sample or temperature, etc., that would imply a different value for the alignment tensor. By
default, there is one dataset to which each observed value is assigned. The tensors themselves are
entered for each dataset in the DIPOLE ﬁle.

field

Magnetic ﬁeld (in MHz) for the residual CSA being considered here. This is indexed from 1 to ncsa,
and is nucleus dependent. For example, if the proton frequency is 600 MHz, then ﬁeld for 13C would
be 150, and that for 15N would be 60.

sigma11, sigma22, sigma12, sigma13, sigma23 Values of the CSA tensor (in ppm) for atom icsa, in the
local coordinate frame deﬁned by atoms icsa, jcsa and kcsa. See $AMBERHOME/test/pcsa/RST.csa
for examples of how to set these.

ccut

Controls printing of calculated and observed residual CSAs. Only values where abs(cobs(u,l) - ccalc)
is greater than ccut will be printed. Default is 0.1 Hz. Set to a negative value to print all information.

The residual CSA facility is new as of Amber 10, and has not been used as much as other parts
of the NMR reﬁnement package. You should study the example ﬁles listed above to see how things
work. The residual CSA values should closely match those found by the RAMAH package (http://www-
personal.umich.edu/~hashimi/Software.html), and testing this should be a ﬁrst step in making sure you have entered
the data correctly.

27.7. Preparing restraint ﬁles for Sander

Fig. 27.1 shows the general information ﬂow for auxiliary programs that help prepare the restraint ﬁles. Once
the restraint ﬁles are made, Fig. 27.2 shows a ﬂow-chart of the general way in which sander reﬁnements are carried
out.

557

27. NMR reﬁnement

Figure 27.1.: Notation: circles represent logical information, whose format might differ from one project to the
next; solid rectangles are in a speciﬁc format (largely compatible with DIANA and other programs),
and are intended to be read and edited by the user; ellipses are speciﬁc to sander, and are generally
not intended to be read or edited manually. The conversion of NOESY volumes to distance bounds
can be carried out by a variety of programs such as mardigras or xpk2bound that are not included
with Amber. Similarly, the analysis and partial assignment of ambiguous or overlapped peaks is a
separate task; at TSRI, these are typically carried out using the programs xpkasgn and ﬁlter.pl

558

NOESYpeak-listvariouscalibrations7/8 columndistanceboundsmakeDIST_RSTdistancerestraintsmakeDIST_RSTvolumerestraintschemicalshiftrestraintschemicalshiftsanalyzeambiguitiesMAPﬁledefaultMAP ﬁleSHIFTS orFANTASIANspectr um5columncouplingconstantsmakeANG_RSTJ-couplingrestraintsDISANGﬁledefaultchiralityinfor m.makeCHIR_RSTchiralityrestraintsdirectdipolarcouplingsmakeDIP_RSTalignmentrestraints27.7. Preparing restraint ﬁles for Sander

Figure 27.2.: General organization of NMR reﬁnement calculations.

The basic ideas of this scheme owe a lot to the general experience of the NMR community over the past
decade. Several papers outline procedures in the Scripps group, from which a lot of the NMR parts of sander
are derived.[577, 587–591] They are by no means the only way to proceed. We hope that the ﬂexibility incorpo-
rated into sander will encourage folks to experiment with reﬁnement protocols.

27.7.1. Preparing distance restraints: makeDIST_RST

The makeDIST_RST program converts a simpliﬁed description of distance bounds into a detailed input for

sander. A variety of input and output ﬁlenames may be speciﬁed on the command line:

input:

-upb <filename> 7-col file of upper distance bounds, OR
-ual <filename> 8-col file of upper and lower bounds, OR
-vol <filename> 7-col file of NOESY volumes
-pdb <filename> Brookhaven format file
-map <filename> MAP file (default:map.DG-AMBER)
-les <filename> LES atom mappings, made by addles

output:

-dgm <filename> DGEOM95 restraint format
-rst <filename> SANDER restraint format
-svf <filename> Sander Volume Format, for NOESY refinement

other options:

-help (gives you this explanation, overrides other parameters)
-report (gives you short runtime diagnostic output)
-nocorr (do not correct upper bound for r**-6 averaging)
-altdis (use alternative form for the distance restraints)

The 7/8 column distance bound ﬁle is essentially that used by the DIANA or DISGEO programs. It consists of
one-line per restraint, which would typically look like the following:

559

gener icPDB-ﬁleprotonateAmberPDB-ﬁleLEaPpr mtop&pr mcrdﬁlessandercontrolﬁleSANDERNMRrestraintssanderoutputsviolviolationstatisticsAmbercoordinatesambpdboutputpdb-ﬁles27. NMR reﬁnement

23 ALA HA 52 VAL H 3.8 # comments go here

The ﬁrst three columns identify the ﬁrst proton, the next three the second proton, and the seventh column gives the
upper bound. Only the ﬁrst three letters of the residue name are used, so that DIANA ﬁles that contain residues
like "ASP-" will be correctly interpreted. An alternate, 8-column, format has both upper and lower bounds as the
seventh and eighth columns, respectively. A typical line might in an "8-col" ﬁle might look like this:

23 ALA HA 52 VAL H 3.2 3.8 # comments go here

Here the lower bound is 3.2 Åand the upper bound is 3.8 Å. Comments typically identify the spectrum and peak-
number or other identiﬁcation that allow cross-referencing back to the appropriate spectrum.
If the comment
contains the pattern "< integer>:<integer>", then the ﬁrst integer is treated as a peak-identiﬁer, and the second as
a spectrum-identiﬁer. These identiﬁers go into the ixpk and nxpk variables, and will later be printed out in sander,
to facilitate going back to the original spectra to track down violations, etc.

The format for the -vol option is the same as for the -upb option except that the seventh column holds a peak

intensity (volume) value, rather than a distance upper bound.

The input PDB ﬁle must exactly match the Amber prmtop ﬁle that will be used; use the ambpdb -aatm command

to create this.

If all peaks involved just single protons, and were fully assigned, this is all that one would need. In general,
though, some peaks (especially methyl groups or fast-rotating aromatic rings) represent contributions from more
than one proton, and many other peaks may not be fully assigned. Sander handles both of these situations in the
same way, through the notion of an "ambiguous" peak, that may correspond to several assignments. These peaks
are given two types of special names in the 7/8-column format ﬁle:

1. Commonly-occurring ambiguities, like the lack of stereospeciﬁc assignments to two methylene protons, are
given names deﬁned in the default MAP ﬁle. These names, also more-or-less consistent with DIANA, are
like the names of "pseudo-atoms" that have long been used to identify such partially assigned peaks, e.g.
"QB" refers to the (HB2,HB3) combination in most residues, and "MG1" in valine refers collectively to the
three methyl protons at position CG1, etc.

2. There are generally also molecule-speciﬁc ambiguities, arising from potential overlap in a NOESY spectrum.
Here, the user assigns a unique name to each such ambiguity or overlap, and prepares a list of the potential
assignments. The names are arbitrary, but might be constructed, for example, from the chemical shifts that
identify the peak, e.g. "p_2.52" might identify the set of protons that could contribute to a peak at 2.52 ppm.
The chemical shift list can be used to prepare a list of potential assignments, and these lists can often be
pruned by comparison to approximate or initial structures.

The default and molecule-speciﬁc MAP ﬁles are combined into a single ﬁle, which is used, along with the
7-column restraint ﬁle, the the program makeDIST_RST to construct the actual sander input ﬁles. You should
consult the help ﬁle for makeDIST_RST for more information. For example, here are some lines added to the
MAP ﬁle for a recent TSRI reﬁnement:

AMBIG n2:68 = HE 86 HZ 86
AMBIG n2:72 = HE 24 HD 24 HZ 24
AMBIG n2:73 = HN 81 HZ 13 HE 13 HD 13 HZ 24
AMBIG n2:78 = HN 76 HZ 13 HE 13 HZ 24
AMBIG n2:83 = HN 96 HN 97 HD 97 HD 91
AMBIG n2:86 = HD1 66 HZ2 66
AMBIG n2:87 = HN 71 HH2 66 HZ3 66 HD1 66

Here the spectrum name and peak number were used to construct a label for each ambiguous peak. Then, an entry
in the restraint ﬁle might look like this:

123 GLY HN 0 AMB n2:68 5.5

indicating a 5.5 Åupper bound between the amide proton of Gly 123 and a second proton, which might be either
the HE or HZ protons of residue 86. (The "zero" residue number just serves as a placeholder, so that there will be

560

27.7. Preparing restraint ﬁles for Sander

the same number of columns as for non-ambiguous restraints.) If it is possible that the ambiguous list might not
be exhaustive (e.g. if some protons have not been assigned), it is safest to set ialtd=1, which will allow "mistakes"
to be present in the constraint list. On the other hand, if you want to be sure that every violation is "active", set
ialtd=0.

If the -les ﬂag is set, the program will prepare distance restraints for multiple copies (LES) simulations. In this
case, the input PDB ﬁle is one without LES copies, i.e. with just a single copy of the molecule. The "lesﬁle"
speciﬁed by this ﬂag is created by the addles program, and contains a mapping from original atom numbers into
the copy numbers used in the multiple-copies simulation.

The -rst and -svf ﬂags specify outputs for sander, for distance restraints and NOESY restraints, respectively.
In each case, you may need to hand-edit the outputs to add additional parameters. You should make it a habit to
compare the outputs with the descriptions given earlier in this chapter to make sure that the restraints are what you
want them to be.

It is common to run makeDIST_RST several times, with different inputs that correspond to different spectra,
different mixing times, etc. It is then expected that you will manually edit the various output ﬁles to combine them
into the single ﬁle required by sander.

27.7.2. Preparing torsion angle restraints: makeANG_RST

There are fewer "standards" for representing coupling constant information. We have followed the DIANA

convention in the program makeANG_RST. This program takes as input a ﬁve-column torsion angle constraint ﬁle
along with an Amber PDB ﬁle of the molecule. It creates as output (to standard out) a list of constraints in RST
format that is readable by Amber.

Usage: makeANG_RST -help
makeANG_RST -pdb ambpdb_file [-con constraint] [-lib libfile]
[-les lesfile ]

The input torsion angle constraint ﬁle can be read from standard in or from a ﬁle speciﬁed by the -con option on
the command line. The input constraint ﬁle should look something like this:

1 GUA PPA 111.5 144.0
2 CYT EPSILN 20.9 100.0
2 CYT PPA 115.9 134.2
3 THY ALPHA 20.4 35.6
4 ADE GAMMA 54.7 78.8
5 GLY PHI 30.5 60.3
6 ALA CHI 20.0 50.0
....

Lines beginning with "#" are ignored. The ﬁrst column is the residue number; the second is the residue name (three
letter code, or as deﬁned in your personal torsion library ﬁle). Only the ﬁrst three letters of the residue name are
used, so that DIANA ﬁles that contain residues like "ASP-" will be correctly interpreted. Third is the angle name
(taken from the torsion library described below).The fourth column contains the lower bound, and the ﬁfth column
speciﬁes the upper bound. Additional material on the line is (presently) ignored.
Note: It is assumed that the lower bound and the upper bound deﬁne a region of allowed conformation on the
unit circle that is swept out in a clockwise direction from lb → ub. If the number in the lb column is greater than
the the number in the ub column, 360°will successively be subtracted from the lb until lb < ub. This preserves
the clockwise deﬁnition of the allowed conformation space, while also making the number that speciﬁes the lower
bound less than the number that speciﬁes the upper bound, as is required by Amber. If this occurs, a warning
message will be printed to stderr to notify the user that the data has been modiﬁed.

The angles that one can constrain in this manner are deﬁned in the library ﬁle that can be optionally speciﬁed on
the command line with the -lib ﬂag, or the default library "tordef.lib" (written by Garry P. Gippert) will be used. If
you wish to specify your own nomenclature, or add angles that are not already deﬁned in the default ﬁle, you
should make a copy of this ﬁle and modify it to suit your needs. The general format for an entry in the library is:

561

27. NMR reﬁnement

LEU PSI N CA C N+

where the ﬁrst column is the residue name, the second column is the angle name that will appear in the input ﬁle
when specifying this angle, and the last four columns are the atom names that deﬁne the torsion angle. When a
torsion angle contains atom(s) from a preceding or succeeding residue in the structure, a "-" or "+" is appended
to those atom names in the library, thereby specifying that this is the case. In the example above, the atoms that
deﬁne PSI for LEU residues are the N, CA, and C atoms of that same LEU and the N atom of the residue after that
LEU in the primary structure. Note that the order of atoms in the deﬁnition is important and should reﬂect that the
torsion angle rotates about the two central atoms as well as the fact that the four atoms are bonded in the order that
is speciﬁed in the deﬁnition.

If the ﬁrst letter of the second ﬁeld is "J", this torsion is assumed to be a J-coupling constraint. In that case,

three additional ﬂoats are read at the end of the line, giving the A,B and C coefﬁcients for the Karplus relation for
this torsion. For example:

ALA JHNA H N CA HA 9.5 -1.4 0.3

will set up a J-coupling restraint for the HN-HA 3-bond coupling, assuming a Karplus relation with A,B, C as 9.5,
-1.4 and 0.3. (These particular values are from Brüschweiler and Case, JACS 116: 11199 (1994).)

This program also supports pseudorotation phase angle constraints for prolines and nucleic acid sugars; each of

these will generate restraints for the 5 component angles which correspond to the lb and ub values of the input
pseudorotation constraint. In the torsion library, a pseudorotation deﬁnition looks like:

PSEUDO CYT PPA NU0 NU1 NU2 NU3 NU4
CYT NU0 C4’ O4’ C1’ C2’
CYT NU1 O4’ C1’ C2’ C3’
CYT NU2 C1’ C2’ C3’ C4’
CYT NU3 C2’ C3’ C4’ O4’
CYT NU4 C3’ C4’ O4’ C1’

The ﬁrst line describes that a PSEUDOrotation angle is to be deﬁned for CYT that is called PPA and is made up of
the ﬁve angles NU0-NU4. Then the deﬁnition for NU0-NU4 should also appear in the ﬁle in the same format as
the example given above for LEU PSI.

PPA stands for Pseudorotation Phase Angle and is the angle that should appear in the input constraint ﬁle when
using pseudorotation constraints. The program then uses the deﬁnition of that PPA angle in the library ﬁle to look
for the 5 other angles (NU0-NU4 in this case) which it then generates restraints for. PPA for proline residues is
included in the standard library as well as for the DNA nucleotides.

If the -les ﬂag is set, the program will prepare torsion angle restraints for multiple copies (LES) simulations. In
this case, the input PDB ﬁle is one without LES copies, i.e. with just a single copy of the molecule. The "lesﬁle"
speciﬁed by this ﬂag is created by the addles program, and contains a mapping from original atom numbers into
the copy numbers used in the multiple-copies simulation.

Torsion angle constraints deﬁned here cannot span two different copy sets, i.e., there cannot be some atoms of
a particular torsion that are in one multiple copy set, and other atoms from the same torsion that are in other copy
sets. It is OK to have some atoms with single copies, and others with multiple copies in the same torsion. The
program will create as many duplicate torsions as there are copies.

A good alternative to interpreting J-coupling constants in terms of torsion angle restraints is to reﬁne directly
against the coupling constants themselves, using an appropriate Karplus relation. See the discussion of the variable
RJCOEF, above.

27.7.3. Chirality restraints: makeCHIR_RST

Usage: makeCHIR_RST <pdb-file> <output-constraint-file>

We also ﬁnd it useful to add chirality constraints and trans-peptide ω constraints (where appropriate) to prevent
chirality inversions or peptide bond ﬂips during the high-temperature portions of simulated annealing runs. The
program makeCHIR_RST will create these constraints. Note that you may have to edit the output of this program
to change trans peptide constraints to cis, as appropriate.

562

27.7. Preparing restraint ﬁles for Sander

27.7.4. Direct dipolar coupling restraints: makeDIP_RST

For simulations with residual dipolar coupling restraints, the makeDIP_RST.protein, makeDIP_RST.dna and
makeDIP_RST.diana are simple codes to prepare the input ﬁle. Use -help to obtain a more detailed description of
the usage. For now, this code only handles backbone NH and CαH data. The header specifying values for various
parameters needs to be manually added to the output of makeDIP_RST.

Use of residual dipolar coupling restraints is new both for Amber and for the general NMR community. Re-
ﬁnement against these data should be carried out with care, and the optimal values for the force constant, penalty
function, and initial guesses for the alignment tensor components are still under investigation. Here are some
suggestions from the experiences so far:

1. Beware of overﬁtting the dipolar coupling data in the expense of Amber force ﬁeld energy. These dipolar
coupling data are very sensitive to tiny changes in the structure. It is often possible to drastically improve
the ﬁtting by making small distortions in the backbone angles. We recommend inclusion of explicit angle
restraints to enforce ideal backbone geometry, especially for those residues that have corresponding residual
dipolar coupling data.

2. The initial values for the Cartesian components of the alignment tensor can inﬂuence the ﬁnal structure and
alignment if the structure is not ﬁxed (ibelly = 0). For a ﬁxed structure (ibelly = 1), these values do not
matter. Therefore, the current "best" strategy is to ﬁt the experimental data to the ﬁxed starting structure, and
use the alignment tensor[s] obtained from this ﬁtting as the initial guesses for further reﬁnement.

3. Amber is capable of simultaneously ﬁtting more than one set of alignment data. This allows the use of
individually obtained datasets with different alignment tensors. However, if the different sets of data have
equal directions of alignment but different magnitudes, using an overall scaling factor for these data with a
single alignment tensor could greatly reduce the number of ﬁtting parameters.

4. Because the dipolar coupling splittings depend on the square root of the order parameters (0 ≤ S2 ≤1), these
order parameters describing internal motion of individual residues are often neglected (N. Tjandra and A.
Bax, Science 278, 1111-1113, 1997). However, the square root of a small number can still be noticeably
smaller than 1, so this may introduce undesirable errors in the calculations.

27.7.5. Using NMR exchange format (NEF) ﬁles

The NMR community, in collaboration with the worldwide PDB, is developing a common format for encoding

of NMR restraints, including all of the kinds discussed above. This format is not yet ﬁnalized, but we are
including here a conversion script, nef_to_RST, that would convert these ﬁles to sander format. Because this
format is so new, and is still subject to revisions, care should be taken in using this script: make sure that the
output ﬁles do what they should be doing. Here are the usage instructions (which you can also get by typing
“nef_to_RST -help” at the command line:

# nef_to_RST
convert NEF restraints to Amber format
input:

-nef <filename>: NEF file
-pdb <filename>: PDBFILE using AMBER nomenclature and numbering
-map <filename>: MAP file (default:map.NEF-AMBER)

output:

-rst <filename>: SANDER restraint format
-rdc <filename>: SANDER DIP format

other options:

-nocorr (do not correct upper bound for r**-6 averaging)
-altdis (use alternative form for the distance restraints)
-help

(gives you this explanation, overrides other parameters)

563

27. NMR reﬁnement

-report (gives you short runtime diagnostic output)

errors come to stderr.

27.7.6. fantasian

A program to evaluate magnetic anisotropy tensor parameters

Ivano Bertini
Depart. of Chemistry, Univ. of Florence, Florence, Italy
e-mail: bertini@risc1.lrm.fi.cnr.it

INPUT FILES:

Observed shifts ﬁle (pcshifts.in):

1st column --> residue number
2nd column --> residue name
3rd column --> proton name
4th column --> observed pseudocontact shift value
5th column --> multiplicity of the NMR signal (for example it is 3 for of a methyl group)
6th column --> relative tolerance
7th column --> relative weight

Amber pdb ﬁle (parm.pdb): coordinates ﬁle in PDB format. If you need to use a solution NMR family of structures
you have to superimpose the structures before to use them.

OUTPUT FILES:

Observed out ﬁle (obs.out): This ﬁle is built and read by the program itself, it reports the data read from the input
ﬁles.

output ﬁle (res.out): The main output ﬁle. In this ﬁle the result of the ﬁtting is reported. Using fantasian it
is possible to deﬁne an internal reference system to visualize the orientation of the tensor axes. Then in this ﬁle
you can ﬁnd PDB format lines (ATOM) which can be included in a PDB ﬁle to visualize the internal reference
system and the tensor axes. In the main output ﬁle all the three equivalent permutations of the tensor parameters
with respect to the reference system are reported. The summary of the minimum and maximum errors and that of
squared errors are also reported.

Example ﬁles: in the directory example there are all the ﬁles necessary to run a fantasian calculation:

fantasian.com --> run file
pcshifts.in --> observed shifts file
parm.pdb --> coordinate file in PDB format
obs.out --> data read from input files
res.out --> main output file ~

27.8. Getting summaries of NMR violations

If you specify LISTOUT=POUT when running sander, the output ﬁle will contain a lot of detailed information
about the remaining restraint violations at the end of the run. When running a family of structures, it can be useful
to process these output ﬁles with sviol, which takes a list of sander output ﬁles on the command line, and sends a
summary of energies and violations to STDOUT. If you have more than 20 or so structures to analyze, the output
from sviol becomes unwieldy. In this case you may also wish to use sviol2, which prints out somewhat less detailed
information, but which can be used on larger families of structures. The senergy script gives a more detailed view
of force-ﬁeld energies from a series of structures. (We thank the TSRI NMR community for helping to put these
scripts together, and for providing many useful suggestions.)

564

27.9. Time-averaged restraints

27.9. Time-averaged restraints

The model of the previous sections involves the "single-average-structure" idea, and tries to ﬁt all constraints to
a single model, with minimal deviations. A generalization of this model treats distance constraints arising from
from NOE crosspeaks (for example) as being the average distance determined from a trajectory, rather than as the
single distance derived from an average structure.

Time-averaged bonds and angles are calculated as

(cid:26)(cid:90) t

e(t(cid:48)−t)/τr(t(cid:48))−idt(cid:48)(cid:27)−1/i

¯r = (1/C)

0

(27.1)

where

¯r

t

τ
r(t(cid:48))
i

C

= time-averaged value of the internal coordinate (distance or angle)

= the current time

= the exponential decay constant

= the value of the internal coordinate at time t’

= average is over internals to the inverse of i. Usually i = 3 or 6 for NOE distances, and -1 (linear
averaging) for angles and torsions.

= a normalization integral.

Time-averaged torsions are calculated as

< ϕ >= tan−1 (< sin(φ ) > / < cos(φ ) >)

where φ is the torsion, and < sin(φ ) > and < cos(φ ) > are calculated using the equation above with sin(φ (t(cid:48)))

or cos(φ (t(cid:48))) substituted for r(t(cid:48)).

Forces for time-averaged restraints can be calculated either of two ways. This option is chosen with the DISAVI

/ ANGAVI / TORAVI commands. In the ﬁrst (the default),

(27.2)
(and analogously for y and z). The forces then correspond to the standard ﬂat-bottomed well functional form, with
the instantaneous value of the internal replaced by the time-averaged value. For example, when r3 < ¯r < r4,

∂ E/∂ x = (∂ E/∂ ¯r)(∂ ¯r/∂ r(t))(∂ r(t)/∂ x)

E = k3(¯r− r3)2

and similarly for other ranges of ¯r.

forces are calculated as

When the second option for calculating forces is chosen (IINC = 1 on a DISAVI, ANGAVI or TORAVI card),

∂ E/∂ x = (∂ E/∂ ¯r)(∂ r(t)/∂ x)

(27.3)

For example, when r3 < ¯r < r4,

∂ E/∂ x = 2k3(¯r− r3)(∂ r(t)/∂ x)

Integration of this equation does not give Eq. 27.2, but rather a non-intuitive expression for the energy (although
one that still forces the bond to the target range). The reason that it may sometimes be preferable to use this second
option is that the term ∂ ¯r/∂ r(t), which occurs in the exact expression [Eq. 27.2], varies as (¯r/r(t))1+i. When
i=3, this means the forces can be varying with the fourth power the distance, which can possibly lead to very large
transient forces and instabilities in the molecular dynamics trajectory. [Note that this will not be the case when
linear scaling is performed, i.e. when i = −1, as is generally the case for valence and torsion angles. Thus, for
linear scaling, the default (exact) force calculation should be used].

565

27. NMR reﬁnement

It should be noted that forces calculated using Eq. 27.3 are not conservative forces, and would cause the system
to gradually heat up, if no velocity rescaling were performed. The temperature coupling algorithm should act to
maintain the average temperature near the target value. At any rate, this heating tendency should not be a problem
in simulations, such as ﬁtting NMR data, where MD is being used to sample conformational space rather than to
extract thermodynamic data.

This section has described the methods of time-averaged restraints. For more discussion, the interested user is

urged to consult studies where this method has been used.[592–596]

27.10. Multiple copies reﬁnement using LES

NMR restraints can be made compatible with the multiple copies (LES) facility; see the following chapter for

more information about LES. To use NMR constraints with LES, you need to do two things:

(1) Add a line like "ﬁle wnmr name=(lesnmr) wovr" to your input to addles. The ﬁlename (lesnmr in this
example) may be whatever you wish. This will cause addles to output an additional ﬁle that is needed at the next
step.

(2) Add "-les lesnmr" to the command line arguments to makeDIST_RST. This will read in the ﬁle created
by addles containing information about the copies. All NMR restraints will then be interpreted as "ambiguous"
restraints, so that if any of the copies satisﬁes the restraint, the penalty goes to zero.



Note that although this scheme has worked well on small peptide test cases, we have yet not used it extensively
for larger problems. This should be treated as an experimental option, and users should use caution in applying or
interpreting the results.

27.11. Some sample input ﬁles

The next few pages contain excerpts from some sample NMR reﬁnement ﬁles used at TSRI. The ﬁrst example
just sets up a simple (but often effective) simulated annealing run. You may have to adjust the length, temperature
maximum, etc. somewhat to ﬁt your problem, but these values work well for many "ordinary" NMR problems.



27.11.1. 1. Simulated annealing NMR reﬁnement

15ps simulated annealing protocol
&cntrl

nstlim=15000, ntt=1, !(time limit, temp. control)
ntpr=500, pencut=0.1, !(control of printout)
ipnlty=1, nmropt=1, !(NMR penalty function options)
vlimit=10, !(prevent bad temp. jumps)
ntb=0, !(non-periodic simulation)
igb=8, !(generalize Born solvent model)

/
#
# Simple simulated annealing algorithm:
#
# from steps 0 to 1000: raise target temperature 10-1200K
# from steps 1000 to 3000: leave at 1200K
# from steps 3000 to 15000: re-cool to low temperatures
#
&wt type='TEMP0', istep1=0,istep2=1000,value1=10.,

value2=1200., /

&wt type='TEMP0', istep1=1001, istep2=3000, value1=1200.,

value2=1200.0, /

&wt type='TEMP0', istep1=3001, istep2=15000, value1=0.,

value2=0.0, /

#

566

27.11. Some sample input ﬁles

# Strength of temperature coupling:
# steps 0 to 3000: tight coupling for heating and equilibration
# steps 3000 to 11000: slow cooling phase
# steps 11000 to 13000: somewhat faster cooling
# steps 13000 to 15000: fast cooling, like a minimization
#
&wt type='TAUTP', istep1=0,istep2=3000,value1=0.2,value2=0.2, /
&wt type='TAUTP', istep1=3001,istep2=11000,value1=4.0,value2=2.0, /
&wt type='TAUTP', istep1=11001,istep2=13000,value1=1.0,value2=1.0, /
&wt type='TAUTP', istep1=13001,istep2=14000,value1=0.5,value2=0.5, /
&wt type='TAUTP', istep1=14001,istep2=15000,value1=0.05,value2=0.05, /
#
# "Ramp up" the restraints over the first 3000 steps:
#
&wt type='REST', istep1=0,istep2=3000,value1=0.1,value2=1.0, /
&wt type='REST', istep1=3001,istep2=15000,value1=1.0,value2=1.0, /
&wt type='END' /
LISTOUT=POUT (get restraint violation list)
DISANG=RST.f (file containing NMR restraints)



The next example just shows some parts of the actual RST ﬁle that sander would read. This ﬁle would ordinarily
not be made or edited by hand; rather, run the programs makeDIST_RST, makeANG_RST and makeCHIR_RST,
combining the three outputs together to construct the RST ﬁle.

27.11.2. Part of the RST.f ﬁle referred to above



# first, some distance constraints prepared by makeDIST_RST:

# (comment line is input to makeRST, &rst namelist is output)
#
#( proton 1 proton 2 upper bound)
#---------------------------------------------
#
# 2 ILE HA 3 ALA HN 4.00
#
&rst iat= 23, 40, r3= 4.00, r4= 4.50,
r1 = 1.3, r2 = 1.8, rk2=0.0, rk3=32.0, ir6=1, /
#
# 3 ALA HA 4 GLU HN 4.00
#
&rst iat= 42, 50, r3= 4.00, r4= 4.50, /
#
# 3 ALA HN 3 ALA MB 5.50
#
&rst iat= 40, -1, r3= 6.22, r4= 6.72,
igr1= 0, 0, 0, 0, igr2= 44, 45, 46, 0, /
#
# .......etc......
#
# next, some dihedral angle constraints, from makeANG_RST:
#
&rst iat= 213, 215, 217, 233, r1=-190.0,
r2=-160.0, r3= -80.0, r4= -50.0, /
&rst iat= 233, 235, 237, 249, r1=-190.0,
r2=-160.0, r3= -80.0, r4= -50.0, /
# .......etc.......

567

27. NMR reﬁnement

#
# next, chirality and omega constraints prepared by makeCHIR_RST:
#
#
# chirality for residue 1 atoms: CA CG HB2 HB3
&rst iat= 3 , 8 , 6 , 7 ,
r1=10., r2=60., r3=80., r4=130., rk2 = 10., rk3=10., /
#
# chirality for residue 1 atoms: CB SD HG2 HG3
&rst iat= 5 , 11 , 9 , 10 , /
#
# chirality for residue 1 atoms: N C HA CB
&rst iat= 1 , 18 , 4 , 5 , /
#
# chirality for residue 2 atoms: CA CG2 CG1 HB
&rst iat= 22 , 26 , 30 , 25 , /
#
......etc........
# trans-omega constraint for residue 2
&rst iat= 22 , 20 , 18 , 3 ,
r1=155., r2=175., r3=185., r4=205., rk2 = 80., rk3=80., /
#
# trans-omega constraint for residue 3
&rst iat= 41 , 39 , 37 , 22 , /
#
# trans-omega constraint for residue 4
&rst iat= 51 , 49 , 47 , 41 , /
#
# ......etc........
#
The next example is an input file for volume-based NOE refinement. As with the distance/angle RST file shown above, the user would generally not construct this file, but create it from a "7-column" file using the makeDIST_RST program. Hand-editing might be used at the top of the file, to change the correlation times, etc.

27.11.3. 3. Sample NOESY intensity input ﬁle

# A part of a NOESY intensity file:

&noeexp
id2o=1, (exchangeable protons removed)
oscale=6.21e-4, (scale between exp. and calc. intensity units)
taumet=0.04, (correlation time for methyl rotation, in ns.)
taurot=4.2, (protein tumbling time, in ns.)
NPEAK = 13*3, (three peaks, each with 13 mixing times)
EMIX = 2.0E-02, 3.0E-02, 4.0E-02, 5.0E-02, 6.0E-02,
8.0E-02, 0.1, 0.126, 0.175, 0.2, 0.25, 0.3, 0.35,
(mixing times, in sec.)
IHP(1,1) = 13*423, IHP(1,2) = 13*1029, IHP(1,3) = 13*421,
(number of the first proton)
JHP(1,1) = 78*568, JHP(1,2) = 65*1057, JHP(1,3) = 13*421,
(number of the second proton)
AEXP(1,1) = 5.7244, 7.6276, 7.7677, 9.3519,
10.733, 15.348, 18.601,
21.314, 26.999, 30.579,
33.57, 37.23, 40.011,
(intensities for the first cross-peak)

568

27.11. Some sample input ﬁles

AEXP(1,2) = 8.067, 11.095, 13.127, 18.316,
22.19, 26.514, 30.748,
39.438, 44.065, 47.336,
54.467, 56.06, 60.113,
AEXP(1,3) = 7.708, 13.019, 15.943, 19.374,
25.322, 28.118, 35.118,
40.581, 49.054, 53.083,
56.297, 59.326, 62.174,
/
SUBMOL1
RES 27 27 29 29 39 41 57 57 70 70 72 72 82 82 (residues in this submol)

END END

Next, we illustrate the form of the ﬁle that holds residual dipolar coupling restraints. Again, this would generally
be created from a human-readable input using the program makeDIP_RST.

27.11.4. Residual dipolar restraints, prepared by makeDIP_RST:

&align
ndip=91, dcut=-1.0, gigj = 37*-3.1631, 54*7.8467,
s11=3.883, s22=53.922, s12=33.855, s13=-4.508, s23=-0.559,
id(1)=188, jd(1)=189, dobsu(1)= 6.24, dobsl(1)= 6.24,
id(2)=208, jd(2)=209, dobsu(2)= -10.39, dobsl(1)= -10.39,
id(3)=243, jd(3)=244, dobsu(3)= -8.12, dobsl(1)= -8.12,
....
id(91)=1393, jd(91)=1394, dobsu(91)= -19.64, dobsl(91) = -19.64,
/

Finally, we show how the detailed input to sander could be used to generate a more complicated restraint. Here is
where the user would have to understand the details of the RST ﬁle, since there are no "canned" programs to create
this sort of restraint. This illustrates, though, the potential power of the program.



27.11.5. A more complicated constraint

# 1) Define two centers of mass. COM1 is defined by
# {C1 in residue 2; C1 in residue 3; N2 in residue 4; C1 in residue 5}.
# COM2 is defined by {C4 in residue 1; O4 in residue 1; N* in residue 1}.
# (These definitions are effected by the igr1/igr2 and grnam1/grnam2
# variables; You can use up to 200 atoms to define a center-of-mass
# group)
#
# 2) Set up a distance restraint between COM1 and COM2 which goes from a
# target value of 5.0A to 2.5A, with a force constant of 1.0, over steps 1-5000.
#
# 3) Set up a distance restraint between COM1 and COM2 which remains fixed
# at the value of 2.5A as the force slowly constant decreases from
# 1.0 to 0.01 over steps 5001-10000.
#
# 4) Sets up no distance restraint past step 10000, so that free (unrestrained)
# dynamics takes place past this step.
#
&rst iat=-1,-1, nstep1=1,nstep2=5000,

iresid=1,irstyp=0,ifvari=1,ninc=0,imult=0,ir6=0,ifntyp=0,
r1=0.00000E+00,r2=5.0000,r3=5.0000, r4=99.000,rk2=1.0000,rk3=1.0000,
r1a=0.00000E+00,r2a=2.5000,r3a=2.5000, r4a=99.000,rk2a=1.0000,rk3a=1.0000,

569



27. NMR reﬁnement

igr1 = 2,3,4,5,0, grnam1(1)='C1',grnam1(2)='C1',grnam1(3)='N2',
grnam1(4)='C1', igr2 = 1,1,1,0, grnam2(1)='C4',grnam2(2)='O4',grnam2(3)='N*',

/
&rst iat=-1,-1, nstep1=5001,nstep2=10000,

iresid=1,irstyp=0,ifvari=1,ninc=0,imult=0,ir6=0,ifntyp=0,
r1=0.00000E+00,r2=2.5000,r3=2.5000, r4=99.000,rk2=1.0000,rk3=1.0000,
r1a=0.00000E+00,r2a=2.5000,r3a=2.5000, r4a=99.000,rk2a=1.0000,rk3a=0.0100,
igr1 = 2,3,4,5,0, grnam1(1)='C1',grnam1(2)='C1',grnam1(3)='N2',
grnam1(4)='C1', igr2 = 1,1,1,0, grnam2(1)='C4',grnam2(2)='O4',grnam2(3)='N*',

/



570

28. Xray and cryoEM reﬁnement

28.1. EMAP restraints for rigid and ﬂexible ﬁtting into EM maps

EMAP restrained simulation[431, 597] was developed to incorporate electron microscopy (EM) image infor-
mation into macromolecular structure determination. Different from NMR and X-ray data, EM images have low
resolutions (5~50Å). However, EM images of large molecular assemblies up to millions of atoms and in various
biologically relevant environments are available. These low resolution images provide precious structural infor-
mation that can help to determine structures of many molecular assemblies and machineries[597–607].

With EMAP restraints, Sander and PMEMD can be used to perform both rigid[597] and ﬂexible[431] ﬁtting
of molecules into experimental maps of complexes to obtain both complex structures and conformations agreeing
with experimental maps. In addition to experimental map information, homologous structural information can be
used by EMAP to perform targeted conformational search (TCS) to induce simulation systems to form structures
of interest.

If the restraint map or structure is very different from the starting conformation, SGLD is recommended to
induce large conformational change by setting isgld=1. This is often used to simulate conformational transition
between different states. See the Sampling and free energy search section 22.1 for details on running SGLD.

If domain motion is desired while domain structures need to be maintained, one can use an EMAP restraint
generated from the initial coordinates for each domain and set move=1 to allow the restraint map to move with the
domain, so that domains can search the conformational space without unfolding or changing shape.

Each EMAP restraint is deﬁned by a map ﬁle and a selection of atoms, as well as related parameters. Multiple
EMAP restraints can be deﬁned. The map can be either input from an image ﬁle, or generated from a pdb structure
or derived from the starting coordinates. The deﬁnition of EMAP restraints are read in from the input ﬁle as
“&emap” namelists. The following are variables in each &emap namelist.

mapfile

The ﬁlename of a restraint map or structure. The restraint maps must be in “map”, “ccp4”, or “mrc”
format. The structure must be in pdb format. The structure need not be the same as the simulation
system. A resolution can be speciﬁed for the conversion to a density map. When a blank ﬁlename is
speciﬁed, mapﬁle=”, the input coordinates of the masked atoms will be used to generate a restraint
map (default=”).

atmask

The atom mask for selecting atoms to be restrained (default=’:*’).

fcons

move

The restraining constant (default=0.05 kcal/g).

Allow the restraint map to move when move>0 (default=0).

resolution The resolution used to convert an atomic structure to a map (default=2 Å).

ifit

Perform rigid ﬁtting before simulation when iﬁt>0. One would do this when the initial coordinates
don’t match those of the map (default=0). When iﬁt=1, the map is transformed (by translation
and rotation) to match the coordinates; the coordinates are not altered. EMAP allows output of
the re-oriented map (mapﬁt=...) that matches the (ﬁnal) simulation coordinates, and/or output of
the coordinates (molﬁt=...) that would match the orientation of the original map. When iﬁt=2, the
masked atoms will be transformed to ﬁt the map and the transformed coordinates will be used for
the following simulation. For periodic systems, iﬁt=2 may cause atoms to clash with periodic image
atoms.

grids

Grid numbers in x,y,z,phi,psi,theta dimensions for grid-threading rigid ﬁtting[597]. For example,
grids=2,2,2,3,3,3 deﬁnes 2 grid points in each of x,y,z directions between the minimum and maxi-
mum coordinates, and 3 grid points in each of phi (0-360), psi(0-360), theta(0-180) angles. A search

571

28. Xray and cryoEM reﬁnement

for local minimums starts from every grid point and the global minimum is identiﬁed from all the
local minimums (default=1,1,1,1,1,1).

mapfit

The ﬁlename for the ﬁnal constraint map after rigid ﬁtting and/or moving. The ﬁlename must has an
extension of .map, .ccp4, or .mrc (default=”, for no map output).

molfit

The ﬁlename for the ﬁnal restrained atom coordinates after rigid ﬁtting and/or simulation. The
ﬁlename must have an extension of .pdb (default=”, for no structure output).

Here is an example input ﬁle for an EMAP constrained SGLD simulation:



(SGLD)

(turn on EMAP )

(EMAP restraint 1 )

(restraint map can move)
(perform rigid fitting first)

Map Constraint Self-Guided Langevin dynamics
&cntrl ntx=1, ntb=0,nstlim=100000, imin=0, maxcyc=1, ntc=2, ntf=2, cut=9.0,
ntpr=1000, ntwr=100000,ntwx=10000, ntt=3, gamma_ln=10.0,nscm=100, dt=0.001,
ntb=0,igb=0,ips=1, isgld=1, tsgavg=1.0, sgft=0.5,tempsg=0,
iemap=1,
/
&emap
mapfile='data/1gb1.ccp4', (map is input from a map file)
atmask=':1-20',
(residues 1-20 are restrained)
fcons=0.1,
move=1,
ifit=1,
mapfit='scratch/gb1n_1.ccp4',
molfit='scratch/gb1n_1.pdb', / (final restrained atoms related to initial map)
&emap
mapfile='data/1gb1.pdb', (map is generated from a pdb file)
atmask=':22-37',
fcons=0.1,move=0,
ifit=1,
mapfit='scratch/gb1h_1.ccp4',
molfit='scratch/gb1h_1.pdb', / (final restrained atoms related to initial map)
&emap
mapfile='',
atmask=':41-56', (residues 41-56 are restrained)
fcons=0.1,move=1, (restraint map can move)
ifit=1,
mapfit='scratch/gb1c_1.ccp4',
molfit='scratch/gb1c_1.pdb', / (final restrained atoms related to initial map)

(residues 22-37 are restrained)
(restraint map is fixed)
(perform rigid fitting first)

(EMAP restraint 3)
(map is generated from initial coordinates)

(perform rigid fitting first)

(final map, same as initial)

(EMAP restraint 2)

(final map)

(final map)



28.2. FRETrest: Förster Resonance Energy Transfer restraints

FRETrest is a set of helper scripts for generating FRET-restraints for Molecular Dynamics (MD) simulations
performed with the AMBER Software Suite. FRETrest saves restraints in DISANG format, which is also used
for NMR-based restraints (27.1). FRETrest implements FRET restraints for implicit dyes represented by pseudo
atoms. Each pseudo atom represents the statistical mean position of the ﬂuorescent dye as determined by Acces-
sible Volume simulations [608]. These pseudo atoms are restrained with respect to the backbone atoms of the
labeled residue and, optionally, adjacent residues. FRETrest can be used to incorporate experimental data obtained
from different types of FRET experiments [608, 609] with various organic dyes and linkers. For MD simulations
with explicit (as opposed to implicit) dyes see section 3.10.

Adding FRET restraints to an MD simulation takes two steps.
1) Add pseudo atoms to the topology ﬁle with placeAV.py:

placeAV.py [-p <parmtop>] [-o <output>]

[-j <config>] [--chi2 <Xevaluator>]

572





28.2. FRETrest: Förster Resonance Energy Transfer restraints

-p <parmtop> Load <parmtop> as a topology file.
-o <output> Write output to file <output>.
-j <conﬁg> FRET configuration file.
–chi2 <Xevaluator> Set the χ²evaluator.

2) Tether pseudo atoms to the corresponding backbone residues and apply FRET restraints between pseudo atoms
with FRETrest.py:

FRETrest.py [-t <parmtop>] [-r <restart>]

[-j <config>] [--chi2 <Xevaluator>]
[--fout <outfile>] [--restout <restfile>]
[--force <mforce>] [--resoffset <resoff>]

-t <parmtop> Load <parmtop> as a topology file.
-r <restart> Read restart file from <restart>.
-j <conﬁg> FRET configuration file.
–chi2 <Xevaluator> Set the χ²evaluator.
–fout <outﬁle> Resulting restraints output file.
–restout <restﬁle> Resulting adjusted restart file.
–force <mforce> Maximum inter-dummy force in piconewton.
–resoffset <resoff> Integer number of shifted residues between t4l.fps.json and

AMBER topology file. Should be provided if residue numbering starts from
“1” in the t4l.fps.json, but in the .prmtop it starts from “0”, as is
usual.In general, the offset can be any integer number, positive or
negativ.

First, this command will add dummy atoms to a PDB ﬁle of T4 lysozyme protein (PDB ID 148L) and save it to
148l_PA.pdb:

python3 placeAVmp.py -p 148l_noH.pdb -o 148l_PA.pdb -j t4l.fps.json --chi2 ’C3 χ²’

For the script to work, an input PDB ﬁle (148l_noH.pdb) and a FRET conﬁguration ﬁle (t4l.fps.json) must be
provided. The FRET conﬁguration ﬁle can be generated Olga software [610]. C3 χ² is the name of the relevant χ²
evaluator from t4l.fps.json. See the documentation of Olga for more details. Labeling positions that are present in
t4l.fps.json, but are not relevant to the speciﬁed χ² will be omitted from the resulting PDB.

Second, the command will generate the AMBER restraint (DISANG) ﬁle:

python3 FRETrest.py -t 148l_watio_hmr.prmtop -r Equil/26_md_nvt_red_pme_11.restrt \
-j t4l.fps.json --chi2 ’C3 χ²’ --fout prod_0001.f --restout prod_0000.restrt \
--force 50 --resoffset -1

It will also generate an updated restart ﬁle, so that if there are any inconsistencies between the conformation of the
macromolecule and dummy atom positions, positions of the dummy atoms are adjusted accordingly.

Comprehensive

step by step usage

examples/T4L/t4l.sh and exam-
To use the scripts you would need a working installation of AmberTools, and

examples

available

are

at

ples/hGBP1/hGBP1.sh.
python libraries LabelLib [608, 609] and mdtraj [611].

FRETrest was introduced here[610].

573

28. Xray and cryoEM reﬁnement

28.3. X-ray functionality and diffraction-based restraints for pmemd

New to Amber 20, the pmemd and pmemd.cuda programs include an experimental module dedicated to
biomolecular crystallography. It is envisioned that in future Amber can be used as a platform to address various
crystallography-related problems, e.g. to reﬁne crystallographic structures of proteins and nucleic acids (similar to
the existing capability in the area of biomolecular NMR). This module is intended for use with an MD simulation
of the crystal unit cell or a “supercell”.[612] For information on how to set up a crystal simulation, including pe-
riodic boundary conditions to emulate crystalline lattice, see Chapter 18. It is expected that the crystal is solvated
using an explicit (or implicit) solvent in some fashion. Alternate conformations and their respective occupancies
are currently ignored.

Although it is not a part of Amber, it is worth noting that the phenix crystallographic package now allows for X-
ray reﬁnement using Amber (or other) force ﬁelds.[613] This was accomplished by using the python API to sander,
discussed in Section 19.13, and uses locally-enhanced sampling (see Chap. 29) to handle alternate conformations.
It supports all of the X-ray related options in phenix.reﬁne, but has limited options for molecular dynamics, and no
GPU acceleration.

28.3.1. Structure factor calculations

For the crystal simulation, the program can calculate crystallographic structure factors (SFs) for individual MD
frames. The calculations are conducted using direct summation formula;[614] a mask is available to deﬁne the
subset of atoms included in these calculations (atom_selection_mask). For example, this mask could select the
macromolecules, but not the solvent or the neutralizing ions present in the simulation. The B-factors used in the
direct summation formula are supplied through a designated PDB ﬁle. The set of Miller indices for SF calculations
is supplied as a part of the reﬂection_inﬁle.

In principle, explicit solvent and ions can also be accounted for via the direct summation formula. However,
any single individual frame does not offer an adequate statistical sampling with regard to the positioning of water
molecules (if desired, such statistical sampling can be obtained by means of time averaging). Instead, we have
implemented ﬂat bulk-solvent model to account for the contribution of interstitial solvent into SFs.[615] The de-
fault bulk-solvent parameters (k_sol and b_sol) represent consensus values from published structures.[616] The
implementation, including the scheme to build solvent mask, is analogous to the one in cctbx library.[617]

It is worth noting that crystal MD simulations in Amber (as described in Chap. 18) do not maintain a perfect
space group symmetry. Therefore, strictly speaking, the calculated SFs correspond to P(1) space group with the
unit cell that is identical to the simulation box. During the course of the simulation, the calculated SFs can be
collected frame-by-frame at a speciﬁed interval (ntwsf ) and stored in a form of special trajectory ﬁle (sf_outﬁle).

28.3.2. Structure-factor-based restraints

The input reﬂection_inﬁle contains the set of experimental SFs (alternatively, a set of SFs back-calculated from
a target structure can be supplied). For the experimental and calculated SFs, a very simple squared error function
can be formed:

Exray = (1/N)∑

hkl

[Fcalc(hkl)− Fobs(hkl)]2

(28.1)

Observed structure factors are generally divided into a “working” set and a “free” (test) set; the sum in Eq. 28.1 is
over the working set. The normalization factor N is set to the sum of F2
obs over the working set of reﬂections. The
term Exray is then added to the total potential energy with the user-speciﬁed weight (xray_weight):

Etotal = E f orce− f ield + wxrayExray

(28.2)

The expression for Exray, along with the direct-summation formula for Fcalc, provides a basis to evaluate forces.
These “restraint” forces act like those used in NMR reﬁnement, discussed in Chap.27, and are generally used
to drive minimization or MD simulations that minimize Etotal. The value of Exray is reported in the mdout ﬁle,
together with Rwork and R f ree.

574

28.3. X-ray functionality and diffraction-based restraints for pmemd

We envisage that SF-based restraints can be used for a number of purposes. For example, they can be viewed as
an empirical addition to the force ﬁelds, which can potentially remedy certain biases.[618, 619] Another promising
application is reﬁnement of crystallographic structures. Such an Amber-based protocol has been developed by O.
Mikhailovskii, Y. Xue and N.R. Skrynnikov (to be reported; see also https://arx.bio-nmr.spbu.ru for the web inter-
face). Ultimately, the entire process of crystallographic structure determination can be incorporated into Amber.
This approach may be particularly valuable for lower-quality diffraction data sets and incomplete structural models
(e.g. in the case of weak or missing electron density for mobile side chains, loops or terminal regions in protein
molecules). In this situation, the state-of-the-art force ﬁeld provides a natural solution to model the poorly resolved
or unresolved elements of the structure. This is accomplished in a highly realistic manner, by using the explicit
representation of the crystal unit cell (supercell), taking into consideration the effect of solvent, crystal contacts,
etc.

In the near future, we plan to add new functionalities to the described x-ray module.

Importantly, the
simplistic target function Eq.
28.1 will be supplanted with the more useful Maximum Likelihood target
functions;[620, 621] more advanced variants of bulk solvent, as well as the overall anisotropic scaling of SFs,
will also be implemented.[622] The code also provides gradients of Fcalc with respect to B-factors and occupan-
cies, which could be used to drive optimization based on these features.

It should be clear from this discussion that the current implementation of X-ray related calculations is still very
rudimentary. At present, its most immedate use might be for users who can take advantage of GPU acceleration
for the computation of structure factors and their derivatives with respect to atomic positions. As an example, the
repeated evaluation of structure factors for snapshots taken from MD simulation is a key (and currently slow) part
of the analysis of diffuse scattering.[623, 624]

28.3.3. Inputs and ﬁle formats

System setup follows the general procedures outlined in Chap. 18. For users with access to the phenix package of
crystallographic analysis tools, the XrayPrep tool can prepare the system: inputs are simply a PDB ﬁle (xxxx.pdb,
where xxxx is a PDB id) and the corresponding structure factor ﬁle (xxxx-sf.cif ).

For those who will prepare their own inputs, one needs a PDB ﬁle, expanded to the unit cell (see Chap. 18) that
contains the B-factors. The structure factors have to be listed in the reﬂection_inﬁle, which is a human-readable
ascii ﬁle containing the same information that can be normally found in .mtz ﬁles. The ﬁrst line contains a total
number of reﬂections followed by a zero. Subsequent lines list Miller indices h, k and l, followed by the respective
SF values and their standard deviations, followed by an R-free ﬂag (we adopt the convention that “1” indicates a
member of the working set, and “0” a member of the test set). An example ﬁle is given below. Note that column
spacing or number formatting is not critical, but each entry should be separated by at least one space.



41243 0
-19
-19
-19
...
19
19



-6
-6
-5

6
6

1
2
1

1
2

13.86329
46.38137
9.675193

13.86329
46.38137

9.685285
3.528763
21.28529

9.685285
3.528763

0
1
1

0
1





Input variables in the &xray namelist The X-ray functionalities are activated by adding the &xray namelist to
the mdin ﬁle. The keywords in &xray namelist include the following:

File handling:

pdb_infile

name of the PDB input ﬁle containing B-factors

pdb_read_coordinates

if true, use coordinates from the PDB ﬁle, not inpcrd, as starting coordinates

pdb_outfile

name of PDB ﬁle to write the ﬁnal atomic coordinates from the simulation. Cur-
rently writes back the input B-factors and occupancies as read from pdb_inﬁle

575

28. Xray and cryoEM reﬁnement

reflection_infile

name of the input ﬁle containing experimental SFs

sf_outfile

ntwsf

Bulk solvent parameters:

bulk_solvent_model

resolution_high

solvent_mask_expand

name of the trajectory ﬁle with calculated SFs

time interval to write calculated SFs to sf_outﬁle

the type of bulk solvent to use (default ’none’, current option ’simple’ invokes the
default values of k_sol and b_sol)

used to determine the density of the grid to build bulk solvent mask (this value,
divided by four, gives the maximum grid spacing in Å)

to be

increment
selected by
atom_selection_mask as a part of the algorithm to build bulk solvent mask
(default 1.11 Å)

added to atomic

radii of

atoms

the

solvent_mask_probe_radius the radius of solvent probe to apply as a part of the algorithm to build bulk solvent

mask (default 0.9 Å)

mask_update_frequency

the time interval to recompute the bulk solvent mask (default 100 steps)

Other parameters:

atom_selection_mask

ambmask-format mask to specify the atoms that contribute to calculated SFs via
direct summation formula

xray_weight

multiplier wxray to scale Exray contribution, see Eq. 28.2

scale_update_frequency

the time interval to re-scale Fcalc to Fobs (default 100 steps)

576

29. Locally-enchanced sampling

Locally-enhanced sampling (LES) is a method to allow for multiple local copies of regions within a larger
biomolecule. An example would be to allow sidechains in a protein to be “disordered” (that is, to be described as a
superposition of several conﬁgurations), while the backbone is represented as a single conﬁguration. This is similar
to the “alternate conformer” model often used by crystallographers to describe local disorder in proteins. As the
method name implies, this method can achieve enhanced sampling compared to conventional MD. Explanations
of the approach, along with key examples, can be found in early, seminal papers.[625–628]

The LES functionality for sander was written by Carlos Simmerling. It basically functions by modifying the
prmtop ﬁle using the program addles. The modiﬁed prmtop ﬁle is then used with a slightly modiﬁed version of
sander called sander.LES.

29.1. Preparing to use LES with Amber

The ﬁrst decision that must be made is whether LES is an appropriate technique for the system that you are
studying. For further guidance, you may wish to consult published articles to see where LES has proven useful in
the past. Several examples will also be given at the end of this section in order to provide models that you may
wish to follow.

There are three main issues to consider before running the ADDLES module of Amber.

1. What should be copied?

2. How many copies should be used?

3. How many regions should be deﬁned?

A brief summary of my experience with LES follows.

1. You should make copies of ﬂexible regions of interest. This sounds obvious, and in some cases it is. If
you are interested in determining the conformation of a protein loop, copy the loop region. If you need to
determine the position of a side chain in a protein after a single point mutation, copy that side chain. If the
entire biomolecule needs reﬁnement, then copy the entire molecule. Some other cases may not be obvious-
you may need to decide how far away from a particular site structural changes may propagate, and how far
to extend the LES region.

2. You should use as few copies as are necessary. While this doesn’t sound useful, it illustrates the general
point–too few copies and you won’t get the full advantages of LES, and too many will not only increase
your system size unnecessarily but will also ﬂatten the energy surface to the point where minima are no
longer well deﬁned and a wide variety of structures become populated. In addition, remember that LES is
an approximation, and more copies make it more approximate. Luckily, published articles that explore the
sensitivity of the results to the number of copies show that 3-10 copies are usually reasonable and provide
similar results, with 5 copies being a good place to start.

3. Placing the divisions between regions can be the most difﬁcult choice when using LES. This is essentially
a compromise between surface smoothing and copy independence. The most effective surface-smoothing
in LES takes places between LES regions. This is because Na copies in region A interact with all Nb
copies in region B, resulting in Na*Nb interactions, with each scaled by 1/(Na*Nb) compared to the original
interaction. This is better both from the statistics of how many different versions of this interaction contribute
to the LES average, and how much the barriers are reduced. Remember that since the copies of a given region
do not interact with different copies of that same region, interactions inside a region are only scaled by 1/N.

577

29. Locally-enchanced sampling

The other thing to consider is whether these enhanced statistics are actually helpful. For example, if the copies
cannot move apart, you will obtain many copies of the same conformation–obviously not very helpful. This will
also result in less effective reduction in barriers, since the average energy barriers will be very similar to the non-
average barrier. The independence of the copies is also related to how the copies are attached. For example,
different copies of an amino acid side chain are free to rotate independently (at least within restrictions imposed
by the surroundings and intrinsic potential) and therefore each side chain in the sequence could be placed into a
separate LES region. If you are interested in backbone motion, however, placing each amino acid into a separate
region is not the best choice. Each copy of a given amino acid will be bonded to the neighbor residues on each
side. This restriction means that the copies are not very independent, since the endpoints for each copy need to
be in nearly the same places. A better choice is to use regions of 2-4 amino acids. As the regions get larger,
each copy can start to have more variety in conformation- for example, one segment may have some copies in a
helical conformation while others are more strand-like or turn-like. The general rule is that larger regions are more
independent, though you need to consider what types of motions you expect to see.

The best way to approach the division of the atoms that you wish to copy into regions is to make sure that you
have several LES regions (unless you are copying a very small region such as a short loop or a small ligand). This
will ensure plenty of inter-copy averaging. Larger regions permit wider variations in structure, but result in less
surface smoothing. A subtle point should be addressed here- the statistical improvement available with LES is not
a beneﬁt in all cases and care must be taken in the choice of regions. For example, consider a ligand exiting a
protein cavity in which a side chain acts as a gate and needs to move before the ligand can escape. If we make
multiple copies of the gate, and do not copy the ligand, the ligand will interact in an average way with the gates. If
the gate was so large that even the softer copies can block the exit, then the ligand would have to wait until ALL of
the gate copies opened in order to exit. This may be more statistically difﬁcult than waiting for the original, single
gate to open despite the reduced barriers. Another way to envision this is to consider the ligand trying to escape
against a true probability distribution of the gate- if it was open 50% of the time and closed 50%, then the exit may
still be completely blocked. Continuum representations are therefore not always the best choice.

Speciﬁc examples will be given later to illustrate how these decisions can be made for a particular system.

29.2. Using the ADDLES program

The ADDLES module of Amber is used to prepare input for simulations using LES. A non-LES prmtop and
prmcrd ﬁle are generated using a program such as LEaP. This prmtop ﬁle is then given to ADDLES and replaced
by a new prmtop ﬁle corresponding to the LES system. All residues are left intact- copies of atoms are placed in the
same residue as the original atom, so that analysis based on sequence is preserved. Atom numbering is changed,
but atom names are unchanged, meaning that a given residue may have several atoms with the same name. A
different program is available for taking this new topology ﬁle and splitting the copies apart into separate residues,
if desired. All copies are given the same coordinates as in the input coordinate ﬁle for the non-LES system.

Using addles:

addles < inputfile > outputfile

SAMPLE INPUT FILE:

~ a line beginning with ~ is a comment line.
~ all commands are 4 letters.
~ the maximum line length is 80 characters;
~ a trailing hyphen, "-", is the line continuation token.
~ use ’file’ to specify an input/output file, then the type of file

’rprm’ means this is the file to read the prmtop

~ the ’read’ means it is an input file
~
file rprm name=(solv2OO.topo) read
~
~ ’rcrd’ reads the original coordinates- optional, only if you want

578

29.2. Using the ADDLES program

~ a set of coords for the new topology
~ you can also use ’rcvd’ for coords+velocities, ’rcvb’ for coords,
~ velos and box dimensions, ’rcbd’ for coords and box dimensions.
~ use "pack=n" option to read in multiple sets of coordinates and
~ assign different coordinates to different copies.
file rcrd name=(501v200.coords) read
~ ’wprm’ is the new topology file to be written. the ’wovr’ means to
~ write over the file if it exists, ’writ’ means don’t write over.
file wprm name=(lesparm) wovr
~ ’wcrd is for writing coords, it will automatically write velo and box
~ if they were read in by ’rcvd’ or ’rcvb’
file wcrd name=(lescrd) wovr
~ now put ’action’ before creating the subspaces
action
~ the default behavior is to scale masses by 1/N.
~ omas leaves all masses at the original values
omas
~ now we specify LES subspaces using the ’spac’ keyword, followed
~ by the number of copies to make and then a pick command to tell which
~ atom to copy for this subspace
~ 3 copies of the fragment consisting of monomers (=residues) 1 and 2
spac numc=3 pick #mon 1 2 done
~ 3 copies of the fragment consisting of monomers 3 and 4
spac numc=3 pick #mon 3 4 done
~ 3 copies of the fragment consisting of residues 5 and 6
spac numc=3 pick #mon 5 6 done
~ 2 copies of the side chain on residue 1
~ note that this replaces each of the side chains ON EACH OF THE 3
~ COPIES MADE ABOVE with 2 copies - net 6 copies
~ each of the 3 copies of residue 1-2 has 2 side chain copies.
~ the ’#sid’ command picks all atoms in the residue except
~ C,O,CA,HA,N,H and HN.
spac numc=2 pick #sid 1 1 done
spac numc=2 pick #sid 2 2 done
spac numc=2 pick #sid 3 3 done
spac numc=2 pick #sid 4 4 done
spac numc=2 pick #sid 5 5 done
~ use the *EOD to end the input
*EOD

What this does: all of the force constants are scaled in the new prmtop ﬁle by 1/N for N copies, so that this scaling
does not need to be done for each pair during the nonbond calculation. Charges and VDW epsilon values are also
scaled. New bond, angle, torsion and atom types are created. Any of the original types that were not used are
discarded. Since each LES copy should not interact with other copies of the SAME subspace, the other copies are
placed in the exclusion list. If you deﬁne very large LES regions, the exclusion list will get large and you may have
trouble with the ﬁxed length for this entry in the prmtop ﬁle- currently 8 digits.

The coordinates are simply copied - that means that all of the LES copies initially occupy the same positions
in space. In this setup, the potential energy should be identical to the original system- this is a good test to make
sure everything is functioning properly. Do a single energy evaluation of the LES system and the original system,
using the copied coordinate ﬁle. All terms should be nearly identical (to within machine precision and roundoff).
With PME on non- neutral systems, all charges are slightly modiﬁed to neutralize the system. For LES, there are
a different number of atoms than in the original system, and therefore this charge modiﬁcation to each atom will
differ from the non-LES system and electrostatic energies will not match perfectly.

579

29. Locally-enchanced sampling

IMPORTANT: After creating the LES system, the copies will all feel the same forces, and since the coordinates
are identical, they will move together unless the initial velocities are different. If you are initializing velocities
using INIT=3 and TEMPI>0, this is not a problem. In order to circumvent this problem, addles slightly (and
randomly) modiﬁes the copy velocities if they were read from the coordinate input ﬁle. If the keyword "nomodv"
is speciﬁed, the program will leave all of the velocities in the same values as the original ﬁle. If you do not read
velocities, make sure to assign an initial nonzero temperature to the system. You should think about this and
change the behavior to suit your needs. In addition, the program scales the velocities by sqrt(N) for N copies to
maintain the correct thermal energy (mv2), but only when the masses are scaled (not using omas option). Again,
this requires some thought and you may want different behavior. Regardless of what options are used for the
velocities, further equilibration should be carried out. These options are simple attempts to keep the system close
to the original state.[629]

Sometimes it is critical that different copies can have different initial coordinates (NEB for example), this is

why the option "pack" is added to command rcrd(rcvd,rcvb,rcbd). To use this option, user need ﬁrst concatenate
different coordinates into a single ﬁle, and use "pack=n" to indicate how many sets of coordinates there are in the
ﬁle, like the following example:

file rcrd name=(input.inpcrd) pack=4 read

Then addles will assign coordinates averagely. For example, if 4 sets coordinates exists in input ﬁle, and 20 copies
are generated, then copy 1-5 will have coordinate set 1, copy 6-10 will have coordinates set 2, and so on. Note this
option can’t work with multiple copy regions now.

It is important to understand that each subsequent pick command acts on the ORIGINAL particle numbers.
Making a copy of a given atom number also makes copies of all copies of that atom that were already created.
This was the simplest way to be able to have a hierarchical LES setup, but you can’t make extra copies of part of
one of the copies already made. I’m not sure why you would want to, or if it is even correct to do so, but you
should be warned. Copies can be anything -spanning residues, copies of fragments already copied, non-contiguous
fragments, etc. Pay attention to the order in which you make the copies, and look carefully at the output to make
sure you get what you had in mind. Addles will provide a list at the end of all atoms, the original parent atom, and
how many copies were made.

There are array size limits in the ﬁle SIZE.h, I apologize in advance for the poor documentation on these. Mail

carlos.simmerling@stonybrook.edu if you have any questions or problems.

29.3. More information on the ADDLES commands and options

file:

rcrd:

rcvd:

rcvb:

wcrd:

wprm:

open a ﬁle, also use one of

read coords from this ﬁle

read coords + velo from ﬁle

read coords, velo and box from ﬁle

write coords (and more if rcvd, rcvb) to ﬁle

write new topology ﬁle

action:

start run, all of the following options must come AFTER action

nomodv:

do NOT slightly randomize the velocities of the copies

spac:

add a new subspace deﬁnition, using a pick command (see below); follow with “numc=# pickcmd”,
where # is the number of copies to make and pickcmd is a pick command that selects the group of
atoms to copy.

omas:

leave all masses at original values (otherwise scale 1/N)

580

29.4. Using the new topology/coordinate ﬁles with SANDER

pimd:

write an prmtop ﬁle for PIMD simulation, which contains a much smaller non-bond exclusion list,
atoms from other copy will not be included in this non-bond exclusion list.

Syntax for ’pick’ commands

Currently, the syntax for picking atoms is somewhat limited. Simple Boolean logic is followed, but operations

are carried out in order and parentheses are not allowed.

#prt A B

picks the atom range from A to B by atom number

#mon A B

picks the residue range from A to B by residue number

#cca A B

picks the residue range from A to B by residue number, but dividing the residue between CA and C;
the CO for A is included, and the CO for monomer B is not. See Simmerling and Elber, 1994 for an
example of where this can be useful.

chem prtc A picks all atoms named A, case sensitive

chem mono A picks all residues named A, case sensitive

Completion wildcards are acceptable for names: H* picks H, HA, etc. Note that H*2 will select all atoms starting
with H and ignore the 2.

Boolean logic:

|

&

!=

or atoms in either group are selected

and atoms must be in both groups to be selected

not A != B will pick all atoms in A that are NOT in B

The user should carefully check the output ﬁle to ensure that the proper atoms were selected.

Examples:

pick command
pick #mon 4 19 done
pick #mon 1 50 & chem mono GLY done
pick chem mono LYS | chem mono GLU done any GLU or LYS residue
pick #mon 1 5 != #prt 1 3 done

atoms selected
all atoms in residues 4 through 19
only GLY in residues 1 to 50

residues 1 to 5 but not atoms 1 to 3

so, a full command to add a new subspace (LES region) with 4 copies of atoms 15 to 35 is:

spac numc=4 pick #prt 15 35 done

29.4. Using the new topology/coordinate ﬁles with SANDER

These topology ﬁles are ready to use in Sander with one exception: all of the FF parameters have been scaled
by 1/N for N copies. This is done to provide the energy of the new system as an average of the energies of
the individual copies (note that it is an average energy or force, not the energy or force from an average copy
coordinate). However, one additional correction is required for interactions between pairs of atoms in the same
LES region. Sander will make these corrections for you, and this information is just to explain what is being done.
For example, consider a system where you make 2 copies of a sidechain in a protein. Each charge is scaled by
1/2. For these atoms interacting with the rest of the system, each interaction is scaled by 1/2 and there are 2 such
interactions. For a pair of particles inside the sub-space, however, the interaction is scaled by 1/2*1/2=1/4, and
since the copies do not interact, there are only 2 such interactions and the sum does not correspond to the correct
average. Therefore, the interaction must be scaled up by a factor of N. When the PME technique is requested, this
simple scaling cannot be used since the entire charge set is used in the construction of the PME grid and individual
charges are not used in the reciprocal space calculation. Therefore, the intra-copy energies and forces are corrected
in a separate step for PME calculations. Sander will print out the number of correction interactions that need to

581

29. Locally-enchanced sampling

be calculated, and very large amounts of these will make the calculation run more slowly. PME also needs to do a
separate correction calculation for excluded atom pairs (atoms that should not have a nonbonded interaction, such
as those that are connected by a bond). Large LES regions result in large numbers of excluded atoms, and these
will result in a larger computational penalty for LES compared to non-LES simulations. For both of these reasons,
it is more efﬁcient computationally to use smaller LES regions- but see the discussion above for how region size
affects simulation efﬁciency. These changes are included in the LES version of Sander (sander.LES). Each particle
is assigned a LES ’type’ (each new set of copies is a new type), and for each pair of types there is a scaling factor
for the nonbond interactions between LES particles of those types. Most of the scaling factors are 1.0, but some
are not - such as the diagonal terms which correspond to interactions inside a given subspace, and also off-diagonal
terms where only some of the copies are in common. An example of this type is the side chain example given
above- each of the 3 backbone copies has 2 sidechains, and while interactions inside the side chains need a factor
of 6, interactions between the side chain and backbone need a factor of 3. This matrix of scaling factors is stored
in the new topology ﬁle, along with the type for each atom, and the number of types. The changes made in sander
relate to reading and using these scale factors.

29.5. Using LES with the Generalized Born solvation model

LES simulations can be performed using the GB solvent model, with some limitations. Compared to LES
simulations in explicit water, using GB with LES provides several advantages. The most important is how each of
the copies interacts with the solvent. With explicit water, the water is normally not copied and therefore interacts
in an average way with all LES copies. This has important consequences for solvation of the copies. If the copies
move apart, water cannot overlap any of them and therefore the water cavity will be that deﬁned by the union of
the space occupied by the copies. This has two consequences. First, moving the copies apart requires creation of a
larger solvent cavity and therefore copies have a greater tendency to remain together, reducing the effectiveness of
LES. Second, when the copies do move apart, each copy will not be individually solvated.

These effects arise because the water interacts with all of the copies; for each copy to be solvated independently
of the other copies would require copying the water molecules. This is normally not a good idea, since copying all
of the water would result in very signiﬁcant computational expense. Copying only water near the solute would be
tractable, but one would need to ensure that the copied waters did not exchange with non-LES bulk waters.

Using GB with LES largely overcomes these problems since each copy can be individually solvated with the
continuum model. Thus when one copy moves, the solvation of the other copies are not affected. This results in a
more reasonable solvation of each copy and also improves the independence of the copies. Of course the resulting
simulations do retain all of the limitations that accompany the GB models.

The current code allows igb values of 1, 5 or 7 when using LES. Surface area calculations are not yet supported
with LES. Only a single LES region is permitted for GB+LES simulations. A new namelist variable was introduced
(RDT) in sander to control the compromise of speed and accuracy for GB+LES simulations. The article referenced
below provides more detail on the function of this variable. RDT is the effective radii deviation threshold. When
using GB+LES, non-LES atoms require multiple effective Born radii for an exact calculation. Using these multiple
radii can signiﬁcantly increase calculation time required for GB calculations. When the difference between the
multiple radii for a non-LES atom is less than RDT, only a single effective radius will be used. A value of 0.01
has been found to provide a reasonable compromise between speed and accuracy, and is the default value. Before
using this method, it is strongly recommended that the user read the article describing the derivation of the GB+LES
approach.[630]

29.6. Case studies: Examples of application of LES

29.6.1. Enhanced sampling for individual functional groups: Glucose

The ﬁrst example will deal with enhancing sampling for small parts of a molecule, such as individual

functional groups or protein side chains. In this case we wanted to carry out separate simulations of α and β (not
converting between anomers, only for conversions involving rotations about bonds) glucose, but the 5 hydroxyl
groups and the strong hydrogen bonds between neighboring hydroxyls make conversion between different

582

29.6. Case studies: Examples of application of LES

rotamers slow relative to affordable simulation times. The eventual goal was to carry out free energy simulations
converting between anomers, but we need to ensure that each window during the Gibbs calculation would be able
to sample all relevant orientations of hydroxyl groups in their proper Boltzmann-weighted populations. We were
initially unsure how many different types of structures should be populated and carried out non-LES simulations
starting from different conformations. We found that transitions between different conformations were separated
by several hundred picoseconds, far too long to expect converged populations during each window of the free
energy calculation. We therefore decided to enhance conformational sampling for each hydroxyl group by
making 5 copies of each hydroxyl hydrogen and also 5 copies of the entire hydroxymethyl group. Since the
hydroxyl rotamer for each copy should be relatively independent, we decided to place each group in a different
LES region. This meant that each hydroxyl copy interacted with all copies of the neighboring groups, with a total
of 5*5*5*5*5 or 3125 structural combinations contributing to the LES average energy at each point in time. The
input ﬁle is given below.

file rprm name=(parm.solv.top) read
file rcvb name=(glucose.solv.equ.crd) read
file wprm name=(les.prmtop) wovr
file wcrd name=(glucose.les.crd) wovr
action
omas
~ 5 copies of each hydroxyl hydrogen- copying oxygen will make no difference
~ since they will not be able to move significantly apart anyway
spac numc=5 pick chem prtc HO1 done
spac numc=5 pick chem prtc HO2 done
spac numc=5 pick chem prtc HO3 done
spac numc=5 pick chem prtc HO4 done
~ take the entire hydroxy methyl group
spac numc=5 pick #prt 20 24 done
*EOD

This worked quite well, with transitions now occurring every few ps and populations that were essentially inde-
pendent of initial conformation.[627]

29.6.2. Enhanced sampling for a small region: Application of LES to a nucleic acid loop

In this example, we consider a biomolecule (in this case a single RNA strand) for which part of the structure
is reliable and another part is potentially less accurate. This can be the case in a number of different modeling
situations, such as with homologous proteins or when the experimental data is incomplete. In this case two different
structures were available for the same RNA sequence. While both structures were hairpins with a tetraloop, the
loop conformations differed, and one was more accurate. We tested whether MD would be able to show that one
structure was not stable and would convert to the other on an affordable timescale.

Standard MD simulations of several ns were not able to undergo any conversion between these two structures

(the initial structure was always retained). Since the stem portion of the RNA was considered to be accurate, LES
was only applied to the tetraloop region. In this case, both of the ends of the LES region would be attached to the
same locations in space, and there was no concern about copies diffusing too far apart to re-converge to the same
positions after optimization. The issues that need to be addressed once again are the number of copies to use, and
how to place the LES region(s). I usually start with the simplest choices and used 5 LES copies and only a single
LES region consisting of the entire loop. If each half of the loop was copied, then it might become too crowded
with copies near the base-pair hydrogen bonds and conformational changes that required moving a base through
this regions could become even more difﬁcult (see the background section for details). Therefore, one region was
chosen, and the RNA stem, counterions and solvent were not copied. The ADDLES input ﬁle is given below.

file rprm name=(prm.top) read
file rcvb name=(rna.crd) read
file wprm name=(les.parm) wovr

583

29. Locally-enchanced sampling

file wcrd name=(les.crd) wovr
action
omas
~ copy the UUCG loop region- residues 5 to 8.
~ pick by atom number, though #mon 5 8 would work the same way
spac numc=5 pick #prt 131 255 done
*EOD

Subsequent LES simulations were able to reproducibly convert from what was known to be the incorrect structure
to the correct one, and stay in the correct structure in simulations that started there. Different numbers of LES
copies as well as slightly changing the size of the LES region (from 4 residues to 6, extending 1 residue beyond
the loop on either side) were not found to affect the results. Fewer copies still converted between structures, but on
a slower timescale, consistent with the barrier heights being reduced roughly proportional to the number of copies
used. See Simmerling, Miller and Kollman, 1998, for further details.

29.6.3. Improving conformational sampling in a small peptide

In this example, we were interested not just in improving sampling of small functional groups or even

individual atoms, but in the entire structure of a peptide. The peptide sequence is AVPA, with ACE and NME
terminal groups. Copying just the side chains might be helpful, but would not dramatically reduce the barriers to
backbone conformational changes, especially in this case with so little conformational variety inherent in the Ala
and Pro residues. We therefore apply LES to all atoms. If we copied the entire peptide in 1 LES regions, the
copies could ﬂoat apart. While this would not be a disaster, it would make it difﬁcult to bring all of the copies
back together if we were searching for the global energy minimum, as described above. We therefore use more
than one LES region, and need to decide where to place the boundaries between regions. A useful rule of thumb
is that regions should be at least two amino acids in size, so we pick our two regions as Ace-Ala-Val and Pro-Ala-
Nme. If we make ﬁve LES copies of each region and each copy does not interact with other copies of the same
regions, each half the peptide will be represented by ﬁve potentially different conformations at each point in time.
In addition, since each copy interacts with all copies of the rest of the system, there are 25 different combinations
of the two halves of the peptide that contribute at each point in time. This statistical improvement alone is
valuable, but the corresponding barriers are also reduced by approximately the same factors. When we place the
peptide in a solvent box the solvent interacts in an average way with each of the copies. The input ﬁle is given
below, and all of the related ﬁles can be found in the test directory for LES.

~ all file names are specified at the beginning, before "action"
~ specify input prmtop
file rprm name=(prmtop) read
~ specify input coordinates, velocities and box (this is a restart file)
file rcvb name=(md.solv.crd) read
~ specify LES prmtop
file wprm name=(LES.prmtop) wovr
~ specify LES coordinates (and velocities and box since they were input)
file wcrd name=(LES.crd) wovr
~ now the action command reads the files and tells addles to
~ process commands
action
~ do not scale masses of copied particles
omas
~ divide the peptide into 2 regions.
~ use the CCA option to place the division between carbonyl and
~ alpha carbon
~ use the "or" to make sure all atoms in the terminal residues
~ are included since the CCA option places the region division at C/CA
~ and we want all of the terminal residue included on each end

584

29.6. Case studies: Examples of application of LES

~
~ make 5 copies of each half
~ "spac" defines a LES subspace (or region)
spac numc=5 pick #cca 1 3 | #mon 1 1 done
spac numc=5 pick #cca 4 6 | #mon 6 6 done
~ the following line is required at the end
*EOD

This example brings up several important questions:

1. Should I make LES copies before or after adding solvent? Since LEaP is used to add solvent, and LEaP
will not be able to load and understand a LES structure, you must run ADDLES after you have solvated the
peptide in LEaP. ADDLES should be the last step before running SANDER.

2. Which structure should be used as input to ADDLES? If you will also be carrying out non-LES simulations,
then you can equilibrate the non-LES simulation and carry out any amount of production simulation desired
before taking the structure and running ADDLES. At the point you may switch to only LES simulations,
or continue both LES and non-LES from the same point (using different versions of SANDER). Typically
I equilibrate my system without LES to ensure that it has initial stability and that everything looks OK,
then switch to LES afterward. This way I separate any potential problems from incorrect LES setup from
those arising from problems with the non-LES setup, such as in initial coordinates, LEaP setup, solvent box
dimensions and equilibration protocols.

3. How can I analyze the resulting LES simulation? This is probably the most difﬁcult part of using LES. With
all of the extra atoms, most programs will have difﬁculty. For example, a given amino acid with LES will
have multiple phi and psi backbone dihedral angles. There are basically two options: ﬁrst, you can process
your trajectory such that you obtain a single structure (non-LES). This might be just extracting one of the
copies, or it might be one by taking the average of the LES copies. After that, you can proceed to traditional
analysis but must keep in mind that the average structure may be non-physical and may not represent any
actual structure being sampled by the copies, especially if they move apart signiﬁcantly. A better way
is to use LES-friendly analysis tools, such as those developed in the group of Carlos Simmerling. The
visualization program MOIL-View (http://morita.chem.sunysb.edu/carlos/moil-view.html) is one example of
these programs, and has many analysis tools that are fully LES compatible. Read the program web page or
manual for more details.

1.7. Unresolved issues with LES in Amber

1. Sander can’t currently maintain groups of particles at different temperatures (important for dynamics, less
so for optimization.)[626, 631] Users can set temp0les to maintain all LES atoms at a temperature that is
different from that for the system as a whole, but all LES atoms are then coupled to the same bath.

2. Initial velocity issues as mentioned above- works properly, user must be careful.

3. Analysis programs may not be compatible. See http://morita.chem.sunysb.edu/carlos/moil-view.html for an

LES-friendly analysis and visualization program.

4. Visualization can be difﬁcult, especially with programs that use distance-based algorithms to determine

bonds. See #3 above.

5. Water should not be copied- the fast water routines have not been modiﬁed. For most users this won’t matter.

6. Copies should not span different ’molecules’ for pressure coupling and periodic imaging issues. Copies of
an entire ’molecule’ should result in the copies being placed in new, separate molecules- currently this is not
done. This would include copying things such as counterions and entire protein or nucleic acid chains.

7. Copies are placed into the same residue as the original atoms- this can make some residues much larger than
others, and may result in less efﬁcient parallelization with algorithms that assign nonbond workload based
on residue numbers.

585

30. gem.pmemd

30.1. Introduction

The Amoeba force ﬁeld is a multipolar/polarizable force ﬁeld with parameters for water, univalent ions, small
organic molecules, proteins, nucleic acids and ionic liquids.[16, 17, 432, 433, 632–638] Differences from the
current amber force ﬁelds include more complex valence terms including anharmonic bond and angle corrections
and bond angle and bond dihedral cross terms, and a two dimensional spline ﬁt for the phi-psi bitorsional energy.
The differences in the nonbond treatment include the use of atomic multipoles up to quadrupole order, induced
dipoles using a Tholé screening model, and the use of the Halgren buffered 7-14 functional form for van der
Waals interactions. The PME implementation used here, as well as a multigrid approach for atomic multipoles, is
described in Ref. [439].

Right now, setting up the system is a bit complex: you need to set up the system in Tinker, then run the tinker-to-
amber program to convert to Amber prmtop and coordinate ﬁles. Some examples are in $AMBERHOME/Amber-
Tools/src/gem.pmemd/build_amoeba. For ionic liquid sytems, a separate Tinker–style parameter ﬁle is provided in
the same directory. We hope to provide a simpler path soon, and will post a notice on the Amber webpage when
available.

Two executables are provided to perform AMOEBA simulations, sander and gem.pmemd. Both executables
employ the same input parameters for the &amoeba namelist (see below). The gem.pmemd executable has full
AMOEBA capabilities, and, in addition, can run MD simulations for an experimental implementation of the GEM*
water potential. [639–642] Features such as replica exchange and vdw soft core capabilities are not supported in
gem.pmemd. Also note that GEM* and the GEM implementation in gem.pmemd are experimental, the gme.pmemd
executable is being provided primarily as an option for AMOEBA simulations, as it provides improved parallel
performance. Two tests are provided for GEM* for a 2048 waters box involving the model published in Ref. [642]
The code and test for GEM* are provided as is, and methods to build other boxes/parameters are unavailable.

With the use of AMOEBA, minimization as well as usual methods of molecular dynamics can be used, including
constant temperature and pressure simulations. In addition, with the AMOEBA implementation it is possible to use
the Beeman dynamics integrator, which is helpful in making detailed comparisons to Tinker results. Note that the
Amoeba forceﬁeld is parametrized for fully ﬂexible molecules. Thus, SHAKE is not used with with this forceﬁeld.
In addition to these capabilities, gem.pmemd provides the ability to employ a Monte Carlo barostat for constant
pressure simulations with AMOEBA.

The parameters ew_coeff, nfft1, nfft2, nfft3, and order from the &ewald section of input all relate to the accu-
racy of the PME method, which is used in the AMOEBA implementation in sander. Due to the use of atomic
quadrupoles, order (i.e. the B-spline polynomial degree plus one) needs to be at least 5 since the B-spline needs 3
continuous derivatives. The ew_coeff together with the direct sum cutoff (see below) controls the accuracy in the
Ewald direct sum, and ew_coeff together with the PME grid dimensions nfft1,2,3 and order controls the accuracy
in the reciprocal sum. Since AMOEBA atomic multipoles are typically dominated by the charges, experience
gained in the usual use of PME is pertinent. Typical values we have used for a good cost vs. accuracy balance are
ew_coeff=0.45, order=5, and nfft1,2,3 approximately 1.25 times the cell length in the relevant direction.

30.2. Input variables

&cntrl Namelist input:

iamoeba

It should be set to 1 to use the AMOEBA force ﬁeld. To use GEM* set to 2. When AMOEBA is
used, only an &amoeba namelist is required (see below). When GEM* is used, both &amoeba and

586

30.2. Input variables

&gem namelists must be provided. The &amoeba section then serves to provide information needed
to evaluate covalent and polarization terms of the forceﬁeld.

&amoeba Namelist input:

beeman_integrator Setting this to be one turns on the Beeman integrator. This is the default integrator for
AMOEBA in Tinker. In sander this integrator can be used for NVE simulations, or for NVT or
NTP simulations using the Berendsen coupling scheme. (This means that you must set ntt to 0 or 1
if you use the Beeman integrator.) By default, beeman_integrator=0, and the usual velocity Verlet
integration scheme is used instead.

amoeba_verbose In addition to the usual sander output, by setting amoeba_verbose=1, energy and virial compo-

nents can be output. By default, amoeba_verbose=0.

ee_dsum_cut This is the ewald direct sum cutoff. In the amoeba implementation this is allowed to be different
from the nonbond cutoff speciﬁed by cut. It should be less than or equal to the latter. (Note, this
feature does not apply to the direct sum for standard amber force ﬁelds, which use the nonbond cutoff
for the Ewald direct sum as well as van der Waals interactions. The default is 7.0 Angstroms, which
is conservative for energy conservation with ew_coeff=0.45.

dipole_scf_tol The induced dipoles in the amoeba force ﬁeld are solutions to a set of linear equations (like
the Applequist model but modiﬁed by Tholé damping for close dipole-dipole interactions). These
equations are solved iteratively by the method of successive over-relaxation. dipole_scf_tol is the
convergence criterion for the iterative solution to the linear equations. The iterations towards con-
vergence stop when the RMS difference between successive sets of induced dipoles is less than this
tolerance in Debye. The default is set to 0.01 Debye, which has been seen to give reasonable en-
ergetics and dynamics, but requires mild temperature restraints. Good energy conservation in NVE
simulations requires a tolerance of about 10-6 Debye.

sor_coefficient This is the successive over-relaxation parameter. This can be adjusted to optimize the number
of iterations needed to achieve convergence. Default value is 0.75. Productive values seem to be in
the range 0.6-0.8 .The optimal values seem to depend on the polarizabilities of the system atoms.

dipole_scf_iter_max This prevents inﬁnite iterations when the polarization equations are somehow not con-
verging. A possible reason for this is a bad sor_coefﬁcient, exacerbated by a close contact. Default
is 50. For comparison, with typical sor_coefﬁcient values and an equilibrated system it should take
4-7 iterations to achieve 0.01 Debye convergence and 18-25 iterations to achieve 10−6 Debye.

ee_damped_cut This is used to cutoff the Tholé damping interactions. The default value is 4.5 Angstroms, which
should work for the typical sized polarizabilities encountered, and the default Tholé screening pa-
rameter (0.39).

do_vdw_taper Amoeba uses a Halgren buffered 7-14 form for the van der Waals interactions. In the Tinker code
these are typically evaluated out to 12 Angstroms, with a taper turned on and no long-range isotropic
continuum corrections to the energy and virial. In the sander implementation, the usual nonbond
cutoff from the &cntrl namelist is used for van der Waals interactions. The long range correction is
available to allow for shorter cutoffs. Setting do_vdw_taper to one causes VDW interactions to be
tapered to zero beginning at 0.9 times the van der waals cutoff. The taper is a 5th order polynomial
switch on the energy term, which gets differentiated for the forces (atom based switching). It’s turned
on by default.

do_vdw_longrange Setting this to one causes the long-range isotropic continuum correction to be turned on.
This adjusts the energy and virial, and in most cases will result in energies and virials that are fairly
invariant to van der Waals cutoff, with or without the above taper function. The integrals involved in
this correction are done numerically.

587

30. gem.pmemd

There are a lot of other do_-preﬁxed keywords that may be used in the &amoeba namelist; these are all used to
turn on or off evaluation of various energy/force components in the Amoeba forceﬁeld. These really were intended
primarily for development test, but we mention them here as you may encounter them in some of the sample test
cases.

In addition to the &amoeba namelist, gem.pmemd must have a &gem namelist which includes several options

to deal with the Gaussian distributions.
&gem Namelist input:

pme_auto_setup Set to 1 to use the PME method

reg_ewald_auto_setup Set to 1 to use the regular Ewald method

ffp_auto_setup Set to 1 to use the Fast Fourier Poisson (FFP) method

nfft#_for_gridtype nfft1_for_gridtype, nfft2_for_gridtype, nfft3_for_gridtype – These keywords determine the
FFT grid count in the x, y, and z dimensions of the unit cell. Assuming that coul_CD_split_exponent
is less than 0.3 (for the current GEM* ﬁtted density), reasonable accuracy is obtained by
specifying values that result in a grid density in the range of 1.3 to 1.5 grids per Å. If the
coul_CD_split_exponent value is higher, which typically results in the inclusion of diffuse hermites
in the system, then values of 2.0 grids per Å or higher are appropriate.

coul_gaussian_extent_tol Coulomb Hermite Gaussian extent error tolerance. The default is 1.d-08.

exch_gaussian_extent_tol Exchange Hermite Gaussian extent error tolerance. The default is 1.d-08.

bspline_order_for_gridtype A bspline order of 6 typically produces reasonable results.

coul_CD_split_expon GEM Hermites with an exponent of less than coul_CD_split_expon will be treated as
diffuse GEM Hermites and all pairs involving Hermites below this exponent (diffuse–difuse and
compact-diffuse) will be evaluated in reciprocal space. The rest of the GEM Hermites will be treated
as compact Hermites and evaluated only in direct space (compact–compact). Setting this value
effectively determines the minimum cutoff required for direct space evaluation of GEM compact
Hermites.

exch_factor The proportionality factor for exchange forces and energies. The current exchange factor for the

ﬁtted GEM* parameters is 6.6899; the current default is 1.d0, and not recommended.

exch_cutoff The current auxiliary ﬁtting basis contains Gaussian Hermites that result in fairly compact Gaussian
products, and it is possible to neglect a large number of overlap integrals for the Exchange repulsion
term by using a cutoff distance. We currently recommend this value be set to 6.d0 Å; the current
default is 10.d0, and is unnecessarily large.

gem_verbose Additional information about energy decomposition, etc. is available by setting gem_verbose to 1,

2, or 3, with information increasing in that order.

gaussian_recip_tol A reciprocal space tolerance only used for FFP. The current default is 1.d-08.

Namelist input reserved for use in GEM forceﬁeld development: The following &gem namelist keywords are
allowed input to gem.pmemd, but usage is discouraged, as usage of these keywords requires an intimate knowledge
of GEM parameters as well as efﬁciency and accuracy considerations. Appropriate system–dependent values for
these keywords are determined by the *_auto_setup keywords in the &gem Namelist. The experimental reserved
keywords include:

user_num_HC_prim_grids, user_num_HD_prim_grids, user_num_aux_Cprims, user_num_aux_Dprims,
user_num_prim_gridtypes, user_gridtype_for_MPOLES, user_gridtype_for_sumch,
user_gridtype_for_HC_prim_grid, user_gridtype_for_HD_prim_grid, user_HC_gridtype_idx_for_Caux,
user_HD_gridtype_idx_for_Daux, coulomb_use_recip, struc_fac_method_for_gridtype

588

30.2. Input variables

gem.pmemd limitations:
The current version of gem.pmemd supports constant T and constant P (only with the Monte Carlo barostat) sim-
ulations with GEM*. Only orthogonal unit cells are supported. The appropriate options to meet these conditions
should be selected under the &cntrl namelist.

Extra gem.pmemd input ﬁles required for the GEM* test:

-gem_aux- File specifying the gem multipole and Hermite basis set/ﬁtting coefﬁcients. The example provided

in the tests is Avg_A4_Analytic.

-gem_lst- File specifying various details about the GEM* molecules, including the local frame descriptions.

-gem_crd- A redundant ﬁle specifying atom coordinates in a format suitable for earlier GEM code. While
this input will be checked to see if it matches inpcrd, there is no requirement for it to match. An
informational message will be printed if the ﬁles do not match. In our test cases, a totally incorrect
ﬁle (but in the correct format) is provided. This has been retained for cross-checking capability, but
is of no use to non-developers. The ﬁle we provide in tests is equil_216_wat_crd.

589

Part V.

Analysis of simulations

590

31. mdout_analyzer.py and ambpdb

mdout_analyzer.py is a simple script designed to help you rapidly parse and analyze the energy components

printed in the output ﬁles from sander and pmemd. It requires that the numpy and matplotlib packages be
installed. The scipy Python package is also required when plotting smoothed histograms using kernel density
estimates. You can use it as follows:

mdout_analyzer.py <mdout1> <mdout2> <mdout3> ... <mdoutN>

Where each mdout ﬁle is combined into a single data set. A GUI window will open up with buttons for every
energy component parsed from the mdout ﬁle followed by a button for each type of graphical analysis you can do
on the data shown below.

A second window has options to control how the graphs will appear. Help is available in the <Help> menu at
the top of the main window. Note, mdout ﬁles must be from the same type of simulation (or at least have all of the
same energy components printed inside) in order to be combined.

Right-clicking on each energy button brings up a little window describing what that energy term is.

31.1. ambpdb

NAME ambpdb - convert amber-format coordinate ﬁles to pdb format

SYNOPSIS

ambpdb [ -p prmtop-file ] < AmberRestartFile
ambpdb [ -p prmtop-file ] -c coordinate-file

Additional Options:

[ -tit title ] [ -pqr|-mol2] [ -aatm ] [-bres ] [-noter] [-offset #] [ -ext ]

ambpdb is a ﬁlter to take a coordinate "restart" ﬁle from an AMBER dynamics or minimization run and prepares a
pdb-format ﬁle (on STDOUT). The program assumes that a prmtop ﬁle is available, from which it gets atom and
residue names. Note: starting with AmberTools15, ambpdb can convert any coordinate ﬁle format that CPPTRAJ
can read using the ’-c’ ﬂag. Either an Amber restart ﬁle must be directed in via STDIN or a ﬁle with ’-c’ must be
speciﬁed.

Print a usage summary to the screen.

Specify the Amber topology ﬁle to use (if not speciﬁed will look for ﬁle named “prmtop”).

Instead of reading an Amber restart from STDIN, speciﬁes ﬁle to read coordinates from; can be any
format that CPPTRAJ can read.

The title, if given, will be output as a REMARK at the top of the ﬁle. It should be protected by
quotes or double quotes if it contains spaces or special characters.

If -pqr is set, output will be in the format needed for the electrostatics programs that need charge and
radius information.

OPTIONS

-h

-p

-c

-tit

-pqr

592

31.1. ambpdb

-mol2

-aatm

-bres

-noter

-offset

creates a TRIPOS mol2 ﬁle with all of the residues and bond information present in the topology
ﬁle.

This switch controls whether the output atom names follow Amber or Brookhaven (PDB) formats.
With the default (when this switch is not set), atom names will be placed into four columns following
the rules used by the Protein Data Base in Version 3.

If -bres (Brookhaven-residue-names) is not set (the default), Amber-speciﬁc atom names (like CYX,
HIE, RG5, etc.) will be kept in the pdb ﬁle; otherwise, these will be converted to PDB-standard
names (CYS, HIS, G, in the above example). Note that setting -bres creates a naming ambiguity
between protonated and unprotonated forms of amino acids.
If you plan to re-read the pdb ﬁle back into Amber programs, you should use the default behavior;
for programs that demand stricter conformance to Brookhaven standards, set -bres.

If -noter is set, the output PDB ﬁle not include TER cards between molecules. Otherwise, TER
cards will be added whenever there is not bond between adjacent residues. Note that this means
there will be a TER card between each water molecule, for example, unless -noter is set. The PDB
is idiosyncratic about TER cards: they are generally present between separate protein chains, but
generally not present between cofactors or solvent molecules. This behavior is not mimicked by
ambpdb.

If a number is given here, it will be added to all residue numbers in the output pdb ﬁle. This is useful
if you want the ﬁrst residue (which is always "1" in an Amber prmtop ﬁle, to be a larger number, (say
to more closely match a ﬁle from Brookhaven, where initial residues may be missing). Note that the
number you provide is one less than what you want the ﬁrst residue to have.
Residue numbers greater than 9999 will not "ﬁt" into the Brookhaven format; ambpdb actually prints
mod(resno,10000); that is, after 9999, the residue number re-cycles to 0.

-ext

This tells ambpdb to use any extended PDB info present in prmtop-ﬁle (from using e.g. the ’addPDB’
command from parmed).

593

32. cpptraj

32.1. Introduction

Cpptraj[643] (the successor to ptraj) is the main program in Amber for processing coordinate trajectories and
data ﬁles. Cpptraj has a wide range of functionality, and makes use of OpenMP/MPI to speed up many calculations,
including processing ensembles of trajectories and/or conducting multiple analyses in parallel with MPI.[644]

Here are several notable features of cpptraj:

1. Trajectories with different topologies can be processed in the same run.

2. Several actions/analyses in cpptraj are OpenMP parallelized; see section 32.2.7.2 for more details.

3. Trajectory and ensemble reads can be MPI parallelized.

4. Almost any ﬁle read or written by cpptraj can be compressed (with the exception of the NetCDF trajectory
format). So for example gzipped/bzipped topology ﬁles can be read, and data ﬁles can be written out as
gzip/bzip2 ﬁles. Compression is detected automatically when reading, and is determined by the ﬁlename
extension (.gz and .bz2 respectively) on writing.

5. The format of output data ﬁles can be speciﬁed by extension. For example, data ﬁles can be written in
xmgrace format if the ﬁlename given has a ’.agr’ extension. A trajectory can be written in DCD format if
the ’.dcd’ extension is used.

6. Multiple output trajectories can be speciﬁed, and can be written during action processing (as opposed to only
after) via the outtraj command. In addition, output ﬁles can be directed to write only speciﬁc frames from
the input trajectories.

7. Multiple reference structures can be speciﬁed. Speciﬁc frames from trajectories may be used as a reference

structure.

8. The rmsd action allows speciﬁcation of a separate mask for the reference structure. In addition, per-residue

RMSD can be calculated easily.

9. Actions that modify coordinates and topology such as the strip/closest actions can often write an accompa-

nying fully-functional stripped topology ﬁle.

10. Users usually are able to ﬁne-tune the output format of data ﬁles declared in actions using the “out” keyword
(for example, the precision of the numbers can be changed). In addition, users can control which data sets
are written to which ﬁles (e.g. if two actions specify the same data ﬁle with the ’out’ keyword, data from
both actions will be written to that data ﬁle).

11. Users can manipulate data sets using mathematical expressions (with some limitations), see 32.5.2 on

page 606 for details.

12. There is some support for creating internal loops over e.g. mask expressions and setting internal variables

(see for, set, and show commands).

See the README.md ﬁle in the cpptraj home directory for information on how to build, authors, and so on.

594

32.2. Running Cpptraj

32.1.1. Manual Syntax Format

The syntax presented in this manual uses the following conventions:

<> Denotes a variable.

[] Denotes something is optional.

{|} Denotes several choices separated by the ’|’ character; one of the choices must be speciﬁed.

... Denotes the preceding option can be repeated.

Everything else is as printed.

32.2. Running Cpptraj

Cpptraj can be run in either “interactive mode” or in “batch mode”.

32.2.1. Command Line Syntax

cpptraj [-p <Top0>] [-i <Input0>] [-y <trajin>] [-x <trajout>]

[-ya <args>] [-xa <args>] [<file>]
[-c <reference>] [-d <datain>] [-w <dataout>] [-o <output>]
[-h | --help] [-V | --version] [--defines] [-debug <#>]
[--interactive] [--log <logfile>] [-tl]
[-ms <mask>] [-mr <mask>] [--mask <mask>] [--resmask <mask>]

* denotes a flag may be specified multiple times.
-p <Top0>* Load <Top0> as a topology file.
-i <Input0>* Read input from <Input0>.
-y <trajin>* Read from trajectory file <trajin>; same as input ’trajin <trajin>’.
-x <trajout>* Write trajectory file <trajout>; same as input ’trajout <trajout>’.
-ya <args>* Input trajectory file arguments.
-xa <args>* Output trajectory file arguments.
<ﬁle>* A topology, input trajectory, or file containing cpptraj input.
-c <reference>* Read <reference> as reference coordinates; same as input

’reference <reference>’.

-d <datain>* Read data in from file <datain> (’readdata <datain>’).
-w <dataout> Write data from <datain> as file <dataout> (’writedata <dataout>).
-o <output> Write CPPTRAJ STDOUT output to file <output>.
-h | –help Print command line help and exit.
-V | –version Print version and exit.
–deﬁnes Print compiler defines and exit.
-debug <#> Set global debug level to <#>; same as input ’debug <#>’.
–interactive Force interactive mode.
–log <logﬁle> Record commands to <logfile> (interactive mode only). Default is

’cpptraj.log’.

-tl Print length of trajectories specified with ’-y’ to STDOUT. The total number

of frames is written out as ’Frames:

<X>’

595

32. cpptraj

-ms <mask> Print selected atom numbers to STDOUT. Selected atoms are written

out as ’Selected= 1 2 3 ...’

-mr <mask> : Print selected residue numbers to STDOUT. Selected residues are

written out as ’Selected= 1 2 3 ...’

–mask <mask> Print detailed atom selection to STDOUT.
–resmask <mask> : Print detailed residue selection to STDOUT.

Note that unlike ptraj, in cpptraj it is not required that a topology ﬁle be speciﬁed on the command line as long as
one is speciﬁed in the input ﬁle with the ’parm’ keyword. Multiple topology/input ﬁles can be speciﬁed by use of
multiple ’-p’ and ’-i’ ﬂags. All topology and coordinate ﬂags will be processed before any input ﬂags.

32.2.2. Commands

Input to cpptraj is in the form of commands, which can be categorized in to 2 types: immediate and queued.
Immediate commands are executed as soon as they are encountered. Queued commands are initialized when they
are encountered, but are not executed until a Run is executed via a run or go command. Actions, Analyses, and
Trajectory commands (except reference) are queued commands; however, they can also be run immediately via
commands such as crdaction, runanalysis, loadcrd, etc. See 32.7 on page 612 for more details.

Commands fall into seven categories:

General (Immediate) These commands are executed immediately when entered.

System (Immediate) These are unix system commands (e.g. ’ls’, ’pwd’, etc).

Coords (Immediate) These commands are used to manipulate COORDS data sets; see 32.7 on page 612 for more

details.

Trajectory (Queued) These commands prepare cpptraj for reading or writing trajectories during a Run.

Topology (Immediate) These commands are used to read, write, and modify topology information.

Action (Queued) These commands specify actions that will be performed on coordinate frames read in from

trajectories during a Run.

Analysis (Queued) These commands specify analyses that will be performed on data that has been either generated

from a Run or read in from an external source.

Control (Immediate) These commands set up control blocks that can be used to e.g. loop over a set of commands.

In addition to normal commands, cpptraj now has the ability to perform certain basic math operations, even on
data sets. See 32.5.2 on page 606 for more details.

Commands in cpptraj can be read in from an input ﬁle or from the interactive command prompt. A ’#’

anywhere on a line denotes a comment; anything after ’#’ will be ignored no matter where it occurs. A ’\’ allows
the continuation of one line to another. For example, the input:

# Sample input
trajin mdcrd # This is a trajectory
rms first out rmsd.dat \

:1-10

Translates to:

trajin mdcrd
rms first out rmsd.dat :1-10

596

32.2. Running Cpptraj

32.2.3. Getting Help

If in interactive mode, ’help <command>’ can be used to get the associated keywords as well as an abbreviated
description of the command. Most commands have a corresponding test which also serves as an example of how
to use the command. See $AMBERHOME/AmberTools/test/cpptraj/README for more details.

32.2.4. Batch mode

In “batch” mode, cpptraj is executed from the command line with one or more input ﬁles containing commands
to be processed or STDIN. The syntax of <input ﬁle> is similar to that of ptraj. Keywords specifying different
commands are given one per line. Lines beginning with ’#’ are ignored as comments. Lines can also be continued
through use of the ’\’ character. This is the only allowed mode for cpptraj.MPI.

32.2.5. Interactive mode

In “interactive mode” users can enter commands in a UNIX-like shell. Interactive mode is useful for running

short and simple analyses or for trying out new kinds of analyses. If cpptraj is run with ’–interactive’, no
arguments, or no speciﬁed input ﬁle:

cpptraj
cpptraj --interactive
cpptraj <parm file>
cpptraj -p <parm file>

this brings up the interactive interface. This interface supports command history (via the up and down arrows)
and tab completion for commands and ﬁle names. If no log ﬁle name has been given (with ’–log <logﬁle>’), all
commands used in interactive mode will be logged to a ﬁle named ’cpptraj.log’, which can subsequently be used
as input if desired. When starting cpptraj, command histories will be read from any existing logs.

32.2.6. Trajectory Processing “Run”

Like ptraj, a trajectory processing “Run” is one of the main ways to run cpptraj. First the Run is set up via
commands read in from an input ﬁle or the interactive prompt. Trajectories are then read in one frame at a time (or
in the case of ensemble processing all frames from a given step are read). Actions are performed on the coordinates
stored in the frame, after which any output coordinates are written. At the end of the run, any data sets generated
are written, and any queued Analyses are performed.

32.2.6.1. Actions and multiple topologies

Since cpptraj supports multiple topology ﬁles, during a Run actions are set up every time the topology changes
in order to recalculate things like what atoms are in a mask etc. Actions that are not valid for the current topology
are skipped for that topology. So for example given two topology ﬁles with 100 residues, if the ﬁrst topology ﬁle
processed includes a ligand named MOL and the second one does not, the action:

distance :80 :MOL out D_80-to-MOL.dat

will be valid for the ﬁrst topology but not for the second, so it will be skipped as long as the second topology is
active.

32.2.7. Parallelization

Cpptraj has many levels of parallelization that can be enabled via the ’-mpi’, ’-openmp’, and/or ’-cuda’ conﬁgure
ﬂags for MPI, OpenMP, and CUDA parallelization respectively. At the highest level, trajectory and ensemble reads
are parallelized with MPI. In addition, certain time consuming actions have been parallelized with OpenMP and/or
CUDA.

597

32. cpptraj

Note that any combination of the ’-openmp’,

hybrid MPI/OpenMP/CUDA binary; however this may require additional runtime setup (e.g.
OMP_NUM_THREADS for OpenMP) to work properly and not oversubscribe cores.

’-cuda’, and ’-mpi’ ﬂags may be used to generate a
setting

32.2.7.1. MPI Trajectory Parallelization

Cpptraj has two levels of MPI parallelization for reading input trajectories. The ﬁrst is for ’trajin’ trajectory
input, where the trajectory read is divided as evenly as possible among all input frames (across-trajectory paral-
lelism). For example, if given two trajectories of 1000 frames each and 4 MPI processes, process 0 reads frames
1-500 of trajectory 1, process 1 reads frames 501-1000 of trajectory 1, process 2 reads frames 1-500 of trajectory 2,
and process 3 reads frames 501-1000 of trajectory 2. Most Actions will work with across-trajectory parallelization
with the exception of the following:

’clusterdihedral’, ’contacts’, ’createreservoir’, ’gist’, ’lipidorder’, ’pairwise’, ’stfcdiffusion’, ’unwrap’, and
’xtalsymm’. Note that ’diffusion’ will only work with across-trajectory parallelism if no imaging is to be per-
formed.

The second is for ’ensemble’ trajectory input, where the reading/processing/writing of each member of the
ensemble is divided up among MPI processes. The number of MPI processes must be a multiple of the ensemble
size. If the number of processes is greater than the ensemble size then the processing of each ensemble member
will be divided among MPI processes (i.e. across-trajectory parallelism will be used). For example, given an
ensemble of 4 trajectories and 8 processes, processes 0 and 1 are assigned to the ﬁrst ensemble trajectory, processes
2 and 3 are assigned to the second ensemble trajectory, and so on. When using ensemble mode in parallel it is
recommended that the ensemblesize command be used prior to any ensemble command as this will make set up
far more efﬁcient.

In order to use the MPI version, Amber/cpptraj should be conﬁgured with the ’-mpi’ ﬂag. You can tell if cpptraj
has been compiled with MPI as it will print ’MPI’ in the title, and/or by calling ’cpptraj —deﬁnes’ and looking for
’-DMPI’.

32.2.7.2. OpenMP Parallelization

Some of the more time-consuming actions/analyses in cpptraj have been parallelized with OpenMP to take
advantage of machines with multiple cores. In order to use OpenMP parallelization Amber/cpptraj should be
conﬁgured with the ’-openmp’ ﬂag. You can easily tell if cpptraj has been compiled with OpenMP as it will print
’OpenMP’ in the title, and/or by calling ’cpptraj —deﬁnes’ and looking for ’-D_OPENMP’. The following
actions/analyses have been OpenMP parallelized:

2drms/rms2d
atomiccorr
checkstructure
closest
cluster (pair-wise distance calculation and sieved frame restore only)
dssp/secstruct
energy
gist (non-bonded calculation)
hbond
kde
lipidscd
mask (distance-based masks only)
matrix (coordinate covariance matrices only)
minimage
radial
replicatecell
rmsavgcorr
spam
surf

598

32.3. General Concepts

velocityautocorr
volmap
watershell
wavelet

By default OpenMP cpptraj will use all available cores. The number of OpenMP threads can be controlled by
setting the OMP_NUM_THREADS environment variable.

32.2.7.3. CUDA Parallelization

Some time-consuming actions in cpptraj have been parallelized with CUDA to take advantage of machines

with NVIDIA GPUs. In order to use CUDA parallelization Amber/cpptraj should be conﬁgured with the ’-cuda’
ﬂag. You can easily tell if cpptraj has been compiled with CUDA as it will print ’CUDA’ and details on the
current graphics device in the title, and/or by calling ’cpptraj —deﬁnes’ and looking for ’-DCUDA’. The
following actions have been CUDA parallelized:

closest
watershell
gist

32.3. General Concepts

32.3.1. Units

Cpptraj uses the AKMA system of units. The execption is time, which is typically expressed in ps (except where

noted).

Variable
Length
Energy
Mass
Charge
Time
Force

Unit

Angstrom
kcal/mol
AMU
electron

ps (typically)

kcal/mol*Angstrom

32.3.2. Atom Mask Selection Syntax

The mask syntax is similar to ptraj. Note that the characters ’:’, ’@’, and ’*’ are reserved for masks and should
not be used in output ﬁle or data set names. All masks are case-sensitive. Either names or numbers can be used.
Masks can contain ranges (denoted with ’-’) and comma separated lists. The logical operands ’&’ (and), ’|’ (or),
and ’!’ (not) are also supported.

The syntax for elementary selections is the following:

@{atom numlist} e.g. ’@12,17’, ’@54-85’, ’@12,54-85,90’

@{atom namelist} e.g. ’@CA’, ’@CA,C,O,N,H’

@%{atom type name} e.g. ’@%CT’

@/{atom_element_name} e.g. ’@/N’

:{residue numlist} e.g. ’:1-10’, ’:1,3,5’, ’:1-3,5,7-9’

:{residue namelist} e.g. ’:LYS’, ’:ARG,ALA,GLY’

::{chain id} e.g. ’::B’, ’::A,D’. Requires chain ID information be present in the topology.

599

32. cpptraj

:;{pdb residue number} e.g. ’:;2-4,8’. Requires a PDB loaded as topology, or Amber topology with embedded

PDB information (see 14.2.2.5 on page 259).

^{molecule numlist} e.g. ’^1-10’, ’:23,84,111’

<mask><distance op><distance> Selection by distance, see below.

Several wildcard characters are supported:

’*’ Zero or more characters.

’=’ Same as ’*’

’?’ One character.

The wildcards can also be used with numbers or other mask characters, e.g. ’:?0’ means
“:10,20,30,40,50,60,70,80,90”, ’:*’ means all residues and ’@*’ means all atoms. If the atom name (or type
name) contains a wildcard character like an asterisk, it can be explictly selected by escaping (i.e. preceding) the
wildcard character with a backslash ’\’. So for example:

atoms @C?*

would select atoms named C5, C4*, C422, etc., but:

atoms @C?\*

would only select C4* out of the above 3 atoms.

Compound expressions of the following type are allowed:

:{residue numlist | namelist}@{atom namelist | numlist}

and are processed as:

:{residue numlist | namelist} & @{atom namelist | numlist}

e.g. ’:1-10@CA’ is equivalent to “:1-10 & @CA”.

More examples:

:ALA,TRP All alanine and tryptophan residues.

:5,10@CA CA carbon in residues 5 and 10.

:*&!@H= All non-hydrogen atoms (equivalent to "!@H=").

@CA,C,O,N,H All backbone atoms.

!@CA,C,O,N,H All non-backbone atoms (=sidechains for proteins only).

:1-500@O&!(:WAT|:LYS,ARG) All backbone oxygens in residues 1-500 but not in water, lysine or arginine

residues.

^1-2:ASP All residues named ’ASP’ in the ﬁrst two molecules.

::A,D@CA All atoms named ’CA’ in chains A and D.

600

32.3. General Concepts

Distance-based Masks

There are two very important things to keep in mind when using distance based masks:
1. Distance-based masks that update each frame are currently only supported by the mask action.
2. Selection by distance for everything but the mask action requires deﬁning a reference frame with reference;
distances are then calculated using the speciﬁed reference frame only. This reference frame can be changed
using the activeref command.

The syntax for selection by distance is a <mask> expression followed by a <distance operator> followed by
a <distance> (which is in Angstroms). The <distance operator> consists of 2 characters: ’<’ (within) or ’>’
(without) followed by either ’^’ (molecules), ’:’ (residues), or ’@’ (atoms). For example, ’<:3.0’ means “residues
within 3.0 Angstroms” etc. For residue- and molecule-based distance selection, if any atom in that residue/-
molecule matches the given distance criterion, the entire residue/molecule is selected.

In plain language, the entire distance mask can be read as “Select <distance operator> <distance> of

<mask>”. So for example, the mask expression:

:11-17<@2.4

Means “Select atoms within 2.4 Å distance of atoms selected by ’:11-17’ (residues numbered 11 through 17)”.

To strip everything outside 3.0 Å (i.e. without 3.0 Å) from residue 4 using speciﬁed reference coordinates:

reference mol.rst7
trajin mol.rst7
strip !(:4<:3.0)

32.3.3. Ranges

For several commands some arguments are ranges (e.g.

’trajout onlyframes <range>’, ’nastruct resrange
<range>’, ’rmsd perres range <range>’); THESE ARE NOT ATOM MASKS. They are simple number ranges
using ’-’ to specify a range and ’,’ to separate different ranges. For example 1-2,4-6,9 speciﬁes 1 to 2, 4 to 6, and
9, i.e. ’1 2 4 5 6 9’.

32.3.4. Parameter/Reference Tagging

Parameter and reference ﬁles may be ’tagged’ (i.e. given a nickname); these tags can then be used in place of

the ﬁle name itself. A tag in cpptraj is recognized by being bounded by brackets (’[’ and ’]’). This can be
particularly useful when reading in many parameter or reference ﬁles. For example, when reading in multiple
reference structures:

trajin Test1.crd
reference 1LE1.NoWater.Xray.rst7 [xray]
reference Test1.crd lastframe [last]
reference Test2.crd 225 [open]
rms Xray ref [xray] :2-12@CA out rmsd.dat
rms Last ref [last] :2-12@CA out rmsd.dat
rms Open ref [open] :2-12@CA out rmsd.dat

This deﬁnes three reference structures and gives them tags [xray], [last], and [open]. These reference structures
can then be referred to by their tags instead of their ﬁlenames by any action that uses reference structures (in this
case the RMSD action).

Similarly, this can be useful when reading in multiple parameter ﬁles:

parm tz2.ff99sb.tip3p.truncoct.parm7 [tz2-water]
parm tz2.ff99sb.mbondi2.parm7 [tz2-nowater]
trajin tz2.run1.explicit.nc parm [tz2-water]
reference tz2.dry.rst7 parm [tz2-nowater] [tz2]
rms ref [tz2] !(:WAT) out rmsd.dat

601

32. cpptraj

This deﬁnes two parm ﬁles and gives them tags [tz2-water] and [tz2-nowater], then reads in a trajectory associated
with one, and a reference structure associated with the other. Note that in the ’reference’ command there are two
tags; the ﬁrst goes along with the ’parm’ keyword and speciﬁes what parameter ﬁle the reference should use, the
second is the tag given to the reference itself (as in the previous example) and is referred to in the subsequent
RMSD action.

32.4. Variables and Control Structures

As of version 18, CPPTRAJ has limited support for “script” variables and ’for’ loops. Script variables are

referred to by a dollar sign (’$’) preﬁx and are replaced when they are processed. These are stored in the master
data set list like other data and are assigned the type “string variable”. Note that to use script variables in
CPPTRAJ input that is inside another script (e.g. a BASH script), they must be escaped with the ’\’
character, e.g.

#!/bin/bash
TOP=MyTop.parm7
cpptraj <<EOF
set topname=$TOP # TOP is a BASH script variable
parm \$topname
EOF

# topname is a CPPTRAJ script variable

Note that regular CPPTRAJ 1D Data Sets that contain a single value can be used as script variables (if the Data
Set contains more than 1 value only the ﬁrst value will be used).

Command

Description

for
set
show

Create a ’for’ loop.

Set or update a script variable.

Show all current script variables and their values.

32.4.1. for

for { {atoms|residues|molecules|molfirstres|mollastres}

<var> inmask <mask> [parm <name> | parmindex <#> | <#>] |

<var> in <list> |
<var> oversets <list> |
<var> datasetblocks <set> blocksize <#> [blockoffset <#>]

[cumulative [firstblock <#>]] |

<var>=<start>;[<var><end OP><end>;]<var><increment OP>[<value>] ... }

END KEYWORD: ’done’

Available ’end OP’
Available ’increment OP’ : ’++’, ’--’, ’+=’, ’-=’

: ’<’ ’>’ ’<=’ ’>=’

atoms|residues|molecules|molﬁrstres|mollastres <var> inmask <mask> Loop over

atoms/residues/molecules/first residue in molecules/last residue in
molecules selected by the given mask expression, set as script variable
<var>.
parm <name> | parmindex <#> <#> Select topology that <mask> should be based

on (default first topology).

<var> in <list> Loop over a comma-separated list of strings.

File name wildcards

can be used.

<var> oversets <list> Loop over sets selected by comma-separated list of names.

Data set wildcards can be used.

<var> datasetblocks <set> Loop over blocks in specified DataSet.

602

32.4. Variables and Control Structures

blocksize <#> Size of blocks to use.
[blockoffset <#>] Offset between blocks.
[cumulative] Instead of blocks of fixed size, use blocks of increasing size

incremented by blocksize.
[ﬁrstblock <#>] When cumulative, the size of the first block (default is

first data set element).

<var>=<start>;[<var><end OP><end>;]<var><increment OP>[<value>] Loop over integer
script variable <var> starting from <start>, optionally ending at <end>,
increment by <value>.

Data Sets Created (datasetblocks loops):
<var>[block]:<start idx> (Data set blocks only) Data set block of blocksize

starting at <start idx>.

<var>[cumul]:<end idx> (Cumulative data set blocks only) Data set block starting

at firstblock and ending at <end idx>.

Create a for loop using one or more mask expressions, integers, etc. Loops can be nested inside each other. Integer
loops may be used without an end condition, but in that case at least one descriptor in the loop should have an end
condition or refer to a mask. Loops are ended by the done keyword.

Note that non-integer variables (e.g. ’inmask’ loops) are NOT incremented after the ﬁnal loop iteration, i.e.

these loop variables always retain their ﬁnal value.

For example:

for atoms A0 inmask :1-3@CA i=1;i++

distance d$i :TCS $A0 out $i.dat

done

This loops over all atoms in the mask expression ’:1-3@CA’ (all atoms named CA in residues 1 to 3) and creates
a variable named ’i’ that starts from 1 and is incremented by 1 each iteration. Inside the loop, the mask selection
is referred to by $A0 and the integer by $i. This is equivalent to doing 3 distance commands like so:

distance d1 :TCS :1@CA out 1.dat
distance d2 :TCS :2@CA out 2.dat
distance d3 :TCS :3@CA out 3.dat

To loop over ﬁles named trajA*.nc and trajB*.nc:

for TRAJ in trajA*.nc,trajB*.nc

trajin $TRAJ 1 last 10

done

32.4.2. set

set { <variable> <OP> <value> |

<variable> <OP> {atoms|residues|molecules} inmask <mask>

[parm <name> | parmindex <#> | <#>]

<variable> <OP> trajinframes }
Available <OP> : ’=’, ’+=’

<variable> <OP> <value> Set or append a script variable.
<variable> <OP> {atoms|residues|molecules} inmask <mask> Set/append a script

variable to/by the total number of atoms/residues/molecules selected by
given mask expression.
parm <name> | parmindex <#> | <#> Topology to which mask should correspond

(default first).

603

32. cpptraj

<variable> <OP> trajinframes Set/append a script variable to/by the total number of

frames in trajectories currently loaded by trajin commands.

Set (<OP> = ’=’) or append (<OP> = ’+=’) a script variable. Script variables are character strings, and are referred
to in CPPTRAJ input by using a dollar sign ’$’ preﬁx.

For example, the following input will load ﬁles my.parm7 and my.rst7:

set PREFIX = my
trajin $PREFIX.parm7
trajin $PREFIX.rst7

For example, the following input will print info for the last 10 atoms in a topology to ’last10.dat’:

set Natom = atoms inmask *
last10 = $Natom - 10
show
atoms "@$last10 - $Natom" out last10.dat

32.4.3. show

show [<var1> ...]

If no variable names speciﬁed, show all current script variables and their values. Otherwise, show the values of the
speciﬁed script variables.

32.5. Data Sets and Data Files

In cpptraj, Actions and Analyses can generate one or more data sets which are available for further processing.
For example, the distance command creates a data set containing distances vs time. The data set can be named by
the user simply by specifying a non-keyword string as an additional argument. If no name is given, a default one
will be generated based on the action name and data set number. For example:

distance d1-2 :1 :2 out d1-2.dat

will create a data set named “d1-2”. If a name is not speciﬁed, e.g.:

distance :1 :2 out d1-2.dat
the data set will be named “Dis_00000”.

Data ﬁles are created automatically by most commands, usually via the “out” keyword. Data ﬁles can also
be explicitly created with the write/writedata and create commands. Data can also be read in from ﬁles via the
readdata command. Cpptraj currently recognizes the formats listed in 32.1, although it cannot write in all formats.
In addition, a data set must be valid for the data ﬁle format. For example, 3D data (such as a grid) can be written
to an OpenDX format ﬁle but not a Grace format ﬁle.

The default ﬁle format is called ’Standard’, which simply has data in columns, like ptraj, although multiple data
sets can be directed to the same output ﬁle. The format of a ﬁle can be changed either by specifying a recognized
keyword (either on the command line itself or later via a ’dataﬁle’ command) or by giving the ﬁle an extension
corresponding to te format, so ’ﬁlename.agr’ will output in Grace format, and ’ﬁlename.gnu’ will output in Gnuplot
contour, and so on. The xmgrace/gnuplot output is particularly nice for the secstruct sumout and rmsd perresout
ﬁles. Additional options for data ﬁles can be found in 32.6 on page 607.

Any action using the “out” keyword will allow data sets from separate commands to be written into the same

ﬁle. For example, the commands:

dihedral phi :1@C :2@N :2@CA :2@C out phipsi.dat
dihedral psi :2@N :2@CA :2@C :3@N out phipsi.dat

will assign the “phi” and “psi” data sets generated from each action to the standard data output ﬁle “phipsi.dat”:

#Frame

phi

psi

604

Format
Standard
Grace
Gnuplot
Xplor

OpenDX

Amber REM log
Amber MDOUT

Amber Evecs

Amber Constant pH

output

Vector pseudo-traj

Gromacs XVG

CCP4

Charmm REPD log

Charmm Output

Filename Extensions

Keyword

Valid Dimensions

Notes

32.5. Data Sets and Data Files

.dat

.agr, .xmgr

.gnu

.xplor, .grid

.dx
.log

.mdout

.evecs
.cpout

.vectraj

.xvg
.ccp4
.exch

.charmmout

dat
grace
gnu
xplor
opendx
remlog
mdout

evecs
cpout

vectraj

xvg
ccp4

charmmrepd
charmmout

1D, 2D, 3D

1D

1D, 2D

3D
3D
-
-

Modes data set only

pH data only

Vector data set only.

-
3D
-
-

Read Only

Energy information,

Read Only

Write Only
Read Only

Read Only

Energy information,

Read Only

Table 32.1.: DataFile formats recognized by cpptraj. ’Valid Dimensions’ shows what dimensions the format is

valid for (e.g. you cannot write a 1D data set with OpenDX format).

32.5.1. Data Set Selection Syntax

Many analysis commands can be used to analyze multiple data sets. The general format for selecting data sets

is:

<name>[<aspect>]:<index>

The ’*’ character can be used as a wild-card for entire names (no partial matches).

• <name>: The data set name, usually speciﬁed in the action (e.g. in ’distance d0 @1 @2’ the data set name

is “d0”).

• <aspect>: Optional; this is set for certain data sets internally in order to easily select subsets of data. The
brackets are required. For example, when using ’hbond series’, both solute-solute and solute-solvent
hydrogen bond time series may be generated. To select all solute-solute hydrogen bonds one would use
the aspect “[solutehb]”; to select solute-solvent hydrogen bonds the aspect “[solventhb]” would be used.
Aspects are hard-coded and are listed in the commands that use them.

• <index>: Optional; for actions that generate many data sets (such as ’rmsd perres’) an index is used. De-
pending on the action, the index may correspond to atom #s, residue #s, etc. A number range (comma and/or
dash separated) may be used.

For example: to select all data sets with aspect “[shear]” named NA_00000:

NA_00000[shear]

To select all data sets with aspect “[stagger]” with any name, indices 1 and 3:

*[stagger]:1,3

In ensemble mode, data set selection has additional syntax:

<name>[<aspect>]:<index>%<member>

Where <member> is the ensemble member number starting from 0.

605

32. cpptraj

32.5.2. Data Set Math

As of version 15, cpptraj can perform basic math operations, even on data sets (with some limitations). Currently

recognized operations are:

Several functions are also supported:

Operation

Symbol

Minus
Plus
Divide
Multiply
Power
Negate
Assign

-
+
/
*
^
-
=

Function
Square Root
Exponential

Natural Logarithm

Absolute Value

Sine
Cosine
Tangent

Summation

Average

Standard Deviation

Minimum
Maximum

Form
sqrt()
exp()
ln()
abs()
sin()
cos()
tan()
sum()
avg()
stdev()
min()
max()

Numbers can be expressed in scientiﬁc notation using “E” notation, e.g. 1E-5 = 0.00001. The parser also

recognizes PI as the number pi. Expressions can also be enclosed in parentheses. So for example, the following
expression is valid:

> 1 - ln(sin(PI/4) * 2)^2
Result: 0.879887

Results of numerical calculations like the above can be assigned to a variable (essentially a data set of size 1) for
use in subsequent calculations, e.g.

> R = 1 - ln(sin(PI/4) * 2)^2
Result stored in ’R’
> R + 1 Result: 1.879887

Data sets can be speciﬁed in expressions as well. Currently data sets in an expression must be of the same type
and only 1D, 2D, and 3D data sets are supported. Functions are applied to each member of the data set. So for
example, given two 1D data sets of the same size named D0 and D1, the following expression:

> D2 = sqrt( D0 ) + D1

would take the square root of each member of D0, add it to the corresponding member of D1, and assign the
result to D2. The following table lists which operations are valid for data set types. If a type is not listed it is not
supported:

606

32.6. Data File Options

Data Set Type

Supported Ops

Supported Funcs

Notes

1D (integer, double, ﬂoat)

1D (vector)
2D (matrices)

3D (grids)

All

+, -, *, /, =
+, -, /, *, =
+, -, /, *, =

All
None

sum, avg, stdev, min, max
sum, avg, stdev, min, max

’*’ is dot product

32.6. Data File Options

Data ﬁle output can be handled multiple ways in cpptraj. Output data ﬁles can be created by Actions/Analy-
ses/Commands, or can be explicitly created with writedata ( 32.8.29 on page 626) or create ( 32.8.4 on page 618)
commands. Reading data from ﬁles is only done via the readdata command ( 32.8.19 on page 623).

In general, data ﬁles which have been declared with an ’out’ keyword will recognize data ﬁle write keywords

on the same command line. For example, the ’time’ argument can be passed directly to the output from a distance
command:

distance d0 :1 :2 out d0.agr time 0.001

The data ﬁle format can be changed from standard implicitly by using speciﬁc ﬁlename extensions or keywords.
If the extension is not recognized or no keyword is give the default format is ’Standard’. Keywords and
extensions for data ﬁle formats recognized by cpptraj are shown in 32.1. Note that the use of certain options may
be restricted for certain data ﬁle formats. These options can also be passed to data ﬁles via the dataﬁle command
( 32.8.6 on page 618).

[<format keyword>]
[{xlabel|ylabel|zlabel} <label>] [{xmin|ymin|zmin} <min>] [sort]
[{xstep|ystep|zstep} <step>] [time <dt>] [prec <width>[.<precision>]]
[xprec <width>[.<precision>]] [xfmt {double|scientific|general}]
[noensextension]
{xlabel | ylabel | zlabel} <label> Set the x-axis label for the specified datafile to

<label>. For regular data files this is the header for the first column of
data. If the data is at least 2-dimensional ’datafile ylabel <label>’ will
likewise set the y-axis label.

{xmin | ymin | zmin} <min> Set the starting X coordinate value to <min>. If the

data is at least 2-dimensional ’datafile ymin <min>’ will likewise set the
starting Y coordinate value.

sort Sort data sets prior to write. Ordering is by name, aspect, then index

(all descending).

{xstep | ystep | zstep} <step> Multiply each frame number by <step> (x coordinates).
If the data is at least 2-dimensional ’datafile ystep <step>’ will likewise
multiply y coordinates by <step>.

time <dt> Equivalent to the ptraj argument ’time’ that could be specified with

many actions. Multiplies frame numbers (x-axis) by <dt>.

prec <width>[.<precision>] Change the output format width (and optionally

precision) of all sets subsequently added to the data file (i.e. does not
change the precision of any data sets currently in the file).
For example,

prec 12.4
prec 10

xprec <width>[.<precision>] Change output ordinate width and precision.
xfmt {double|scientiﬁc|general} Change output ordinate format.
[noensextension] Omit ensemble extension in ensemble processing mode.

NOTE:

THIS OPTION HAS NOT BEEN FULLY TESTED IN PARALLEL.

607

32. cpptraj

32.6.1. Standard Data File Options

Write

[invert] [noxcol] [groupby <type>] [noheader] [square2d|nosquare2d]
[nosparse|sparse [cut <cutoff>]]
invert Normally, data is written out with X-values pertaining to frames (i.e.

data over all trajectories is printed in columns).
behavior so that X-values pertain to data sets (i.e.
trajectories is printed in rows).

This command flips that

data over all

groupby <type> (1D) group data sets by <type>:

name Group by name.
aspect Group by aspect.
idx Group by index.
ens Group by ensemble number.
dim Group by dimension.

xcol Write indices for the specified datafile.

This is usually the default

behavior.

noxcol Prevent printing of indices (i.e.

for the specified datafile. Useful e.g.
as phi vs psi. For example, given the input:

the #Frame column in most datafiles)
if one would like a 2D plot such

dihedral phi :1@C :2@N :2@CA :2@C out phipsi.dat
dihedral psi :2@N :2@CA :2@C :3@N out phipsi.dat
datafile phipsi.dat noxcol

Cpptraj will write a 2 column datafile containing only phi and psi, no
frame numbers will be written.

header Write header line at beginning of data file.

This is usually the

default behavior.

noheader Prevent printing of header line (e.g. ’#Frame

D1’) at the

beginning of data file.

square2d Write 2D data as a square matrix, e.g.:

<1,1> <2,1> <3,1>
<1,2> <2,2> <3,2>

nosquare2d Write 2D data in 3 columns as:

<X> <Y> <Value>

sparse Only write 3D grid voxels with value > cutoff (default 0).

cut <cut> Cutoff for ’sparse’; default 0.

nosparse Write all 3D voxels (default).

[ read1d [index <col>] [onlycols <range>] ]
[read2d] [vector] [mat3x3]
[ read3d [dims <nx>,<ny>,<nz>] [origin <ox>,<oy>,<oz>]

[delta <dx>,<dy>,dz>] [prec {dbl|flt}] [bin {center|corner} ]

index <col> Use column <col> (starting from 1) as index column (1D data only).
read1d Read data as 1D data sets (default).

Read

608

32.6. Data File Options

index <col> Use column <col> (starting from 1) as index column (1D data

only).

onlycols <range> Only read columns in range.
ﬂoatcols <range> Force specified columns to be read as single-precision

floats.

intcols <range> Force specified columns to be read as integers.
stringcols <range> Force specified columns to be read as strings.

read2d Read data as 2D square matrix.
vector Read data as vector. If indices are present they will be skipped.

Assume first 3 columns after the index volumn are vector X, Y, and Z, and
(if present) the next 3 columns contain vector origin X, Y, and Z.

mat3x3 Read data as 3x3 matrix. If indices are present they will be skipped.
M(1,1) M(1,2)

Assume matrices are in row major order on each line, i.e.
... M(3,2) M(3,3).

read3d Read data as 3D grid.

If no dimension data in file must also speify

’dims’.
dims <dx>,<dy>,<dz> Grid dimensions.
origin <ox>,<oy>,<oz> Grid origins (default 0,0,0).
delta <dx>,<dy>,dz> Grid spacings (default 1,1,1).
prec {dbl|ﬂt} Grid precision, double or float (default float).
bin {center|corner} Coords specify bin centers or corners (default corners).

By default, standard data ﬁles are assumed to contain 1D data in columns. Data set legends will be read in if the
ﬁle has a header line (denoted by ’#’). Columns labeled ’#Frame’ are automatically considered the ’index’ column
and skipped. Data sets are stored as <name>:<idx> where <name> is the given data set name (the ﬁle name if not
speciﬁed) and <idx> corresponds to the column the data was read from starting from 1. Cpptraj assumes the data
increases monotonically and will automatically attempt to determine the dimensions of the data set(s); a warning
will be printed if this is not successful.

32.6.2. Grace Data File Options

For more information on Grace see http://plasma-gate.weizmann.ac.il/Grace/.

Write

[invert] [xydy] [<label set>]

invert Normally, data is written out with X-values pertaining to frames (i.e.

data over all trajectories is printed in columns). This command flips that
behavior so that X-values pertain to data sets.

xydy Combine consecutive pairs of sets into XYDY sets.
<label set> If a string dataset is specified, assume it has data point labels.

If a single string data set is speciﬁed when writing Grace format, it is assumed they are data point labels.

Read

Cpptraj will read set legends from grace ﬁles, and data sets are stored as <name>:<idx> where <name> is the
given data set name (the ﬁle name if not speciﬁed) and <idx> corresponds to the set number the data was read from
starting from 0.

609

32. cpptraj

32.6.3. Gnuplot Data File Options

For more information on these options it helps to look at the PM3D options in the Gnuplot manual (see

http://www.gnuplot.info/).

Write

[nolabels] [usemap] [pm3d] [nopm3d] [title <title>]
[jpeg] [noheader] [{xlabels|ylabels|zlabels} <labellist>]

nolabels Do not print axis labels.

usemap pm3d output with 1 extra empty row/col (may improve look).

pm3d Normal pm3d map output.

nopm3d Turn off pm3d

jpeg Plot will write to a JPEG file when used with gnuplot.

title <title> Set plot title (default is file name).

binary Plot will be written in binary format.

header Format the plot so it can be directly processed by gnuplot.

This is

usually the default behavior.

noheader Do not format plot; data output only.

palette <arg> Change gnuplot pm3d palette to <arg>:

’rgb’ Red, yellow, green, cyan, blue, magenta, red.
’kbvyw’ Black, blue, violet, yellow, white.
’bgyr’ Blue, green, yellow, red.
’gray’ Grayscale.

xlabels|ylabels|zlabels <labellist> Set x, y, or z axis labels with comma-separated

list, e.g. ’xlabels X1,X2,X3’.

32.6.4. Amber REM Log Options

Note that multiple REM logs can be speciﬁed in a single readdata command. See 32.12.27 on page 738 for

more on replica log analysis.

Read

[nosearch] [dimfile <file>] [crdidx <crd indices>]

[nosearch] If specified do not automatically search for MREMD dimension logs.

[dimﬁle <ﬁle>] remd.dim file for processing MREMD logs.

[crdidx <crd indices>] Use comma-separated list of indices as the initial

coordinate indices (H-REMD only). For example (4 replicas):

crdidx 4,2,3,1

32.6.5. Amber MDOUT Options

Note that multiple MDOUT ﬁles can be speciﬁed in a single readdata command.

610

32.6. Data File Options

32.6.6. Evecs File Options

Read

[ibeg <firstmode>] [iend <lastmode>]

ibeg <ﬁrstmode> Number of the first mode (or principal component) to read from

evecs file. Default 1.

iend <lastmode> Number of the last mode (or principal component) to read from
evecs file. Default is to read all for newer evecs files (generated by
cpptraj version > 12), 50 for older evecs files.

32.6.7. Vector psuedo-traj Options

This can be used to write out a representation of a vector data set which can then be visualized. See 32.11.84 on

page 707 for more on generating vector data sets.

Write

[trajfmt <format>] [parmout <file>] [noorigin]

trajfmt <format> Output pseudo-trajectory format. See 32.10 on page 635 for

trajectory format keywords.

parmout <ﬁle> File to write pseudo-trajectory topology to.
[noorigin] Do not write vector origin coordinates.

32.6.8. OpenDX ﬁle options

Write

[bincenter] [gridwrap] [gridext]

bincenter Center grid points on bin centers instead of corners.
gridwrap Like ’bincenter’, but also wrap grid density. Useful when grid

encompasses unit cell.

gridext Like ’bincenter’, but also print extra layer of empty bins.

32.6.9. CCP4 ﬁle options

Write

[title <title>]

[title <title>] Set CCP4 output title.

32.6.10. Charmm REPD log options

Read

[nrep <#>] [crdidx <crd indices>]

nrep <#> Total number of replicas.
crdidx <crd indices> Comma-separated list of indices to use as initial coordinate

indices.

611

32. cpptraj

32.6.11. Amber Constant pH Out options

Read

cpin <file>

cpin <ﬁle> Constant pH input (CPIN) file name.

Note that when reading in constant pH data the data set aspect will be set to the residue name and the index will
be set to the residue number. When reading in constant pH REMD data the data is unsorted, and sortensembledata
should be used to create sorted constant pH data sets (see 32.8.27 on page 626).

32.7. Coordinates (COORDS) Data Set Commands

Coordinate I/O tends to be the most time-consuming part of trajectory analysis. In addition, many types of
analyses (for example two-dimensional RMSD and cluster analysis) require using coordinate frames multiple
times. To simplify this, trajectory coordinates may be saved as a separate data set via the loadcrd command or
createcrd action. Any action can then be performed on the COORDS data set with the crdaction command. The
crdout command can be used to write coordinates to an output trajectory (similar to trajout).

Although COORDS data sets store everything internally with single-precision, they can still use a large amount
of memory. Because of this there is a specialized type of COORDS data set called a TRAJ data set (trajectory),
which functions exactly like a COORDS data set except all data is stored on disk. TRAJ data sets can be created
with the loadtraj command. TRAJ data sets cannot be modiﬁed.

There are several analyses that can be performed using COORDS data sets, either as part of the normal analysis
list or via the runanalysis command. Note that while these analyses can be run on speciﬁed COORDS data sets, if
one is not speciﬁed a default COORDS data set will be created, made up of frames from trajin commands.

As an example of where this might be useful is in the calculation of atomic positional ﬂuctuations. Previously

this required two steps: one to generate an average structure, then a second to rms-ﬁt to that average structure
prior to calculating the ﬂuctuations. This can now be done in one pass with the following input:

parm topology.parm7
loadcrd mdcrd.nc
# Generate average structure PDB, @CA only
crdaction mdcrd.nc average avg.pdb @CA
# Load average structure PDB as reference
parm avg.pdb
reference avg.pdb parm avg.pdb
# RMS-fit to average structure PDB
crdaction mdcrd.nc rms reference @CA
# Calculate atomic fluctuations for @CA only
crdaction mdcrd.nc atomicfluct out fluct.dat bfactor @CA

The following COORDS data set commands are available:

612

32.7. Coordinates (COORDS) Data Set Commands

Description

Concatenate two or more COORDS sets.

Combine two or more COORDS sets.
Run a single Action on a COORDS set.

Write a COORDS set to a ﬁle.

(Action) Create a COORDS set during a Run.
Create or append to a COORDS set from a ﬁle.

Create special COORDS set where frames remain on disk.

Rotate speciﬁed dihedral(s) in given COORDS set by speciﬁc interval or to random

values.

Load a single trajectory frame as a reference.

Rotate speciﬁed dihedral to speciﬁed value or by given increment.

Split molecules in a COORDS set into a trajectory.

Command

catcrd

combinecrd
crdaction
crdout
createcrd
loadcrd
loadtraj

permutedihedrals

reference

rotatedihedral
splitcoords

32.7.1. catcrd

catcrd <crd1> <crd2> ... name <name>
<crdX> COORDS data sets to concatentate, specify 2 or more.
name <name> New COORDS set name

Concatentate two or more COORDS data sets into a single COORDS data set. The topologies must have the same
number of atoms for this to work. If the topologies differ in other ways, the topology of the ﬁrst COORDS set
takes priority.

32.7.2. combinecrd

combinecrd <crd1> <crd2> ... [parmname <topname>] [crdname <crdname>]

<crdX> COORDS data sets to combine, specify 2 or more.
[parmname <topname>] Name of combined Topology.
[crdname <crdname>] Name of combined COORDS data set.

Combined two or more COORDS data sets into a single COORDS data set. Note that the resulting topology will
most likely not be usable for MD simulations. Box information will be retained - the largest box dimensions will
be used.

For example, to load two MOL2 ﬁles as COORDS data sets, combine them, and write them out as a single

MOL2:

loadcrd Tyr.mol2 CRD1
loadcrd Pry.mol2 CRD2
combinedcrd CRD1 CRD2 parmname Parm-1-2 crdname CRD-1-2
crdout CRD-1-2 Tyr.Pry.mol2

32.7.3. crdaction

crdaction <crd set> <actioncmd> [<action args>] [crdframes <start>,<stop>,<offset>]

Perform action <actioncmd> on COORDS data set <crd set>. A subset of frames in the COORDS data set can be
speciﬁed with ’crdframes’.

For example, to calculate RMSD for a previously created COORDS data set named crd1 using frames 1 to the

last, skipping every 10:

crdaction crd1 rmsd first @CA out rmsd-ca.agr crdframes 1,last,10

613

32. cpptraj

32.7.4. createcrd

This command is actually an Action that can be used to create COORDS data sets during trajectory processing,

see 32.11.19 on page 655.

32.7.5. crdout

crdout <crd set> <filename> [<trajout args>] [crdframes <start>,<stop>,<offset>]

Write COORDS data set <crd set> to trajectory named <ﬁlename>. A subset of frames in the COORDS data set
can be speciﬁed with ’crdframes’.

For example, to write frames 1 to 10 from a previously created COORDS data set named “crd1” to separate

PDB ﬁles:

crdout crd1 crd1.pdb multi crdframes 1,10

32.7.6. loadcrd

loadcrd <filename> [parm <parm> | parmindex<#>] [<trajin args>] [name <name>]

Immediately load trajectory <ﬁlename> as a COORDS data set named <name> (default base name of <ﬁlename>).
If <name> is already present the coordinates will be appended to the existing data set.

For example, to load frames from trajectories named ’traj1.nc’ and ’traj2.nc’ into a COORDS data set named

Crd1:

loadcrd traj1.nc name Crd1
loadcrd traj2.nc name Crd2

32.7.7. loadtraj

loadtraj name <setname> [<filename>]

This command functions in two ways. If <ﬁlename> is not provided, all currently loaded input trajectories (from
trajin commands) are added to TRAJ data set named <setname>. Note that if the input trajectory list is cleared
(via ’clear trajin’) this will invalidate the TRAJ data set. In addition, currently all trajectories must have the
same number of atoms. Otherwise add trajectory <ﬁlename> to TRAJ data set <setname>.

TRAJ data sets cannot be modiﬁed.

32.7.8. permutedihedrals

permutedihedrals crdset <COORDS set> resrange <range> [{interval | random}]

[outtraj <filename> [<outfmt>]] [crdout <output COORDS>]

Options for ’random’:

[<dihedral types>]

[rseed <rseed>] [out <# problems file> [<set name>]]
[ check [cutoff <cutoff>] [rescutoff <rescutoff>] [checkallresidues]

[backtrack <backtrack>] [increment <increment>] [maxfactor <max_factor>] ]
Options for ’interval’:

<interval deg>

<dihedral types> = alpha beta gamma delta epsilon zeta nu1 nu2 h1p c2p chin

phi psi chip omega

crdset <COORDS set> COORDS data set to operate on.
resrange <range> Residue range to search for dihedrals.

614

32.7. Coordinates (COORDS) Data Set Commands

interval Rotate found dihedrals by <interval>. This is done in an ordered

fashion so that every combination of dihedral rotations is sampled at least
once.

random Rotate each found dihedral randomly.
[outtraj <ﬁlename>] Trajectory file to write coordinates to.

[<outfmt>] Trajectory file format.

[crdout <output COORDS>] COORDS data set to write coordinates to.
<dihedral type> One or more dihedral types to search for.

Options for ’interval:

<interval deg> Amount to rotate dihedral by each step.
Options for ’random’:

[rseed <rseed>] Random number seed.
[out <# problems ﬁle>] File to write number of problems (clashes) each frame to.
[<set name>] Number of problems data set name.
[check] Check randomly rotated structure for clashes.

[cutoff <cutoff>] Atom cutoff for checking for clashes (default 0.8 Å).
[rescutoff <cutoff>] Residue cutoff for checking for clashes (defualt 10.0 Å).
[checkallresidues] If specified all residues checked for clashes, otherwise

only residues up to the currently rotated dihedral check.

[backtrack <backtrack>] If a clash is encountered at dihedral N and cannot be

resolved, go to dihedral N-<backtrack> to try and resolve the clash
(default 4).

[increment <increment>] If a clash is encountered, first attempt to rotate

dihedral by increment to resolve it; if it cannot be resolved by a full
rotation the calculation will backtrack (default 1).

[maxfactor <max_factor>] The maximum number of total attempted rotations will

be <max_factor> * <total # of dihedrals> (default 2).

Create a trajectory by rotating speciﬁed dihedrals in a structure by regular intervals (interval), or create 1 structure
by randomly rotating speciﬁed dihedrals (random). When randomly rotating dihedrals steric clashes will be
checked if check is speciﬁed; in such cases the algorithm will attempt to resolve the clash as best it can.
If
clashes are not being resolved you can increase the number of rotation attempts cpptraj will make by increasing
maxfactor.

For example, to rotate all backbone dihedrals in a protein with coordinates in a ﬁle named tz2.rst7 in -120

degree intervals and write the resulting trajectory in Amber format to rotations.mdcrd:

reference tz2.rst7 [TZ2]
permutedihedrals crdset [TZ2] interval -120 outtraj rotations.mdcrd phi psi

To randomly rotate backbone dihedrals for the same structure and write to ﬁle random.mol2 in MOL2 format:

reference tz2.rst7 [TZ2]
permutedihedrals crdset [TZ2] random rseed 1 check maxfactor 10 phi psi \

outtraj random.mol2 multi

32.7.9. reference

Reference coordinates can now be used and manipulated like COORDS data sets. See 32.10.3 on page 637 for

command syntax.

615

32. cpptraj

32.7.10. rotatedihedral

rotatedihedral crdset <COORDS set> [frame <#>] [name <output set name>]

{value <value> | increment <increment>}
{ <mask1> <mask2> <mask3> <mask4> |

res <#> type <dih type> }

<dih type> = alpha beta gamma delta epsilon zeta nu1 nu2 h1p c2p chin

phi psi chip omega

crdset <COORDS set> Coordinates data set to work on. If a TRAJ data set is

specified, name must also be specified.

[frame <#>] Frame of the COORDS set to work on.

[name <output set name>] Output COORDS set. If not specified the input COORDS

set will be modified.

value <value> Set specified dihedral to given value in degrees.

increment <increment> Increment specified dihedral by increment in degrees.

<mask1> <mask2> <mask3> <mask4> Define dihedral by atom masks. Each mask

should only select one atom.

res <#> Rotate dihedral specified by type in residue number <#>.

type <dih type> Dihedral type to rotate in specified residue.

Rotate the speciﬁed dihedral in given COORDS set to a target value or by given increment. For example, to set
the protein chi dihedral in residue 8 to 35 degrees and write out to a mol2 ﬁle:

parm ../tz2.parm7
loadcrd ../tz2.nc 1 1 name TZ2
rotatedihedral crdset TZ2 value 35 res 8 type chip
crdout TZ2 tz2.rotate.1.mol2

32.7.11. splitcoords

splitcoords <crd set> name <output set name>

<crd set> COORDS set to split.

name <output set name> Name of new set to create.

Split trajectory speciﬁed by <crd set> by molecule into a new COORDS set. All molecules in <crd set> must be
the same size. For example, if there are 10 molecules and 10 frames in COORDS set “Set0”, the following would
create a new COORDS set with 100 frames (original molecules 1-10 frame 1, original molecules 1-10 frame 2,
etc):

splitcoords Set0 name Set0Split

32.8. General Commands

The following general commands are available:

616

32.8. General Commands

Command
activeref

calc
clear
create
createset
dataﬁle
dataﬁlter
dataset

debug | prnlev
ensextension

exit | quit
go | run

help
list

noexitonerror
noprogress

parallelanalysis

precision
printdata
readdata

readensembledata

readinput
removedata

rst

runanalysis

select
selectds

silenceactions

sortensembledata

usediskcache
write | writedata

Description

Select the reference for distance-based masks.
Evaluate the given mathematical expression.
Clear various objects from the cpptraj state.

Create (but do not yet write) a data ﬁle.

Create a dataset from a simple mathematical expression.

Used to manipulate data ﬁles.

Filter data sets based on given criteria.

Use to manipulate data sets.

Set debug level. Higher levels give more info.

Enable/disable ensemble number extension for ﬁles in ensemble mode.

Quit cpptraj.

Start a trajectory processing Run.

Provide help for commands.

List various objects in the cpptraj state.

Attempt to continue even if errors are encountered.

Do not print a progress bar during a Run.

(MPI only) Divide current Analyses among MPI processes.

Change the output precision of data sets.

Print data set to screen.
Read data sets from ﬁles.

Read data ﬁles in ensemble mode.

Read cpptraj input from a ﬁle.
Remove speciﬁed data set(s).

Generate Amber-style distance/angle/torsion restraints.
Run an analysis immediately or run all queued analyses.

Print the results of an atom mask expression.

Print the results of a data set selection expression.

Prevent Actions from writing information to STDOUT.

Sort data sets using replica information (currently constant pH only).

Turn caching of data sets to disk on or off.

Immediately write data to a ﬁle or write to all current data ﬁles.

32.8.1. activeref

activeref <#>

Set which reference structure should be used when setting up distance-based masks for everything but the ’mask’
action. Numbering starts from 0, so ’activeref 0’ selects the ﬁrst reference structure read in, ’activeref 1’ selects
the second, and so on.

32.8.2. calc

calc <expression>
[prec <width>.<precision>] [format {double|general|scientific}]

<expression> Mathematical expression to evaluate. See 32.5.2 on page 606 for

details.

prec <width>.<precision> Set the width and precision of the result.
format {double|general|scientiﬁc} Set the format of the result.

Evaluate the given mathematical expression. This version gives more control over the format of the output.

617

32. cpptraj

32.8.3. clear

clear [{all | <type>}]

(<type> = actions,trajin,trajout,ref,parm,analysis,datafile,dataset)

Clear list of indicated type, or all lists if ’all’ speciﬁed. Note that when clearing actions or analyses, associated
data sets and data ﬁles are not cleared and vice versa.

32.8.4. create

create <filename> <datasetname0> [<datasetname1> ...] [<DataFile Options>]

Add speciﬁed data sets to the data ﬁle named <ﬁlename>; if the ﬁle does not exist, it will be added to the
DataFileList. Data ﬁles created in this way are only written at the end of coordinate processing, analyses, or
via the ’writedata’ command. See 32.6 on page 607 for more data ﬁle format options.

32.8.5. createset

createset <expression> [xmin <min>] xstep <step> nx <nxvals>

expression Simple mathematical expression, must contain equals sign, can contain

X (e.g. Y=2*X). If not enclosed in quotes must not contain whitespace.

xmin <min> Minimum X value.
xstep <step> X step.
nx <nxvals> Number of X values.

Generate a data set from a simple mathematical expression.

32.8.6. dataﬁle

datafile <filename> <datafile arg>

Pass <dataﬁle arg> to data ﬁle <ﬁlename>. See 32.6 on page 607 for more details.

32.8.7. dataﬁlter

datafilter {<dataset arg> min <min> max <max> ...} [out <file>] [name <setname>]

[{multi | filterset <set> [newset <newname>]}]

<dataset arg> min <min> max <max> Data set name and min/max cutoffs to use; can

specify more than one.

[out <ﬁle>] Write out to file named <file>.
[name <setname>] Name of filter data set containing 1 when cutoffs satisfied, 0

otherwise.

[multi] Filter each set separately instead of all together (creates filter set

for each input set). Cannot be used with ’filterset’.

[ﬁlterset <set>] If specified, <set> will be filtered to only contain data that

satisfies cutoffs. Cannot be used with ’multi’.
[newset <newname>] If specified a new set will be created from ’filterset’

instead of replacing ’filterset’.

618

32.8. General Commands

Create a data set (optionally named <setname>) containing 1 for data within given <min> and <max> criteria for
each speciﬁed data set. There must be at least one <min> and <max> argument, and can be as many as there
are speciﬁed data sets. If ’multi’ is speciﬁed then only ﬁlter data sets will be created for each data set instead. If
’ﬁlterset’ is speciﬁed, the speciﬁed <set> will be modiﬁed to only contain ’1’ frames; cannot be used with ’multi’.
If ’newset’ is also speciﬁed, a new set will be created containing the ’1’ frames instead. The ’ﬁlterset’ functionality
only works for 1D scalar sets.

For example, to read in data from two separate ﬁles (d1.dat and a1.dat) and generate a ﬁlter data set named

FILTER having 1 when d1 is between 0.0 and 3.0 and a1 is between 135.0 and 180.0:

readdata a1.dat name a1
readdata d1.dat name d1
datafilter d1 min 0.0 max 3.0 a1 min 135.0 max 180.0 out filter.dat name FILTER

Note that a similar command that can be used with data generated by Actions during trajectory processing is ﬁlter
(see page 663).

32.8.8. dataset

dataset { legend <legend> <set> |

makexy <Xset> <Yset> [name <name>] |
vectorcoord {X|Y|Z} <set> [name <name>] |

cat <set0> <set1> ... [name <name>] [nooffset] |

make2d <1D set> cols <ncols> rows <nrows> [name <name>] |
{drop|keep}points {range <range arg> | [start <#>] [stop <#>] [offset <#>]}

[name <output set>] <set arg1> ... |

remove <criterion> <select> <value> [and <value2>] [<set selection>] |
dim {xdim|ydim|zdim|ndim <#>} [label <label>] [min <min>] [step <step>] |
outformat {double|scientific|general} <set arg1> [<set arg 2> ...] |
invert <set arg0> ... name <new name> [legendset <set>] |
shift [above <value> by <offset>] [below <value> by <offset>] <set arg0> ...

[mode <mode>] [type <type>] <set arg1> [<set arg 2> ...]

}

<mode>: ’distance’ ’angle’ ’torsion’ ’pucker’ ’rms’ ’matrix’ ’vector’
<type>: ’alpha’ ’beta’ ’gamma’ ’delta’ ’epsilon’ ’zeta’ ’nu0’ ’nu1’ ’nu2’ ’nu3’

’nu4’ ’h1p’ ’c2p’ ’chin’ ’phi’ ’psi’ ’chip’ ’omega’ ’chi2’ ’chi3’ ’chi4’
’chi5’ ’pucker’ ’noe’ ’distance’ ’covariance’ ’mass-weighted covariance’
’correlation’ ’distance covariance’ ’IDEA’ ’IRED’ ’dihedral covariance’

Options for ’type noe’:

[bound <lower> bound <upper>] [rexp <expected>] [noe_strong] [noe_medium]

[noe_weak]

[name <name>] New data set name for

makexy/vectorcoord/cat/make2d/droppoints/keeppoints.

legend <legend> <set> Set the legend for data set <set> to <legend>.
makexy <Xset> <Yset> Create a new data set (optionally named <name>) with X

values from <Xset> and Y values from <Yset>.

vectorcoord {X|Y|Z} <set> Extract X/Y/Z coordinates from vector data set into a

new 1D data set.

cat <set0> <set1> ... Concatenate two or more data sets into a new data set

(optionally named <name>).

make2d <1D set> cols <ncols> rows <nrows> Convert 1D data set into row-major 2D

data set with specified number of rows and columns.

619

32. cpptraj

{drop|keep}points <set arg1> ... Drop or keep specified points from data set(s),

optionally creating a new data set.
range <range arg> Range of points to drop/keep.
[start <#>] [stop <#>] [offset <#>] Start/stop/offset values of points to

drop/keep.

remove <criterion> <select> <value> [and <value2>] [<set selection>] Remove data sets

from <set selection> according to specified criterion and selection.

<criterion>: ’ifaverage’ ’ifsize’ ’ifmode’ ’iftype’
<select>

: ’equal’ ’==’ ’notequal’ ’!=’ ’lessthan’ ’<’

’greaterthan’ ’>’ ’between’ ’outside’

dim {xdim|ydim|zdim|ndim <#>} Change specified dimension in set(s).

label <label> Change dimension label to <label>
min <min> Change dimension minimum to <min>.
step <step> Change dimension step to <step>.

invert <set arg0> ... name <new name> [legendset <set>]

<set arg0> ... Specify sets to invert.
name <new name> Inverted output set name.
[legendset <set>] String data set containing legends

shift

[above <value> by <offset>] Values in set(s) above <value> will be shifted by

<offset>.

[below <value> by <offset>] Values in set(s) below <value> will be shifted by

<offset>.

<set arg0> ... Set(s) to shift.

[mode <mode>] Set data set(s) mode to <mode>.

[type <type>] Set data set(s) type to ’type’, useful for e.g. analysis with
statistics. Note this can also be done with ’type <type>’ for certain
commands (distance, dihedral, pucker etc).
compatible with a given <mode>.

Note that not every <type> is

Options for type noe only:

[bound <lower> bound <upper>] Lower and upper bounds for NOE (in Angstroms); must

specify both.

[rexp <expected>] Expected value for NOE (in Angstroms); if not given ’(<lower> +

<upper>)’ / 2.0 is used.

[noe_strong] Set lower and upper bounds to 1.8 and 2.9 Å respectively.

[noe_medium] Set lower and upper bounds to 2.9 and 3.5 Å respectively.

[noe_weak] Set lower and upper bounds to 3.5 and 5.0 Å respectively.

Either set the legend for a single data set, create a new set with X values from one set and Y values from another,
concatenate 2 or more sets, make a 2D set from 1D set, remove sets according to a certain criterion, or change the
mode/type for one or more data sets.

Setting the mode/type can be useful for cases where the data set is being read in from a ﬁle; for example when
reading in a dihedral data set the type can be set to ’dihedral’ so that various Analysis routines like statistics know
to treat it as periodic. A brief description of possible modes and types follows:

620

32.8. General Commands

Mode
distance
angle
torsion

pucker

rms
matrix

Type
noe

alpha
beta

gamma
delta
epsilon

zeta
nu1
nu2
h1p
c2p
chin
phi
psi
chip
omega
pucker

distance
covariance

Description
NOE distance.

Angle.

Nucleic acid alpha.
Nucleic acid beta.

Nucleic acid gamma.
Nucleic acid delta.
Nucleic acid epsilon.

Nucleic acid zeta.

Nucleic pucker (O4’).
Nucleic pucker (C4’).

Nucleic acid H1’.
Nucleic acid C2’.
Nucleic acid chi.

Protein Phi.
Protein psi.
Protein chi.

Protein omega.
Sugar pucker.

RMSD.

Distance matrix.

Cartesian covariance matrix.

’mass-weighted covariance’ Mass weighted Cartesian covariance matrix.

correlation

’distance covariance’

Dynamic cross correlation matrix.

Distance covariance matrix.

IDEA
IRED

IDEA matrix.
IRED matrix.

’dihedral covariance’

Dihedral covariance matrix.

vector

IRED

IRED vector.

The invert mode takes a group of M 1D data sets of size N and create N new "inverted" data sets of size M.

This is similar to the invert keyword already available for standard and Grace data writes, but operates directly on
data sets. For example, given the following two data sets:

D0 D1
1 4
2 5
3 6

The new data sets will be laid out like so:

N0 N1 N2
1 2 3
4 5 6

The dataset invert command can be useful if you want to easily view output from multiple analysis commands in
a single graph. For example, to view state counts from two different simulations side by side:

calcstate name Sim1 state bound1,dist1,0.0,2.0
calcstate name Sim2 state bound1,dist1,0.0,2.0
runanalysis dataset invert Sim*[Count] name Inverted legendset Sim1[Name]
dataset dim xdim label Simulation min 1 step 1 Inverted*
writedata statecount.agr Inverted*

621

32. cpptraj

The dataset shift command can be used for wrapping circular values, such as torsions. For example, to ensure a
pucker has a range from 0 to 360 instead of -180 to 180:

pucker Furanoid @C2 @C3 @C4 @C5 @O2 cremer out CremerF.dat amplitude
run
dataset shift Furanoid below 0 by 360

32.8.9. debug | prnlev

debug [<type>] <#>

(<type> = actions,trajin,trajout,ref,parm,analysis,datafile,dataset)

Set the level of debug information to print. In general the higher the <#> the more information that is printed. If
<type> is speciﬁed only set the debug level for a speciﬁc area of cpptraj.

32.8.10. ensextension

ensextension {on|off}

Turn printing of ensemble member number ﬁlename extensions on or off. By default ensemble extensions are
printed in parallel and not in serial.

NOTE: THE ’ensextension off’ OPTION HAS NOT BEEN FULLY TESTED IN PARALLEL AND IS

NOT CURRENTLY RECOMMENDED.

32.8.11. exit | quit

Exit normally.

32.8.12. go | run

Begin trajectory processing, followed by analysis and dataﬁle write.

32.8.13. help

help [ { All |

<cmd> |

<command category> |
Form[ats] [{read|write}] |
Form[ats] [{trajin|trajout|readdata|writedata|parm|parmwrite} [<fmt key>]] |
Mask

} ]

Command Categories: Gen[eral] Sys[tem] Coor[ds] Traj[ectory] Top[ology]

Act[ion] Ana[lysis] Con[trol]

: Print all known commands.
: Print help for command <cmd>.

All
<cmd>
<command category> : Print all commands in specified category.
Form[ats]
Mask

: Help for file formats.
: Help for mask syntax.

If ’All’ is specifed, list all commands known to cpptraj. If given with a command, print help for that command.
Otherwise, list all commands of a certain category (General, System, Coords, Trajectory, Topology, Action, Anal-
ysis, or Control), help for various ﬁle formats, or help with atom mask syntax.

622

32.8.14. list

list <type>

(<type> = actions,trajin,trajout,ref,parm,analysis,datafile,dataset)

List the currently loaded objects of <type>. If no type is given then list all loaded objects.

32.8. General Commands

32.8.15. noexitonerror

noexitonerror

Normally cpptraj will exit if actions fail to initialize properly. If noexitonerror is speciﬁed, cpptraj will attempt to
continue past such errors. This is the default if in interactive mode.

32.8.16. noprogress

noprogress

Do not display read progress during trajectory processing.

32.8.17. parallelanalysis

parallelanalysis [sync]

MPI only. Divide all currently set up analyses as evenly as possible among available MPI processes and execute.
Each analysis will get a single MPI process. If sync is speciﬁed all data will be synced back to the master thread
(for e.g. subsequent analysis). For an example of how to use the parallelanalysis command, see 32.12.14 on
page 727.

32.8.18. precision

precision {<filename> | <dataset arg>} [<width>] [<precision>]

Set the precision for all data sets in data ﬁle <ﬁlename> or data set(s) speciﬁed by <dataset arg> to width.precision,
where width is the column width and precision is the number of digits after the decimal point. Note that the
<precision> argument only applies to ﬂoating-point data sets.

For example, if one wanted to set the precision of the output of an Rmsd calculation to 8.3, the input could be:

trajin ../run0.nc
rms first :10-260 out prec.dat
precision prec.dat 8 3

and the output would look like:

#Frame RMSD_00000
1 0.000
2 0.630

32.8.19. readdata

readdata <filename> [name <dsname>] [as <fmt>] [separate] [<format options>]

name <dsname> Name for read-in data set(s). Default is <filename>.
as <fmt> Force <filename> to be read as a specific format using given format

keyword.

separate Read each file specified into separate data sets indexed from 0.

623

32. cpptraj

Read data from ﬁle <ﬁlename> and store as data sets. For more information on formats currently recognized by
cpptraj see 32.1 on page 605. For format-speciﬁc options see 32.6. For example, given the ﬁle calc.dat:

#Frame
1

R0

D1
1.7 2.22

The command ’readdata calc.dat’ would read data into two data sets, calc.dat:2 (legend set to “R0”) and
calc.dat:3 (legend set to “D1”).

32.8.20. readensembledata

readensembledata <filename> [filenames <additional files>] [<readdata args>]
<ﬁlename> Lowest replica file name.
ﬁlenames <additional ﬁles> Specified additional members of the ensemble.

If not
specified ensemble members will be search for using numerical extensions.

<readdata args> Additional data file arguments.

Read data sets as an ensemble, i.e. each ﬁle is a different member of an ensemble. This command is MPI-aware.
If one ﬁlename is given, it is assumed it is the "lowest" member of an ensemble with a numerical extension,
e.g. ’ﬁle.001’ and the remaining ﬁles are searched for automatically. Otherwise all other members of the ensemble
can be speciﬁed with ’ﬁlenames’ and a comma-separated list e.g. ’ﬁle.001 ﬁlenames ﬁle.002,ﬁle.003,ﬁle.004. For
additional ’readdata’ arguments that can be passed in see 32.6 on page 607.

For example, to read in data ﬁles named cpout.001 to cpout.006 automatically:

readensembledata cpout.001 cpin cpin name PH

Or speciﬁed:

readensembledata cpout.001 \

filenames cpout.002,cpout.003,cpout.004,cpout.005,cpout.006 \
cpin cpin name PH

32.8.21. readinput

readinput <filename>

Read cpptraj commands from ﬁle <ﬁlename>.

32.8.22. removedata

removedata <arg>

Remove data set corresponding to <arg>.

32.8.23. rst

rst <mask1> <mask2> [<mask3>] [<mask4>]

r1 <r1> r2 <r2> r3 <r3> r4 <r4> rk2 <rk2> rk3 <rk3>
{[parm <parmfile / tag> | parmindex <#>]}
[{ref <refname> | refindex <#> | reference} [offset <off>] [width <width>]]
[out <outfile>]

<mask1> (Required) First atom mask.
<mask2> (Required) Second atom mask.

restraint.

If only two masks assume distance

624

32.8. General Commands

[<mask3>] (Optional) Third atom mask.
[<mask4>] (Optional) Fourth atom mask. If 4 atom masks assume dihedral

If 3 atom masks assume angle restraint.

restraint.

rX <rX> Value of RX (X=1-4, default 0.0)
rk2 <rk2> Value of RK2 (force constant to be applied when R is R1 <= R < R2)
rk3 <rk3> Value of RK3 (force constant to be applied when R is R3 <= R < R4)
[parm <parmﬁle / tag> | parmindex <#>] Topology to be used for atom masks.
{ref <refname> | reﬁndex <#> | reference} Use distance/angle/dihedral in reference

structure to determine values for r1, r2, r3, and r4.
set to <r2> + <off>, r3 = r2, r1 = r2 - <width>, r4 = r3 + <width>.

The value of r2 is

[offset <off>] (Reference only) Value to offset distance/angle/torsion in

reference by (default 0.0).

[width <width>] (Reference only) Width between r1 and r2, r3 and r4 (default

0.5).

[out <outﬁle>] Write restraints to outfile.

If not specified, write to STDOUT.

Generate Amber-style distance restraints for use with nmropt=1. This is particularly useful for generating
distance restraints based off of reference coordinates. For example to generate a distance restraint between two
C5’ atoms using the current distance between them in a reference structure, offsetting the distance by 1.0 Ang.:

parm 30bp-longbox-tip3p-na.parm7
reference 30bp-longbox.rst7
rst :1@C5’ :31@C5’ reference offset 1.0 rk2 10.0 rk3 10.0 out output

32.8.24. runanalysis

runanalysis [<analysiscmd> [<analysis args>]]

Run given analysis command immediately and write any data generated. If no command is given run any analysis
currently set up. NOTE: When ’runanalysis’ is speciﬁed alone, data is not automatically written; to write data
generated with ’runanalysis’ use the ’writedata’ command (this allows multiple analysis runs between output if
desired).

32.8.25. select

select <mask>

Prints the number of selected atoms corresponding to the given mask, as well as the atom numbers with format:

Selected= <#atom1> <#atom2> ...

This does not affect the state in any way, but is intended for use in scripts etc. for testing the results of a mask
expression.

32.8.26. selectds

selectds <dataset arg>

Show the results of a data set selection. Data set selection has the format:

<name>[<aspect>]:<index>

Either the [<aspect>] or the <index> arguments may be omitted. A ’*’ can be used in place of <name> or [<as-
pect>] as a wildcard. The <index> argument can be a single number or a range separated by ’-’ and ’,’.

This command does not affect the state in any way, but is particularly useful in interactive mode for determining

the results of a dataset argument.

625

32. cpptraj

32.8.27. sortensembledata

sortensembledata <dset arg0> [<dset arg1> ...]
<dset arg0> [<dset arg1> ...] Data set(s) to sort.

Sort unsorted data sets. Currently only works for constant pH REMD data.

32.8.28. usediskcache

usediskcache {on|off}

If on, CPPTRAJ will attempt to cache data sets to disk if possible. This currently only works for integer data sets
(e.g. hbond series data sets, etc).

32.8.29. write | writedata

write [<filename> <datasetname0> [<datasetname1> ...]] [<DataFile Options>]

With no arguments, write all ﬁles currently in the data ﬁle list. Otherwise, write speciﬁed data set(s) to <ﬁlename>.
This is like the ’create’ command except a data ﬁle is not added to the data ﬁle list; it is written immediately.
See 32.6 on page 607 for more data ﬁle format options.

32.8.30. System Commands

These commands call the equivalent external system commands.

gnuplot <args> Call gnuplot (if it is installed on your system) with the given arguments.

head <args> Call head, which lists the ﬁrst few lines of a ﬁle.

less <args> Call less, which can be used to view the contents of a ﬁle.

ls <args> List the contents of a directory.

pwd <args> Print the current working directory.

xmgrace <args> Call xmgrace (if it is installed on your system) with the given arguments.

32.9. Topology File Commands

These commands control the reading and writing of topology ﬁles. Cpptraj supports the following topology ﬁle

formats:

Format

Keyword Extension

Notes

Amber Topology

PDB
Mol2
CIF

Charmm PSF

amber
pdb
mol2
cif
psf

Gromacs Topology

gromacs

SDF

Tinker ARC

sdf
arc

.parm7
.pdb
.mol2
.cif
.psf
.top
.sdf
.arc

Only fully-supported format for write.

Read Only
Read Only
Read Only

Limited Write

Read only
Read Only
Read Only

For most commands that require a topology one can be speciﬁed via two keywords:

parm [<name>] Select topology corresponding to given ﬁle name, tag, or name.

626

32.9. Topology File Commands

parmindex [<#>] Select topology by order in which it was loaded, starting from 0.

The following topology related commands are available:

Command

angleinfo, angles, printangles
atominfo, atoms, printatoms
bondinfo, bonds, printbonds

change
charge

comparetop

Description

Print angle info for selected atoms.

Print details for selected atoms.

Print bond info for selected atoms.
Change speciﬁed parts of a topology.
Print total charge for selected atoms.

Compare two topologies and report differences.

dihedralinfo, dihedrals, printdihedrals
improperinfo, impropers, printimpropers

mass
molinfo
parm

parmbox
parminfo
parmstrip
parmwrite

printub, ubinfo

resinfo

scaledihedralk

solvent

updateparameters

Print dihedral info for selected atoms.
Print improper info for selected atoms.

Print total mass for selected atoms.

Print molecule info for selected atoms.

Load a topology ﬁle.

Modify box info for a loaded topology.

Print details for selected topology.

Remove selected atoms from topology.

Write selected topology to ﬁle.

Print Urey-Bradley info for selected atoms.

Print residue info for selected atoms.
Scale selected dihedral force constants.

Change which molecules are considered solvent.

Update/add parameters in/to a topology.

32.9.1. angleinfo | angles | printangles

angleinfo [parm <name> | parmindex <#> | <#>] [<mask1>] [<mask2> <mask3>]

[out <file>]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask1>] Mask to print angle info for.
[<mask2> <mask3>] If specified, angles must match all masks.
[out <ﬁle>] File to print to (default STDOUT).

Print angle information of atoms in <mask> for selected topology (ﬁrst loaded topology by default) with format:

# Angle Kthet degrees atom names (numbers)

Where Angle is the internal angle index, Kthet is the angle force constant, degrees is the angle equilibrium value,
atom names shows the atoms involved in the angle with format :<residue num>@<atom name>, and (numbers)
shows the atom indices involved in a comma-separated list. Atom types will be shown in the last column.

If 3 masks are given instead of 1, print info for angles with ﬁrst atom in <mask1>, second atom in <mask2>,

and third atom in <mask3>.

32.9.2. atominfo | atoms | printatoms

atominfo [parm <name> | parmindex <#> | <#>] [<mask>] [out <file>]
[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask>] Mask selecting atoms to print info for.

627

32. cpptraj

[out <ﬁle>] File to print to (default STDOUT).

Print information on atoms in <mask> for selected topology (ﬁrst loaded topology by default) with format:

#Atom Name #Res Name #Mol Type Charge Mass GBradius El [rVDW] [eVDW]

where #Atom is the internal atom index, the ﬁrst Name column is the atom name, #Res is the atom’s residue number,
the second Name column is residue name, #Mol is the atom’s molecule number, Type is the atom’s type (certain
topologies only), Charge is the atom charge (in units of electron charge), Mass is the atom’s mass (in amu),
GBradius is the generalized Born radius of the atom (Amber topologies only), and El is the 2 character element
string. The ﬁnal two columns are only shown if the topology contains non-bonded parameters: rVDW is the atom’s
Lennard-Jones radius and eVDW is the atom’s Lennard-Jones epsilon.

32.9.3. bondinfo | bonds | printbonds

bondinfo [parm <name> | parmindex <#> | <#>]

[<mask1>] [<mask2>] [out <file>] [nointrares]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask1>] Mask to print bond info for.
[<mask2>] If specified, bonds must match both masks.
[out <ﬁle>] File to print to (default STDOUT).
[nointrares] Do not print intra-residue bonds.

Print bond information for atoms in <mask> for selected topology (ﬁrst loaded topology by default) with format:

# Bond Kb Req atom names (numbers)

where Bond is the internal bond index, Kb is the bond force constant, Req is the bond equilibrium value (in
Angstroms), atom names shows both atom names with format :<residue num>@<atom name>, and (numbers)
shows both atom numbers in a comma-separated list. Atom types will be shown in the last column.

If 2 masks are given instead of 1, print info for bonds with ﬁrst atom in <mask1> and second atom in <mask2>.

32.9.4. change

change [parm <name> | parmindex <#> | <#> |

crdset <COORDS set> ]

{ resname from <mask> to <value> |

chainid of <mask> to <value> |

atomname from <mask> to <value> |

addbond <mask1> <mask2> [req <length> <rk> <force constant>]
removebonds <mask1> [<mask2>] [out <file>] }

parm <name> | parmindex <#> | <#> | crdset <COORDS set> Topology to change.
resname from <mask> to <value> Change residue names for residues in <mask> to the

given <value>.

chainid of <mask> to <value> Change the chain ID of residues in <mask> to given

<value>.

atomname from <mask> to <value> Change atom names for atoms in <mask> to the

given <value>.

addbond <mask1> <mask2> Add bond between atom specified by <mask1> and atom

specified by <mask2>.

628

32.9. Topology File Commands

[req <length>] The equilibrium bond length in Angstroms.
[rk <force constant>] The bond force constant in kcal/mol*Angstrom.

removebonds <mask1> [<mask2>] Remove bonds from atoms in <mask1>. If <mask2>

also given, remove bonds between atoms in <mask1> and atoms in <mask2>.
[out <ﬁle>] If specified, write removed bonds to <file> with format ’<residue

name> <residue num> <atom name> <atom num>’.

Change speciﬁed parts of the speciﬁed topology. For example, to change atoms named ’HN’ to ’H’ in topology 0:

change parmindex 0 atomname from @HN to H

32.9.5. charge

charge [parm <name> | parmindex <#> | <#>] [<mask>] [out <file>] [name <set>]
parm <name> | parmindex <#> Topology to calculate charge from.
[<mask>] Atom(s) to calculate total charge for (default all).
[out <ﬁle>] File to write total charge to.
[name <set>] If specified, a data set named <set> will be cretaed containing

total charge.

Print the total charge of atoms in <mask> (in units of electron charge) for selected topology (ﬁrst loaded topology
by default).

32.9.6. comparetop

comparetop {parm <name> | parmindex <#>} {parm <name> | parmindex <#>} [out <file>]

[atype] [lj] [bnd] [ang] [dih] [atoms]
parm <name> | parmindex <#> Topologies to compare.
out <ﬁle> Print results to file instead of screen.
[atype] Only report atom type differences.
[lj] Only report differences in Lennard-Jones parameters.
[bnd] Only report differences in bond parameters.
[ang] Only report differences in angle parameters.
[dih] Only report differences in dihedral parmeters.
[atoms] Only report differences in atom properties.

Compare and report differences in atoms/parameters between two topologies. Differences are reported in standard
’diff’ format, with ’<’ preﬁx indicating the parameter is from the ﬁrst topology and ’>’ preﬁx indicating the
parameter is from the second topology.

32.9.7. dihedralinfo | dihedrals | printdihedrals

dihedralinfo [parm <name> | parmindex <#> | <#>] [<mask1>] [<mask2> <mask3> <mask4>]

[out <file>]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology. Default is

first loaded topology.

629

32. cpptraj

[<mask1>] Mask to print dihedral info for.
[<mask2> <mask3> <mask4>] If specified, dihedrals must match all masks.
[out <ﬁle>] File to print to (default STDOUT).

Print dihedral information of atoms in <mask> for selected topology (ﬁrst loaded topology by default) with
format:

#Dihedral pk phase pn atoms

where #Dihedral is the internal dihedral index, pk is the dihedral force constant, phase is the dihedral phase, pn
is the dihedral periodicity, and atoms shows the names of the atoms involved in the angle with format :<residue
num>@<atom name>, followed by the atom indices involved in a comma-separated list. In addition if the dihedral
is an end dihedral, improper dihedral, or both it will be prefaced with an E, I, or B respectively. Atom types will
be shown in the last column.

If 4 masks are given instead of 1, print info for dihedrals with ﬁrst atom in <mask1>, second atom in <mask2>,

third atom in <mask3>, and fourth atom in <mask4>.

32.9.8. improperinfo | impropers | printimpropers

improperinfo [parm <name> | parmindex <#> | <#>] [<mask1>] [<mask2> <mask3> <mask4>]

[out <file>]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask1>] Mask to print improper info for.
[<mask2> <mask3> <mask4>] If specified, impropers must match all masks.
[out <ﬁle>] File to print to (default STDOUT).

For speciﬁed topology (ﬁrst by default) either print CHARMM improper info for all atoms in <mask1>, or print
info for dihedrals with ﬁrst atom in <mask1>, second atom in <mask2>, third atom in <mask3>, and fourth atom
in <mask4>.

32.9.9. mass

[<parmindex>] [parm <name> | parmindex <#> | <#>] [<mask>] [out <file>] [name <set>]

parm <name> | parmindex <#> Topology to calculate mass from.
[<mask>] Atom(s) to calculate total mass for (default all).
[out <ﬁle>] File to write total mass to.
[name <set>] If specified, a data set named <set> will be cretaed containing

total mass.

Print the total mass of atoms in <mask> (in amu) for selected topology (ﬁrst loaded topology by default).

32.9.10. molinfo

molinfo [parm <name> | parmindex <#> | <#>] [<mask>] [out <file>]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask>] Mask selecting molecules to print info for.

630

32.9. Topology File Commands

[out <ﬁle>] File to print to (default STDOUT).

Print molecule information for atoms in <mask> for selected topology (ﬁrst loaded topology by default) with
format:

#Mol Natom #Res Name C [SOLVENT]

where #Mol is the molecule number, Natom is the number of atoms in the molecule, #Res and Name are the residue
number and residue name of the ﬁrst residue in the molecule respectively, and C is the chain ID of the ﬁrst residue.
SOLVENT will be printed if the molecule is currently considered a solvent molecule.

32.9.11. parm

parm <filename> [{[TAG] | name <setname>}]

[{ nobondsearch |

[bondsearch <offset>] [searchtype {grid|pairlist}]

}]

<ﬁlename> Parameter file to read in; format is auto-detected.
’[TAG]’ Optional tag (bounded in brackets) which can be referred to in place of

the topology file name in order to simplify references to it (see 32.3.4 on
page 601 for examples of how to use tags).

[name <setname>] Optional name that can be used to refer to the topology in

place of the file name.

[nobondsearch] Optional; if specified do not search for bonds via geometry if

Topology does not include bond information.
fail.

May cause some Actions to

[bondsearch <offset>] Optional; when searching for bonds via geometry search

(default for Topologies without bond information) add <offset> to distances
(default 0.2 Å). Increase this if your system includes unusually long
bonds.

[searchtype {grid|pairlist}] Change search algorithm from the default search between

residues algorithm:
grid Uses a grid when searching for bonds between residues.

This can find

bonds between residues that are not sequential (e.g.

disulfide bonds).

pairlist Uses a pair list to search for bonds between atoms. This can

potentially find bonds across periodic boundaries, but is the more
experimental of the two.

Read in parameter ﬁle. The ﬁle format will be auto-detected. Current formats recognized by cpptraj are listed on
page 626. If the ﬁle does not contain bond information, cpptraj will attempt to assign bonds based on a simple
distance search of atoms within and between residues. The distance cutoff for determining bonds between atoms
depends on the elements of the two atoms in question, augmented by <offset>. Molecule information is then
determined from bond information.

32.9.11.1. PDB format:

[pqr] [readbox] [noconect]

[pqr] Read charge and radius information from the occupancy and B-factor

columns.

[readbox] Read unit cell information from CRYST1 record if present.
[noconect] Do not read in CONECT records from PDB file.

631

32. cpptraj

IMPORTANT NOTES FOR PDB FILES Sometimes PDB ﬁles can contain alternate coordinates for the same
atom in a residue, e.g.:

ATOM
ATOM
ATOM
ATOM

806
807
808
809

CA ACYS A 105
CB ACYS A 105
CA BCYS A 105
CB BCYS A 105

6.460 -34.012 -21.801
6.054 -33.502 -20.415
6.468 -34.015 -21.815
6.025 -33.499 -20.452

0.49 32.23
0.49 35.28
0.51 32.42
0.51 35.38

If this is the case cpptraj will print a warning about duplicate atom names but will take no other action. Both
residues are considered ’CYS’ and the mask ’:CYS@CA’ would select both atom 806 and 809. Residue insertion
codes are read in but also not used by the mask parser.

32.9.11.2. Charmm PSF:

[param <file>]

[param <ﬁle>] Read CHARMM parameters from given file.

Can do multiple times.

32.9.12. parmbox

parmbox [parm <name> | parmindex <#> | <#>] [nobox] [truncoct]

[x <xval>] [y <yval>] [z <zval>] [alpha <a>] [beta <b>] [gamma <g>]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology to modify.

Default is first loaded topology.

[nobox] Remove box information.

[truncoct] Set truncated octahedon angles with lengths equal to <xval>.

[x <xval>] Box X length.

[y <yval>] Box Y length.

[z <zval>] Box Z length.

[alpha <a>] Box alpha angle.

[beta <b>] Box beta angle.

[gamma <g>] Box gamma angle.

Modify the box information for speciﬁed topology. Overwrites any box information if present with speciﬁed
values; any that are not speciﬁed will remain unchanged. Note that unlike the box action this command affect box
information immediately. This can be useful for e.g. removing box information from a parm when stripping
solvent:

parm mol.water.parm7
parmstrip :WAT
parmbox nobox
parmwrite out strip.mol.nobox.parm7

32.9.13. parminfo

parminfo [parm <name> | parmindex <#> | <#>] [<mask>]

Print a summary of information contained in the speciﬁed topology (ﬁrst loaded topology by default) .

632

32.9. Topology File Commands

32.9.14. parmstrip

parmstrip <mask> [parm <name> | parmindex <#> | <#>]

Strip atoms in <mask> from speciﬁed topology (by default the ﬁrst topology loaded). Note that unlike the strip
Action, this permanently modiﬁes the topology for as long as cpptraj is running, so this should not be used if the
topology is being used to read or write a trajectory via trajin/trajout. This command can be used to quickly
created stripped Amber topology ﬁles. For example, to strip all residues name WAT from a topology and write a
new topology:

parm mol.water.parm7
parmstrip :WAT
parmwrite out strip.mol.parm7

32.9.15. parmwrite

parmwrite out <filename> [{parm <name> | parmindex <#> | <#> | crdset <setname>}]

[<fmt>] [nochamber]

<ﬁlename> File to write to.
[parm <name> | parmindex <#> | <#>] Topology to write out.
[crdset <setname>] Write topology from specified COORDS data set.
[<fmt>] Format keyword. If not specified the file name extension will be used.

Default is Amber Topology.

[nochamber] (Amber topology only) Remove any CHAMBER information from the

topology.

Write out speciﬁed topology (ﬁrst topology loaded by default) to <ﬁlename> with format <fmt> (Amber topology
if not speciﬁed). Note that the Amber topology format is the only fully supported format for topology writes.

32.9.15.1. Amber Topology

[nochamber] [writeempty]
[nochamber] Do not write CHAMBER information to topology (useful for e.g.

using topology for visualization with older versions of VMD).

[writeempty] Write Amber tree, join, and rotate info even if not present.

32.9.15.2. Charmm PSF

[oldpsf] [ext]
[oldpsf] Write atom type indices instead of type names (not recommended).
[ext] Use extended format.

32.9.16. printub | ubinfo

printub [parm <name> | parmindex <#> | <#>] [<mask1>] [<mask2>] [out <file>]
[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask1>] Atoms to print UB info for.
[<mask2>] If specified, UB info must match both masks.
[out <ﬁle>] File to print to (default STDOUT).

For speciﬁed topology (ﬁrst by default) either print CHARMM Urey-Bradley info for all atoms in <mask1>, or
print info for bonds with ﬁrst atom in <mask1> and second atom in <mask2>.

633

32. cpptraj

32.9.17. resinfo

resinfo [parm <name> | parmindex <#> | <#>] [<mask>] [short [maxwidth <#res>]]

[out <file>]

[parm <name> | parmindex <#> | <#>] Name/tag or index of topology.

Default is

first loaded topology.

[<mask>] Mask selecting residues to print info for.
[short] Use a short 1 character residue name format

[maxwidth <#res>] Max # of residues to print in one line (default 50).

[out <ﬁle>] File to print to (default STDOUT).

Print residue information for atoms in <mask> for selected topology (ﬁrst loaded topology by default) with
format:

#Res

Name First Last Natom #Orig #Mol C

where #Res is the residue number, Name is the residue name, First and Last are the ﬁrst and last atom numbers
of the residue, Natom is the total number of atoms in the residue, #Orig is the original residue number (in PDB
ﬁles), #Mol is the molecule number, and C is the chain ID.

If short is speciﬁed then residues will be printed out in a condensed format. Each residue name will be

shortened to 1 character, and residues are printed out in groups of 10, 5 groups to a line, with each line beginning
with a residue number, e.g.

> resinfo short 4
1
51

MGFLAGKKIL ITGLLSNKSI AYGIAKAMHR EGAELAFTYV GQFKDRVEKL
CAEFNPAAVL PCDVISDQEI KDLFVELGKV WDGLDAIVHS IAFAPRDQLE

If the 1 character name for a residue is unknown it will be shown as the ﬁrst letter of the residue name in lower-case.

32.9.18. scaledihedralk

scaledihedralk [parm <name> | parmindex <#>] <scale factor> [<mask> [useall]]

Scale dihedral force constants for dihderals selected by <mask> for speciﬁed topology. If useall is speciﬁed all
atoms in <mask> must be present to select a dihedral, otherwise any atom in <mask> will selected a dihedral.

32.9.19. solvent

solvent [parm <name> | parmindex <#> | <#>] { <mask> | none }

Set solvent for selected topology (ﬁrst loaded topology by default) based on <mask>, or set nothing as solvent if
none is speciﬁed.

32.9.20. updateparameters

parm <name> | parmindex <#> setname <parm set>
parm <name> | parmindex <#> Topology to update.
setname <parm set> Topology or parameter data set containing parameters to use.

NOTE: This command is provided for convenience only. For editing topology ﬁles, ParmEd is a much better
alternative.

Update parameters in speciﬁed topology with those from <parm set>. <parm set> can either be a parameter set

or a topology. If a parameter from <parm set> does not exist in the topology it will be added.

For example, to modify parameters in a topology ﬁle named lys.parm7 with those from parameter ﬁle kcx.str:

634

32.10. Trajectory File Commands

# Read Topology to modify
parm lys.parm7
# Read CHARMM parameters
readdata kcx.str as charmmrtfprm name MyParm
# Update parameters in Topology with those from kcx.str
updateparameters parmindex 0 setname MyParm
# Write out the updated Topology
parmwrite out lys.kcx.parm7

32.10. Trajectory File Commands

These commands control the reading and writing of trajectory ﬁles. There are three trajectory types in cpptraj:
input, output, and reference. In cpptraj, trajectories are always associated with a topology ﬁle. If a topology ﬁle is
not speciﬁed, a trajectory ﬁle will be associated with the ﬁrst topology ﬁle loaded by default (this is true for both
input and output trajectories.

Cpptraj currently understands the following trajectory ﬁle formats:

Format

Amber Trajectory

Keyword(s)

crd

Amber NetCDF
Amber Restart

Amber NetCDF Restart

Charmm “DCD” Trajectory

Charmm COORdinates

Charmm Restart

PDB
Mol2

Scripps Binpos
Gromacs TRR
Gromacs GRO
Gromacs XTC
Gromacs TNG

CIF

Tinker ARC
SQM Input

SDF
XYZ

Desmond DTR (Anton)

LMOD Conﬂib

cdf, netcdf

restart

ncrestart, restartnc

dcd, charmm

cor

charmmres

pdb
mol2
binpos

trr
gro
xtc
tng
cif
arc
sqm
sdf
xyz
dtr

Extension

.crd

.nc

.rst7, .rst

.ncrst
.dcd
.cor
.res
.pdb
.mol2
.binpos

.trr
.gro
.xtc
.tng
.cif
.arc
.sqm
.sdf
.xyz
.dtr

Notes

Default format if

keywords/extensions not

recognized.

No compression.

Read Only

Read Only

Read Only
Read Only
Read Only
Write Only
Read Only

Read Only

conﬂib

.conﬂib

Read Only, Detection by

extension

The following trajectory-related commands are available:

Command
ensemble

ensemblesize

reference

trajin
trajout

Description

Set up a trajectory ensemble for reading during a run.

(MPI only) specify number of members expected in subsequent ensemble commands.

Read in a reference structure.

Set up a trajectory for reading during a Run.

Set up an output trajectory or ensemble for writing during a Run.

635

32. cpptraj

32.10.1. ensemble

ensemble <file0> {[<start>] [<stop> | last] [offset]} | lastframe

[parm <parmfile / tag> | parmindex <#>]
[trajnames <file1>,<file2>,...,<fileN>
[remlog <remlogfile> [nstlim <nstlim> ntwx <ntwx>]]

<ﬁle0> Lowest replica filename.

[<start>] Frame to begin reading ensemble at (default 1).

[<stop> | last] Frame to stop reading ensemble at; if not specified or ’last’

specified, end of trajectories.

[<offset>] Offset for reading in trajectory frames (default 1).

[lastframe] Select only the final frame of the trajectories.

[parm <parmﬁle>] Topology filename/tag to associate with trajectories (default

first topology).

[parmindex <#>] Index of Topology to associate with trajectories (default 0,

first topology).

[trajnames <ﬁle1>,...,<ﬁleN>] Do not automatically search for additional replica

trajectories; use comma-separated list of trajectory names.

[remlog <remlogﬁle>] For H-REMD trajectories only, use specified REMD log file to

sort trajectories by coordinate index (instead of by Hamiltonian).

[nstlim <nstlim> ntwx <ntwx>] If trajectory and REMD log were not written at

the same rate, these are the values for nstlim (steps between each
exchange) and ntwx (steps between trajectory write) used in the REMD
simulation.

Read in and process trajectories as an ensemble. Similar to ’trajin remdtraj’, except instead of processing one
frame at a target temperature, process all frames. This means that action and trajout commands apply to the entire
ensemble; note however that not all actions currently function in ’ensemble’ mode. For example, to read in a
replica ensemble, convert it to temperature trajectories, and calculate a distance at each temperature:

parm ala2.99sb.mbondi2.parm7
ensemble rem.crd.000 trajnames rem.crd.001,rem.crd.002,rem.crd.003
trajout temp.crd
distance d1 out d1.ensemble.dat @1 @21

This will output 4 temperature trajectories named ’temp.crd.X’, where X ranges from 0 to 3 with 0 corresponding
to the lowest temperature, and ’d1.ensemble.dat’ containing 4 columns, each corresponding to a temperature. If
run with MPI, data will be written to separate ﬁles named ’d1.ensemble.dat.X’, similar to the output trajectories.
Note that in parallel (i.e. MPI) users should specify the ensemblesize command prior to ensemble in order to

improve set up efﬁciency.

32.10.2. ensemblesize

ensemblesize <#>

This command is MPI only. It is used to set the expected number of members in any subsequent ensemble com-
mand, which dramatically improves set up efﬁciency.

636

32.10. Trajectory File Commands

32.10.3. reference

reference <name> [<frame#>] [<mask>] ([tag]) [lastframe] [crdset]

[parm <parmfile / tag> | parmindex <#>]

<name> File name (or COORDS set name if ’crdset’ specified) to read in as

reference; any trajectory recognized by ’trajin’ can be used.

[<frame#>] Frame number to use (default 1).
[<mask>] Only load atoms corresponding to <mask> from reference.
([tag]) Tag to give this reference file, e.g. “[MyRef]”; BRACKETS MUST BE

INCLUDED.

[lastframe] Use last frame of reference.
[crdset] Use for COORDS data set named <name> instead of file.
[parm <parmﬁle/tag>] Topology filename/tag to associate with reference (default

first topology).

[parmindex <#>] Index of Topology to associate with reference (default 0, first

topology).

Use speciﬁed trajectory as reference coordinates. For trajectories with multiple frames, the ﬁrst frame is used if a
speciﬁc frame is not speciﬁed. An optional tag can be given (bounded in brackets) which can then be used in place
of the name (see 32.3.4 on page 601 for examples of how to use tags). If desired, an atom mask can be used to
read in only speciﬁed atoms from a reference.

Reference coordinates are now considered COORDS data sets and can be used anywhere a COORDS data set

could, which allows reference structures to be manipulated once they are loaded. For example, a reference
structure could be centered on the origin like so:

reference tz2.rst7 [MyRef]
crdaction [MyRef] center origin

Note that the ’average’ keyword has been deprecated for reference. If desired, an averaged reference COORDS
data set can be created from a trajectory using the ’average’ command like so:

parm myparm.parm7
trajin mytraj.nc
rms first :1-12
average crdset RefAvg
run
rms ToAvg reference :1-12 out ToAvg.dat

32.10.4. trajin

trajin <filename> {[<start> [<stop> | last] [<offset>]]} | lastframe

[parm <parmfile / tag> | parmindex <#>]
[mdvel <velocities>] [mdfrc <forces>]
[as <format keyword>] [ <Format Options> ]
[ remdtraj {remdtrajtemp <Temperature> | remdtrajidx <idx1,idx2,...>

| remdtrajvalues <value1,value2,...>}

[trajnames <file1>,<file2>,...,<fileN>] ]

<ﬁlename> Trajectory file to read in.
[<start>] Frame to begin reading at (default 1).

means “<start> frames before <stop>”.

If a negative value is given it

637

32. cpptraj

[<stop> | last] Frame to stop reading at; if not specified or ’last’ specified, end

of trajectory.

[<offset>] Offset for reading in trajectory frames (default 1).
[lastframe] Select only the final frame of the trajectory.
[parm <parmﬁle/tag>] Topology filename/tag to associate with trajectory (default

first topology).

[parmindex <#>] Index of Topology to associate with trajectory (default 0, first

topology).

[mdvel <velocities>] Use velocities from specified file.
[mdfrc <forces>] Use forces from specified file.
[as <format keyword>] Force file to be read as specified format; overrides file

autodetection.

[<Format Options>] See below.
[remdtraj] Read <filename> as the first replica in a group of replica

trajectories.
remdtrajtemp <Temperature> | remdtrajidx <idx1,idx2,...> Use frames at

<Temperature> (for temperature replica trajectories) or index
<idx1,idx2,...> (for Hamiltonian replica trajectories); For
Multidimensional REMD simulations, multiple values are comma-separated.

remdtrajvalues <value1,value2,...> Use frames at <value1,value2,...> (for

Multidimensional REMD trajectories). Each value may correspond to
either temperature, pH, Redox Potential or Hamiltonian index.
The
values need to be entered in the same order as the dimensions in the
Multidimensional REMD simulation.
For example, for T,pH-REMD value1
would correspond to a temperature and value2 to a pH. In the command,
the values are comma-separated.

[trajnames <ﬁle1>,...,<ﬁleN>] Do not automatically search for additional replica

trajectories; use comma-separated list of trajectory names.

Read in trajectory speciﬁed by ﬁlename. See page 635 for currently recognized trajectory ﬁle formats. If just the
<start> argument is given, all frames from <start> to the last frame of the trajectory will be read. To read in a
trajectory with offsets where the last frame # is not known, specify the last keyword instead of a <stop>
argument, e.g.

trajin Test1.crd 10 last 2

This will process Test1.crd from frame 10 to the last frame, skipping by 2 frames. To explicitly select only the last
frame, specify the lastframe keyword:
trajin Test1.crd lastframe

Here is an example of loading in multiple trajectories which have difference topology ﬁles:

parm top0.parm7
parm top1.parm7
parm top2.parm7 [top2]
parm top3.parm7
trajin Test0.crd
trajin Test1.crd parm top1.parm7
trajin Test2.crd parm [top2]
trajin Test3.crd parmindex 3

Test0.crd is associated with top0.parm7; since no parm was speciﬁed it defaulted to the ﬁrst parm read in. Test1.crd
was associated with top1.parm7 by ﬁlename, Test2.crd was associated with top2.parm7 by its tag, and ﬁnally
Test3.crd was associated with top3.parm7 by its index (based on the order it was read in).

638

32.10. Trajectory File Commands

Replica Trajectory Processing

If the remdtraj keyword is speciﬁed the trajectory is treated as belonging to the lowest # replica of a group of

REMD trajectories. The remaining replicas can be either automatically detected by following a naming
convention of <REMDFILENAME>.X, where X is the replica number, or explicitly speciﬁed in a
comma-separated list following the trajnames keyword. All trajectories will be processed at the same time, but
only frames with a temperature matching the one speciﬁed by remdtrajtemp or remdtrajidx will be processed.
For example, to process replica trajectories rem.001, rem.002, rem.003, and rem.004, grabbing only the frames at
temperature 300.0 (assuming that this is a temperature in the ensemble):

trajin rem.001 remdtraj remdtrajtemp 300

or

trajin rem.001 remdtraj remdtrajtemp 300 trajnames rem.002,rem.003,rem.004

Note that the remdout keyword is deprecated. For this functionality see the ensemble keyword.

32.10.4.1. Options for Amber NetCDF, Amber NC Restart, Amber Restart:

[usevelascoords] [usefrcascoords]

usevelascoords Read in velocities in place of coordinates if present.
usefrcascoords Read in forces in place of coordinates if present.

32.10.4.2. Options for CHARMM DCD:

[{ucell | shape}]
ucell Force reading of box information as unit cell (for e.g.

NAMD DCD

trajectories).

shape Force reading of box information as shape matrix.

32.10.5. trajout

trajout <filename> [<format>] [append] [nobox] [novelocity]

[notemperature] [notime] [noforce] [noreplicadim]
[parm <parmfile> | parmindex <#>] [onlyframes <range>] [title <title>]
[onlymembers <memberlist>]
[start <start>] [stop <stop>] [offset <offset>]
[ <Format Options> ]

<ﬁlename> Trajectory file to write to.
[<format>] Keyword specifying output format (see Table on page 635).

If not

specified format will be determined from extension, otherwise default to
Amber trajectory.

[append] If <filename> exists, frames will be appended to <filename>.
[nobox] Do not write box coordinates to trajectory.
[novelocity] Do not write velocities to trajectory.
[notemperature] Do not write temperature to trajectory.
[notime] Do not write time to trajectory.
[noreplicadim] Do not write replica dimensions to trajectory.
[parm <parmﬁle>] Topology filename/tag to associate with trajectory (default

first topology).

639

32. cpptraj

[parmindex <#>] Index of Topology to associate with trajectory (default 0, first

topology).

[onlyframes <range>] Write only the specified input frames to <filename>.
[title <title>] Output trajectory title.
[onlymembers <memberlist>] Ensemble processing only; only write from specified

members (starting from 0).

[start <start>] Begin output at frame <start> (1 by default).
[stop <stop>] End output at frame <stop> (last frame by default).
[offset <offset>] Skip <offset> frames between each output (1 by default).

During a run, write frames to trajectory speciﬁed by ﬁlename in speciﬁed ﬁle format (Amber trajectory if none
speciﬁed) after all Action processing has occurred. To write out trajectories within the Action queue see the
outtraj Action ( 32.11.54 on page 690). See page 635 for currently recognized output trajectory formats and their
associated keyword(s). Note that now the ﬁle type can be determined from the output extension if not speciﬁed by
a keyword. Multiple output trajectories of any format can be speciﬁed.

Frames will be written to the output trajectory when the parameter ﬁle being processed matches the

parameter ﬁle the output trajectory was set up with. So given the input:

parm top0.parm7
parm top1.parm7 [top1]
trajin input0.crd
trajin input1.crd parm [top1]
trajout output.crd parm [top1]

only frames read in from input1.crd (which is associated with top1.parm7) will be written to output.crd. The
trajectory input0.crd is associated with top0.parm7; since no output trajectory is associated with top0.parm7 no
frames will be written when processing top0.parm7/input0.crd.

If onlyframes is speciﬁed, only input frames matching the speciﬁed range will be written out. For example,

given the input:

trajin input.crd 1 10
trajout output.crd onlyframes 2,5-7

only frames 2, 5, 6, and 7 from input.crd will be written to output.crd.

32.10.5.1. Options for pdb format

[dumpq | parse | vdw] [pdbres] [pdbatom]
[pdbv3] [teradvance] [terbyres | pdbter | noter]
[model | multi] [chainid <ID>] [sg <group>]
[include_ep] [conect] [keepext] [usecol21]
[bfacdefault <#>] [occdefault <#>]
[bfacdata <set>] [occdata <set>] [bfacbyres] [occbyres]
[bfacscale] [occscale] [bfacmax <max>] [occmax <max>]
[adpdata <set>]

dumpq PQR format; write charges (in units of e-) and GB radii to occupancy and

B-factor columns respectively.

parse PQR format; write charges and PARSE radii to occupancy/B-factor columns.
vdw PQR format; write charges and vdW radii to occupancy/B-factor columns.
pdbres: Use PDB V3 residue names. Will write a default chain ID (’Z’) for each

residue if the corresponding topology does not have chain ID information.

640

32.10. Trajectory File Commands

pdbatom: Use PDB V3 atom names.
pdbv3: Use PDB V3 residue/atom names. Same as specifying ’pdbres’ and

’pdbatom’.

teradvance: Increment record (atom) number for TER records (not done by

default).

terbyres: Print TER cards based on residue sequence instead of molecules.
pdbter: Print TER cards according to original PDB TER (if available).
noter: Do not write TER cards.
model (Default) Frames will be written to a single PDB file separated by

MODEL/ENDMDL keywords.

multi Each frame will be written to a separate file with the frame # appended to

<filename>.

chainid <ID> Write PDB file with chain ID <ID>.
sg <group> Space group for CRYST1 record; only used if box coordinates written.
include_ep Include extra points.
conect Write CONECT records for all bonds.
keepext Keep filename extension; write ’<name>.<num>.<ext>’ instead (implies

’multi’).

usecol21 Use column 21 for 4-letter residue names.
bfacdefault <#> Default value to use in B-factor column (default 0.0).
occdefault <#> Default value to use in occupancy column (default 1.0).
bfacdata <set> Use data in <set> for B-factor column.
occdata <set> Use data in <set> for occupancy column.
bfacbyres If specified assume X values in B-factor data set are residue numbers.
occbyres If specified assume X values in occupancy data set are residue

numbers.

bfacscale If specified scale values in B-factor column between 0 and <bfacmax>.
occscale If specified scale values in occupancy column between 0 and <occmax>.
bfacmax <max> Max value for bfacscale.
occmax <max> Max value for occscale.
adpdata <set> Use data in <set> (e.g.

from the atomicfluct command, on

page 648) for anisotropic B-factors.

32.10.5.2. Options for Amber ASCII format:

[remdtraj] [highprecision] [mdvel|mdfrc]

remdtraj Write REMD header to trajectory that includes temperature:

<Replica> <Step> <Total_Steps> <Temperature>’.
concept of replica number, 0 is printed for <Replica>.
<Total_Steps> are set to the current frame #.

’REMD
Since cpptraj has no

<Step> and

highprecision: (EXPERT USE ONLY) Write with 8.6 precision instead of 8.3.

Note

that since the width does not change, the precision of large coords may be
lower than 6.

mdvel Write velocities instead of coordinates.
mdfrc Write forces instead of coordinates.

641

32. cpptraj

32.10.5.3. Options for Amber NetCDF format:

[remdtraj] [mdvel] [mdfrc] [mdcrd]

remdtraj Write replica temperature to trajectory.
mdvel Write only velocity information in trajectory.
mdfrc Write only force information in trajectory.
mdcrd Write coordinates to trajectory (only required with mdvel/mdfrc).

32.10.5.4. Options for Amber Restart/NetCDF Restart format:

[remdtraj] [novelocity] [notime] [time0 <initial time>] [dt <timestep>] [keepext]

remdtraj Write replica temperature to restart.

Note that this will

automatically include time in the restart file (see the time0 keyword).

time0 <initial time> Time for first frame (default 1.0).
dt <timestep> Time step between frames (default 1.0). Time is calculated as

t=(time0+frame)*dt.

keepext Keep filename extension; write ’<name>.<num>.<ext>’ instead.

32.10.5.5. Options for CHARMM COORdinates:

[keepext] [ext] [segid <segid>] [segmask <mask> <segid> ...]
keepext Keep filename extension; write ’<name>.<num>.<ext>’
ext Use ’extended’ format (default when > 99999 atoms).
segid <segid> Use <segid> as segment ID for all atoms.
segmask <mask> <segid> Use <segid> as segment ID for atoms selected by <mask>.

Can be specified more than once.

32.10.5.6. Options for CHARMM DCD:

[x64] [ucell] [veltraj]
x64 Use 8 byte block size (default 4 bytes).
ucell Write older (v21) format trajectory that stores unit cell params instead

of shape matrix.

veltraj Write velocity trajectory instead of coordinates.

32.10.5.7. Options for GROMACS TRX/XTC format:

[dt <time step>]
dt Time step tp multiply set numbers by (default 1.0).

Ignored if time already

present.

32.10.5.8. Options for mol2 format:

[single | multi] [sybyltype] [sybylatom <file>] [sybylbond <file>] [keepext]

single (Default) Frames will be written to a single Mol2 file separated by

MOLECULE keywords.

multi Each frame will be written to a separate file with the frame # appended to

<filename>.

642

32.11. Action Commands

sybyltype Convert Amber atom types (if present) to SYBYL types.

Requires

$AMBERHOME is set.

sybylatom File containing Amber to SYBYL atom type correspondance (optional).
sybylbond File containing Amber to SYBYL bond type correspondance (optional).
keepext Keep filename extension; write ’<name>.<num>.<ext>’ instead (implies

’multi’).

32.10.5.9. Options for SQM input format:

[charge <c>]

charge <c> Set total integer charge. If not specified it will be calculated

from atomic charges.

32.10.5.10. Options for XYZ format:

ftype {atomxyz|xyz} titletype {none|single|perframe} width <#> prec <#>
ftype {atomxyz|xyz} Choose either ’ATOM X Y Z’ (default) or ’X Y Z’ output format.
titletype {none|single|perframe} No title, one title (default), or title before every

frame.

width <#> Output format width.
prec <#> Output format precision.

32.11. Action Commands

Actions in cpptraj operate on frames read in by the trajin or ensemble commands one at a time and extract
derived data, modify the coordinates/topology in some way, or both. Most Actions in cpptraj function exactly the
way they do in ptraj and are backwards-compatible. Some Action commands in cpptraj have extra functionality
compared to ptraj (such as the per-residue RMSD function of the rmsd Action, or the ability to write out stripped
topologies for visualization in the strip Action), while other Actions produce slightly different output (like the
hbond/secstruct Actions).

Unlike some other command types, when an Action command is issued it is by default added to the Action
queue and is not executed until trajectory processing is started (e.g. by a run or go command). However, Actions
can be executed immediately on COORDS data sets via the crdaction command ( 32.7.3 on page 613).

When a frame is modiﬁed by an Action, it is modiﬁed for every Action that follows them during trajectory
processing. For example, given a solvated system with water residues named WAT and the following Action
commands:

rmsd R1 first :WAT out water-rmsd.dat
strip :WAT
rmsd R2 first :WAT out water-rmsd-2.dat

the ﬁrst rms command will be valid, but the second rms command will not since all residues named WAT are
removed from the state by the strip command.

Note that for commands which can use a reference mask as well as a target mask (e.g. rms, drmsd, symmrmsd,
etc.) there must be a 1 to 1 correspondence between the atoms in each mask, i.e. the number of atoms and the
ordering of selected atoms must be the same.

The following Actions are available. If an Action may modify coordinate/topology information for subsequent

Actions it is denoted with an X in the Mod column.

Command

Description

Mod

643

32. cpptraj

align
angle

areapermol
atomiccorr

atomicﬂuct, rmsf

atommap

autoimage
average
bounds

box
center

check, checkoverlap,

checkstructure
checkchirality

closest, closestwaters

Align structure to a reference.

Calculate the angle between three points.

Calculate area per molecule for molecules in a speciﬁed plane.

Calculate average correlation between motions of speciﬁed atoms.
Calculate root mean square ﬂuctuation of speciﬁed atoms/residues.

Attempt to create a map between atoms in molecules with different atom

ordering.

Automatically re-image coordinates.

Calculate average structure.

Calculate the min/max coordinates for speciﬁed atoms. Can be used to

create grid data sets.

Set or overwrite box information for frames.

Center speciﬁed coordinates to box center or onto reference structure.

Check for bad atomic overlaps or bond lengths.

Can be used to skip corrupted frames.

Report chirality around alpha carbons in amino acids (L, D).

Retain only the speciﬁed number of solvent molecules closest to speciﬁed

solute.

Assign frames into clusters based on binning of backbone dihedral angles

clusterdihedral

contacts
createcrd

createreservoir

density
diffusion
dihedral
dihrms

dihedralrms

dipole

distance

drms, drmsd
dssp, secstruct

energy

esander

ﬁlter

in amino acids.

Older version of nativecontacts, retained for backwards compatibility.

Create a COORDS data set from input frames.

Create a structure reservoir for use with reservoir REMD simulations.

Calculate density along a coordinate.

Calculate translational diffusion of molecules.
Calculate the dihedral angle using four points.

Calculate the RMSD of dihedrals to dihedrals in a reference structure.

Bin dipoles of solvent molecules in 3D grid. Not well tested, may be

obsolete.

Calculate the distance between two points.

Calculate the RMSD of distance pairs within selected atoms.

Calculate secondary structure content using the DSSP algorithm

Calculate simple bond, angle, dihedral, and non-bonded energy terms (no

PME).

Calculate energies using via SANDER; requires compilation with the

SANDER API.

Filter frames for subsequent Actions using data sets and user deﬁned

criteria.

ﬁxatomorder

ﬁximagedbonds

Fix atom ordering so that all atoms in molecules are sequential.

Fix bonds which have been split across periodic boundaries by imaging.

Perform grid inhomogenous solvation theory.

Bin selected atoms on a 3D grid.

Calculate hydrogen bonds using geometric criteria.

Re-image coordinates. The autoimage command typically provides better

results.

Calculate J-coupling values from speciﬁed dihedral angles.

Split/average frames from LES trajectories.

Calculate linear interaction energy between user-speciﬁed ligand and

surroundings.

gist
grid
hbond
image

jcoupling
lessplit

lie

644

X

X

X

X

X

X

X

lipidorder
lipidscd

makestructure

mask

matrix

minimage

molsurf

multidihedral
multivector

nastruct

nativecontacts

outtraj
pairdist
pairwise
principal
projection

pucker

radgyr, rog
radial, rdf

randomizeions
replicatecell

rms, rmsd

rotate

runavg,

runningaverage

scale

setvelocity

spam

stfcdiffusion

strip
surf

symmrmsd
temperature

time

trans, translate

unstrip

32.11. Action Commands

Calculate order parameters for lipids in planar membranes.

Calculate lipid order parameters SCD (|<P2>|) for lipid chains.

Automatically identiﬁes lipids.

Modify structure by applying dihedral values to speciﬁed residues.

X

Print the results of selection by speciﬁed atom mask. Good for

distnace-based masks.

Calculate a matrix of the speciﬁed type from input coordinates.

Calculate minimum non-self imaged distance between atoms in speciﬁed

masks.

Calculate Connolly surface area of speciﬁed atoms. Cannot do partial

surface areas.

Calculate multiple dihedral angles of speciﬁed/given types.

Calculate multiple vectors between speciﬁed atoms.

Perform nucelic acid structure analysis.

Calculate native contacts within a region or between two regions using a

given reference.

Can also be used to get min/max distances between groups of atoms.

Write frames to a trajectory ﬁle within a list of Actions.

Calculate pair distribution function.

Calculate pair-wise non-bonded energies.

Calculate and optionally align system along principal axes.

Project coordinates along given eigenvectors.
Calculate ring pucker using ﬁve or six points.

Calculate radius of gyration (and optionally tensor) for speciﬁed atoms.

Calculate radial distribution function.

Swap speciﬁed ions with randomly selected solvent molecules.

Replicate unit cell in speciﬁed (or all) directions for specﬁed atoms and

write to trajectory.

Perform best ﬁt of coordinates to reference and calculate coordinate

RMSD.

Fitting can be disabled.

Rotate the system around X/Y/Z axes, a speciﬁed axis, or via given

rotation matrices.

Calculate the running average of coordinates over speciﬁed window size.

Scale coordinates in X/Y/Z directions by speciﬁed factors.

Set velocities for speciﬁed atoms using Maxwellian distribution based on

given temperature.

SPAM method for estimating relative free energies of waters in hydration

shell around proteins.

Alternative translational diffusion calculation which can calculate

diffusion in speciﬁed regions.

Remove speciﬁed atoms from the system.

Calculate the LCPO surface area of speciﬁed atoms. Can do partial

surface areas.

Calculate symmetry-corrected RMSD.

Calculate system temperature using velocities of speciﬁed atoms.

Add/remove/modify time information in frames.

Translate speciﬁed atoms by speciﬁed amounts in X/Y/Z directions.

Undo all previous strip Action commands.

X

X

X

X

X

X

X

X

X
X

645

32. cpptraj

unwrap

vector

velocityautocorr

volmap

volume
watershell

xtalsymm

32.11.1. align

Reverse of image; unwrap selected atoms so they have continuous

trajectories.

Calculate various types of vector quantities.
Calculate velocity autocorrelation function.

Create volumetric map for speciﬁed coordinates; similar to grid but takes

into account atomic radii. Similar to VMD volmap.

Calculate unit cell volume.

Calculate the number of waters in the ﬁrst and second solvation shells

based on distance critera.

Re-image coordinates based on crystal space group symmetry operations

and asymmetric unit volume.

X

X

align <mask> [<refmask>] [move <mask>] [mass]

[ first | reference | ref <name> | refindex <#> | previous |

reftraj <name> [parm <name> | parmindex <#>] ]

<mask> Target atoms to fit.
[<refmask>] Reference atoms to fit (default is target mask).
[move <mask>] Atoms to move when aligning (default is target mask).
[mass] Mass-weight the fit.
Reference keywords:

ﬁrst Use the first trajectory frame processed as reference.
reference Use the first previously read in reference structure (refindex 0).
ref <name> Use previously read in reference structure specified by filename/tag.
reﬁndex <#> Use previously read in reference structure specified by <#> (based

on order read in).

previous Use frame prior to current frame as reference.
reftraj <name> Use frames from COORDS set <name> or read in from trajectory file

<name> as references. Each frame from <name> is used in turn, so that
frame 1 is compared to frame 1 from <name>, frame 2 is compared to frame 2
from <name> and so on. If <trajname> runs out of frames before processing
is complete, the last frame of <trajname> continues to be used as the
reference.
parm <parmname> | parmindex <#> If reftraj specifies a trajectory file,

associate it with specified topology; if not specified the first
topology is used.

Align structure using speciﬁed <mask> onto reference. If ’move’ is speciﬁed, only move atoms in the move mask.

32.11.2. angle

angle [<dataset name>] <mask1> <mask2> <mask3> [out <filename>] [mass]

[<dataset name>] Output data set name.
<maskX> Three atom masks selecting atom(s) to calculate angle for.

646

[out <ﬁlename>] Output file name.
[mass] Use center of mass of atoms in <maskX> instead of geometric center.

Calculate angle (in degrees) between atoms in <mask1>, <mask2>, and <mask3>. For example, to calculate the
angle between the ﬁrst three atoms in the system:

32.11. Action Commands

angle A123 @1 @2 @3 out A123.agr

32.11.3. areapermol

areapermol [<name>] {[<mask1>] [nlayers <#>] | nmols <#>} [out <filename>]

[{xy | xz | yz}]

[<name>] Data set name.
[<mask1>] Atom mask for selecting molecules.
selected the whole molecule is selected.

If any atom in a molecule is

[nlayers <#>] Number of layers of molecules.

Total number of molecules used will

be # molecules divided by # layers.

[nmols <#>] If <mask1> is not specified, the number of molecules to use when

calculating area per molecule.

[out <ﬁlename>] Output file name.
[{xy|xz|yz}] Cross-section of box to calculate area of.

Default is X-Y.

Calculate area per molecule as Area / # molecules. The area is determined from the speciﬁed cross-section of the
box (X-Y by default). Currently the calculation is only guaranteed to work properly with orthorhombic unit cells.
For example, to get the area per molecule of residues named “OL” which are arranged in 2 layers:

areapermol OL_area :OL nlayers 2 out apm.dat

32.11.4. atomiccorr

atomiccorr [<mask>] out <filename> [cut <cutoff>] [min <min spacing>]

[byatom | byres]

<mask> Atoms to calculate motion vectors for.
out <ﬁlename> File to write results to.
cut <cutoff> Only print correlations with absolute value greater than <cutoff>.
min <min spacing> Only calculate correlations for motion vectors spaced <min

spacing> apart.

byatom Default; calculate atomic motion vectors.
byres Calculate motion vectors for entire residues (selected atoms in residues

only).

Calculate average correlations between the motion of atoms in <mask>. For each frame, a motion vector is cal-
culated for each selected atom from its previous position to its current position. For each pair of motion vectors
Va and Vb, the average correlation between those vectors is calculated as the average of the dot product of those
vectors over all N frames.

AvgCorr(a,b) = ∑Va(i)·Vb(i)

N

The value of AvgCorr can range from 1.0 (correlated) to 0.0 (no correlation) to -1.0 (anti-correlated). For

example, to calculate the correlation of motion vectors between residues 1 to 13, writing to a Gnuplot-readable
formatted ﬁle:

atomiccorr :1-13 out acorr.gnu byres

647

32. cpptraj

32.11.5. atomicﬂuct | rmsf

atomicfluct [<name>] [out <filename>] [<mask>] [byres | byatom | bymask]

[bfactor] [calcadp [adpout <file>]]
[start <start>] [stop <stop>] [offset <offset>]

<name> Output data set name.
out <ﬁlename> Write data to file named <filename>
[<mask>] Calculate fluctuations for atoms in <mask> (all if not specified).
byres Output the average (mass-weighted) fluctuation by residue.
bymask Output the average (mass-weighted) fluctuation for all atoms in <mask>.
byatom (default) Output the fluctuation by atom.
[bfactor] Calculate atomic positional fluctuations squared and weight by 8
this is similar but not necessarily equivalent to the calculation of
crystallographic B-factors.

3π2;

[calcadp [adpout <ﬁle>]] Calculate anisotropic displacement parameters and

optionally output them to <file>.

[<start>] Frame to begin calculation at (default 1).
[<stop>] Frame to end calculation at (default last).
[<offset>] Frames to skip between calculations (default 1).

DataSets created
<name> Hold atomic fluctuations.
<name>[ADP] Hold anisotropic displacement parameters if ’calcadp’ specified.

Compute the atomic positional ﬂuctuations (also referred to as root-mean-square ﬂuctuations, RMSF) for atoms
speciﬁed in the <mask>. The RMSF of a given atom i is calculated as:

(cid:114)(cid:68)
(xi −(cid:104)xi(cid:105))2(cid:69)

RMSFi =

where x denotes atomic positions and the averages are over all input frames.
Note that RMS ﬁtting is not done implicitly.

If you want ﬂuctuations without rotations or translations (for
example to the average structure), perform an RMS ﬁt to the average structure (best) or the ﬁrst structure (see
rmsd) prior to this calculation. The units are (Å) for RMSF or Å2 × 8

3π2 if bfactor is speciﬁed.

If byres or bymask are speciﬁed, the mass-weighted average of atomic ﬂuctuations of each atom for either each

residue or the entire mask will be calculated respectively:

(cid:104)Fluct(cid:105) = ∑AtomFlucti∗Massi

∑Massi

If calcadp is speciﬁed, anisotropic displacement factors for atoms will be calculated and written to the ﬁle
speciﬁed by adpout (or STDOUT if not speciﬁed) using PDB ANISOU record format. The displacement factors
will be saved to a data set. Note that calcadp automatically implies bfactor.

With cpptraj it is possible to perform coordinate averaging, the ﬁt to average coordinates, and the atomic

ﬂuctuation calculation in a single execution like so:

parm myparm.parm7
trajin mytrajectory.crd
rms first
average crdset MyAvg
run
rms ref MyAvg
atomicfluct out fluct.agr

648

32.11. Action Commands

To write the mass-weighted B-factors for the protein backbone atoms C, CA, and N, averaged by residue use the
command:

atomicfluct out back.agr @C,CA,N byres bfactor

To write the RMSF or atomic positional ﬂuctuations of the same atoms, use the command:

atomicfluct out backbone-atoms.agr @C,CA,N

To write a PDB of averaged coordinates (after ﬁtting to the ﬁrst frame) with both B-factors and anisotropic
temperature factors:

parm myparm.parm7
trajin mytraj.nc
rms first
average crdset MyAvg
atomicfluct MyFluct calcadp
run
crdout MyAvg mypdb.pdb adpdata MyFluct[ADP] bfacdata MyFluct

32.11.6. atommap

atommap <target> <reference> [mapout <filename>] [maponly]

[rmsfit [ rmsout <rmsout> ]]

<target> Reference structure whose atoms will be remapped.
<reference> Reference structure that <target> should be mapped to.
mapout <ﬁlename> Write atom map to <filename> with format:

TargetAtomNumber TargetAtomName ReferenceAtomNumber ReferenceAtomName
Target atoms that cannot be mapped to a reference atom are denoted “--”.

maponly Write atom map but do not reorder atoms.
rmsﬁt Any input frames using the same topology as <target> will be RMS fit to

<reference> using whatever atoms could be mapped.
rmsout <rmsout> If rmsfit specified, write resulting RMSDs to <rmsout>.

Attempt to map the atoms of <target> to those of <reference> based on structural similarity. This is useful e.g.
when there are two ﬁles containing the same structure but with different atom names or atom ordering. Both
<target> and <reference> need to have been read in with a previous reference command. The state will then be
modiﬁed so that any trajectory read in with the same parameter ﬁle as <target> will have its atoms mapped (i.e.
reordered) to match those of <reference>. If the number of atoms that can be mapped in <target> are less than
those in <reference>, the reference structure speciﬁed by <reference> will be modiﬁed to include only mapped
atoms; this is useful if for example the reference structure is protonated with respect to the target. The rmsﬁt
keyword is useful in cases where the atom mapping will not be complete (e.g. two ligands with the same scaffold
but different substituents).

For example, say you have the same ligand structure in two ﬁles, Ref.mol2 and Lig.mol2, but the atom ordering

in each ﬁle is different. To map the atoms in Lig.mol2 onto those of Ref.mol2 so that Lig.mol2 has the same
ordering as Ref.mol2:

parm Lig.mol2
reference Lig.mol2
parm Ref.mol2
reference Ref.mol2 parmindex 1
atommap Lig.mol2 Ref.mol2 mapout atommap.dat
trajin Lig.mol2
trajout Lig.reordered.mol2 mol2

649

32. cpptraj

32.11.7. autoimage

autoimage [<mask> | anchor <mask> [fixed <mask>] [mobile <mask>]]

[origin] [firstatom] [familiar | triclinic]

[<mask> | anchor <mask>] Atoms to image around; this is the region that will be

centered. Default is the entire first molecule.

[ﬁxed <mask>] Molecules that should remain ’fixed’ to the anchor region; default

is all non-ion/non-solvent molecules.

[mobile <mask>] Molecules that can be freely imaged; default is all ion/solvent

molecules.

[origin] Center anchor region at the origin; if not specified, center at box

center.

[ﬁrstatom] Image based on molecule first atom; default is to image by molecule

center of mass.

[familiar] Image to familiar truncated-octahedral shape; this is on by default if

the original cell is truncated octahedron.

[triclinic] Force general triclinic imaging.

Automatically center and image (by molecule) a trajectory with periodic boundaries. For most cases just speci-
fying ’autoimage’ alone is sufﬁcient. The atoms of the ’anchor’ region (default the entire ﬁrst molecule) will be
centered; all ’ﬁxed’ molecules will be imaged only if imaging brings them closer to the ’anchor’ molecule (default
for ’ﬁxed’ molecules is all non-solvent non-ion molecules). All other molecules (referred to as ’mobile’) will be
imaged freely.

The autoimage command works for the majority of systems; however, for very densely packed systems the
default anchor (entire ﬁrst molecule) may not be appropriate. In these cases, it is recommended to choose as the
anchor a small region which should lie near the center of your system. For example, in a protein dimer system one
could choose a single residue that is near the center of the interface between the two monomers.

32.11.8. average

average {crdset <set name> | <filename>} [<mask>]

[start <start>] [stop <stop>] [offset <offset>]
[Trajout Args]

<ﬁlename> If specified, write averaged coordinates to <filename> (not

compatible with crdset).

crdset <set name> If specified, save averaged coordinates to COORDS set <set

name> (not compatible with <filename>).

[<mask>] Average coordinates in <mask> (all atoms if not specified).
[<start>] Frame to begin calculation at (default 1).
[<stop>] Frame to end calculation at (default last).
[<offset>] Frames to skip between calculations (default 1).
[Trajout args] Output trajectory format argument(s) (default Amber Trajectory).

Calculate the average of input coordinates and write out to ﬁle named <ﬁlename> or save to COORDS set named
<set name> in any trajectory format cpptraj recognizes (Amber Trajectory if not speciﬁed). If the number of
atoms in <mask> are less than the total number of atoms, the topology will be stripped to match <mask>.

Note that since coordinates are being averaged over many frames, resulting structures may appear distorted. For
example, if one averages the coordinates of a freely rotating methyl group the average position of the hydrogen

650

32.11. Action Commands

atoms will be close to the center of rotation. Also note that typically one will want to remove global rotational and
translation movement prior to this command by using e.g. the rms ( 32.11.64 on page 696) command.

Any arguments that are valid for the trajout command ( 32.10.5 on page 639) can be passed to this command in
order to control the format of the output coordinates. For example, to write out a PDB ﬁle containing the averaged
coordinates over all frames:

average test.pdb pdb

To write out a mol2 ﬁle containing only the averaged coordinates of residues 1 to 10 for frames 1 to 100:

average test.mol2 mol2 start 1 stop 100 :1-10

To create an average structure of atoms named CA and then use it as a reference for an rms command in a
subsequent run:

trajin Input.nc
average crdset MyAvg @CA
run
rms ref MyAvg @CA out RmsToAvg.dat
run

32.11.9. avgcoord

This command is deprecated. Use ’vector center’ (optionally with keyword ’magnitude’) instead.

32.11.10. bounds

bounds [<mask>] [out <filename>]

[dx <dx> [dy <dy>] [dz <dz>] name <gridname> [offset <bin offset>]]

[<mask>] Mask of atoms to determine bounds of.
[out <ﬁlename>] File to write bounds to (default STDOUT if not specified).
[dx <dx> [dy <dy>] [dz <dz>]] Triggers creation of a grid data set from bounds.
If only dx is

Spacings of generated grid in the X, Y and Z directions.
specified <dx> will be used for <dy> and <dz> as well.

[name <gridname>] Name of generated data sets.
[offset <bin offset>] Number of bins to add/subtract in each direction to generated

grid.

DataSets Generated

<gridname> The 3D grid (only if ’dx’ etc specified).
<gridname>[xmin] The minimum x coordinate encountered.
<gridname>[xmax] The maximum x coordinate encountered.
<gridname>[ymin] The minimum y coordinate encountered.
<gridname>[ymax] The maximum y coordinate encountered.
<gridname>[zmin] The minimum z coordinate encountered.
<gridname>[zmax] The maximum z coordinate encountered.

the max/min X/Y/Z coordinates) of atoms in <mask> and write to <ﬁlename>
Calculate the boundaries (i.e.
(STDOUT if not speciﬁed). Useful for determining dimensions for the grid command, and can be used to generate
a grid data set that can be used by grid (see 32.11.36 on page 670).

651

32. cpptraj

32.11.11. box

box [x <xval>] [y <yval>] [z <zval>] [alpha <a>] [beta <b>] [gamma <g>]

[nobox] [truncoct]

[x <xval>] [y <yval>] [z <zval>] Change box length(s) to specified value(s).
[alpha <a>] [beta <b>] [gamma <g>] Change box angle(s) to specified value(s).
[nobox] Remove any existing box information.
[truncoct] Set box angles to truncated octahedron.

Modify box information during trajectory processing. Note that this will permanently modify the box information
for topology ﬁles during trajectory processing as well. It is possible to modify any number of the box parameters
(e.g. only the Z length can be modiﬁed if desired while leaving all other parameters intact).

32.11.12. center

center [<mask>] [origin] [mass]

[ reference | ref <name> | refindex <#> [<refmask>]]

[<mask>] Center based on atoms in mask; default is all atoms.
[origin] Center to origin (0, 0, 0); default is center to box center (X/2, Y/2,

Z/2).

[mass] Use center of mass instead of geometric center.
[reference | ref <name> | reﬁndex <#> [<refmask]] Center using coordinates in specified

reference structure selected by <refmask> (<mask> if not specified.

Move all atoms so that the center of the atoms in <mask> is centered at the speciﬁed location: box center (default),
coordinate origin, or reference coordinates.

For example, to move all coordinates so that the center of mass of residue 1 is at the center of the box:

center :1 mass

32.11.13. check | checkoverlap | checkstructure

check [<mask>] [around <mask2>] [reportfile <report>] [noimage] [skipbadframes]

[offset <offset>] [cut <cut>] [nobondcheck] [silent]

[<mask>] Check structure of atoms in <mask> (all if not specified).
[around <mask2>] If specified, only check for problems between atoms in <mask>

and atoms in <mask2>.

[reportﬁle <report>] Write any problems found to <report> (STDOUT if not

specified).

[noimage] Do not image distances.
[skipbadframes] If errors are encountered for a frame, subsequent

actions/trajectory output will be skipped.

[offset <offset>] Report bond lengths greater than the equilibrium value plus

<offset> (default 1.0 Å)

[cut <cut>] Report atoms closer than <cut> (default 0.8 Å).
[nobondcheck] Check overlaps only.
[silent] Do not print information for bad frames - useful in conjunction with the

skipbadframes option.

652

32.11. Action Commands

Check the structure and report problems related to atomic overlap/unusual bond length. Problems are reported
when any two atoms in the mask are closer than <cut>. If bonds are being checked then bond lengths greater than
their equilibrium value + <offset> are reported as well. This command can also be used to skip corrupted frames
in a trajectory during processing. For example, if this message is encountered:

Warning: Frame 10 coords 1 & 2 overlap at origin; may be corrupt.

One could use check so that e.g. a subsequent distance command is not processed for bad frames:

check @1,2 skipbadframes silent
distance d1 :1 :10

Usually frame corruption can be detected using only a few atoms, but this may not catch all types of corruption.
The more atoms that are used the better the corruption detection will be, but the slower it will be to process the
command. Typically a good procedure to follow when corruption is suspected is to run check using all important
atoms (e.g. all solute heavy atoms) with the skipbadframes keyword followed by a trajout command to write all
non-corrupt frames, for example:

trajin corrupted.crd
check :1-13 skipbadframes silent
trajout fixed.corrupted.nc

32.11.14. checkchirality

checkchirality [<name>] [<mask>] [out <filename>]

[<name>] Data set name.
[<mask>] Atoms to check.
[out <ﬁlename>] File to write results to.

DataSet Aspects:

[L] Number of frames ’L’ for each residue.
[D] Number of frames ’D’ for each residue.

Check the chirality around the alpha carbon in amino acid residues selected by <mask>. Note that cpptraj expects
atom names to correspond to the PDB V3 standard: N, CA, C, CB. For each residue, the number of frames in
which the amino acid is ’L’ or ’D’ will be recorded. For example, to check the chirality of all amino acids in a
system and write to a ﬁle named chiral.dat with data set name DPDP:

checkchirality DPDP out chiral.dat

Output will have format similar to:

#Res

2.000

DPDP[L] DPDP[D]
0

100

So in this example residue 2 was ’L’ for 100 frames and ’D’ for 0 frames.

32.11.15. closest | closestwaters

closest <# to keep> <mask> [solventmask <solvent mask>] [noimage]

[first | oxygen] [center] [closestout <filename> [name <setname>]]
[outprefix <parmprefix>] [parmout <file>]

<# to keep> Number of solvent molecules to keep around <mask>
<mask> Mask of atoms to search for closest waters around.

653

32. cpptraj

[solventmask <solvent mask>] Optional mask for selecting solvent atoms.

If not

specified, atoms in all molecules marked as “solvent” will be used.

[noimage] Do not perform imaging; only recommended if trajectory has previously

been imaged.

[ﬁrst | oxygen] Calculate distances between all atoms in <mask> and the first atom
of solvent only (recommended for standard water models as it will increase
speed of calculation).

[center] Search for waters closest to geometric center of <mask> instead of each

atom in <mask>.

[closestout <ﬁlename>] Write information on the closest solvent molecules to

<filename>.

[outpreﬁx <preﬁx>] Write corresponding topology to file with name prefix

<prefix>.

[parmout <ﬁle>] Write corresponding topology to file with name <file>.
DataSet Aspects:

[Frame] Frame number.
[Mol] Original solvent molecule number.
[Dist] Solvent molecule distance in Å.
[FirstAtm] First atom number of original solvent molecule.

Similar to the strip command, but modify coordinate frame and topology by keeping only the speciﬁed number
of closest solvent molecules to the region speciﬁed by the given mask. Solvent molecules can be determined
automatically by cpptraj (by default residues named WAT, HOH, or TIP3), can be speciﬁed prior via the solvent
command ( 32.9.19 on page 634), or can be selected by solventmask.

The format of the closestout ﬁle is:

Frame

Molecule

Distance

FirstAtom#

For example, to obtain the 10 closest waters to residues 1-268 by distance to the ﬁrst atom of the waters, write out
which waters were closest for each frame to a ﬁle called “closestmols.dat”, and write out the stripped topology
with preﬁx “closest” containing only the solute and 10 waters:

closest 10 :1-268 first closestout closestmols.dat outprefix closest

As of version 17 this command is CUDA-enabled in CUDA versions of CPPTRAJ.

32.11.16. cluster

Although the ’cluster’ command can still be speciﬁed as an action, it is now considered an analysis. See 32.12.4

on page 716.

32.11.17. clusterdihedral

clusterdihedral [phibins <N>] [psibins <M>] [out <outfile>]

[dihedralfile <dfile> | <mask>]
[framefile <framefile>] [clusterinfo <infofile>]
[clustervtime <cvtfile>] [cut <CUT>]

Cluster frames in a trajectory using dihedral angles. To deﬁne which dihedral angles will be used for clustering
either an atom mask or an input ﬁle speciﬁed by the dihedralﬁle keyword should be used. If dihedral ﬁle is used,
each line in the ﬁle should contain a dihedral to be binned with format:

654

ATOM#1 ATOM#2 ATOM#3 ATOM#4 #BINS

32.11. Action Commands

where the ATOM arguments are the atom numbers (starting from 1) deﬁning the dihedral and #BINS is the number
of bins to be used (so if #BINS=10 the width of each bin will be 36º). If an atom mask is speciﬁed, only protein
backbone dihedrals (Phi and Psi deﬁned using atom names C-N-CA-C and N-CA-C-N) within the mask will be
used, with the bin sizes speciﬁed by the phibins and psibins keywords (default for each is 10 bins).

Output will either be written to STDOUT or the ﬁle speciﬁed by the out keyword. First, information about

which dihedrals were clustered will be printed. Then the number of clusters will be printed, followed by detailed
information of each cluster. The clusters are sorted from most populated to least populated. Each cluster line has
format

Cluster CLUSTERNUM CLUSTERPOP [ dihedral1bin, dihedral2bin ... dihedralNbin ]

followed by a list of frame numbers that belong to that cluster. If a cutoff is speciﬁed by cut, only clusters with
population greater than CUT will be printed.

If speciﬁed by the clustervtime keyword, the number of clusters for each frame will be printed to <cvtﬁle>. If

speciﬁed by the frameﬁle keyword, a ﬁle containing cluster information for each frame will be written with
format

Frame CLUSTERNUM CLUSTERSIZE DIHEDRALBINID

where DIHEDRALBINID is a number that identiﬁes the unique combination of dihedral bins this cluster belongs
to (speciﬁcally it is a 3*number-of-dihedral-characters long number composed of the individual dihedral bins).

If speciﬁed by the clusterinfo keyword, a ﬁle containing information on each dihedral and each cluster will be

printed. This ﬁle can be read by SANDER for use with REMD with a structure reservoir (-rremd=3). The ﬁle,
which is essentially a simpliﬁed version of the main output ﬁle, has the following format:

#DIHEDRALS
dihedral1_atom1 dihedral1_atom2 dihedral1_atom3 dihedral1_atom4
...
#CLUSTERS
CLUSTERNUM1 CLUSTERSIZE1 DIHEDRALBINID1
...

32.11.18. contacts

contacts [ first | reference | ref <ref> | refindex <#> ] [byresidue]

[out <filename>] [time <interval>] [distance <cutoff>] [<mask>]

NOTE: Users are encouraged to try the nativecontacts command ( on page 687), an update version of this com-
mand.

For each atom given in mask, calculate the number of other atoms (contacts) within the distance cutoff. The
default cutoff is 7.0 A. Only atoms in mask are potential interaction partners (e.g., a mask @CA will evaluate only
contacts between CA atoms). The results are dumped to ﬁlename if the keyword “out” is speciﬁed. Thereby,
the time between snapshots is taken to be interval. In addition to the number of overall contacts, the number of
native contacts is also determined. Native contacts are those that have been found either in the ﬁrst snapshot of
the trajectory (if the keyword “first” is speciﬁed) or in a reference structure (if the keyword “reference” is
speciﬁed). Finally, if the keyword “byresidue” is provided, results are output on a per-residue basis for each
snapshot, whereby the number of native contacts is written to ﬁlename.native.

32.11.19. createcrd

createcrd [<name>] [ parm <name> | parmindex <#> ]

655

32. cpptraj

This command creates a COORDS data set named <name> using trajectory frames that are associated with the
speciﬁed topology.

For example, to save frames that have been previously RMS-ﬁt to a reference structure into a COORDS set

named MyCrd you would use the input:

rms reference :1-12@CA
createcrd MyCrd
strip :6-8

Note that here the strip command will have no effect on the coordinates saved in MyCrd since it occurs after the
createcrd command.

32.11.20. createreservoir

createreservoir <filename> ene <energy data set> [bin <cluster bin data set>]

temp0 <temp0> iseed <iseed> [velocity]
[parm <parmfile> | parmindex <#>] [title <title>]

<ﬁlename> File name of the reservoir to create.
ene <energy data set> Data set with energies corresponding to frames.
[bin <cluster bin data set>] Data set with bin numbers (for RREMD=3).
temp0 <temp0> Reservoir temperature.
iseed <iseed> Reservoir random number seed.
[velocity] Include velocities in the reservoir.
[parm <parmﬁle> | parmindex <#>] Associated topology.
[title <title>] Reservoir title.

Create structure reservoir for use with reservoir REMD simulations using energies in <energy data set>, temper-
ature <temp0> and random seed <iseed> Include velocities if [velocity] is speciﬁed. If <cluster bin data set> is
speciﬁed from e.g. a previous ’clusterdihedral’ command, the reservoir can be used for non-Boltzmann reservoir
REMD (rremd==3).

32.11.21. density

density [out <filename>]

[ <mask1> ... <maskN> [name <set name>] [delta <resolution>] [{x|y|z}]

[{number|mass|charge|electron}] [{bincenter|binedge}] ]

[out <ﬁlename>] Output file for histogram (relative distances vs.

densities for

each mask) or total density.

[name <set name>] Output data set name.
<mask1> ... <maskN> Arbitrary number of masks for atom selection; a dataset is

created and the output will contain entries for each mask.
[delta <resolution>] Resolution, i.e. determines number of slices (i.e.

histogram bins). (default 0.25 Å)

[{x|y|z}] Coordinate for density calculation. (default z)
[{number|mass|charge|electron}] Number, mass, partial charge (q) or electron

(Ne - q) density. Electron density will be converted to e-/Å3 by
dividing the average area spanned by the other two dimensions.
(default number)

[{bincenter|binedge}] Determine whether histogram bin coordinates will be

based on bin center (default) or bin edges.

656

32.11. Action Commands

DataSet Aspects:
[avg] Average density over coordinate.
[sd] Standard deviation of density over coordinate.

If no arguments are speciﬁed, calculate the total system density. Otherwise, calculate speciﬁed density along the
given axis for atoms in speciﬁed mask(s). Defaults are shown in parentheses above. The format of the ﬁle is as
follows. Comments are lines starting with ’#’ or empty lines. All other lines must contain the atom type followed
by an integer number for the electron number. Entries must be separated by spaces or ’=’. Example input:

density out number_density.dat number delta 0.25 ":POPC@P1" ":POPC@N" \

":POPC@C2" ":POPC"

density out mass_density.dat mass delta 0.25 ":POPC@P1" ":POPC@N" \

":POPC@C2" ":POPC"

density out charge_density.dat charge delta 0.25 ":POPC@P1" ":POPC@N" \

":POPC@C2" ":POPC"

density out electron_density.dat electron delta 0.25 efile Nelec.in \

":POPC@P1" ":POPC@N" ":POPC@C2" ":POPC" ":TIP3" \
":POPC | :TIP3" "*"

density out ion_density.dat number delta 0.25 ":SOD" ":CLA"

See also $AMBERHOME/AmberTools/test/cpptraj/Test_Density.

32.11.22. diffusion

Note that although the syntax for diffusion has changed as of version 16, the old syntax is still supported.

diffusion [{out <filename> | separateout <suffix>}] [time <time per frame>] [noimage]

[<mask>] [<set name>] [individual] [diffout <filename>] [nocalc]

[out <ﬁlename>] Write mean-square displacement (MSD) data set output to file

specified by <filename>.

[separateout <sufﬁx>] Write each MSD data set type to files with suffix <suffix>;

see description below.

[time <time_per_frame>] Time in-between each coordinate frame in ps; default is

1.0.

[noimage] If specified do not perform imaging.
should be unwrapped prior to this command.

If this is specified coordinates

[<mask>] Mask of atoms to calculate diffusion for; default all atoms.
[<set name>] MSD data set name.
[individual] Write diffusion for each individual atom as well as average diffusion

for atoms in mask.

[diffout <ﬁlename>] Write diffusion contants calculated from fits of MSD data sets

to <filename>.

[nocalc] Do not calculate diffusion constants.

DataSet Aspects:
[X] MSD(s) in the X direction.
[Y] MSD(s) in the Y direction.
[Z] MSD(s) in the Z direction.
[R] Overall MSD(s).

657

32. cpptraj

[A] Overall displacement(s).
[D] Diffusion constants.
[Label] Diffusion constant lablels.
[Slope] Linear regression slopes.
[Intercept] Linear refression Y-intercepts.
[Corr] Linear regression correlation coefficients.

Compute mean square displacement (MSD) plots (using distance traveled from initial position) for the atoms in
<mask>. By default only the diffusion averaged over all atoms in <mask> is calculated; if individual is speciﬁed
diffusion for individual atoms is calculated as well.

In order to correctly calculate diffusion molecules should take continuous paths, so imaging of atoms is autoimat-
ically performed. If the trajectory is already unwrapped (or the unwrap command is used prior to this command)
the noimage keyword can be used.

The following types of displacements are calculated.

If separateout is specﬁed the following ﬁles will be

created:
x_<sufﬁx> Mean square displacement(s) in the X direction (in Å2/ps).

y_<sufﬁx> Mean square displacement(s) in the Y direction (in Å2/ps).

z_<sufﬁx> Mean square displacement(s) in the Z direction (in Å2/ps).

r_<sufﬁx> Overall mean square displacement(s) (in Å2/ps).

a_<sufﬁx> Total distance traveled (in Å/ps).
The diffusion coefﬁcient D can be calculated using the Einstein relation:

2nD = lim
t→∞

MSD

t

Where n is the number of dimensions; for overall MSD n = 3, for single dimension MSD (e.g. X) n = 1, etc.
Unless nocalc is speciﬁed, the diffusion constant is calculated automatically from MSD data sets (and written to
the ﬁle speciﬁed by diffout) in the following manner. The slope the plot of MSD versus time is obtained via linear
regression. To convert from units of Å2/ps to 1x10-5 cm2/s, the slope is multiplied by 10.0/(2n). Both the calculated
diffusion constants as well as the results of the ﬁt are reported.

Due to the fact that diffusion is currently calculated from initial positions only, diffusion calculated for small
numbers of atoms will be inherently stochastic, so the results are most sensible when averaged over many atoms;
for example, the diffusion of water should be calculated using all waters in the system.

For example, to calculate the diffusion of water in a system:

diffusion :WAT@O out WAT_O.agr WAT_O diffout DC.dat

32.11.23. dihedral

dihedral [<name>] <mask1> <mask2> <mask3> <mask4> [out <filename>] [mass]

[type {alpha|beta|gamma|delta|epsilon|zeta|chi|c2p|h1p|phi|psi|omega|pchi}]
[range360]

[<name>] Output data set name.
<maskX> Four atom masks selecting atom(s) to calculate dihedral for.
[out <ﬁlename>] Output file name.
[mass] Use center of mass of atoms in <maskX>; default is geometric center.
[range360] Output dihedral angle values from 0 to 360 degrees instead of -180 to

180 degrees.

658

32.11. Action Commands

[type <type>] Label dihedral as <type> for use with statistics analysis; note

’chi’ is nucleic acid chi and ’pchi’ is protein chi.

Calculate dihedral angle (in degrees) between the planes deﬁned by atoms in <mask1>, <mask2>, <mask3> and
<mask2>, <mask3>, <mask4>. To calculate multiple dihedral angles see the multidihedral command on page 683.

32.11.24. dihedralrms | dihrms

dihedralrms [<name>] <dihedral types> [out <file>]

[ first | reference | ref <name> | refindex <#> | previous |

reftraj <name> [parm <name> | parmindex <#>] ]

[dihtype <name>:<a0>:<a1>:<a2>:<a3>[:<offset>] ...]

[tgtrange <range> [refrange <range>]]

[<name>] Output data set name.
<dihedral types> Dihedral types to look for. Note that chip is ’protein chi’,

chin is ’nucleic chi’.

[out <ﬁlename>] Output file name.
[dihtype <name>:<a0>:<a1>:<a2>:<a3>[:<offset>] Search for a custom dihedral type

called <name> using atom names <a0>, <a1>, <a2>, and <a3>.
Offset: -2=<a0><a1> in previous res, -1=<a0> in previous res, 0=All <aX>
in single res, 1=<a3> in next res, 2=<a2><a3> in next res.
[tgtrange <range>] Residue range to look for target dihedrals in.

Default is all

solute residues.

[refrange <range>] Residues range to look for reference dihedrals in.

If not

specified, use target range.

Calculate RMSD of selected dihedrals to dihedrals in a reference structure. See the multidihedral command syntax
on page 683 for a list of all available dihedral types.

32.11.25. dihedralscan

This command has been replaced by permutedihedrals; see 32.7.8 on page 614.

32.11.26. dipole

dipole <filename> {data <dsname> | <nx> <dx> <ny> <dy> <nz> <dz>

[gridcenter <cx> <cy> <cz>]}

[box|origin|center <mask>] [negative] [name <gridname>]

<mask1> {origin | box} [max <max_percent>]

NOTE: This command is not well-tested and may be obsolete.

Same as grid (see 32.11.36 on page 670 below) except that dipoles of the solvent molecules are binned. The
output ﬁle format is for Chris Bayly’s discern delegate program that comes with Midas/Plus. Consult the code in
Action_Dipole.cpp for more information.

32.11.27. distance

distance [<name>] <mask1> [<mask2>] [point <X> <Y> <Z>]

[ reference | ref <name> | refindex <#> ]
[out <filename>] [geom] [noimage] [type noe]

Options for ’type noe’:

[bound <lower> bound <upper>] [rexp <expected>] [noe_strong] [noe_medium] [noe_weak]

659

32. cpptraj

[<name>] Output data set name
<mask1> Atom mask selecting atom(s) to calculate distance between.
<mask2> If specified, second atom mask selection atom(s) to calculate distance

from <mask1>.

point <X> <Y> <Z> If specified instead of second mask, calculate distance between

<mask1> and specified XYZ coordinates.

reference | ref <name> | reﬁndex <#> If specified, calculate distance between
<mask1> in each input frame and <mask2> in the specified reference.

[out <ﬁlename>] Output filename.
[geom] Use geometric center of atoms in <mask1>/<mask2>; default is to use

center of mass.

[noimage] Do not image distances across periodic boundaries.
[type noe] Mark distance as ’noe’ for use with statistics analysis.

[bound <lower> bound <upper>] Lower and upper bounds for NOE (in Angstroms);

must specify both.

[rexp <expected>] Expected value for NOE (in Angstroms); if not given

’(<lower> + <upper>)’ / 2.0 is used.

[noe_strong] Set lower and upper bounds to 1.8 and 2.9 Å respectively.
[noe_medium] Set lower and upper bounds to 2.9 and 3.5 Å respectively.
[noe_weak] Set lower and upper bounds to 3.5 and 5.0 Å respectively.

Calculate distance between the center of mass of atoms in <mask1> to atoms in <mask2>, between atoms in
<mask1> from each input frame and atoms in <mask2> in speciﬁed reference, or atoms in <mask1> and the
speciﬁed point. If geom is speciﬁed use the geometric center instead. For periodic systems imaging is turned on
by default; the noimage keyword disables imaging.

A distance can be labeled using ’type noe’ for further analysis as an NOE using the ’statistics’ analysis com-

mand ( 32.12.34 on page 744).

32.11.28. drms | drmsd (distance RMSD)

drmsd [<dataset name>] [<mask> [<refmask>]] [out <filename>]

[ first | ref <refname> | refindex <#> |

reftraj <trajname> [parm <trajparm> | parmindex <parm#>] ]

[<dataset name>] Output data set name.
[<mask>] Atoms to calculate DRMSD for.
[<refmask>] Mask corresponding to atoms in reference; if not specified, <mask>

is used.

[out <ﬁlename>] Output file name.
[ﬁrst] Use the first trajectory frame processed as reference.
[reference] Use the first previously read in reference structure.
[ref <refname>] Use previously read in reference structure specified by

<refname>.

[reﬁndex <#>] Use previously read in reference structure specified by <#> (based

on order read in).

previous Use frame prior to current frame as reference.

660

32.11. Action Commands

reftraj <name> Use frames from COORDS set <name> or read in from trajectory file

<name> as references. Each frame from <name> is used in turn, so that
frame 1 is compared to frame 1 from <name>, frame 2 is compared to frame 2
from <name> and so on. If <trajname> runs out of frames before processing
is complete, the last frame of <trajname> continues to be used as the
reference.
parm <parmname> | parmindex <#> If reftraj specifies a file associate

trajectory <name> with specified topology; if not specified the first
topology is used.

Calculate the distance RMSD (i.e. the RMSD of all pairs of internal distances) between atoms in the frame deﬁned
by <mask> (all if no <mask> speciﬁed) to atoms in a reference deﬁned by <refmask> (<mask> if <refmask> not
speciﬁed). Both <mask> and <refmask> must specify the same number of atoms, otherwise an error will occur.
Because this method compares pairs of internal distances and not absolute coordinates, it is not sensitive to
translations and rotations the way that a no-ﬁt RMSD calculation is. It can be more time consuming however, as
(N2-N)/2 distances must be calculated and compared for both the target and reference structures.

For example, to get the DRMSD of a residue named LIG to its structure in the ﬁrst frame read in:

drmsd :LIG first out drmsd.dat

32.11.29. dssp

See 32.11.72 on page 699.

32.11.30. energy

energy [<name>] [<mask1>] [out <filename>]

[bond] [angle] [dihedral] {[nb14] | [e14] | [v14]}
{[nonbond] | [elec] [vdw]} [kinetic [ketype {vel|vv}] [dt <dt>]]
[ etype { simple |

directsum [npoints <N>] |
ewald [cut <cutoff>] [dsumtol <dtol>] [rsumtol <rtol>]

[ewcoeff <coeff>] [maxexp <max>] [skinnb <skinnb>]
[mlimits <X>,<Y>,<Z>] [erfcdx <dx>]

pme [cut <cutoff>] [dsumtol <dtol>] [order <order>] [ljswidth <width>]

[ewcoeff <coeff>] [ljpme] [ewcoefflj] [skinnb <skinnb>]
[nfft <nfft1>,<nfft2>,<nfft3>] [erfcdx <dx>]

} ]

[<name>] Data set name.
[<mask1>] Mask of atoms to calculate energy for.
[out <ﬁlename>] File to write results to.
[bond] Calculate bond energy.
[angle] Calculate angle energy.
[dihedral] Calculate dihedral energy.
[nb14] Calculate nonbonded 1-4 energy.
[e14] Calculate 1-4 electrostatics.
[v14] Calculate 1-4 van der Waals.
[nonbond] Calculate nonbonded energy (electrostatics and van der Waals).
[elec] Calculate electrostatic energy (Coulomb potential).
[vdw] Calculate van der Waals energy (Lennard-Jones 6-12 potential).

661

32. cpptraj

[etype <type>] Calculate electrostatics via specified type.
[simple] Use simple Coulomb term for electrostatics, no cutoff.
[directsum] Use direct summation method for electrostatics.

[npoints <N>] Number of cells in each direction to calculate the direct sum.

[ewald] Use Ewald summation for electrostatics.

If van der Waals energy will be

calculated a long-range correction for periodicity will be applied.
cut <cutoff> Direct space cutoff in Angstroms (default 8.0).
dsumtol <dtol> Direct sum tolerance (default 0.00001). Used to determine

Ewald coefficient.

rsumtol <rtol> Reciprocal sum tolerance (default 0.00005). Used to determine

number of reciprocal space vectors.

ewcoeff <coeff> Ewald coefficient in 1/Ang.
skinnb Used to determine pairlist atoms (added to cut, so pairlist cutoff

is cut + skinnb); included in order to maintain consistency with
results from sander.

mlimits <X>,<Y>,<Z> Explicitly set the number of reciprocal space vectors in

each dimension. Will be determined automatically if not specified.

erfcdx <dx> Spacing to use for the ERFC splines (default 0.0002 Ang.).

[pme] Use particle mesh Ewald for electrostatics.

If van der Waals energy will

be calculated a long-range correction for periodicity will be applied.
cut <cutoff> Direct space cutoff in Angstroms (default 8.0).
dsumtol <dtol> Direct sum tolerance (default 0.00001). Used to determine

Ewald coefficient.

order <order> Spline order for charges.
ljswidth <width> If specified, use a force-switching form for the
Lennard-Jones calculation from <cutoff>-<width> to <cutoff>.

ewcoeff <coeff> Ewald coefficient in 1/Ang.
ljpme If specified use particle mesh Ewald for calculating Lennard-Jones

interactions.

ewcoefﬂj Ewald coefficient for Lennard-Jones PME.
skinnb Used to determine pairlist atoms (added to cut, so pairlist cutoff

is cut + skinnb); included in order to maintain consistency with
results from sander.

nfft <nfft1>,<nfft2>,<nfft3> Explicitly set the number of FFT grid points in each

dimension. Will be determined automatically if not specified.

erfcdx <dx> Spacing to use for the ERFC splines (default 0.0002 Ang.).

DataSet Aspects:

[bond] Bond energy.
[angle] Angle energy.
[dih] Dihedral energy.
[vdw14] 1-4 van der Waals energy.
[elec14] 1-4 electrostatic energy.
[vdw] van der Waals energy.
[elec] Electrostatic energy.
[total] Total energy.

662

32.11. Action Commands

Calculate the energy for atoms in <mask>. If no terms are speciﬁed, all terms are calculated. Note that the non-
bonded energy terms for ’simple’ do not take into account periodicity and there is no distance cut-off. Electrostatics
can also be determined via the direct sum, Ewald, or particle-mesh Ewald summation procedures. The particle
mesh Ewald functionality requires that CPPTRAJ be compiled with FFTW and a C++11 compliant compiler.

Calculation of energy terms requires that the associated topology ﬁle have parameters for any of the calculated
terms, so for example angle calculations are not possible when using a PDB ﬁle as a topology, etc. All nonbonded
calculations methods other than simple require unit cell parameters.

For example, to calculate all energy terms and write to a Grace-format ﬁle:

parm DPDP.parm7
trajin DPDP.nc
energy DPDP out ene.agr

32.11.31. esander

esander [<name>] [out <filename>] [saveforces] [parmname <file>] [keepfiles]

[<namelist vars> ...]

[<name>] Data set name.
[out <ﬁlename>] File to write results to.
[saveforces] If specified, save forces to frames.

NetCDF format.

Requires writing frames in

[parmname <ﬁle>] Name of temporary topology file (default:

’CpptrajEsander.parm7’).

[keepﬁles] Keep temporary topology file after program execution.
[<namelist vars>] Namelist variables supported by the sander API in format ’var

<value>’; see below.

Calculate energies for input frames using the sander API. It requires compilation with the SANDER API (sander-
lib). This can be considered as a faster alternative to energy post-processing with sander (imin = 5). Currently the
following sander namelist variables are supported: extidel, intdiel, rgbmax, saltcon, cut, dielc, igb, alpb, gbsa,
lj1264, ipb, inp, vdwmeth, ew_type, ntb, ntf, ntc. See 19 on page 336 for details.

If ntb/cut/igb are not speciﬁed cpptraj will attempt to pick reasonable values based on the input system. The
defaults for a non-periodic system are ntb=0, cut=9999.0, igb=1. The defaults for a periodic system are ntb=1,
cut=8.0, igb=0. This currently requires writing a temporary Amber topology, the name of which can be set by
parmname. If keepﬁles is speciﬁed this temporary topology will not be deleted after execution.

For example, to calculate energies for a non-periodic system using igb=1 (the default) with GB surface area

turned on (gbsa=1):

parm DPDP.parm7
trajin DPDP.nc
esander DPDP out Edpdp.dat gbsa 1

32.11.32. ﬁlter

filter <dataset1 arg> min <min1> max <max1>

[<dataset2 arg> min <min2> max <max2> ...]
[out <file> [name <setname>]]

<datasetX arg> Data set name(s) to use for filtering
min <minX> Allow values greater than <min> in dataset X.
max <maxX> Allow values greater than <max> in dataset X.

663

32. cpptraj

[out <ﬁle>] File containing 1 for frames that were allowed, 0 for frames that

were filtered.

[name <setname>] Filtered data set name containing 1 for allowed frames, 0 for

filtered frames.

For all following actions, only include frames that are between <min> and <max> of data sets in <dataset arg>.
There must be at least one <min> and <max> argument, and there must be as many <min>/<max> arguments as
there are speciﬁed data sets. For example, to write only frames in-between an RMSD of 0.7-0.8 Angstroms for a
given input trajectory:

trajin ../tz2.truncoct.nc
rms R1 first :2-11
filter R1 min 0.7 max 0.8 out filter.dat
outtraj maxmin.crd

The output trajectory will only contain frames that meet the RMSD requirement, and the ﬁlter.dat ﬁle can be used
to see which frames those were that were output.

A similar command that can be used with data that already exists (e.g. it has been read in with readdata) is

dataﬁlter (see page 618).

32.11.33. ﬁxatomorder

fixatomorder [outprefix <name>]

Cpptraj (and most of Amber) expects that atom indices in molecules to increase monotonically. However,
occasionally atom indices in molecules can become disordered or non-sequential, in which case cpptraj will print
an error message such as the following:

Error: Atom 45 was assigned a lower molecule # (1) than previous atom (2).

and:

Error: Could not determine molecule information for <topology file>.

. This command ﬁxes atom ordering so that all atoms in molecules are sequential. The outpreﬁx keyword will
write out the re-ordered topology with name <name>.<original name>.

For example, given an out of order topology named ’outoforder.parm7’ and a corresponding trajectory

’min1.crd’, the following will produce a reordered topology named ’reorder.outoforder.parm7’ and a reordered
trajectory named ’reorder.mdcrd’:

parm outoforder.parm7
trajin min1.crd 1 10
fixatomorder outprefix reorder
trajout reorder.mdcrd

32.11.34. ﬁximagedbonds

fiximagedbonds [<mask>]

<mask> Mask expression of atoms to check.

Fix bonds that have been split across periodic boundary conditions by imaging. It may be desirable to reimage the
coordinates after this with autoimage.

664

32.11.35. gist (Grid Inhomogeneous Solvation Theory)

32.11. Action Commands

gist [doorder] [doeij] [skipS] [skipE] [refdens <rdval>] [temp <tval>]

[noimage] [gridcntr <xval> <yval> <zval>] [excludeions]
[griddim <xval> <yval> <zval>] [gridspacn <spaceval>]
[prefix <filename prefix>] [ext <grid extension>] [out <output>]
[info <info>]

[doorder] Calculate the water order parameter [645] for each voxel.
[doeij] Calculate the triangular matrix representing the water-water interactions

between pairs of voxels (see below).

[skipE] Skip all energy calculations (cannot be specified with ’doeij’).
[skipS] Skip all entropy calculations.
[refdens rdval>] Reference density of bulk water, used in computing g_O, g_H, and

the translational entropy. Default is 0.0334 molecules/Å3.

[temp <tval>] Temperature of the input trajectory.
[noimage] Disable distance imaging in energy calculation.
[excludeions] If specified, exclude any ions from the calculation.
[gridcntr <xval> <yval> <zval>] Coordinates (Å) of the center of the grid (default

0.0, 0.0, 0.0).

[griddim <xval> <yval> <zval>] Grid dimensions along each coordinate axis (default

40, 40, 40).

[gridspacn <spaceval>] Grid spacing (linear dimension of each voxel) in

Angstroms. Values greater than 0.75 Å are not recommended (default 0.5 Å).

[preﬁx <ﬁlename preﬁx>] Output file name prefix (default “gist”).
[ext <grid extension>] Output grid file name extension (default “.dx”).
[out <output>] Name of the main GIST output file.

If not specified set to

’<prefix>-output.dat’.

[info <info>] Name of main GIST info file.

If not specified info is written to

standard output.

DataSet Aspects:
[gO] Number density of oxygen centers found in the voxel, in units of the bulk

density.

[gH] Number density of hydrogen centers found in the voxel in units of the

reference bulk density.

[Esw] Mean solute-water interaction energy density.
[Eww] Mean water-water interaction energy density.
[dTStrans] First order translational entropy density.
[dTSorient] First order orientational entropy density .
[neighbor] Mean number of waters neighboring the water molecules found in this

voxel multiplied by the voxel number density.

[dipole] Magnitude of mean dipole moment (polarization).
[order] Average Tetrahedral Order Parameter.
[dipolex] x-component of the mean water dipole moment density
[dipoley] y-component of the mean water dipole moment density
[dipolez] z-component of the mean water dipole moment density

665

32. cpptraj

Figure 32.1.: Diagram, in 2D, of GIST’s gridded water properties in a binding site.

[Eij] Water-water interaction matrix.

Grid Inhomogeneous Solvation Theory [646, 647] (GIST) is a method for analyzing the structure and thermody-
namics of solvent in the vicinity of a solute molecule. The current implementation works for only water, but the
method can be generalized to other solvents whose molecules are rigid like water, such as chloroform or dimethyl-
sulfoxide (DMSO). GIST post-processes explicit solvent simulation data to create a three-dimensional mapping of
water density and thermodynamic properties within a region of interest, which is deﬁned by a user-speciﬁed 3D
rectangular grid. The small grid boxes are referred to as voxels, and each voxel is associated with solvent proper-
ties. (See Fig. 32.1.) The GIST implementation incorporated into AmberTools cpptraj also calculates a number of
other local water properties, as listed below. GIST works for the nonpolarizable water models currently supported
by AMBER.

In order to carry out a GIST calculation, you must have a trajectory ﬁle generated with explicit water, as well
as the corresponding topology ﬁle. To generate the most readily interpretable results, it is recommended that the
solute (e.g., a protein) be restrained into essentially one conformation. GIST will then provide information about
the structure and thermodynamics of the solvent for that conformation. For a room-temperature simulation of a
solvent-exposed binding site, and a grid-spacing of 0.5 Å, it is recommended that the simulation be at least 10-20
ns in duration, and it is also a good idea to check for convergence of the GIST properties you are interested in by
loading and then processing successively more frames of your trajectory ﬁle. Because GIST assumes that the solute
of interest comprises all molecules in the simulation that are not waters, it is a good idea to remove all counterions
and cosolutes with cpptraj’s strip command before running GIST. A sample series of cpptraj commands for running
GIST is provided below.

Although it is not mandatory to supply values of gridcntr, griddim and gridspcn, these parameters should
be carefully chosen, because they determine the region to be analyzed (gridcntr and griddim) and the spatial
resolution and convergence properties of the results (gridspcn). In particular, although smaller grid spacings will
give ﬁner spatial resolution, longer simulation times will be needed to converge the properties in the smaller voxels
that result. A larger grid spacing will allow earlier convergence, but will smooth the spatial distributions and hence
can reduce accuracy.

The reference density of water (rdval) is taken by default to be the experimental number density of pure water
at 300 K and 1 atm. However, different water models may yield slightly different bulk densities under these
conditions, and the density also depends on T and P. If you know that the bulk density of the water model you
are using, at the T and P of your simulation, deviates signiﬁcantly from 0.0334 water molecules/Å3, it would be
advisable to supply the actual value with the refdens keyword, instead of allowing GIST to supply the default
value.

For GIST, a GPU accelerated version is available, in which the interaction energy is calculated using CUDA.
When using the GPU accelerated version of GIST, the doeij keyword is not available. It is recommended to use
a grid covering the entire box, when using the GPU implementation. You may also choose a smaller grid, but
all interaction energies, i.e., each atom with each atom, will always be calculated independent of the chosen grid.
This ensures optimum performance when calculating the interaction energies. Thus, the additional time required
to calculate the order parameters (doorder) is negligible.

666

GIST Output

32.11. Action Commands

GIST generates a main output ﬁle and a collection of grid data ﬁles that by default are in Data Explorer for-
mat (.dx); this can be changed via the ext keyword. These grid ﬁles enable visualization of the various gridded
quantities, such as with the program VMD [648]. If the doeij keyword is provided, GIST also writes out a matrix
of water-water interactions between pairs of voxels. In addition, run details are written to stdout, which can be
redirected into a log ﬁle.

Note that a number of quantities are written out as both densities and normalized quantities. For example,
the output ﬁle includes both the solute-water energy density and the normalized (per water) solute-water energy.
In all cases, the normalized quantity at voxel i, Xi,norm is related to the corresponding density, Xi,dens, by the
relationship Xi,norm = ρiXi,dens, where ρi is the number density of water in the voxel. The normalized quantity
provides information regarding the nature of the water found in the voxel. The density has the property that, if the
grid extended over the entire simulation volume, the total system quantity would be given by Xtot = Vvoxel ∑i Xi,dens,
where Vvoxel is the volume of one grid voxel.

The main output ﬁle takes the form of a space-delimited-variable ﬁle, where each row corresponds to one
voxel of the grid. This ﬁle can easily be opened with and manipulated with spreadsheet programs like Excel and
LibreOfﬁce Calc. The columns are as follows.

• index - A unique, sequential integer assigned to each voxel

• xcoord - x coordinate of the center of the voxel (Å)

• ycoord - y coordinate of the center of the voxel (Å)

• zcoord - z coordinate of the center of the voxel (Å)

• population - Number of water molecule, ni, found in the voxel over the entire simulation. A water molecule
is deemed to populate a voxel if its oxygen coordinates are inside the voxel. The expectation value of this
quantity increases in proportion to the length of the simulation.

• g_O - Number density of oxygen centers found in the voxel, in units of the bulk density (rdval). Thus, the

expectation value of g_O for a neat water system is unity.
• g_H - Number density of hydrogen centers found in the voxel in units of the reference bulk density (2×rdval).
Thus, the expectation value of g_H for a neat water system would be unity.

• dTStrans-dens - First order translational entropy density (kcal/mole/Å3), referenced to the translational

entropy of bulk water, based on the value rdval.

• dTStrans-norm - First order translational entropy per water molecule (kcal/mole/molecule), referenced
to the translational entropy of bulk water, based on the value rdval. The quantity dTStrans-norm equals
dTStrans-dens divided by the number density of the voxel.

• dTSorient-dens - First order orientational entropy density (kcal/mole/Å3), referenced to bulk solvent (see

below).

• dTSorient-norm - First order orientational entropy per water molecule (kcal/mole/water), referenced to
bulk solvent (see below). This quantity equals dTSorient-dens divided by the number density of the voxel.

• Esw-dens - Mean solute-water interaction energy density (kcal/mole/Å3). This is the interaction of the sol-
vent in a given voxel with the entire solute. Both Lennard-Jones and electrostatic interactions are computed
without any cutoff, within the minimum image convention but without Ewald summation. This quantity is
referenced to bulk, in the trivial sense that the solute-solvent interaction energy is zero in bulk.

• Esw-norm - Mean solute-water interaction energy per water molecule. This equals Esw-dens divided by

the number density of the voxel (kcal/mole/molecule).

667

32. cpptraj

• Eww-dens - Mean water-water interaction energy density, scaled by ½ to prevent double-counting, and not
referenced to the corresponding bulk value of this quantity (see below). This quantity is one half of the
mean interaction energy of the water in a given voxel with all other waters in the system, both on and off the
GIST grid, divided by the volume of the voxel (kcal/mole/Å3). Again, both Lennard-Jones and electrostatic
interactions are computed without any cutoff, within the minimum image convention.

• Eww-norm - Mean water-water interaction energy, normalized to the mean number of water molecules in

the voxel (kcal/mole/water). See prior column deﬁnition for details.

• Dipole_x-dens - x-component of the mean water dipole moment density (Debye/Å3).

• Dipole_y-dens - y-component of the mean water dipole moment density (Debye/Å3).

• Dipole_z-dens - z-component of the mean water dipole moment density (Debye/Å3).

• Dipole-dens - Magnitude of mean dipole moment (polarization) (Debye/Å3).

• Neighbor-dens - Mean number of waters neighboring the water molecules found in this voxel multiplied by
the voxel number density. Two waters are considered neighbors if their oxygens are within 3.5 angstroms
of each other. For any given frame, the contribution to the average is set to zero if no water is found in the
voxel (units of number/Å3).

• Neighbor-norm - Mean number of neighboring water molecules, per water molecule found in the voxel

(units of number per water).

• Order-norm - Average Tetrahedral Order Parameter [645], qtet, for water molecules found in the voxel,
normalized by the number of waters in the voxel. The order parameter for water i in a given frame is given
by: qtet (i) = 1− 3
3 )2 where j and k index the 4 closest water neighbors to water i,
and φi jk is the angle formed by water i, j, and k. If the doorder keyword is not provided or is set to FALSE,
then this calculation will not be done, and the entries in this column will be set to zero.

k= j+1(cosφi jk + 1

j=1 ∑4

8 ∑3

Grid ﬁles are provided for all computed quantities listed above, except that the normalized quantities are not in-
cluded. The ﬁlenames are as follows: gist-gO.dx, gist-gH.dx, gist-dTStrans-dens.dx, gist-dTSorient-dens.dx, gist-
Esw-dens.dx, gist-Eww-dens.dx, gist-dipolex-dens.dx, gist-dipoley-dens.dx, gist-dipolez-dens.dx, gist-dipole-
dens.dx, gist-neighbor-dens.dx, gist-neighbor-norm.dx, gist-order-norm.dx. If the doorder keyword is not pro-
vided, then the data in gist-order-norm.dx will all be zeroes. Note that the ﬁle of voxel water densities, gist-gO.dx,
can be used as input to the program Placevent [649], in order to deﬁne spherical hydration sites based on the density
distribution.

Similar grid ﬁles with other computed quantities can be generated by reading the gist.out ﬁle into a spreadsheet

program, processing the numbers to generate a new column of voxel data of interest, and writing this column to
an ascii text ﬁle. Then the Perl script write_dx_ﬁle.pl, which should be available on the GIST tutorial web-site,
may be used to read in the column of data and create the corresponding dx ﬁle. The input format, and an example,
are as follows:

./write_dx_file.pl [filename] [x-dimension y-dimension z-dimension]
[x-origin y-origin z-origin] [grid spacing]
./write_dx_file.pl file.dat 40 40 40 13.0 13.0 13.0 0.75

If the doeij keyword is provided, GIST also writes a large ﬁle, Eww_ij.dat, containing the mean water-water
interaction energies between pairs of voxels, scaled by ½. (See below.) This ﬁle has three columns. The ﬁrst two
columns are voxel indexes, i, j, where j > i, so that no pair appears more than once, and the third column is the
mean interaction energy (kcal/mole) of water in voxels i and j, scaled by ½. If the occupancy of either voxel is
0, such as for voxels covered by solute atoms, then the interaction energy is zero. In order to save space, such
interactions are omitted from the ﬁle.

Sample cpptraj input ﬁle to run GIST

668

Water Model Mean Energy (Eww-norm) (kcal/mol/water) Number Density (Å−3)

32.11. Action Commands

TIP3P

TIP4PEW

TIP4P
TIP5P

Tip3PFW

SPCE
SPCFW

-9.533
-11.036
-9.856
-9.596
-11.369
-11.123
-11.873

0.0329
0.0332
0.0332
0.0329
0.0334
0.0333
0.0329

Table 32.3.: Water model energy and density.

The following input ﬁle, gist.in, causes cpptraj to read a parameter ﬁle named topology.top; read in the ﬁrst

5000 frames of the trajectory ﬁle named trajectoryﬁle.mdcrd; strip out all Na and Cl ions; and carry out a GIST
run which computes order parameters, uses a 41x41x45 grid centered at (25.0, 31.0, 30.0) with a spacing of 0.5
Å, uses the default bulk water density of 0.0334 molecules/Å3, and generates the main output ﬁle gist.out.

parm topology.top
trajin trajectoryfile.mdcrd 1 5000
strip @Na
strip @Cl
gist doorder doeij gridcntr 25.0 31.0 30.0 griddim 41 41 45

gridspacn 0.50 out gist.out

go

To execute this run in the background, use

cpptraj<gist.in>gist.log& or cpptraj -i gist.in>gist.log&

Referencing GIST results to unperturbed (bulk) water

Inhomogeneous ﬂuid solvation theory, which is the basis of GIST, is designed to provide information on how
water structure and thermodynamics around a solute molecule, such as a protein, are changed relative to the
structure and thermodynamics of unperturbed (bulk) water. Accordingly, the quantities reported by GIST are
most informative when the results are referenced to the corresponding bulk water properties. For the orientational
entropy, the reference value is the same regardless of water model or conditions, because the ﬁrst order orientational
distribution of water in the bulk is always uniform. Therefore, the GIST results for orientational entropies are
already referenced to bulk. However, cpptraj reports unreferenced values for those GIST quantities whose reference
values depend upon the water model and the simulation conditions; i.e., the energies. The translational entropy as
well as the number densities will be referenced to bulk using the input referenced density or the default density
value of 0.0334. The table below provides useful reference values for these quantities, computed for various water
models at P=1atm, T=300K, using GIST in order to ensure a consistent minimum image treatment of periodic
boundary conditions.

Users running calculations under signiﬁcantly different conditions, or with different water models, should con-
sider generating their own reference quantities by applying GIST to a simulation of pure water under their condi-
tions of interest. The quantities of interest can then be obtained in their most precise available form by averaging
over voxels, for the pure water simulation. If the quantity of interest is Q, then its average reference value is
Qre f erence = ∑niQi
, where Qi and ni are, respectively, GIST’s reported values of the quantity and the population in
∑ni
voxel i. The densities, ρi, are referenced to the corresponding bulk densities, ρo, as gi = ρi/ρo, while the energy
and entropy terms are referenced by subtracting their bulk values.

669

32. cpptraj

Interpreting GIST results

GIST provides access to the ﬁrst order entropies and the ﬁrst- and second-order energies of inhomogeneous ﬂuid
solvation theory. Non-zero higher-order entropies exist but are not yet computationally accessible. However, for
a pairwise additive force-ﬁeld, such as those listed in the Table above, the energy is fully described at the second
order provided by GIST.

GIST is a research tool, and its applications (to, for example, protein-ligand binding and protein function) are

still being explored. The following general comments may be helpful to users studying GIST results.

1. The water in voxels near a solute (e.g., a protein) almost always has unfavorable water-water interaction
energies, relative to bulk, simply because the solute displaces water, resulting in fewer proximal water-water inter-
actions.

2. The unfavorable water-water energies mentioned in [646] may be balanced by favorable water-solute inter-
actions. If they are not, as may occur especially for voxels in small, hydrophobic pockets, then the net energy of
the water in the voxel may be unfavorable relative to bulk, in which case a ligand which displaces water from the
voxel into bulk may get a boost in afﬁnity.

3. Because the ﬁrst order orientational distribution of bulk water is uniform, and a nonuniform distribution
always has lower entropy than a uniform one, the solute can only lower the orientational entropy of water, relative
to bulk. Thus, this term always opposes solvation, and displacing oriented water into the bulk is always favorable
from the standpoint of orientational entropy.

4. Localized water, which corresponds to voxels with high water density, has a low ﬁrst order translational
entropy, and the translational entropy around a solute is lower than that in bulk, as a nonuniform translational
distribution takes the place of the uniform translational distribution of bulk water.

5. The displacement of highly oriented (low orientational entropy) and localized (low translational entropy)

water into bulk leads to a favorable increase in these entropy terms.

6. However, highly oriented and localized water is often the consequence of strongly favorable polar interactions,
such as hydrogen-bonding, between water and the solute. As a consequence, the net favorability of displacing such
water is frequently a balance between favorable entropic consequences and unfavorable energetic consequences.

7. The water-water energy associated with a given voxel accounts for the interactions of the waters in this voxel
with all other waters in the system, including waters in other voxels. This quantity is multiplied by ½, so that, in a
pure-water system where the GIST grid covers the entire simulation box, the sum over all voxels equals the correct
mean water-water interaction energy. Note that Reference [647] does not include this factor of ½.

8. For a typical GIST application, in which the grid occupies only part of the simulation box, the en-
ergy bookkeeping can become complicated, as discussed in Section II.B.3 (page 044101-6) of Reference [647].
That section also explains how one can compute the water-water energy associated with a region R deﬁned
by a set of voxels, ER
WW . The regional water-water energy, on a normalized (per water) basis, is given by
WW = 2(∑i∈R Ei,WW − ∑i∈R ∑ j∈R, j>i Ei, j,WW ) where i ∈ R means that voxel i is in region R, Ei,WW is the value
ER
of Eww-norm for voxel i, and Ei, j,WW is the value of the water-water interaction energy between voxels i and j,
taken from the ﬁle Eww_ij.dat. The extra factor of 2 in the present formula, relative to that in the paper, results
from application of an extra factor of ½ to the reported water-water interaction energies here.

32.11.36. grid

grid <filename>

{ data <dsname> | boxref <ref name/tag> <nx> <ny> <nz> |

<nx> <dx> <ny> <dy> <nz> <dz> [gridcenter <cx> <cy> <cz>] }

[box|origin|center <mask>] [negative] [name <gridname>]
<mask> [normframe | normdensity [density <density>]]

[pdb <pdbout> [max <fraction>]] [{byres|mymol}]

[[smoothdensity <value>] [invert]] [madura <madura>]

<ﬁlename> File to write out grid to. Use “.grid” or “.xplor” extension for

XPLOR format, “.dx” for OpenDX format.

670

32.11. Action Commands

Options for setting up grid:
data <dsname> Use previously calculated/loaded grid data set named <dsname>.

When using this option there is no need to specify grid
bins/spacing/center.

boxref <ref name/tag> <nx> <ny> <nz> Set up grid using box information from a

previously loaded reference structure. Currently the only way to set up
non-orthogonal grids.

<nx> <dx> <ny> <dy> <nz> <dz> Number of grid bins and spacing in the X/Y/Z

directions.

[gridcenter <cx> <cy> <cz>] Location of grid center, default is origin (0.0, 0.0,

0.0).

Options for offset during grid binning (must center grid at origin):
[box] Offset each point by location of box center prior to gridding.

Cannot be

used with ’gridcenter’.

[origin] No offset (default)
[center <mask>] Offset each point by center of atoms in <mask> prior to

gridding. Cannot be used with ’gridcenter’.

Other options:
[negative] Grid negative density instead of positive density.
[name <gridname>] Grid data set name.
<mask> Mask of atoms to grid.
[normframe] Normalize grid bins by the number of frames.
[normdensity [density <density>]] Normalize grid bins by density: GridBin = GridBin

/ (Nframes * BinVolume * density).
(molecules/Ang^3) for water based on 1.0 g/mL.

Default particle density

[pdb <pdbout> [max <fraction>]] Write a pseudo-PDB of grid points that have density

greater than <fraction> (default 0.80) of the grid max value.

[{byres|bymol}] Grid the centers of mass of residues or molecules selected by

<mask>.

Less common options:
[smoothdensity <smooth>] Used to smooth density. The smoothing takes the form

of GridBin = 0 if GridBin < smooth, otherwise GridBin = GridBin - (GridBin
* exp[-(GridBin - smooth)^2 / (0.2 * smooth^2)]).

[invert] (Only used if smoothdensity also used) Do inverse smoothing (i.e. if

GridBin > smooth).

[madura <madura>] Grid values lower than <madura> become flipped in sign,

exposes low density.

Data Sets Created:
<dsname> Grid data set.

Create a grid representing the histogram of atoms in mask1 on the 3D grid that is "nx * x_spacing by ny * y_spacing
by nz * z_spacing angstroms (cubed). By default the grid is centered at the origin unless gridcenter is speciﬁed.
Grid points can be offset by either the box center (using box) or the center of speciﬁed atoms (using center
<mask>); if either of these options are used the grid must be centered at the origin. Note that the bounds command
( on page 651) can be very useful for determining grid dimensions.

Note that when calculating grid densities for things like solvent/ions, the solute of interest (about which the
atomic densities are binned) should be rms ﬁt, centered and imaged prior to the grid call in order to provide any
meaningful representation of the density. If the optional keyword negative is also speciﬁed, then these density
will be stored as negative numbers. Output can be in the XPLOR or OpenDX data formats.

671

32. cpptraj

Examples

Grid water density around a solute.

trajin tz2.truncoct.nc
autoimage origin
rms first :1-13
# Create average of solute to view with grid.
average avg.mol2 :1-13
grid out.dx 20 0.5 20 0.5 20 0.5 :WAT@O

Generate grid from bounds command.

trajin tz2.ortho.nc
autoimage
rms first :1-13&!@H= mass
bounds :1-13 dx .5 name MyGrid out bounds.dat
average bounds.mol2 :1-13
# Save coordinates for second pass.
createcrd MyCoords
run
# Grid using grid data set from bounds command.
crdaction MyCoords grid bounds.xplor data MyGrid :WAT@O

Create non-orthogonal grid:

trajin tz2.truncoct.nc
reference ../tz2.truncoct.nc [REF]
autoimage triclinic
grid nonortho.dx boxref [REF] 50 50 50 :WAT@O pdb nonortho.pdb

32.11.37. hbond

hbond [<dsname>] [out <filename>] [<mask>] [angle <acut>] [dist <dcut>]

[donormask <dmask> [donorhmask <dhmask>]] [acceptormask <amask>]
[avgout <filename>] [printatomnum] [nointramol] [image]
[solventdonor <sdmask>] [solventacceptor <samask>]
[solvout <filename>] [bridgeout <filename>] [bridgebyatom]
[series [uuseries <filename>] [uvseries <filename>]]

[<dsname>] Data set name.
[out <ﬁlename>] Write # of solute-solute hydrogen bonds (aspect [UU]) vs time to

this file. If searching for solute-solvent hydrogen bonds, write # of
solute-solvent hydrogen bonds (aspect [UV]) and # of bridging solvent
molecules (aspect [Bridge]), as well as the residue # of the bridging
solvent and the solute residues being bridged with format ’<solvent
resnum>(<solute res1>+<solute res2>+...+),...’

(aspect [ID]).
[<mask>] Atoms to search for solute hydrogen bond donors/acceptors.
[angle <acut>] Angle cutoff for hydrogen bonds (default 135°).

Can be disabled

by specifying -1.

[dist <dcut>] Distance cutoff for hydrogen bonds (acceptor to donor heavy atom,

default 3.0 Å).

[donormask <dmask>] Use atoms in <dmask> as solute donor heavy atoms.

If

’donorhmask’ not specified only atoms bonded to hydrogen will be considered
donors.

672

32.11. Action Commands

[donorhmask <dhmask>] Use atoms in <dmask> as solute donor hydrogen atoms.

Should only be specified if ’donormask’ is.
correspondence between donormask and donorhmask.

Should be a 1 to 1

[acceptormask <amask>] Use atoms in <amask> as solute acceptor atoms.
[avgout <ﬁlename>] Write solute-solute hydrogen bond averages to <filename>.
[printatomnum] Add atom numbers to the output, in addtion to residue name,

residue number and atom name.

[nointramol] Ignore intramolecular hydrogen bonds.
[image] Turn on imaging of distances/angles.
[solventdonor <sdmask>] Use atoms in <sdmask> as solvent donors. Can specify

ions as well.

[solventacceptor <samask>] Use atoms in <samask> as solvent acceptors. Can

specify ions as well.

[solvout <ﬁlename>] Write solute-solvent hydrogen bond averages to <filename>.
If not specified and ’avgout’ is, solute-solvent hydrogen bonds averages
will be written to that file.

[bridgeout <ﬁlename>] Write information on detected solvent bridges to

<filename>. If not specified, will be written to same place as ’solvout’.

[bridgebyatom] Report bridging results by atom instead of by residue.
[series] Save hydrogen bond formed (1.0) or not formed (0.0) per frame for any

detected hydrogen bond. Solute-solute hydrogen bonds are saved with aspect
[solutehb], solute-solvent hydrogen bonds are saved with aspect
[solventhb].
[uuseries <ﬁlename>] File to write solute-solute hbond time series data to.
[uvseries <ﬁlename>] File to write solute-solvent hbond time series data to.

Data Sets Created:
<dsname>[UU] Number of solute-solute hydrogen bonds.
<dsname>[UV] (only for solventdonor/solventacceptor) Number of solute-solvent

hydrogen bonds.

<dsname>[Bridge] (only for solventdonor/solventacceptor) Number of bridging

solvent molecules.

<dsname>[ID] (only for solventdonor/solventacceptor) String identifying

bridging solvent residues and the solute residues they bridge.

<dsname>[solutehb] (series only) Time series for solute-solute hydrogen bonds; 1

for present, 0 for not present.

<dsname>[solventhb] (series only) Time series for solute-solvent hydrogen bonds;

1 for present, 0 for not present.

Note that series data sets are not generated until hydrogen bonds are actually determined (i.e. run is called).

Determine hydrogen bonds in each coordinate frame using simple geometric criteria. A hydrogen bond is
deﬁned as being between an acceptor heavy atom A, a donor hydrogen atom H, and a donor heavy atom D. If the
A to D distance is less than the distance cutoff and the A-H-D angle is greater than the angle cutoff a hydrogen
bond is considered formed. Imaging of distances/angles is not performed by default, but can be turned on using
the image keyword.

Potential hydrogen bond donor/acceptor atoms are searched for as follows:

1. If just <mask> is speciﬁed donors and acceptors will be automatically determined from <mask>.

673

32. cpptraj

2. If donormask is speciﬁed donors will be determined from <dmask> (only atoms bonded to hydrogen will
be considered valid). Optionally, donorhmask can be used in conjunction with donormask to explic-
itly specify the hydrogen atoms bonded to donor atoms. Acceptors will be automatically determined from
<mask>.

3. If acceptormask is speciﬁed acceptors will be determined from <amask>. Donors will be automatically

determined from <mask>.

4. If both acceptormask and donormask are speciﬁed only <amask> and <dmask> will be used; no searching

will occur in <mask>.

Automatic determination of hydrogen bond donors/acceptors uses the simplistic criterion that “hydrogen bonds are
FON”, i.e., hydrogens bonded to F, O, and N atoms are considered donors, and F, O, and N atoms are considered
acceptors. Intra-molecular hydrogen bonds can be ignored using the nointramol keyword.

The number of hydrogen bonds present at each frame will be determined and written to the ﬁle speciﬁed by out.
If the series keyword is speciﬁed the time series for each hydrogen bond (1 for present, 0 for not present) will also
be saved for subsequent analysis (e.g. with lifetime, see on page 731); solute-solute hydrogen bonds will be saved
to ’<dataset name>[solutehb]’ and solute-solvent hydrogen bonds will be saved to ’<dataset name>[solventhb]’.
The data set legends are set with the residues and atoms involved in the hydrogen bonds. In the case of solute to
non-speciﬁc solvent hydrogen bonds, a V is used in place of solvent.

If avgout is speciﬁed the average of each solute-solute hydrogen bond (sorted by population) formed over the

course of the trajectory is printed with the format:

Acceptor

DonorH

Donor

Frames

Frac

AvgDist

AvgAng

where Acceptor, DonorH, and Donor are the residue and atom name of the atoms involved in the hydrogen bond,
Frames is the number of frames the bond is present, Frac is the fraction of frames the bond is present, AvgDist is
the average distance of the bond when present, and AvgAng is the average angle of the bond when present. The
printatomnum keyword can be used to print atom numbers as well.

Solute to non-speciﬁc solvent hydrogen bonds can be tracked by using the solventdonor and/or

solventacceptor keywords. The number of solute-solvent hydrogen bonds and number of “bridging” solvent
molecules (i.e. solvent that is hydrogen bonded to two or more different solute residues at the same time) will also
be written to the ﬁle speciﬁed by out. These keywords can also be used to track non-speciﬁc interactions with
ions. If avgout or solvavg is speciﬁed the average of each solute solvent hydrogen bond will be printed with the
format:

Acceptor

DonorH

Donor

Count

Frac

AvgDist

AvgAng

where Acceptor, DonorH, and Donor are either the residue and atom name of the solute atoms or
“SolventAcc”/”SolventH”/”SolventDnr” representing solvent, Count is the total number of interactions between
solute and solvent (note this can be greater than the total number of frames since for any given frame more than
one solvent molecule can hydrogen bond to the same place on solute and vice versa), AvgDist is the average
distance of the bond when present, and AvgAng is the average angle of the bond when present. If avgout or
bridgeout is speciﬁed information on residues that were bridged by a solvent molecule over the course of the
trajectory will be written to <bﬁlename> with format:

Bridge Res <N0:RES0> <N1:RES1> ... , <X> frames.

where ’<N0:RES0> ...’ is a list of residues that were bridged (residue # followed by residue name) and <X> is the
number of frames the residues were bridged.

hbond Examples

To search for all hydrogen bonds within residues 1-22, writing the number of hydrogen bonds per frame to

“nhb.dat” and information on each hydrogen bond found to “avghb.dat”:

hbond :1-22 out nhb.dat avgout avghb.dat

674

To search for all hydrogen bonds formed between donors in residue 1 and acceptors in residue 2:

hbond donormask :1 acceptormask :2 out nhb.dat avgout avghb.dat

To search for all intermolecular hydrogen bonds only and solute-solvent hydrogen bonds, saving time series data
to HB:

32.11. Action Commands

hbond HB out nhb.dat avgout solute_avg.dat \
solventacceptor :WAT@O solventdonor :WAT \
solvout solvent_avg.dat bridgeout bridge.dat \
series uuseries uuhbonds.agr uvseries uvhbonds.agr

To search for non-speciﬁc hydrogen bonds between solute and ions named Na+:

hbond HB-Ion out nhb.agr avgout ion_avg.dat \

solventacceptor :Na+ solventdonor :Na+

32.11.38. image

image [origin] [center] [triclinic | familiar [com <commask>]] [<mask>]

[ bymol | byres | byatom ] [xoffset <x>] [yoffset <y>] [zoffset <z>]

[origin] Image to coordinate origin (0.0, 0.0, 0.0); default is to image to box

center.

[center] For bymol/byres, image by center of mass; default is to image by first

atom position.

[triclinic] Force imaging with triclinic code. This is the default for

non-orthorhombic cells.

[familiar [com <commask>]] Image to truncated octahedron shape.

If ’com

<commask>’ is given, image with respect to the center of mass of atoms in
<commask>.

[<mask>] Image atoms/residues/molecules in mask.
[bymol] Image by molecule (default).
[byres] Image by residue.
[byatom] Image by atom.
[xoffset <x>] Shift atoms by a factor of <x> in the X-direction.
[yoffset <y>] Shift atoms by a factor of <y> in the Y-direction.
[zoffset <z>] Shift atoms by a factor of <z> in the Z-direction.

Note this command is intended for advanced use; for most cases the autoimage command should be sufﬁcient.

For periodic systems only, image molecules/residues/atoms that are outside of the box back into the box.
Currently both orthorhombic and non-orthorhombic boxes are supported. A typical use of image is to move
molecules back into the box after performing center. For example, the following commands move all atoms so
that the center of residue 1 is at the center of the box, then image so that all molecules that are outside the box
after centering are wrapped back inside:

center :1
image

The xoffset etc. keywords can be used to shift the entire unit cell in a certain direction by the given factor, which
can be useful for visualizing trajectories with periodic boundary conditions. For example, to generate a trajectory
that is offset by 1.0 box length in the X direction, one could use:

image xoffset 1.0
trajout traj.offsetx1.nc

675

32. cpptraj

32.11.39. jcoupling

jcoupling <mask> [outfile <filename>] [kfile <param file>] [out <filename>]

[name <dsname>]

<mask> Atom mask in which to search for dihedrals within.
[outﬁle <ﬁlename>] File to write j-coupling values to with fixed format.
[kﬁle <param ﬁle>] File containing Karplus parameters (default is

$AMBERHOME/dat/Karplus.txt).

[out <ﬁlename>] File to write data set output to.
[name <dsname>] Data set name.

Note data sets are not generated until run is called.

Calculate J-coupling values for all dihedrals found within <mask> (all atoms if no mask given). In order to use
this function, Karplus parameters for all dihedrals which will be calculated must be loaded. By default cpptraj will
use the data found in $AMBERHOME/dat/Karplus.txt; if this is not found cpptraj will look for the ﬁle speciﬁed
by the $KARPLUS environment variable.

In the Karplus parameter ﬁle each parameter set consists of two lines for each dihedral with the format:

[<Type>]<Name1><Name2><Name3><Name4><A><B><C>[<D>]
<Resname1>[<Resname2>...]

The ﬁrst line deﬁnes the parameter set for a dihedral. <Type> is optional; if not given the form for calculating the
J-coupling will be as described by Chou et al.[650]; if ’C’ the form will be as described by Perez et al.[651]. The
<NameX> parameters deﬁne the four atoms involved in the dihedral. Each <NameX> parameter is 5 characters
wide, starting with a plus ’+’, minus ’-’ or space ’ ’ character indicating the atom belongs to the next, previous, or
current residue. The remaining 4 characters are the atom name. The parameters <A>, <B>, <C>, and <D> are
ﬂoating point values 6 characters wide describing the Karplus parameters. For the ’C’ form A, B, and C
correspond to C0, C1, and C2; D is unused and should not be speciﬁed. The second line is a list of residue names
(4 characters each) to which the dihedral applies. For example:

CA

C HA
ILE VAL

CB

HB

5.40 -1.37 3.61

Describes a dihedral between atoms HA-CA-CB-HB using the Perez et al. form with constants C0=5.40, C1=-1.37,
C2=3.61 applied to ILE and VAL residues.

Output can be in both a ﬁxed format (outﬁle <ﬁlename>) and using cpptraj data set/data ﬁle formatting (out
<ﬁlename>). The ﬁxed format has each dihedral that is deﬁned from <mask1> printed along with its calculated
J-coupling value for each frame, e.g.:

#Frame 1
1 SER HA CA CB HB2 45.334742 4.024759
1 SER HA CA CB HB3 -69.437134 1.829510
...

First the frame number is printed, then for each dihedral: Residue number, residue name, atom names 1-4 in the
dihedral, the value of the dihedral, the J-coupling value.

In cpptraj format, only the J-coupling value is written.

32.11.40. lessplit

lessplit [out <filename prefix>] [average <avg filename>] <trajout args>

[out <ﬁlename preﬁx>] Write split LES trajectories to <filename prefix>.X, where

X is an integer.

676

32.11. Action Commands

[average <avg ﬁlename>] Write trajectory of averaged LES regions to <avg

filename>.

<trajout args> Arguments for output trajectories.

Split and/or average LES trajectory. At least one of ’out’ or ’average’ must be speciﬁed. If both are speciﬁed they
share <trajout args>.

32.11.41. lie

lie [<name>] <Ligand mask> [<Surroundings mask>] [out <filename>] [nopbc]

[noelec] [novdw] [cutvdw <cutoff>] [cutelec <cutoff>] [diel <dielc>]

DataSet Aspects:
[EELEC] Electrostatic energy (kcal/mol).
[EVDW] van der Waals energy (kcal/mol).

For each frame, calculate the non-bonded interactions between all atoms in <Ligand mask> with all atoms in
<Surroundings mask>. Electrostatic and van der Waals interactions will be calculated for all atom pairs. A separate
electrostatic and van der Waals cutoff can be applied, the default is 12.0 Angstroms for both. <dielc> is an optional
dielectric constant. Either the electrostatic or van der Waals calculations can be suppressed via the keywords noelec
and novdw, respectively. Periodic boundary conditions (and the minimum image convention) can be abandoned
with the “nopbc” keyword. Note, however, that no prior imaging is performed if the frames contain periodic
boundaries. This may be useful for instances when you are simulating a microscopic droplets.

The electrostatic interactions are calculated according to a simple shifting function shown below. The data ﬁle
will contain two data sets—one for electrostatic interactions and one for van der Waals interactions. Periodic
topologies and trajectories are required (i.e., explicit solvent is necessary). The minimum image convention is
followed.

Eelec = k

qiq j
ri j

32.11.42. lipidorder

(cid:33)2

(cid:32)
1− r2
i j
r2
cut

order out <filename> [x|y|z] [scd] [unsat <mask>]

[taildist <filename> [delta <resolution>] tailstart <mask>

tailend <mask>] <mask0> ... <maskN>

out Output file for order parameters:

Sx, Sy, Sz (each succeeded by the

standard deviation), and two estimates for the deuterium-order parameter
|SCD| = 0.5Sz and |SCD| = -(2Sx + Sy)/3. If scd is set then the order
parameter directly computed from the C-H vectors is output.

x|y|z Reference axis. (z)
unsat Mask for unsaturated bonds.

Sz is calculated for vector Cn-Cn+1. This

is only relevant if scd (below) is not set, i.e.
calculated from carbon position only.

order parameters are

scd Calculate the deuterium-order parameter |SCD| directly from the C-H vectors

(masks must contain C-H-H triplets, see below). Otherwise the order
parameter is estimated from carbon positions only (masks must contain only
relevant carbons). (false)

taildist Optional output file for end-to-end distances.
delta Optional resolution for taildist. (0.1)
tailstart Mask for the start of the tail. Must be given if taildist.

677

32. cpptraj

tailend Mask for the end of the tail.
mask0 ... maskN Masks for each group in the lipid chain.

Must be given if taildist.

The order parameters Sx, Sy, Sz and |SCD| are calculated. Carbons must be given in bonding order. If scd the
masks must be made up of C-H-H triples, hence hydrogens to double bonds must be enumerated twice while
methyl groups require an additional mask which will also create two entries in the output.
Szis the vector joining carbons Cn−1 and Cn+1, Sx the vector normal to the Cn−1 −Cn and Cn −Cn+1 plane and
Sy is the third axis in the molecular coordinate system. The order parameter is then calculated from Sc = 0.5 <
3cos(2θ ) > −1, where θ is the angle to the chosen reference axis. See example input ﬁle.
Example input (all atom names according to CHARMM27 force ﬁeld for POPC).
sn1 chain: order parameters Sx, Sy, Sz and |SCD| = 0.5× Sz and |SCD| = −(2Sx + Sy)/3

lipidorder out sn1.dat z taildist e2e_sn1.dat delta 0.1 \

tailstart ":POPC@C32" tailend ":POPC@C316" \
":POPC@C32" ":POPC@C33" ":POPC@C34" ":POPC@C35" \
":POPC@C36" ":POPC@C37" ":POPC@C38" ":POPC@C39" \
":POPC@C310" ":POPC@C311" ":POPC@C312" ":POPC@C313" \
":POPC@C314" ":POPC@C315" ":POPC@C316"

See also $AMBERHOME/AmberTools/test/cpptraj/Test_LipidOrder.

32.11.43. lipidscd

lipidscd [<name>] [<mask>] [{x|y|z}] [out <file>] [p2]

<name> Output data set name.
<mask> Atom mask specifying where to search for lipids.
x|y|z Axis to calculate order parameters with respect to (default z).
out <ﬁle> File to write order parameters to.
p2 If specified, report raw <P2> values.

DataSets Generated:

<name>[H1]:<idx> Hold lipid order parameters for each C-H1.

Each lipid type

will have a different <idx> starting from 0.

<name>[H2]:<idx> Hold lipid order parameters for each C-H2.

If no H2, the C-H1

value will be used.

<name>[H3]:<idx> Hold lipid order parameters for each C-H3.

If no H3, the

C-H2/C-H1 value will be used.

<name>[SDHX]:<idx> Hold standard deviation of lipid order parameters for each

C-HX.

Calculate lipid order parameters SCD (|<P2>|) for lipid chains in mask <mask>. Lipid chains are identiﬁed by
carboxyl groups, i.e. O-(C=O)-C1-...-CN, where C1 is the ﬁrst carbon in the acyl chain and CN is the last. Order
parameters will be determined for each hydrogen bonded to each carbon. If ’p2’ is speciﬁed the raw <P2> values
will be reported.

32.11.44. makestructure

makestructure <List of Args>

Apply dihedrals to speciﬁed residues using arguments found in <List of Args>, where an argument is 1 or more of
the following arg types:

678

<sstype keyword>:<res range>

Apply secondary structure type (via phi/psi backbone angles) to residues in given range.

structure type is a turn, the residue range must correspond to a multiple of 2 residues.

If the secondary

32.11. Action Commands

Keyword

alpha
left
pp2

hairpin
extended

typeI
typeII
typeVIII
typeI’
typeII

typeVIa1
typeVIa2
typeVIb

phi, psi (deg.)
-57.8, -47.0
-57.8, 47.0
-75.0, 145.0
-100.0, 130.0
-150.0, 155.0

-60.0, -30.0 | -90.0, 0.0
-60.0, 120.0 | 80.0, 0.0

-60.0, -30.0 | -120.0, 120.0

60.0, 30.0 | 90.0, 0.0
60.0, -120.0 | -80.0, 0.0
-60.0, 120.0 | -90.0, 0.0
-120.0, 120.0 | -60.0, 0.0
-135.0, 135.0 | -75.0, 160.0

# residues

1
1
1
1
1
2
2
2
2
2
2
2
2

<custom ss name>:<res range>[:<phi>:<psi>]

If <phi> and <psi> are given, deﬁne a custom secondary structure conformation named <custom_ss> and apply

to residues in range. If <custom_ss> has been previously deﬁned then apply it to residues in range.

<custom turn name>:<res range>[:<phi1>:<psi1>:<phi2>:<psi2>]

If <phi1>, <psi1>, <phi2>, and <psi2> are given, deﬁned a custom turn conformation named <custom_turn>
and apply to residues in range (range must correspond to a multiple of 2 residues). If <custom_turn> has been
previously deﬁned then apply it to residues in range.

<custom dih name>:<res range>[:<dih type>:<angle>]

<dih type> = alpha beta gamma delta epsilon zeta nu0 nu1 nu2 nu3 nu4

h1p c2p chin phi psi chip omega chi2 chi3 chi4 chi5

If <dih type> and <angle> are given, apply <angle> to selected dihedrals of type in range. If <custom dih> has
been previously deﬁned then apply it to residues in range.

<custom dih name>:<res range>[:<at0>:<at1>:<at2>:<at3>:<angle>[:<offset>]]

Apply <angle> to dihedral deﬁned by atoms <at1>, <at2>, <at3>, and <at4>, or use previously deﬁned <cus-

tom_dih>.

<offset>

Description

-2
-1
0
1
2

<at0> and <at1> in previous residue.

<at0> in previous residue.
All atoms in single residue.

<at3> in next residue.

<at2> and <at3> in next residue.

ref:<range>:<refname>[:<ref range>[:<dih types>]] [refvalsout <ﬁle>] [founddihout <ﬁle>]

Apply dihedrals from residues <ref_range> in previously loaded reference structure <refname> to dihedrals
in <range>. If <ref range> is speciﬁed, use those residues from reference. The dihedral types to be used (see

679

32. cpptraj

<dih_type> above) can be speciﬁed in a comma-separated list; default is phi/psi. Note that in order to specify <dih
types>, <ref range> must be speciﬁed. The ’refvalsout’ and ’founddihout’ keywords can be used to print dihedrals
found in the reference and target structures respectively to ﬁles.

Examples

Assign polyproline II structure to residues 1 through 13:

makestructure pp2:1-13

Make residues 1 and 12 ’extended’, residues 6 and 7 a type I’ turn, and two custom assignments, one (custom1)
for residues 2-5, the other (custom2) for residues 8-11:

makestructure extended:1,12 \

custom1:2-5:-80.0:130.0:-130.0:140.0 \
typeI’:6-7 \
custom2:8-11:-140.0:170.0:-100.0:140.0

Assign residue 5 phi 90 degrees, residues 6 and 7 phi=-70 and psi=60 degrees:

makestructure customdih:5:phi:90 custom:6,7:-70:60

Create a new dihedral named chi1 and assign it a value of 35 degrees in residue 8:

makestructure chi1:8:N:CA:CB:CG:35

Assign ’extended’ structure to residues 1 and 12, a custom turn to residues 2-5 and 8-11, and a typeI’ turn to
residues 6-7:

makestructure extended:1,12 \

custom1:2-5:-80.0:130.0:-130.0:140.0 \
typeI’:6-7 \
custom1:8-11

Assign secondary structure from reference structure:

parm ../tz2.parm7
reference ../tz2.rst7
trajin pp2.rst7.save
makestructure "ref:1-13:tz2.rst7" rmsd reference
trajout fromref.pdb multi

32.11.45. mask

mask <mask> [maskout <filename>]

[ {maskpdb <filename> | maskmol2 <filename>}

[trajargs <comma-separated args>] ]

<mask> Atom mask to process.
maskout <ﬁlename> Write information on atoms in <mask> to <filename>.
maskpdb <ﬁlename> Write PDB of atoms in <mask> to <name>.X.
maskmol2 <ﬁlename> Write Mol2 of atoms in <mask> to <name>.X.
trajargs <comma-separated args> When writing output PDB/Mol2, additional

trajectory arguments to pass to the output trajectory.

For each frame determine all atoms that correspond to <mask>. This is most useful when using distance-based
masks, since the atoms in the mask are updated for every frame read in. If maskout is speciﬁed information on all
atoms in <mask> will be written to <ﬁlename> with format:

680

#Frame AtomNum Atom ResNum Res MolNum

32.11. Action Commands

where #Frame is the frame number, AtomNum is the number of the selected atom, Atom is the name of the selected
atom, ResNum is the residue number of the selected atom, Res is the residue name, and MolNum is the molecule
number of the selected atom.

If maskpdb or maskmol2 are speciﬁed a PDB/Mol2 ﬁle corresponding to <mask> will be written out every

frame with name “<name>.frame#”.

For example, to write out all residues within 3.0 Angstroms of residue 195 that are named WAT to

“Res195WAT.dat”, as well as write out corresponding PDB ﬁles:

mask “(:195<:3.0)&:WAT” maskout Res195WAT.dat maskpdb Res195WAT.pdb

To write all out atoms outside of 5.0 Angstroms of residues named ARG to PDB ﬁles with a chain ID of ’B’:

mask :ARG>@5.0 maskpdb Outside5Arg.pdb trajargs “chainid ’B’”

32.11.46. matrix

matrix [out <filename>] [start <#>] [stop|end <#>] [offset <#>]

[name <name>] [ byatom | byres [mass] | bymask [mass] ]
[ ired [order <#>] ]
[ {distcovar | idea} <mask1> ]
[ {dist | correl | covar | mwcovar} <mask1> [<mask2>] ]
[ dihcovar dihedrals <dataset arg> ]

[out <ﬁlename>] If specified, write matrix to <filename>.
[start <#>] [stop|end <#>] [offset <#>] Start, stop, and offset frames to use (as a

subset of all frames read in).

[name <name>] Name of the matrix dataset (for referral in subsequent analysis).
byatom Write results by atom (default).

This is the sole option for covar,

mwcovar, and ired.

byres Write results by calculating an average for each residue (mass weighted

if mass is specified).

bymask Write average over <mask1>, and if <mask2> is specified <mask1> x

<mask2> and <mask2> as well (mass weighted if mass is specified).

Calculate matrix of the speciﬁed type from input coordinate frames:

dist <mask1> [<mask2>] Distance matrix (default).

correl <mask1> [<mask2>] Correlation matrix (aka dynamic cross correlation[652]).

covar <mask1> [<mask2>] Coordinate covariance matrix.

mwcovar <mask1> [<mask2>] Mass-weighted coordinate covariance matrix.

distcovar <mask1> Distance covariance matrix.

idea <mask1> Isotropically Distributed Ensemble Analysis matrix.[653]

ired [order <#>] Isotropic Reorientational Eigenmode Dynamics matrix[654] with Legendre polynomials of spec-
iﬁed order (default 1). IRED vectors must have been speciﬁed previously with ’vector ired’ (see 32.11.84
on page 707).

dihcovar dihedrals <dataset arg> Dihedral covariance matrix. Dihedral data sets must have been previously
deﬁned with e.g. dihedral or multidihedral commands or read in externally with readdata and marked as
dihedrals.

681

32. cpptraj

Matrix dimensions will be of the order of N x M for dist, correl, idea, and ired, 2N x 2N for dihcovar, 3N x 3M
for covar and mwcovar, and N(N-1) x N(N-1) / 4 for distcovar (with N being the number of data sets in the case of
ired and dihcovar and the number of atoms in <mask1> otherwise, and M being the number of atoms in <mask2>
if speciﬁed or <mask1> otherwise). No mask is required for ired; the matrix will be made up of previously deﬁned
IRED vectors (see the vector command on page 707). Similarly no mask is required for dihcovar; dihedral data
sets must have been previously deﬁned. Only one mask can be used with distcovar and idea matrices (i.e. they
can be symmetric only), otherwise one or two masks can be used (for symmetric and full matrices respectively).
If two masks are speciﬁed the number of atoms covered by mask1 must be greater than or equal to the number of
atoms covered by mask2, and on output <mask1> corresponds to columns while <mask2> corresponds to rows.
Note that for backwards compatibility, output ﬁles written with ’out <ﬁlename>’ will have the options
’noheader noxcol square2d’ applied to them (see 32.6 on page 607 for more details). To prevent any of these
from taking effect, simply specify ’header’, ’xcol’, and/or ’nosquare2d’ after ’out <ﬁlename>’.
As a simple example, a distance matrix of all CA atoms is generated and output to ’distmat.dat’.

matrix dist @CA out distmat.dat

32.11.47. mindist

This functionality is now part of the nativecontacts command; see 32.11.53 on page 687.

32.11.48. minimage

minimage [<name>] <mask1> <mask2> [out <filename>] [geom] [maskcenter]

<name> Data set name.
<mask1> First atom mask.
<mask2> Second atom mask.
out <ﬁlename> File to write to.
geom (maskcenter only) If specified, use geometric center instead of center of

mass.

maskcenter Calculate distance from center of masks instead of between each

atom.

Data Sets Created:
<name> Minimum distance to an image in Ang.
<name>[A1] Atom number in mask 1 involved in minimum distance.
<name>[A2] Atom number in mask 2 involved in minimum distance.

Calculate the shortest distance to an image, i.e.
the distance to a neighboring unit cell, as well as the numbers
of the atoms involved in the distance. By default the distance between each atom in <mask1> and <mask2> is
considered; if maskcenter is speciﬁed the center of the masks is used. By convention, the lower atom number is
saved as A1 and the higher is saved as A2.

32.11.49. molsurf

molsurf [<name>] [<mask>] [out filename] [probe <probe_rad>]

[radii {gb | parse | vdw}] [offset <rad_offset>]

[<name>] Name of surface area data set.
[<mask>] Atoms to calculate surface area of.
[out <ﬁlename>] File to write values to.
[probe <probe_rad>] Probe radius (default 1.4 Angstrom).

682

32.11. Action Commands

[offset <rad_offset>] Add <rad_offset> to each atom radius (default 0.0).
[radii {gb|parse|vdw}] Specify radii to use:

gb GB radii (default).
parse PARSE radii.
vdw van der Waals radii.

Calculate the Connolly surface area[655] of atoms in <mask> (default all atoms if no mask speciﬁed) using rou-
tines from molsurf (originally developed by Paul Beroza) using the probe radius speciﬁed by probe (1.4 Å if not
speciﬁed). Note that if GB/VDW radii are not present in the topology ﬁle (e.g. for PDB ﬁles), then PARSE radii
can be used. Also note that this routine only calculate absolute surface areas, i.e.
it cannot be used to get the
contribution of a subset of atoms to overall surface area; if such functionality is needed try the surf command
( 32.11.77 on page 704).

32.11.50. multidihedral

multidihedral [<name>] <dihedral types> [resrange <range>] [out <filename>] [range360]

[dihtype <name>:<a0>:<a1>:<a2>:<a3>[:<offset>] ...]

Offset -2=<at0><at1> in previous res, -1=<at0> in previous res,

0=All <atX> in single res,
1=<at3> in next res, 2=<at2><at3> in next res.

<dihedral types> = alpha beta gamma delta epsilon zeta

nu0 nu1 nu2 nu3 nu4 h1p c2p chin
phi psi chip omega chi2 chi3 chi4 chi5

[<name>] Output data set name.
<dihedral types> Dihedral types to look for. Note that chip is ’protein chi’,

chin is ’nucleic chi’.

[resrange <range>] Residue range to look for dihedrals in. Default is all solute

residues.

[out <ﬁlename>] Output file name.
[range360] Wrap torsion values from 0.0 to 360.0 (default is -180.0 to 180.0).
[dihtype <name>:<a0>:<a1>:<a2>:<a3>[:<offset>] Search for a custom dihedral type

called <name> using atom names <a0>, <a1>, <a2>, and <a3>.
Offset: -2=<a0><a1> in previous res, -1=<a0> in previous res, 0=All <aX>
in single res, 1=<a3> in next res, 2=<a2><a3> in next res.

DataSet Aspects:
[<dihedral type>]:<#> Aspect corresponds to the dihedral type name (e.g.

[phi],

[psi], etc). The index is the residue number.

Note data sets are not generated until run is called.

Calculate speciﬁed dihedral angle types for residues in given range. By default, dihedral angles are identiﬁed

based on standard Amber atom names. The resulting data sets will have aspect equal to [<dihedral type>] and
index equal to residue #. To differentiate the chi angle, chip is used for proteins and chin for nucleic acids. For
example, to calculate all phi/psi dihedrals for residues 6 to 9:

multidihedral MyTorsions phi psi resrange 6-9 out PhiPsi_6-9.dat

This will generate data sets named MyTorsions[phi]:6, MyTorsions[psi]:6, MyTorsions[phi]:7, etc. Dihedrals
other than those deﬁned in <dihedral types> can be searched for using dihtype. For example to create a custom
dihedral type called chi1 using atoms N, CA, CB, and CG (all in the same residue), then search for and calculate
the dihedral in all residues:

multidihedral dihtype chi1:N:CA:CB:CG out custom.dat

683

32. cpptraj

32.11.51. multivector

multivector [<name>] [resrange <range>] name1 <name1> name2 <name2> [out <filename>]

[ired]

[<name>] Data set name.
[resrange <range>] Range of residues to look for vectors in.
name1 <name1> Name of first atom in each residue.
name2 <name2> Name of second atom in each residue.
[out <ﬁlename>] File to write results to.

Search for and calculate atomic vectors between atoms named <name1> and <name2> in residues speciﬁed by
the given <range>; each one is equivalent to the command ’vector <name1> <name2>’. For example, to
calculate all vectors between atoms named ’N’ and atoms named ’H’ in residues 5-20, storing the results in data
sets named NH and writing to NH.dat:

multivector NH name1 N name2 H ired out NH.dat resrange 5-20

32.11.52. nastruct

nastruct [<dataset name>] [resrange <range>] [naout <suffix>]

[noheader] [resmap <ResName>:{A,C,G,T,U} ...] [calcnohb]

[noframespaces] [baseref <file>] ...

[hbcut <hbcut>] [origincut <origincut>] [altona | cremer]
[zcut <zcut>] [zanglecut <zanglecut>] [groovecalc {simple | 3dna}]
[{ first | reference | ref <name> | refindex <#> | allframes | guessbp}]

[bptype {anti | para} ...]

[<dataset name>] Output data set name.
[resrange <range>] Residue range to search for nucleic acids in (default all).
[naout <sufﬁx>] File name suffix for output files; BP.<suffix> for base pair

parameters, BPstep.<suffix> for base pair step parameters, and
Helix.<suffix> for base pair step helical parameters.

[noheader] Do not print header to naout file.
[resmap <ResName>:{A,C,G,T,U}] Attempt to treat residues named <ResName> as if it

were A, C, G, T, or U; useful for residues with modifications or
non-standard residue names.
are present in <ResName>.

This will only work if enough reference atoms

[calcnohb] Calculate parameters between bases in base pairs even if no hydrogen

bonds present between them.

[noframespaces] If specified there will be no spaces between frames in the naout

files.

[baseref <ﬁle>] Specify a custom nucleic acid base reference.

One file per

custom residue; multiple ’baseref’ keywords may be present. See below for
details.

[hbcut <hbcut>] Distance cutoff (in Angstroms) for determining hydrogen bonds

between bases (default 3.5).

[origincut <origincut>] Distance cutoff (in Angstroms) between base pair axis

origins for determining which bases are eligible for base-pairing (default
2.5).

684

32.11. Action Commands

[altona] Use method of Altona & Sundaralingam to calculate sugar pucker (default,

see pucker command).

[cremer] Use method of Cremer and Pople to calculate sugar pucker (see pucker

command).

[zcut] Distance cutoff (in Angstroms) between base reference axes along the Z

axis (i.e. stagger) for determining base pairing (default 2).

[zanglecut] Angle cutoff (in degrees) between base reference Z axes for

determining base pairing (default 65).
[groovecalc] Groove width calculation method:

simple Use P-P distance for major groove, O4-O4 distance for minor groove.

Output to ’BP.<suffix>’.

3dna Use groove width calculation of El Hassan and Calladine[656].

Output

to ’BPstep.<suffix>’.

[ﬁrst] Use first frame to determine base pairing (default).
[reference | reﬁndex <#> | ref <name>] Reference structure to use to determine base

pairing.

[allframes] If specified determine base pairing each frame.
[guessbp [bptype{anti|para}]] If specified base pairing will be determined based on

selected NA strands. It is assumed that consecutive strands will be
base-paired and that they are arranged 5’ to 3’. The specific type of base
pairing between strands can be specified with one or more ’bptype’
arguments.

DataSets Created:
<name>[pucker]:X Base X (residue number) sugar pucker.
Base pairs:
<name>[shear]:X Base pair X (starting from 1) shear.
<name>[stretch]:X Base pair stretch.
<name>[stagger]:X Base pair stagger.
<name>[buckle]:X Base pair buckle.
<name>[prop]:X Base pair propeller.
<name>[open]:X Base pair opening.
<name>[hb]:X Number of WC hydrogen bonds between bases in base pair.
<name>[bp]:X Contain 1 if bases are base paired, 0 otherwise.
<name>[major]:X (If groovecalc simple) Major groove width calculated between P

atoms of each base.

<name>[minor]:X (If groovecalc simple) Minor groove width calculated between O4

atoms of each base.

Base pair steps:
<name>[shift]:X Base pair step X (starting from 1) shift.
<name>[slide]:X Base pair step slide.
<name>[rise]:X Base pair step rise.
<name>[title]:X Base pair step tilt.
<name>[roll]:X Base pair step roll.
<name>[twist]:X Base pair step twist.

685

32. cpptraj

<name>[zp]:X Base pair step Zp value.
<name>[major]:X (If groovecalc 3dna) Major groove width, El Hassan and

Calladine.

<name>[minor]:X (If groovecalc 3dna) Minor groove width, El Hassan and

Calladine.

Helical steps:

<name>[xdisp]:X Helical step X (starting from 1) X displacement.
<name>[ydisp]:X Helical Y displacement.
<name>[hrise]:X Helical rise.
<name>[incl]:X Helical inclination.
<name>[tip]:X Helical tip.
<name>[htwist]:X Helical twist.

Note that data sets are not created until base pairing is determined.

Calculate basic nucleic acid (NA) structure parameters for all residues in the range speciﬁed by resrange (or all

NA residues if no range speciﬁed). Residue names are recognized with the following priority: standard Amber
residue names DA, DG, DC, DT, RA, RG, RC, and RU; 3 letter residue names ADE, GUA, CYT, THY, and URA;
and ﬁnally 1 letter residue names A, G, C, T, and U. Non-standard/modiﬁed NA bases can be recognized by using
the resmap keyword. For example, to make cpptraj recognize all 8-oxoguanine residues named ’8OG’ as a
guanine-based residue:

nastruct naout nastruct.dat resrange 274-305 resmap 8OG:G

The resmap keyword can be speciﬁed multiple times, but only one mapping per unique residue name is allowed.
Note that resmap may fail if the residue is missing heavy atoms normally present in the speciﬁed base type.

Base pairs are determined either once from the ﬁrst frame or from a reference structure, or can be determined
each frame if allframes is speciﬁed. Base pairing is determined ﬁrst by base reference axis origin distance, then
by stagger, then by angle between base Z axes, then ﬁnally by hydrogen bonding (at least one hydrogen bond must
be present). Base pair parameters will only be written for determined base pairs. Both Watson-Crick and other
types of base pairing can be detected. Note that although all possible hydrogen bonds are searched for, only WC
hydrogen bonds are reported in the BP.<sufﬁx> ﬁle.

The procedure used to calculate NA structural parameters is the same as 3DNA[657], with algorithms adapted
from Babcok et al.[658] and reference frame coordinates from Olson et al.[659]. Given the same base pairs are
determined, cpptraj nastruct gives the exact same numbers as 3DNA.

Calculated NA structure parameters are written to three separate ﬁles, the sufﬁx of which is speciﬁed by naout.

Base pair parameters (shear, stretch, stagger, buckle, propeller twist, opening, # WC hydrogen bonds, base
pairing, and simple groove widths) are written to BP.<sufﬁx>, along with the number of WC hydrogen bonds
detected. Base pair step parameters (shift, slide, rise, tilt, roll, twist, Zp, and El Hassan and Calladine groove
widths) are written to BPstep.<sufﬁx>, and helical parameters (X-displacement, Y-displacement, rise, inclination,
tip, and twist) are written to Helix.<sufﬁx>. If noheader is speciﬁed a header will not be written to the output
ﬁles. Note that although base puckering is calculated, it is not written to an output ﬁle by default. You can output
pucker to a ﬁle via the create or write/writedata commands after the data has been generated, e.g.:

nastruct NA naout nastruct.dat resrange 1-3,28-30
run
writedata NApucker.dat NA[pucker]

Custom Nucleic Acid Base References

Users can now specify baseref <ﬁle> to load a custom nucleic acid base reference. The base reference ﬁles are

white-space delimited, begin with the line NASTRUCT REFERENCE, and have the following format:

686

32.11. Action Commands

NASTRUCT REFERENCE
<base character> <res name 0> [<res name 1> ...]
<atom name> <X> <Y> <Z> <HB type> <RMS fit>
...

There is a line for each reference atom. Lines beginning with ’#’ are ignored as comments.

<base character> Used to identify the underlying base type: A G C T or U. If none of these, it will be considered

an unknown residue (which just means WC hydrogen bonding will not be identiﬁed).

<res name X> Speciﬁes what residue names this reference corresponds to. There must be at least one residue

name. There can be any number of these speciﬁed.

<atom name> A reference atom name.

<X> <Y> <Z> The X Y and Z coordinates of the reference atom.

<HB type> Denotes if and how the atom participates in hydrogen bonding. Can be ’d’onor, ’a’cceptor, or ’n’one

(or the numbers 1, 2, 0 respectively). Only the ﬁrst character of the word actually matters.

<RMS ﬁt> Denotes whether the atom is involved in RMS-ﬁtting.

Here is an example for GUA:

NASTRUCT REFERENCE
G G G5 G3
# Modified into format readable by cpptraj nastruct
C1’ -2.477
N9 -1.289
0.023
C8
0.870
N7
0.071
C5
C6
0.424
O6
1.554
N1 -0.700
C2 -1.999
N2 -2.949
N3 -2.342
C4 -1.265

0
0.000 0
5.399
1
0.000 0
4.551
0.000 0
1
4.962
0.000 accept 1
3.969
1
0.000 0
2.833
0.000 0
1
1.460
0.000 accept 0
0.955
1
0.000 donor
0.641
1.087
0.000 0
1
0.139 -0.001 donor 0
2.364
0.001 accept 1
1
0.000 0
3.177

32.11.53. nativecontacts

nativecontacts [<mask1> [<mask2>]] [writecontacts <outfile>] [resout <resfile>]

[noimage] [distance <cut>] [out <filename>] [includesolvent]
[ first | reference | ref <name> | refindex <#> ]
[resoffset <n>] [contactpdb <file>] [pdbcut <cut>] [mindist] [maxdist]
[name <dsname>] [byresidue] [map [mapout <mapfile>]]
[series [seriesout <file>]]
[savenonnative [seriesnnout <file>] [nncontactpdb <file>]]
[resseries { present | sum } [resseriesout <file>]] [skipnative]

<mask1> First mask to calculate contacts for.
[<mask2>] (Optional) Second mask to calculate contacts for.
[writecontacts <outﬁle>] Write information on native contacts to <outfile> (STDOUT

if not specified).

[resout <resﬁle>] File to write contact residue pairs to.

687

32. cpptraj

[noimage] Do not image distances.
[distance <cut>] Distance cutoff for determining native contacts in Angstroms

(default 7.0 Ang).

[out <ﬁlename>] File to write number of native contacts and non-native contacts.
[includesolvent] By default solvent molecules are ignored; this will explicitly

include solvent molecules.

[ﬁrst | reference | ref <name> | reﬁndex <#>] Reference structure to use for

determining native contacts.

[resoffset <n>] (byresidue only) Ignore contacts between residues spaced less than

<n> residues apart in sequence.

[contactpdb <ﬁle>] Write PDB with B-factor column containing relative contact

strength for native contacts (strongest is 100.0).

[pdbcut <cut>] If writing contactpdb, only write contacts with relative contact

strength greater than <cut>.

[mindist] If specified, determine the minimum distance between any atoms in the

mask(s).

[maxdist] If specified, determine the maximum distance between any atoms in the

mask(s).

[name <dsname>] Data set name.
[byresidue] Write out the contact map by residue instead of by atom.
[map] Calculate matrices of native contacts ([nativemap]) and non-native

contacts ([nonnatmap]). These matrices are normalized by the total number
of frames, so that a value of 1.0 means “contact always present”. If
byresidue specified, the values for each individual atom pair are summed
over the residues they belong to (this means for byresidue values greater
than 1.0 are possible).

[mapout <mapﬁle>] Write native/non-native matrices to ’native.<mapfile>’ and

’nonnative.<mapfile>’ respectively.

[series] Calculate native contact time series data, 1 for contact present and 0

otherwise.

[seriesout <ﬁle>] Write native contact time series data to file.
[savenonnative] Save non-native contacts; series must also be specified.

This is

enabled by default if skipnative specified.
[seriesnnout <ﬁle>] Write non-native contact time series data to file.
[nncontactpdb <ﬁle>] Write PDB with B-factor column containing relative

contact strength for non-native contacts (strongest is 100.0).

[resseries {present | sum} Create contacts time series by residue; series must also

be specified.
present Record a 1 if any contact is present and 0 if no contact is present

for the residue pair.

sum The sum of all individual contacts is recorded for the residue pair.
[resseriesout <ﬁle>] Write residue time series data to <file>.

[skipnative] If specified, skip native contacts determination, i.e.

treat all

sonctacts as non-native contacts. Implies savenonnative.

Data Sets Created:
<dsname>[native] Number of native contacts.

688

32.11. Action Commands

<dsname>[nonnative] Number of non-native contacts.
<dsname>[mindist] (mindist only) Minimum observed distance each frame.
<dsname>[maxdist] (maxdist only) Maximum observed distance each frame.
<dsname>[nativemap] (map only) Native contacts matrix (2D).
<dsname>[nonnatmap] Non-native contacts matrix (2D).
<dsname>[NC] Native contacts time series.
<dsname>[NN] Non-native contacts time series.
<dsname>[NCRES] Residue native contacts time series.
<dsname>[NNRES] Residue non-native contacts time series.

Deﬁne and track “native” contacts as determined by a simple distance cut-off, i.e. any atoms which are closer than
<cut> in the speciﬁed reference frame (the ﬁrst frame if no reference speciﬁed) are considered a native contact. If
one mask is provided, contacts are looked for within <mask1>; if two masks are provided, only contacts between
atoms in <mask1> and atoms in <mask2> are looked for (useful for determining intermolecular contacts). By
default only native contacts are tracked. This can be changed by specifying the savenonnative keyword or by
specifying skipnative. The time series for contacts can be saved using the series keyword; these can be further
consolidated by residue using the resseries keyword. When using <resseries> the data set index is calculated as
(r2 * nres) + r1 so that indices can be matched between native/non-native contact pairs. Non-native residue contact
legends have an nn_ preﬁx.

Native contacts that are found are written to the ﬁle speciﬁed by writecontacts (or STDOUT) with format:

# Contact Nframes Frac. Avg Stdev

Where Contact takes the form ’:<residue1 num>@<atom name>_:<residue2 num>@<atom name>, Nframes is
the number of frames the contact is present, Frac. is the total fraction of frames the contact is present, Avg is the
average distance of the contact when present, and Stdev is the standard deviation of the contact distance when
present. If resout is speciﬁed the total fraction of contacts is printed for all residue pairs having native contacts
with format:

#Res1 #Res2 TotalFrac Contacts

Where #Res1 is the ﬁrst residue number, #Res2 is the second residue number, TotalFrac is the total fraction of
contacts for the residue pair, and Contacts is the total number of native contacts involved with the residue pair.
Since TotalFrac is calculated for each pair as the sum of each contact involving that pair divided by the total
number of frames, it is possible to have TotalFrac values greater than 1 if the residue pair includes more than 1
native contact.

During trajectory processing, non-native contacts (i.e. any pair satisfying the distance cut-off which is not
already a native contact) are also searched for. The time series for native contacts can be saved as well, with 1 for
contact present and 0 otherwise (similar to the hbond command). This data can be subsequently analyzed using
e.g. 32.12.19 on page 731.

Contact maps (matrices) are generated for native and non-native contacts. If byresidue is speciﬁed, contact
maps are summed over residues, and contacts between residues spaced <resoffset> residues apart in sequence are
ignored.

If contactpdb is speciﬁed a PDB is generated containing relative contact strengths in the B-factor column. The
relative contact strength is normalized so that a value of 100 means that atom participated in the most contacts with
other atoms.

Example command looking for contacts between residues 210 to 260 and residue named NDP, using reference

structure ’FtuFabI.WT.pdb’ to deﬁne native contacts:

parm FtuFabI.parm7
trajin FtuFabI.nc
reference FtuFabI.WT.pdb

689

32. cpptraj

nativecontacts name NC1 :210-260&!@H= :NDP&!@H= \

byresidue out nc.all.res.dat mindist maxdist \
distance 3.0 reference map mapout resmap.gnu \
contactpdb Loop-NDP.pdb \
series seriesout native.dat

32.11.54. outtraj

outtraj <filename> [ trajout args ]

[maxmin <dataset> min <min> max <max>] ...

<ﬁlename> Output trajectory file name.
[trajout args] Output trajectory arguments (see 32.10.5 on page 639).
[maxmin <dataset> min <min> max <max>] Only write frames to <filename> if values

in <dataset> for those frames are between <min> and <max>. Can be
specified for one or more data sets.

The outtraj command is similar in function to trajout, and takes all of the same arguments. However, instead of
writing a trajectory frame after all actions are complete outtraj writes the trajectory frame at its position in the
Action queue. For example, given the input:

trajin mdcrd.crd
trajout output.crd
outtraj BeforeRmsd.crd
rms R1 first :1-20@CA out rmsd.dat
outtraj AfterRmsd.crd

three trajectories will be written: output.crd, BeforeRmsd.crd, and AfterRmsd.crd. The output.crd and After-
Rmsd.crd trajectories will be identical, but the BeforeRmsd.crd trajectory will contain the coordinates of mdcrd.crd
before they are RMS-ﬁt.

The maxmin keyword can be used to restrict output using one more more data sets. For example, to only write

frames for which the RMSD value is between 0.7 and 0.8:

trajin tz2.truncoct.nc
rms R1 first :2-11
outtraj maxmin.crd maxmin R1 min 0.7 max 0.8

32.11.55. pairdist

pairdist out <filename> mask <mask> [delta <resolution>]

Calculate pair distribution function. In the following, defaults are given in parentheses. The out keyword speciﬁes
output ﬁle for histogram: distance, P(r), s(P(r)). The mask option speciﬁes atoms for which distances should be
computed. The delta option speciﬁes resolution. (0.1 Å)

32.11.56. pairwise

pairwise [<name>] [<mask>] [out <filename>] [cuteelec <ecut>] [cutevdw <vcut>]

[ reference | ref <name> | refindex <#> ] [cutout <cut mol2 prefix>]

[vmapout <vdw map>] [emapout <elec map>] [avgout <avg file>]
[eout <eout file>] [pdbout <pdb file>] [scalepdbe] [printmode {only|or|and|}]

[<name>] Data set name; van der Waals energy will get aspect [EVDW] and

electrostatic energy will get aspect [EELEC].

[<mask>] Atoms to calculate energy for.

690

32.11. Action Commands

[out <ﬁlename>] File to write total EELEC and EVDW to.
[eout <eout ﬁle>] File to write individual EELEC and EVDW interactions to.
[reference | ref <name> | reﬁndex <#> ] Specify a reference to compare frames to (i.e.

calculate Eref - Eframe).

[cuteelec <cut>] Only report interaction EELEC (or delta EELEC) if absolute value

is greater than <ecut> (default 1.0 kcal/mol).

[cutevdw <cutv>] Only report interaction EVDW (or delta EVDW) if absolute value

is greater than <vcut> (default 1.0 kcal/mol).

[cutout <cut mol2 preﬁx>] Write out mol2 containing only atom pairs which satisfy

<ecut> and <vcut>.

[vmapout <vdw map>] Write out interaction EVDW (or delta EVDW) matrix to file

<vdw map>.

[emapout <elec map>] Write out interaction EELEC (or delta EELEC) matrix to file

<elec map>.

[avgout <avg ﬁle>] Print average interaction EVDW|EELEC (or average delta

EVDW|EELC) to <avg file>.

[pdbout <pdb ﬁle>] Write PDB with EVDW|EELEC in occupancy|B-factor columns to

<pdb file>.

[scalepdbe] Scale energies written to PDB from 0 to 100.
[printmode {only|or|and}] Control when/how average energies are written

Data Sets Created:
<name>[EELEC] Electrostatic energy in (kcal/mol).
<name>[EVDW] van der Waals energy in (kcal/mol).
<name>[VMAP] van der Waals energy matrix.
<name>[EMAP] Electrostatic energy matrix.

This action has two related functions: 1) Calculate pairwise (i.e. non-bonded) energy (in kcal/mol) for atoms in
<mask>, or 2) Compare pairwise energy of frames to a reference frame. This calculation does use an exclusion
list but is not periodic.

When comparing to a reference frame, the eout ﬁle will contain the differences for each individual interaction
(i.e. Eref - Eframe), otherwise the eout ﬁle will contain the absolute value of each individual interaction. The
cuteelc and cutevdw keywords can be used to restrict printing of individual interactions to those for which the
absolute value is above a cutoff. The VMAP and EMAP matrix elements will contain these values as well (differ-
ences for reference, absolute value otherwise) averaged over all frames. The avgout ﬁle will contain only these
values averaged over all frames that satisfy the cutoffs. The printmode keyword controls when the average ener-
gies are written: only means only average energy components that satisfy cutoffs will be printed, or means that
both energy components will be printed if either satistfy a cutoff, and and means that both energy components will
be written only if both satisfy the cutoffs.

The cutout keyword can be used to write out MOL2 ﬁles each frame named ’<cut mol2 preﬁx>.evdw.mol2.X’
and ’<cut mol2 preﬁx>.eelec.mol2.X’ (where X is the frame number) containing only atoms with energies that
satisfy the cutoffs. Similarly, the pdbout keyword can be used to write out a PDB ﬁle (with 1 MODEL per frame).
The occupancy and B-factor columns will contain the total van der Waals and electrostatic energy for each atom if
cutoffs are satisﬁed, or 0.0 otherwise.

32.11.57. principal

principal [<mask>] [dorotation] [out <filename>] [name <dsname>]

[<mask>] Mask of atoms used to determine principal axes (default all).

691

32. cpptraj

[dorotation] Align coordinates along principal axes.
[out <ﬁlename>] Write resulting eigenvalues/eigenvectors to <filename>.
[name <dsname>] Data set name (3x3 matrices).

Data Sets Created (name keyword only):
<dsname>[evec] Eigenvectors (3x3 matrix, row-major).
<dsname>[eval] Eigenvalues (vector).

Determine principal axes of each frame determined by diagonalization of the inertial matrix from the coordinates
of the speciﬁed atoms. At least one of dorotation, out, or name must be speciﬁed. The resulting eigenvectors are
sorted from largest eigenvalue to smallest, and the corresponding axes labelled using the cpptraj convention of X
> Y > Z (similar to ’vector principal’). If out is speciﬁed the eigenvectors and eigenvalues will be written for
each frame N with format:

<N> EIGENVALUES: <EX> <EY> <EZ>
<N> EIGENVECTOR 0: <Xx> <Xy> <Xz>
<N> EIGENVECTOR 1: <Yx> <Yy> <Yz>
<N> EIGENVECTOR 2: <Zx> <Zy> <Zz>

NOTE: The eigenvector 3x3 matrix data set could subsequently be used e.g. with the rotate action.

Example: Align system (residues 1-76) along principle axes:

parm myparm.parm7
trajin protein.nc
principal :1-76 dorotation out principal.dat

32.11.58. projection

projection [<name>] evecs <dataset name> [out <outfile>] [beg <beg>] [end <end>]

[<mask>] [dihedrals <dataset arg>]
[start <start>] [stop <stop>] [offset <offset>]

[<name>] Output data set name.
evecs <dataset name> Data set containing eigenvectors (modes).
[out <outﬁle>] Write projections to <outfile>.
[beg <beg>] First eigenvector/mode to use (default 1).
[end <end>] Final eigenvector/mode to use (default 2).
[<mask>] (Not dihedral covariance) Mask of atoms to use in projection; MUST

CORRESPOND TO HOW EIGENVECTORS WERE GENERATED.

[dihedrals <dataset arg>] (Dihedral covariance only) Dihedral data sets to use in

projection; MUST CORRESPOND TO HOW EIGENVECTORS WERE GENERATED.

[start <start>] Frame to start calculating projection.
[stop <stop>] Frame to stop calculating projection.
[offset <offset>] Frames to skip between projection calculations.

Data Sets Created:
DataSet indices correspond to mode #.
<name> (All execpt IDEA) Projection data set.
<name>[X] X component of mode (IDEA modes only).
<name>[Y] Y component of mode (IDEA modes only).

692

32.11. Action Commands

<name>[Z] Z component of mode (IDEA modes only).
<name>[R] Magnitude of mode (IDEA modes only).

Projects snapshots onto eigenvectors obtained by diagonalizing covariance or mass-weighted covariance matrices.
Eigenvectors are taken from previously generated (e.g. with diagmatrix) or previously read-in (e.g. with readdata)
eigenvectors with name <dataset name>. The user has to make sure that the atoms selected by <mask> agree with
the ones used to calculate the modes (i.e., if mask = ’@CA’ was used in the “matrix” command, mask = ’@CA’
needs to be set here as well). See 32.13 on page 750 for examples using the projection command.

32.11.59. pucker

pucker [<name>] <mask1> <mask2> <mask3> <mask4> <mask5> [<mask6>] [geom]

[out <filename>] [altona | cremer] [amplitude] [theta]

[range360] [offset <offset>]

<name> Output data set name.
<maskX> Five (optionally six) atom masks selecting atom(s) to calculate pucker

for.

[geom] Use geometric center of atoms in <maskX> (default is center of mass).
[out <ﬁlename>] Output file name.
[altona] Use method of Altona & Sundaralingam (5 masks only).
[cremer] Use method of Cremer and Pople (5 or 6 masks). This is the default

when 6 masks are specified.

[amplitude] Also calculate amplitude.
[theta] (6 masks only) Also calculate theta.
[range360] Wrap pucker values from 0.0 to 360.0 (default is -180.0 to 180.0).
[offset <offset>] Add <offset> to pucker values.

Data Sets Created:

<name> Pucker in degrees.
<name>[Amp] Amplitude (if amplitude was specified).
<name>[Theta] Theta (if theta and 6 masks were specified).

Calculate the pucker (in degrees) for atoms in <mask1>, <mask2>, <mask3>, <mask4>, <mask5> using the method
of Altona & Sundarlingam[660, 661] (default for 5 masks, or if altona speciﬁed), or the method of Cremer &
Pople[662] (default for 6 masks, or if cremer is speciﬁed). If the amplitude or theta keywords are given, am-
plitudes/thetas (also in degrees) will be calculated in addition to pucker. The results from pucker can be further
analyzed with the statistics analysis.

By default, pucker values are wrapped to range from -180 to 180 degrees. If the range360 keyword is speciﬁed
values will be wrapped to range from 0 to 360 degrees. Note that the Cremer & Pople convention is offset from
Altona & Sundarlingam convention (with nucleic acids) by +90.0 degrees; the offset keyword will add an offset
to the ﬁnal value and so can be used to convert between the two. For example, to convert from Cremer to Altona
specify “offset 90”.

To calculate nucleic acid pucker specify C1’ ﬁrst, followed by C2’, C3’, C4’ and O4’. For example, to

calculate the sugar pucker for nucleic acid residues 1 and 2 using the method of Altona & Sundarlingam, with
ﬁnal pseudorotation values ranging from 0 to 360:

pucker p1 :1@C1’ :1@C2’ :1@C3’ :1@C4’ :1@O4’ range360 out pucker.dat
pucker p2 :2@C1’ :2@C2’ :2@C3’ :2@C4’ :2@O4’ range360 out pucker.dat

693

32. cpptraj

32.11.60. radgyr | rog

radgyr [name>] [<mask>] [out <filename>] [mass] [nomax] [tensor]

[<name>] Data set name.
[<mask>] Atoms to calculate radius of gyration for; default all atoms.
[out <ﬁlename>] Write data to <filename>.
[mass] Mass-weight radius of gyration.
[nomax] Do not calculate maximum radius of gyration.
[tensor] Calculate radius of gyration tensor, output format ’XX YY ZZ XY XZ YZ’.

Data Sets Created:
<name> Radius of gyration in Ang.
<name>[Max] Max radius of gyration in Ang.
<name>[Tensor] Radius of gyration tensor; format ’XX YY ZZ XY XZ YZ’.

Calculate the radius of gyration of speciﬁed atoms. For example, to calculate only the mass-weighted radius of
gyration (not the maximum) of the non-hydrogen atoms of residues 4 to 10 and print the results to “RoG.dat”:

radgyr :4-10&!(@H=) out RoG.dat mass nomax

32.11.61. radial | rdf

radial [out <outfilename>] <spacing> <maximum> <solvent mask1>

[<solute mask2>] [noimage] [density <density> | volume] [<dataset name>]
[intrdf <file>] [rawrdf <file>]
[{{center1|center2|nointramol} | [byres1] [byres2] [bymol1] [bymol2]}]]

[out <outﬁlename>] File to write RDF to.
<spacing> Bin spacing, required.
<maximum> Max bin value, required.
<solvent mask1> Atoms to calculate RDF for, required.
[<solute mask2>] (Optional) If specified calculate RDF of all atoms in <solvent

mask1> to each atom in <solute mask2>.

[noimage] Do not image distances.
[density <density>] Use density value of <density> for normalization (default

0.033456 molecules Å−3).

[volume] Determine density for normalization from average volume of input

frames.

[<setname>] Name of output data sets.
[center1] Calculate RDF from geometric center of atoms in <solvent mask1> to all

atoms in <solute mask2>.

[center2] Calculate RDF from geometric center of atoms in <solute mask2> to all

atoms in <solvent mask1>.

[nointramol] Ignore intra-molecular distances.
[intrdf <ﬁle>] Calculate integral of RDF bin values (averaged over # of frames but

otherwise not normalized) and write to <file> (can be same as
<output_filename>).

[rawrdf <ﬁle>] Write raw (non-normalized) RDF values to <file>.

694

32.11. Action Commands

[byres1] Calculate using the centers of mass of each residue in the first mask.
[bymol1] Calculate using the centers of mass of each molecule in the first mask.
[byres2] Calculate using the centers of mass of each residue in the second mask.
[bymol2] Calculate using the centers of mass of each molecule in the second

mask.

DataSet Aspects:
<setname> The radial distribution function.
<setname>[int] (intrdf only) Integral of RDF bin values.
<setname>[raw] (rawrdf only) Raw (non-normalized) RDF values.

Calculate the radial distribution function (RDF, aka pair correlation function) of atoms in <solvent mask1> (note
that this mask does not need to be solvent, but this nomenclature is used for clarity). If an optional second mask
(<solute mask2>) is given, calculate the RDF of ALL atoms in <solvent mask1> to EACH atom in <solute
mask2>.
If desired, the geometric center of atoms in <solvent mask1> or <solute mask2> can be used by
specifying the center1 or center2 keywords respectively, or alternatively intra-molecular distances can be ignored
by specifying the nointramol keyword.

The RDF is calculated from the histogram of the number of particles found as a function of distance R, normal-

ized by the expected number of particles at that distance. The normalization is calculated from:

(cid:16)
(R + dR)3 − R3(cid:17)

Density∗ 4π
3

where dR is equal to the bin spacing. Some care is required by the user in order to normalize the RDF correctly.
The default density value is 0.033456 molecules Å−3, which corresponds to a density of water approximately equal
to 1.0 g mL−1. To convert a standard density in g mL−1, multiply the density by 0.6022
, where Mr is the mass of the
Mr
molecule in atomic mass units. Alternatively, if the volume keyword is speciﬁed the density is determined from
the average volume of the system over all Frames.

Note that correct normalization of the RDF depends on the number of atoms in each mask; if multiple topology
ﬁles are being processed that result in changes in the number of atoms in each mask, the normalization will be off.

32.11.62. randomizeions

randomizeions <mask> [around <mask> by <distance>] [overlap <value>]

[noimage] [seed <value>]

This can be used to randomly swap the positions of solvent and single atom ions. The “overlap” speciﬁes the
minimum distance between ions, and the “around” keyword can be used to specify a solute (or set of atoms)
around which the ions can get no closer than the distance speciﬁed. The optional keywords “noimage” disable
imaging and “seed” update the random number seed. An example usage is

randomizeions @NA around :1-20 by 5.0 overlap 3.0

The above will swap Na+ ions with water getting no closer than 5.0 Å from residues 1 – 20 and no closer than
3.0 Å from any other Na+ ion.

32.11.63. replicatecell

replicatecell [out <traj filename>] [parmout <parm filename>] [name <dsname>]

{ all | dir <XYZ> [dir <XYZ> ...] } [<mask>]

out <traj ﬁlename> Write replicated cell to output trajectory file.
parmout <parm ﬁlename> Write replicated cell topology to topology file. This

file will not be viable to use for simulations.

695

32. cpptraj

name <dsname> If specified save replicated cell to COORDS data set.
all Replicate cell once in all possible directions.
dir <XYZ> Repicate cell once in specified directions.

<XYZ> should consist of 3
numbers with no spaces in between them and are restricted to values of -1,
1, and 0. May be specified more than once.

<mask> Mask of atoms to replicate.

Create a trajectory where the unit cell is replicated in 1 or more directions (up to 27). The resulting coordinates and
topology can be written to a trajectory/topology ﬁle. They can also be saved as a COORDS data set for subsequent
processing. Currently replication is only allowed 1 axis length in either direction. The all keyword will replicate
the cell once in all directions. The dir keyword can be used to restrict replication to speciﬁc directions, e.g. ’dir
10-1’ would replicate the cell once in the +X, -Z directions.

For example, to replicate a cell in all directions, writing out to NetCDF trajectory cell.nc:

parm ../tz2.truncoct.parm7
trajin ../tz2.truncoct.nc
replicatecell out cell.nc parmout cell.parm7 all

32.11.64. rms | rmsd

rmsd [<name>] <mask> [<refmask>] [out <filename>] [mass]

[nofit | norotate | nomod]
[savematrices [matricesout <file>]]
[savevectors {combined|separate} [vecsout <file>]]
[ first | reference | ref <name> | refindex <#> | previous |

reftraj <name> [parm <name> | parmindex <#>] ]

[perres perresout <filename> [perresavg <avgfile>]

[range <resRange>] [refrange <refRange>]
[perresmask <additional mask>] [perrescenter] [perresinvert]

[<name>] Output data set name.
[<mask>] Mask of atoms to calculate RMSD for; if not specified, calculate for

all atoms.

[<refmask>] Reference mask; if not specified, use <mask>.
[out <ﬁlename>] Output data file name.
[mass] Mass-weight the RMSD calculation.
[noﬁt] Do not perform best-fit RMSD.
[norotate] If calculating best-fit RMSD, translate but do not rotate coordinates.
[nomod] If calculating best-fit RMSD, do not modify coordinates.
[savematrices] If specified save rotation matrices to data set with aspect [RM].

matricesout <ﬁle> Write rotation matrices to specified file.

[savevectors {combined|separate}] If specified save translation vectors: combined

means save target-to-origin plus the origin-to-reference translation
vectors, separate means save target-to-origin as Vx, Vy, Vz and save
origin-to-reference as Ox Oy Oz in the output vector data set.
vecsout <ﬁle> Output translation vector data set to <file>.

Reference keywords:
ﬁrst Use the first trajectory frame processed as reference.
reference Use the first previously read in reference structure (refindex 0).

696

32.11. Action Commands

ref <name> Use previously read in reference structure specified by filename/tag.
reﬁndex <#> Use previously read in reference structure specified by <#> (based

on order read in).

previous Use frame prior to current frame as reference.
reftraj <name> Use frames from COORDS set <name> or read in from trajectory file

<name> as references. Each frame from <name> is used in turn, so that
frame 1 is compared to frame 1 from <name>, frame 2 is compared to frame 2
from <name> and so on. If <trajname> runs out of frames before processing
is complete, the last frame of <trajname> continues to be used as the
reference.
parm <parmname> | parmindex <#> If reftraj specifies a trajectory file,

associate it with specified topology; if not specified the first
topology is used.

Per-residue RMSD keywords:
perres Activate per-residue no-fit RMSD calculation.
perresout <perresﬁle> Write per-residue RMSD to <perresfile>.
perresavg <avgﬁle> Write average per-residue RMSDs to <avgfile>.
range <res range> Calculate per-residue RMSDs for residues in <res range>

(default all solute residues).

refrange <ref range> Calculate per-residue RMSDs to reference residues in <ref

range> (use <res range> if not specified).

perresmask <additional mask> By default residues are selected using the mask ’:X’

where X is residue number; this appends <additional mask> to the mask
expression.

perrescenter Translate residues to a common center of mass prior to calculating

RMSD.

perresinvert Make X-axis residue number instead of frame number.
Data Sets Created:
<name> RMSD of atoms in mask to reference.
<name>[RM] (savematrices only) Rotation matrices of target to reference.
<name>[TV] (savevectors only) Translation vector.
<name>[res] (perres only) Per-residue RMSDs; index is residue number.
<name>[Avg] (perres only) Average per-residue RMSD for each residue.
<name>[Stdev] (perres only) Standard deviation of RMSD for each residue.

Note that perres data sets are not generated until run is called.

Calculate the coordinate RMSD of input frames to a reference frame (or reference trajectory). Both <mask> and

<refmask> must specify the same number of atoms, otherwise an error will occur.

For example, say you have a trajectory and you want to calculate RMSD to two separate reference structures.
To calculate the best-ﬁt RMSD of the C, CA, and N atoms of residues 1 to 20 in each frame to the C, CA, and N
atoms of residues 3 to 23 in StructX.crd, and then calculate the no-ﬁt RMSD of residue 7 to residue 7 in another
structure named Struct-begin.rst7, writing both results to Grace-format ﬁle “rmsd1.agr”:

reference StructX.crd [structX]
reference md_begin.rst7 [struct0]
rmsd BB :1-20@C,CA,N ref [structX] :3-23@C,CA,N out rmsd1.agr
rmsd Res7 :7 ref [struct0] out rmsd1.agr nofit

697

32. cpptraj

Per-residue RMSD calculation

If the perres keyword is speciﬁed, after the initial RMSD calculation the no-ﬁt RMSD of speciﬁed residues is

also calculated. So for example:

rmsd :10-260 reference perres perresout PRMS.dat range 190-211 perresmask &!(@H=)

will ﬁrst perform a best-ﬁt RMSD calculation to the ﬁrst speciﬁed reference structure using residues 10 to 260,
then calculate the no-ﬁt RMSD of residues 190 to 211 (excluding any hydrogen atoms), writing the results to
PRMS.dat. Two additional recommendations for the ’perres’ option: 1) try not including backbone atoms by
using the ’perresmask’ keyword, e.g. "perresmask &!@H,N,CA,HA,C,O", and 2) try using the ’perrescenter’
keyword, which centers each residue prior to the ’noﬁt’ calculation; this is useful for isolating changes in residue
conformation.

32.11.65. rms2d | 2drms

Although the ’rms2d’ command can still be speciﬁed as an action, it is now considered an analysis. See 32.12.28

on page 739.

32.11.66. rmsavgcorr

Although the ’rmsavgcorr’ command can still be speciﬁed as an action, it is now considered an analysis.

See 32.12.29 on page 740.

32.11.67. rmsf | atomicﬂuct

See 32.11.5 on page 648.

32.11.68. rotate

rotate [<mask>] { [x <xdeg>] [y <ydeg>] [z <zdeg>] |

axis0 <mask0> axis1 <mask1> <deg> |
usedata <set name> [inverse] }

[<mask>] Rotate atoms in <mask> (default all).
[x <xdeg] Degrees to rotate around the X axis.
[y <xdeg] Degrees to rotate around the Y axis.
[z <xdeg] Degrees to rotate around the Z axis.
axis0 <mask0> Mask defining the beginning of a user-defined axis.
axis1 <mask1> Mask defining the end of a user-defined axis.
<deg> Value in degrees to rotate around user defined axis.
usedata <set name> If specified, use 3x3 rotation matrices in specified data set

to rotate coordinates.

[inverse] Perform inverse rotation from input rotation matrices.

Rotate speciﬁed atoms around the X, Y, and/or Z axes by the speciﬁed amounts, around a user-deﬁned axis (spec-
iﬁed by <mask0> and <mask1>), or use a previously read in or generated data set of 3x3 matrices to perform
rotations.

For example, to rotate the entire system 90 degrees around the X axis:

rotate x 90

698

To rotate residue 270 90 degrees around the axis deﬁned between atoms C1, C2, C3, C4, C5, and C6 in residue
270 and atoms C7, C8, C9, C10, C11, and C12 in residue 270:

rotate :270 axis0 :270@C1,C2,C3,C4,C5,C6 axis1 :270@C7,C8,C9,C10,C11,C12 90.0

32.11. Action Commands

To rotate the system with rotation matrices read in from rmatrices.dat:

trajin tz2.norotate.crd
readdata rmatrices.dat name RM mat3x3
rotate usedata RM

32.11.69. rotdif

The ’rotdif’ command is now an analysis (see 32.12.30 on page 741), and requires that rotation matrices be

generated via an rmsd action. For example:

reference avgstruct.pdb
trajin tz2.nc
rms R0 reference @CA,C,N,O savematrices
rotdif rmatrix R0[RM] rseed 1 nvecs 10 dt 0.002 tf 0.190 \

itmax 500 tol 0.000001 d0 0.03 order 2 rvecout rvecs.dat \
rmout matrices.dat deffout deffs.dat outfile rotdif.out

32.11.70. runavg | runningaverage

runavg [window <window_size>]

Note that for backwards compatibility with ptraj “runningaverage” is also accepted.

Replaces the current frame with a running average over a number of frames speciﬁed by window

<window_size> (5 if not speciﬁed). This means that in order to build up the correct number of frames to calculate
the average, the ﬁrst <window_size> minus one frames will not be processed by subsequent actions. So for
example given the input:

runavg window 3
rms first out rmsd.dat

the rms command will not take effect until frame 3 since that is the ﬁrst time 3 frames are available for averaging
(1, 2, and 3). The next frame processed would be an average of frames 2, 3, and 4, etc.

32.11.71. scale

scale x <sx> y <sy> z <sz> <mask>

Scale the X|Y|Z coordinates of atoms in <mask> by <sx>|<sy>|<sz>.

32.11.72. secstruct

secstruct [<name>] [out <filename>] [<mask>] [sumout <filename>]

[assignout <filename>] [totalout <filename> [ptrajformat]
[betadetail]
[namen <N name>] [nameh <H name>] [nameca <CA name>]
[namec <C name>] [nameo <O name>] [namesg <sulfur name>]

[<name>] Output data set name.
[out <ﬁlename>] Output file name for secondary structure vs time.
[<mask>] Atom mask in which residues should be looked for.

699

32. cpptraj

[sumout <sumﬁlename>] Write average secondary structure values for each residue

to <sumfilename>; if not specified <filename>.sum is used.

[assignout <ﬁlename>] Write overall secondary structure assignment (based on

dominant secondary structure type for each residue) to file.

[ptrajformat] Write secondary structure as a string of characters for each frame,

similar to ptraj output.

[betadetail] Record anti-parallel beta and parallel beta in place of extended and
bridge secondary structure. If a residue could be both only anti-parallel
is reported.

[namen <N name>] Backbone amide nitrogen atom name (default ’N’).
[nameh <H name>] Backbone amide hydrogen atom name (default ’H’).
[nameca <CA name>] Backbone alpha carbon atom name (default ’CA’).
[namec <C name>] Backbone carbonyl carbon atom name (default ’C’).
[nameo <O name>] Backbone carbonyl oxygen atom name (default ’O’).
[namesg <SG name>] Cysteine sulfur atom name, used to ignore disulfide

connectivity (default ’SG’).

Data Sets Created:
<name>[res] Residue secondary structure per frame; index corresponds to residue

number. If ptrajformat specified these will be characters, otherwise
integers (see table below).

<name>[avgss] Average of each type of secondary structure; index corresponds to

secondary structure type (see table below; no index for “None”).

<name>[None] Total fraction of residues with no structure vs time.
<name>[Para] Total fraction of residues with parallel beta structure vs time.
<name>[Anti] Total fraction of residues with anti-parallel beta structure vs

time.

<name>[3-10] Total fraction of 3-10 helical structure vs time.
<name>[Alpha] Total fraction of alpha helical structure vs time.
<name>[Pi] Total fraction of Pi helical structure vs time.
<name>[Turn] Total fraction of turn structure vs time.
<name>[Bend] Total fraction of bend structure vs time.

As of version 4.18.0, this command now produces output that better conforms with the original deﬁnitions
in Kabsch and Sander 1983; namely that Extended beta (i.e. 2 or more consecutive beta bridges of the same
type) and beta Bridge (i.e. an isolated beta bridge) are now reported instead of anti-parallel and parallel
beta. To restore the original behavior the ’betadetail’ keyword must be speciﬁed.

Note that the residue and [avgss] data sets are not generated until run is called.
Calculate secondary structural propensities for residues in <mask> (or all solute residues if no mask given)
using the DSSP method of Kabsch and Sander[663], which assigns secondary structure types for residues based
on backbone amide (N-H) and carbonyl (C=O) atom positions. By default cpptraj assumes these atoms are named
“N”, “H”, “C”, and “O” respectively. If a different naming scheme is used (e.g. amide hydrogens are named
“HN”) the backbone atom names can be customized with the nameX keywords (e.g. ’nameH HN’). Note that it
is expected that some residues will not have all of these atoms (such as proline); in this case cpptraj will print
an informational message but the calculation will proceed normally. If a residue has no atoms selected it will be
skipped. When determining residue connecivity, disulﬁde bonds will be ignored; cpptraj identiﬁes such bonds
based on the namesg atom name (default “SG”).

Results will be written to ﬁlename speciﬁed by out with format:

700

32.11. Action Commands

<#Frame>

<ResX SS> <ResX+1 SS> ... <ResN SS>

where <#Frame> is the frame number and <ResX SS> is an integer representing the calculated secondary
structure type for residue X. If the keyword ptrajformat is speciﬁed, the output format will instead be:

<#Frame>

STRING

where STRING is a string of characters (one for each residue) where each character represents a different structural
type (this format is similar to what ptraj had outputed and is retained for backwards compatibility). The various
secondary structure types and their corresponding integer/character are listed below. If ’betadetail’ is speciﬁed
what is reported and the characters used change slightly.

STRING (betadetail)

Integer DSSP

SS type (betadetail)

0

E (b)

B
G
H
I
T
S

0
1
2
3
4
5
6
7

’ ’
’E’
’B’
’G’
’H’
’I’
’T’
’S’

None

Extended beta (parallel beta)

Isolated beta (anti-parallel beta)

3-10 helix
Alpha helix
Pi (3-14) helix

Turn
Bend

Average structural propensities over all frames for each residue will be written to the ﬁle speciﬁed by sumout

(or “<ﬁlename>.sum” if sumout is not speciﬁed). The total structural propensity over all residues for each
secondary structure type will be written to the ﬁle speciﬁed by totalout. If assignout is speciﬁed, the overall
secondary structure assignment for each residue will be printed in two line chunks of 50 residues, with the ﬁrst
line containing the residue number the line starts with and one character residue names, and the second line
containing secondary structure assignment using DSSP-style characters, like so:

1 KCNTATCATQ RLANFLVHSS NNFGAILSST NVGSNTRn

SSS

TH HHHTTSEEEE TTTEEEE SS

S

The output of secstruct command is amenable to visualization with gnuplot. To generate a 2D map-style plot of
secondary structure vs time, with each residue on the Y axis simply give the output ﬁle a “.gnu” extension. For
example, to generate a 2D map of secondary structure vs time, with different colors representing different
secondary structure types for residues 1-22:

secstruct :1-22 out dssp.gnu

The resulting ﬁle can be visualized with gnuplot:

gnuplot dssp.gnu

Similarly, the sumout ﬁle can be nicely visualized using xmgrace (use “.agr” extension).

secstruct :1-22 out dssp.gnu sumout dssp.agr
xmgrace dssp.agr

32.11.73. spam

spam <filename> [solv <solvname>] [reorder] [name <name>]

[purewater] [cut <cut>] [info <infofile>] [summary <summary>]
[site_size <size>] [sphere] [out <datafile>]
[dgbulk <dgbulk>] [dhbulk <dhbulk>] [temperature <T>]

<ﬁlename> File with the peak locations present (XYZ- format)
<solvname> Name of the solvent residues

701

32. cpptraj

<cut> Non-bonded cutoff for energy evaluation
<dgbulk> SPAM free energy of the bulk solvent in kcal/mol; default is -30.3

kcal/mol (SPC/E water).

<dhbulk> SPAM enthalpy of the bulk solvent in kcal/mol; default is -22.2

kcal/mol (SPC/E water).

<T> Temperature at which SPAM calculation was run.
<infoﬁle> File with stats about which sites are occupied when.
<size> Size of the water site around each density peak.
[sphere] Treat each site like a sphere.
[purewater] The system is pure water---used to parametrize the bulk values.
[reorder] The solvent should be re-ordered so the same solvent molecule is always

in the same site.

<summary> File with the summary of all SPAM results. If not specified, no

SPAM energies will be calculated.

<dataﬁle> Data file with all SPAM energies for each snapshot.

Perform proﬁling of bound water molecules via SPAM analysis[664]. Brieﬂy, this method identiﬁes and estimates
the free energy proﬁles of bound waters via calculation of the distribution of interaction energies between the water
and it’s environment from explicit solvent MD trajectories. The interaction energies are calculated using a force-
and energy-shifted electrostatic term with a hard cutoff.

Prior to this command, the volmap command should be run with the peakﬁle keyword (see 32.11.86 on

page 709) to generate the peaks ﬁle. If not using peaks from the volmap command, the peaks ﬁle should have one
line per peak with format:

C <X> <Y> <Z> <Density>

Values of dgbulk and dhbulk for different water models can be calculated from pure water simulations with the
purewater keyword.

32.11.74. setvelocity

setvelocity [<mask>]

[{ tempi <temperature> |

scale [factor <fac>] [sx <xfac>] [sy <yfac>] [sz <zfac>] |
none |
modify}]

[[ntc <#>]] [[dt <time>] [epsilon <eps>]]

[zeromomentum] [ig <random seed>]

<mask> Mask of atoms to assign velocities to.
tempi <temperature> Assign velocities at specified temperature (default 300.0 K).
scale Scale existing velocities

[factor <fac>] Factor to scale velocities by.
[sx <xfac>] Factor to scale X component of velocities by.
[sy <yfac>] Factor to scale Y component of velocities by.
[sz <zfac>] Factor to scale Z component of velocities by.

none Remove any velocities.
modify If specified, do not set, just modify any existing velocities (via ’ntc’

or ’zeromomentum’).

702

32.11. Action Commands

ig <random seed> Random seed to use to generate velocity distribution.
ntc <#> Correct set velocities for SHAKE constraints.

Numbers match

sander/pmemd: 1 = no SHAKE, 2 = SHAKE on hydrogens, 3 = SHAKE on all
atoms.

dt <time> Time step for SHAKE correction.
epsilon <eps> Epsilon for SHAKE correction
zeromomentum If specified adjust velocities so the total momentum of atoms in

<mask> is zero.

Set velocities in frame for atoms in <mask> using Maxwellian distribution based on given temperature.

32.11.75. stfcdiffusion

stfcdiffusion mask <mask> [out <file>] [time <time per frame>]

[mask2 <mask> [lower <distance>] [upper <distance>]]
[nwout <file>]) [avout <file>] [distances] [com]
[x|y|z|xy|xz|yz|xyz]

mask Atoms for which MSDs will be computed.
out Output file: time vs. MSD.
time Time step in the trajectory. (1.0 ps)
mask2 Compute MSDs only within the lower and upper limit of mask2.

may be very slow!!!

IMPORTANT:

lower Smaller distance from reference point(s).
upper Larger distance from reference point(s).
nwout Output file containing number of water molecules in the chosen region,

(0.01 Å)

(3.5 Å)

see mask2. (off)

avout Output file containing average distances. (off)
x|y|z|xy|xz|yz|xyz Computation of the mean square displacement in the chosen

dimension. (xyz)

distances Dump un-imaged distances.
com Calculate MSD for centre of mass.

(off)

By default only averages are output.

(off)

Calculate diffusion for selected atoms using code based on the ’diffusion’ routine developed by Hannes Loefﬂer at
STFC (http://www.stfc.ac.uk/CSE).

32.11.76. strip

strip <mask> [outprefix <name>] [<parmout> file>] [nobox]

<mask> Remove atoms specified by mask from the system.
[outpreﬁx <preﬁx>] Write out stripped topology file with name ’<prefix>.<Original

Topology Name>’.

[parmout <ﬁle>] Write corresponding topology to file with name <file>.
[nobox] Remove any box information from the stripped topology.

Strip all atoms speciﬁed by <mask> from the frame and modify the topology to match for any subsequent Actions.
The outpreﬁx keyword can be used to write stripped topologies; stripped Amber topologies are fully-functional.

Note that stripping a system renumbers all atoms and residues, so for example after this command:

703

32. cpptraj

strip :1

residue 1 will be gone, and the former second residue will now be the ﬁrst, and so on.
For example, to strip all residues named WAT from each topology/coordinate frame:

strip :WAT

The next example uses a distance-based mask to strip atoms in a single frame. Note that with the exception of the
mask command, distance-based masks do not update on a per-frame basis. To strip all residues outside of 6.0 from
any atom in residues 1 to 14 and write out the stripped topology and coordinates, both with no box information:

parm parm7
trajin frame_1000.rst.1
reference frame_1000.rst.1
strip !(:1-14<:6.0) outprefix f1.1 nobox
trajout f1.1.x restart nobox

32.11.77. surf

surf [<name>] [<mask1>] [out <filename>] [solutemask <mask>]
[offset <offset>] [nbrcut <cut>]

<name> Output data set name.
<mask1> Atoms to calculate surface area for.
out <ﬁlename> File to write surface area to.
solutemask <mask> If specified, calculate the contribution of <mask1> to

<mask>.

offset <offset> Increment van der Waals radii by <offset>; 1.4 Ang.

is the

default (as used by Amber).

nbrcut <cut> Only atoms with van der Waals radii greater than <cut> are

considered to have neighbors (2.5 Ang Amber default).

Calculate the surface area in Å2 of atoms in <mask> (if no mask speciﬁed, all atoms not marked as ’solvent’ that
are part of a molecule > 1 atom in size) using the LCPO algorithm of Weiser et al.[170]. In order for this to work,
the topology needs to have bond information and atom type information.

Note that even if <mask> does not include all solute atoms, the neighbor list is still calculated for all solute
atoms so the surface area calculated reﬂects the contribution of atoms in <mask> to the overall surface area, not
the surface area of <mask> as an isolated system. As a result, it may be possible to obtain a negative surface area
if only a small fraction of the solute is selected.

For example, to calculate the overall surface area of all solute atoms, as well as the contribution of residue 1 to

the overall surface area, writing both results to “surf.dat”:

surf out surf.dat
surf :1 out surf.dat

32.11.78. symmrmsd

symmrmsd [<name>] [<mask>] [<refmask>] [out <filename>] [nofit] [mass] [remap]

[ first | reference | ref <name> | refindex <#> | previous |

reftraj <name> [parm <parmname> | parmindex <#>] ]

[<name>] Output data set name.
[<mask>] Mask of atoms to calculate RMSD for; if not specified, calculate for

all atoms.

704

32.11. Action Commands

[<refmask>] Reference mask; if not specified, use <mask>.
[out <ﬁlename>] Output data file name.
[noﬁt] Do not perform best-fit RMSD (not recommended).
[mass] Mass-weight the RMSD calculation.
[remap] Re-arrange atoms according to symmetry.

See below for more details.

Reference keywords:
ﬁrst Use the first trajectory frame processed as reference.
reference Use the first previously read in reference structure (refindex 0).
ref <name> Use previously read in reference structure specified by filename/tag.
reﬁndex <#> Use previously read in reference structure specified by <#> (based

on order read in).

previous Use frame prior to current frame as reference.
reftraj <name> Use frames from COORDS set <name> or read in from trajectory file

<name> as references. Each frame from <name> is used in turn, so that
frame 1 is compared to frame 1 from <name>, frame 2 is compared to frame 2
from <name> and so on. If <trajname> runs out of frames before processing
is complete, the last frame of <trajname> continues to be used as the
reference.
parm <parmname> | parmindex <#> If reftraj specifies a file associate

trajectory <name> with specified topology; if not specified the first
topology is used.

Perform symmetry-corrected RMSD calculation. This is done by identifying potential symmetric atoms in each
residue, performing an initial best-ﬁt, then determining which conﬁguration of symmetric atoms will give the
lowest RMSD using atomic distance to reference atoms.

Note that when re-mapping, all atoms in the residues of interest should be selected to prevent cases where
selected symmetric atoms are swapped but the atoms they are bonded to are not. Also, occasionally larger
symmetric structures (e.g. 6 membered rings) may become distorted due to only part of the residue being corrected
for symmetry. This appears to happen about 4% of the time but does not overly inﬂate the RMSD. The ’check’
command can be used after symmrmsd to look for such distortions.

Warning: the symmetry correction is generally robust enough to account for symmetries in the standard amino
and nucleic acid residues, but has not been extensively tested on residues with more extended types of symmetry.

32.11.79. temperature

temperature [<name>] [out <filename>]

{ frame |

[<mask>] [ntc <#>] [update] [remove {trans|rot|both}]

}

[<name>] Data set name.
[out <ﬁlename>] File to write values to.
frame Do not calculate temperature; use existing frame temperature.
[<mask>] Atoms to calculate temperature for.
[ntc <#>] Value of SHAKE bond constraint: 1 - none, 2 - bonds to H, 3- all bonds

(equivalent to SANDER/PMEMD).

[update] Update temperature in Frames with calculated temperatures.
[remove {trans|rot|both}] Correct for removed translational, rotational, or both

kinds of degrees of freedom.

705

32. cpptraj

Calculate temperature in frame based on velocity information. If ’update’ is speciﬁed, update frame temperature
too. If ’frame’ is speciﬁed just use frame temperature (e.g. read in from a REMD trajectory).

The ’ntc’ keyword can be used to correct for lost degrees of freedom due to SHAKE constraints (2 = bonds to
hydrogen, 3 = all bonds). The ’remove’ keyword can be used to account for removed translational and/or rotational
degrees of freedom.

For example, if using a trajectory that has been generated with SHAKE on hydrogens, no periodic boundary

conditions (i.e. no box), and has had the center of mass periodically removed:

temperature T1 ntc 2 remove both out T1.dat

If using a trajectory that has been generated with SHAKE on hydrogens, periodic boundary conditions (i.e. with a
box), and has had the center of mass periodically removed:

temperature T1 ntc 2 remove trans out T1.dat

If using a trajectory that has been generated with SHAKE on all bonds, periodic boundary conditions, and no
center of mass motion removal:

temperature T1 ntc 3 out T1.dat

32.11.80. time

time {time0 <initial time> dt <step> [update] | remove}
time0 <initial time> Time of the first frame (ps).
dt <step> Time step between frames (ps).
[update] If specified, modify any existing time info.
remove Remove any time info from frame.

Either add time information to frames, modify existing time information in frames, or remove existing time infor-
mation from frames. Note that currently COORDS data sets do not store time information, so using this command
with the crdaction command will have no effect.

32.11.81. trans | translate

translate [<mask>] [x <dx>] [y <dy>] [z <dz>]

Translate atoms in <mask> (all atoms if no mask speciﬁed) <dx> Å in the X direction, <dy> Å in the Y direction,
and <dz> Å in the Z direction.

32.11.82. unstrip

unstrip

Requests that the original topology and frame be used for all following actions. This has the effect of undoing any
command that modiﬁes the state (such as strip). For example, the following code takes a solvated complex and
uses a combination of strip, unstrip, and outtraj commands to write out separate dry complex, receptor, and ligand
ﬁles:

parm Complex.WAT.pdb
trajin Complex.WAT.pdb
# Remove water, write complex
strip :WAT
outtraj Complex.pdb pdb
# Reset to solvated Complex
unstrip

706

32.11. Action Commands

# Remove water and ligand, write receptor
strip :WAT,LIG
outtraj Receptor.pdb pdb
# Reset to solvated Complex
unstrip
# Remove water and receptor, write ligand
strip :WAT
strip !(:LIG)
outtraj Ligand.pdb pdb

32.11.83. unwrap

unwrap [center] [{bymol | byres | byatom}]

[ reference | ref <name> | refindex <#> ] [<mask>]

[center] Unwrap by center of mass; otherwise unwrap by first atom position.
bymol Unwrap by molecule (default).
byres Unwrap by residue.
byatom Unwrap by atom.
[ reference | ref <name> | reﬁndex <#> ] Reference structure to use in unwrapping.
[<mask>] Selection to unwrap.

Under periodic boundary conditions, MD trajectories are not continuous if molecules are wrapped(imaged) into the
central unit cell. Especially, in sander, with iwrap=1, molecular trajectories become discontinuous when a molecule
crosses the boundary of the unit cell. This command, unwrap processes the trajectories to force the masked
molecules continuous by translating the molecules into the neighboring unit cells. It is the opposite function of
image, but this command can also be used to place molecules side by side, for example, two strands of a DNA
duplex. However, this command fails when the masked molecules travel more than half of the box size within a
single frame.

If the optional argument “reference” is speciﬁed, then the ﬁrst frame is unwrapped according to the reference

structure. Otherwise, the ﬁrst frame is not modiﬁed.

As an example, assume that :1-10 is the ﬁrst strand of a DNA duplex and :11-20 is the other strand of the

duplex. Then the following commands could be used to create system where the two strands are not separated
artiﬁcially:

unwrap :1-20
center :1-20 mass origin
image origin center familiar

32.11.84. vector

vector [<name>] <Type> [out <filename> [ptrajoutput]] [<mask1>] [<mask2>]

[magnitude] [ired]
<Type> = { mask

box

| minimage
| dipole | center
| boxcenter | ucellx | ucelly

| corrplane |
| ucellz

momentum | principal [x|y|z] | velocity | force }

[<name>] Vector data set name.
<Type> Vector type; see below.
[out <ﬁlename>] Write vector data to <filename> with format ’Vx Vy Vz Ox Oy Oz’

where V denotes vector coordinates and ’O’ denotes origin coordinates.

707

32. cpptraj

[ptrajoutput] Write vector data in ptraj style (Vx Vy Vz Ox Oy Oz Vx+Ox Vy+Oy

Vz+Oz). This prevents additional formatting of <filename> and is not
compatible with ’magnitude’.

[<mask1>] Atom mask, required for all types except ’box’.
[<mask2>] Second atom mask, only required for type ’mask’.
[magnitude] Store the magnitude of the vector with aspect [Mag].
[ired] Mark this vector for subsequent IRED analysis with commands ’matrix ired’

and ’ired’.

Data Sets Created:
<name> Vector data set.
<name>[Mag] (magnitude only) Vector magnitude.

This command will keep track of a vector value (and its origin) over the trajectory; the data can be referenced for
later use based on the name (which must be unique). The types of vectors that can be calculated are:
mask (Default) Store vector from center of mass of atoms in <mask1> to atoms in <mask2>.
minimage Store minimum-imaged vector from center of mass of atoms in <mask1> to atoms in <mask2>.
dipole Store the dipole and center of mass of the atoms speciﬁed in <mask1>. The vector is not converted to

appropriate units, nor is the value well-deﬁned if the atoms in the mask are not overall charge neutral.

center Store the center of mass of atoms in <mask1>. The reference point is the origin (0.0, 0.0, 0.0).
corrplane This deﬁnes a vector perpendicular to the (least-squares best) plane through the atoms in <mask1>.

The reference point is the center of mass of atoms in <mask1>.

box (No mask needed) Store the box lengths of the trajectory. The reference point is the origin (0.0, 0.0, 0.0).

boxcenter (No mask needed) Store the center of the box as a vector.

ucell{x|y|z}: (No mask needed) Store speciﬁed unit cell (i.e. box) vector.

momentum Store momentum of atoms selected by <mask1> (requires velocities).

principal [x|y|z] Store one of the principal axis vectors determined by diagonalization of the inertial matrix from
the coordinates of the atoms speciﬁed by <mask1>. The eigenvector with the largest eigenvalue is considered
“x” (i.e., the hardest axis to rotate around) and the eigenvector with the smallest eigenvalue is considered
“z”. If none of x or y or z are speciﬁed, then the “x” principal axis is stored. The reference point is the
center of mass of atoms in <mask1>.

velocity Store velocity of atoms in <mask1> (requires velocities).

force Store force of atoms in <mask1> (requires forces).

Cpptraj supports writing out vector data in a pseudo-trajectory format for easy visualization. Once a vector data
set has been generated the writedata command can be used with the vectraj keyword (see 32.6 on page 607 for
more details) to write a pseudo trajectory consisting of two atoms, one for the vector origin and one for the vector
from the origin (i.e. V+O). For example, to create a MOL2 containing a pseudo-trajectory of the
minimum-imaged vector from residue 4 to residue 11:

trajin tz2.nc
vector v8 minimage out v8.dat :4 :11
run
writedata v8.mol2 vectraj v8 trajfmt mol2

Auto-correlation or cross-correlation functions can be calculated subsequently for vectors using either the corr
analysis command or the timecorr analysis command (to calculate via spherical harmonic theory).

708

32.11. Action Commands

32.11.85. velocityautocorr

velocityautocorr [<set name>] [<mask>] [usevelocity] [out <filename>] [diffout <file>]

[maxlag <frames>] [tstep <timestep>] [direct] [norm]

[<set name>] Data set name.
[<mask>] Atoms(s) to calculate velocity autocorrelation (VAC) function for.
[usevelocity] Use velocity information in frame if present.

This will only give
sensible results if the velocities are recorded close to the order of the
simulation time step.

[out <ﬁlename>] Write VAC function to <filename>.
[diffout <ﬁle>] File to write diffusion constants to.
[maxlag <frames>] Maximum lag in frames to calculate VAC function for.

Default

is half the total number of frames.

[tstep <timestep>] Time between frames in ps (default 1.0).
[direct] Calculate VAC function directly instead of via FFT (will be much

slower).

[norm] Normalize resulting VAC function to 1.0.

DataSet Aspects:
[D] Diffusion constant calculated from integral over VAC function in 1x10-5

cm2/s.

Calculate the velocity autocorrelation (VAC) function averaged over the atoms in <mask>. Pseudo-velocities are
calculated using coordinates and the speciﬁed time step. As with all time correlation functions the statistical noise
will increase if the maximum lag is greater than half the total number of frames. In addition to calculating the
velocity autocorrelation function, the self-diffusion coefﬁcient will be reported in the output, calculated from the
integral over the VAC function.

32.11.86. volmap

volmap filename dx dy dz <mask> [radscale <factor>]

{ data <existing set> |

name <setname> { size <x,y,z> [center <x,y,z>] |

centermask <mask> [buffer <buffer>] } }

[peakcut <cutoff>] [peakfile <xyzfile>]

ﬁlename The name of the output file with the grid density.
dx, dy, dz The grid spacing (Angstroms) in the X-, Y-, and Z-dimensions,

respectively

<mask> The atom selection from which to calculate the number density.
radscale <factor> Factor by which to scale radii (by division). To match the

atomic radius of Oxygen used by the VMD volmap tool, a scaling factor of
1.36 should be used. Default 1.0.

data <setname> Name of existing grid data set to use.
name <setname> Name of grid set that will be created (size/center or

centermask/buffer keywords).

size <x,y,z> Specify the size of the grid in the X-, Y-, and Z-dimensions.

Must

be used alongside the center argument.

709

32. cpptraj

center <x,y,z> Specify the grid center explicitly. Note, the size argument must

be present in this case. Default is the origin.

centermask <mask> The mask around which the grid should be centered (via

geometric center). If this is omitted and the center and size are not
specified, the default <mask> entered (see above) is used in its place.

buffer <buffer> A buffer distance, in Angstroms, by which the edges of the grid

should clear every atom of the centermask (or default mask if centermask is
omitted) in every direction.
ignored if the center and size are specified (see below).

The default value is 3.

The buffer is

peakcut <cutoff> The minimum density required to consider a local maximum a

’density peak’ in the outputted peak file (default 0.05).

peakﬁle <xyzﬁle> A file in XYZ-format that contains a carbon atom centered at
the grid point of every local density maximum. This file is necessary
input to the spam action command.

Grid data as a volumetric map, similar to the ’volmap’ command in VMD. The density is calculated by treating
each atom as a 3-dimensional Gaussian function whose standard deviation is equal to the van der Waals radius.
The density calculated is the number density averaged over the entire simulation. The grid can be speciﬁed in one
of three ways:

1. An existing grid data set (from e.g. bounds), speciﬁed with the data keyword.

2. Via the sizes and center speciﬁed by the size and center keywords (comma-separated strings, e.g.

’20,20,20’).

3. Centered on the atoms in the mask given by centermask with an additional buffer in each direction speciﬁed

by buffer.

32.11.87. volume

volume [<name>] [out <filename>]

<name> Data set name.
out <ﬁlename> Output file name.

Calculate unit cell volume.

32.11.88. watershell

watershell <solutemask> [out <filename>] [lower <lower cut>] [upper <upper cut>]

[noimage] [<solventmask>]

<solutemask> Atom mask corresponding to solute of interest (required).
[out <ﬁlename>] Output file name.
[lower <lower cut>] Cutoff for the first water shell (default 3.4 Angstroms).
[upper <upper cut>] Cutoff for the second water shell (default 5.0 Angstroms).
[noimage] Do not image distances.
[<solventmask>] Optional atom mask corresponding to solvent.

DataSet Aspects:

[lower] Number of solvent molecules in first solvent shell.

710

32.11. Action Commands

[upper] Number of solvent molecules in second solvent shell.

This option will count the number of waters within a certain distance of the atoms in the <solutemask> in order to
represent the ﬁrst and second solvation shells. The optional <solventmask> can be used to consider other atoms as
the solvent; the default is “:WAT”.

This action is often used prior to the closest command in order to determine how many waters around a solute

should be retained to maintain the ﬁrst and/or second water shells.

As of version 17 this command is CUDA-enabled in CUDA versions of CPPTRAJ.

32.11.89. xtalsymm

xtalsymm <mask> group <space group> [collect [centroid]]

[ first | reference | ref <name> | refindex <#> ]
[na <na>] [nb <nb>] [nc <nc>]

<mask> Atom mask defining the asymmetric unit within the larger system

(required).

group <space group> The space group to which the system belongs. Omit spaces in

the name. Example: “P22(1)2(1)”.

[collect] Optional flag to have all solvent particles, not just the asymmetric

units, re-imaged. This will trigger cpptraj to compute the unit cell
volume that constitutes the aymmetric unit and thereby classify all
particles for re-imaging.
[centroid] If specified along with collect, re-image solvent molecules by

centroids, not individual atom coordinates. This is useful for keeping
water molecules intact.

[ﬁrst | reference | ref <name> | reﬁndex <#>] Reference structure to use for

determining crystal symmetry.

[na <na>] [nb <nb>] [nc <nc>] The number of times the crystal unit cell is

replicated along the “a,” “b,” or “c” axes (for orthorhombic unti cells,
these are the x, y, and z axes) of the simulation; default is 1.
crystal unit cells are too small in one or more dimensions for our
simulation cutoffs, and replicating the unit cell is an effective way to
counter imaging artifacts even for larger unit cells.

Many

Calculate the optimal approach for superimposing symmetry-related subunits of the simulation back onto one
another. The calculation assumes that the system is a simulation of an X-ray structure in its native crystal lattice,
ﬁnds all copies of the asymmetric unit among the entire system, and devises plans for re-imagining their coordinates
to superimpose them back on the original asymmetric unit. The space group information can be found in a PDB X-
ray structure used as the initial coordinates for a simulation. All 230 space groups are supported, and a scan of the
PDB was made to ensure that common variants of the names are included (P2(1)22(1) is the same as P22(1)2(1),
but with different axis conventions). If your space group is not understood, contact the Amber mailing list. This
command is compute intensive, especially for simulations that are “supercells” containing many crystallographic
unit cells.

This command will cause cpptraj to locate all asymmetric units from within the topology, then determine what
wrapping, if any, has occurred in order to bring about an optimal re-alignment based on the space group symmetry
operations. The user need not worry about wrapping or drift of the simulation over time–the asymmetric units will
be re-imaged frame by frame. Coordinate modiﬁcations due to this action are permanent and will affect the results
of subsequent actions and analyses.

711

32. cpptraj

32.12. Analysis Commands

Analyses in cpptraj operate on data sets which have been generated by Actions in a prior Run or read in with
a readdata command ( 32.8.19 on page 623). Unlike ptraj, Analysis commands in cpptraj do not need to be
prefaced with ’analysis’. The exception to this is ’analyze matrix’ in order to differentiate it from the matrix
Action command; users are encouraged to use the new command diagmatrix instead.

Like Actions, when an Analysis command is issued it is by default added to the Analysis queue and is not
executed until after trajectory processing is completed; a complete list of data sets available for analysis is shown
after trajectory processing (prefaced by ’DATASETS’) or can be shown with the ’list dataset’ command. Analyses
can also be executed immediately via the runanalysis command ( 32.8.24 on page 625).

Note that for Analysis commands that use COORDS data sets, if no COORDS data set is speciﬁed then a default

one will be automatically created from frames read in by trajin commands.

Command
autocorr

avg

calcstate
cluster
corr,

correlationcoe

cphstats
crank,

crankshaft
crdﬂuct

crosscorr

curveﬁt

diagmatrix

divergence

FFT

hausdorff

hist, histogram

integrate

ired

kde

lifetime

lowestcurve

meltcurve

modes

712

Description

Calculate autocorrelation function for multiple data sets.
Calculate average, standard deviation, min, and max for

(or over) data sets.

Set Type(s)
N 1D sclar
N 1D scalar

Calculate states based on given data sets and criteria.

Perform cluster analysis.

Calculate auto or cross correlation for 1 or 2 data sets.

N 1D scalar

COORDS, N 1D scalar

1D scalar, vector

Calculate statistics for constant pH data sets.

Calculate crankshaft motion between two data sets.

Calculate atomic ﬂuctuations (RMSF) for atoms over

time blocks.

Calculate a matrix of Pearson product-moment

coefﬁcients between given data sets.

Perform non-linear curve ﬁtting on given data set.
Calculate eigenvectors and eigenvalues from given

symmetric matrix.

Calculate Kullback-Leibler divergence between two data

sets.

Perform a fast Fourier transform on data sets.

Calculate the Hausdorff distance for given matrix data

set(s).

Calculate N-dimensional histogram for N given data

sets.

Perform integration on each of the given data sets.

Perform isotropic reorientational eigenmode dynamics

analysis using given IRED vectors.

Calculate 1D histogram from given data set using a

kernel density estimator.

Also time-dependent Kullback-Leibler divergence

analysis with another set.

Perform lifetime analysis on given data sets.

For each given data set, calculate a curve that traces

the lowest N points over speciﬁed bins.

Calculate a melting curve from given data sets assuming

simple 2 state kinetics.

Perform various analyses on eigenmodes (from e.g.

diagmatrix).

pH data sets
2 1D scalar

COORDS

N 1D scalar

1D scalar

symmetric matrix

2 1D scalar

N 1D scalar
N 2D matrices

N 1D scalar

N 1D scalar

N IRED vectors

1 or 2 1D scalar

N 1D scalar
N 1D scalar

N 1D scalar

eigenmodes

multicurve

multihist

phipsi

regress
remlog

rms2d, 2drms

rmsavgcorr

rotdif

runningavg

spline

stat, statistics

ti

timecorr

vectormath

wavelet

32.12. Analysis Commands

Perform non-linear curve ﬁtting for multiple input data

sets.

Calculate 1D histograms (optionally with a kernel
density estimator) from multiple input data sets.

Calculate and plot the average phi and psi values from

input dihedral data sets.

Perform linear regression on multiple input data sets.
Calculate various statistics from a replica log data set.

Calculate 2D RMSD between frames in 1 or 2 COORDS

data sets.

Calculate RMS average correlation curve for a

COORDS data set.

Calculate rotational diffusion using given rotation

matrices (from e.g. rms).

Calculate running average for given data sets using given

window size.

Calculate cubic splines for given data sets.

Calculate various statistics for given data sets.

Peform Gaussian quadrature integration for given

DV/DL data sets.

Calculate auto/cross-correlation functions for given

vector(s) using spherical harmonics.

Perform math on given vector data sets.

Perform wavelet analysis on coordinates from given

COORDS set.

N 1D scalar

N 1D scalar

N phi/psi dihedrals

N 1D scalar
replica log

1 or 2 COORDS

COORDS

rotation matrices

N 1D scalar

N 1D scalar
N 1D scalar
N 1D scalar

1 or 2 vector

2 vector
COORDS

32.12.1. autocorr

autocorr [name <dsetname>] <dsetarg0> [<dsetarg1> ...] [out <filename>]

[lagmax <lag>] [nocovar] [direct]

<dsetarg0> [dsetarg1> ...] Argument(s) specifying datasets to be used.
[name <dsetname>] Store results in dataset(s) named <dsetname>:X.
[out <ﬁlename>] Write results to file named <filename>.
[lagmax] Maximum lag to calculate for. If not specified all frames are used.
[nocovar] Do not calculate covariance.
[direct] Do not use FFTs to calculate correlation; this will be much slower.

This is for integer/double/ﬂoat datasets only; for vectors see the ’timecorr’ command.

Calculate auto-correlation (actually auto-covariance by default) function for datasets speciﬁed by one or more

dataset arguments. The datasets must have the same # of data points.

32.12.2. avg

avg <dset0> [<dset1> ...] [torsion] [out <file>] [oversets]

[name <name>] [nostdout]

<dsetX> Data set(s) to calculate the average for.
[torsion] If the data sets are not already marked periodic (e.g.

’readdata’), treat them as periodic torsion.

if read in via

713

32. cpptraj

[out <ﬁle>] File to write results to.
[oversets] If specified, calculate the average over all inpout sets instead of

each input set.

[name <name>] Output data set name.
[nostdout] If ’nostdout’ specified do not write averages to STDOUT when ’out’

not specified.

DataSets Created (not oversets):
<name>[avg] Average of each set.
<name>[sd] Standard deviation of each set.
<name>[ymin] Y minimum of each set.
<name>[ymax] Y maximum of each set.
<name>[yminidx] Index of minimum Y value.
<name>[ymaxidx] Index of maximum Y value.
<name>[names] Name of each set.
DataSets Created (oversets)
<name> Average over all input sets for each frame.
<name>[SD] Standard deviation over all input sets for each frame.

Calculate the average, standard deviation, min, and max of given 1D data sets. Alternatively, if oversets is speciﬁed
the average over each set for each point is calculated; this requires all input sets be the same size.

For example, to read in data from a ﬁle named perres.peptide.dat and calculate the averages etc for all the input

sets:

readdata perres.peptide.dat
avg perres.peptide.dat out output.dat name V

32.12.3. calcstate

calcstate {state <ID>,<dataset>,<min>,<max>[,<dataset1>,<min1>,<max1>]} ...

[out <state v time file>] [name <setname>]
[curveout <curve file>] [stateout <states file>]
[transout <transitions file>] [countout <count file>]

state <ID>,<dataset>,<min>,<max> Define a state according to given data set and

criteria. Multiple states can be given, and each state can have multiple
criteria. If multiple criteria are specified, each one must be satisfied
in order to assign the state. If the same state is defined multiple times,
the state will be assigned if either criteria match.
<ID> Name to give each state index. State indices start at 0.

-1 means

“undefined state”.

<dataset> Data set to use.
<min>,<max> Frames with data set value above <min> and below <max> will be

assigned <ID>.

[out <state v time ﬁle>] File to write state index vs frame to.
[name <setname>] Data set name.
[curveout <curve ﬁle>] File to write state lifetime and transition curves to.
[stateout <states ﬁle>] File to write state lifetime data to.

714

32.12. Analysis Commands

[transout <transitions ﬁle>] File to write state transition data to.
[countout <state count ﬁle>] File to write state counts (i.e.

how many frames each

state was observed) to.

DataSets Created:
<setname> State index vs frame.
<setname>[Count] Number of frames each state was observed.
<setname>[Frac] Fraction of time each state was observed
<setname>[Nlifetimes] Number of times each state was reached.
<setname>[Avglife] Average lifetime length for each state.
<setname>[Maxlife] Maximum lifetime of each state.
<setname>[Name] Name (<ID>) of each state.
<setname>[Xlifetimes] Number of times each state transitioned to each other

state.

<setname>[Xavglife] Average lifetime of each state before transitioning to each

other state.

<setname>[Xmaxlife] Maximum lifetime of each state before transitioning to each

other state.

<setname>[Xname] Name of each transition, format “StateA->StateB”.
<setname>[sCurve]:X State curves; lifetime curve for transitions from given

state to any other state.

<setname>[tCurve]:X Transition curves; lifetime curve for transitions from given

state to other specific state.

Data for the speciﬁed data set(s) that matches the given criteria will be assigned a state index. State indices start
from 0 and match the order in which state keywords were given. The -1 state index is reserved for “undeﬁned
state”. For example, the following input:

parm DPDP.parm7
trajin DPDP.nc
distance d1 :19@O :12@N
angle a1 :19@O :12@H :12@N
calcstate state D,d1,3.0,4.0 state A,a1,100,120 out state.dat curveout curve.agr \

stateout States.dat transout States.dat name d1_a1

run

Deﬁnes two states. State index 0 is deﬁned as a state named “D” based on the distance from ’:19@O’ to ’:12@N’
(data set d1) being between 3 and 4 Angstroms. State index 1 is deﬁned as a state named “A” based on the angle
between ’:19@O’, ’:12@H’, and ’:12@N’ (data set a1) being between 100 and 120 degrees. The output in
state.dat might look like:

#Frame

1
2
3
4
5
6
7
8
9
10

d1_a1
-1
0
0
0
-1
1
-1
-1
0
-1

715

32. cpptraj

where the values in column d1_a1 refer to state index: -1 is undeﬁned, 0 is state “D”, and 1 is state “A”.

To deﬁne a state State1 as having a distance named “dist” between 2.5 and 5.0 Ang. and an angle named “ang”

between 30 and 60 degrees OR having a distance named “distA” between 0.0 and 3.0 Ang.:

calcstate state State1,dist,2.5,5.0,ang,30,60 \

state State1,distA,0.0,3.0

Lifetime curves (see 32.12.19 on page 731 for further explanation) are calculated for transitions from each state to
any other state (aspect [sCurve]) and each state to each other state (aspect [tCurve]). In this case there will be 3
sCurves and 4 tCurves:

d1_a1[sCurve]:0 "Undefined" (double), size is 10
d1_a1[sCurve]:1 "D" (double), size is 3
d1_a1[sCurve]:2 "A" (double), size is 1
d1_a1[tCurve]:0 "Undefined->D" (double), size is 10
d1_a1[tCurve]:1 "D->Undefined" (double), size is 3
d1_a1[tCurve]:2 "Undefined->A" (double), size is 1
d1_a1[tCurve]:3 "A->Undefined" (double), size is 1

Lifetime analysis from each state to any other state is directed to the ﬁle speciﬁed by stateout and has format:

#Index N Average Max State

Where #Index is the state index, N is the number of lifetimes in that state, Average is the average lifetime while
in that state (in frames), Max is the maximum lifetime while in that state (in frames) and State is the name of the
state.

Finally, lifetime analysis of transitions from each state to each other state is directory to the ﬁle speciﬁed by

transout and has format:

#N Average Max Transition

Where #N is the number of transitions, Average is the average lifetime (in frames) in the ﬁrst state before tran-
sitioning to the second state, Max is the max lifetime (in frames) before transitioning to the second state, and
Transition is the name of the transition.

32.12.4. cluster

cluster [crdset <crd set> | nocoords]

Algorithms:

[hieragglo [epsilon <e>] [clusters <n>] [linkage|averagelinkage|complete]

[epsilonplot <file>] [includesieved_cdist]]

[dbscan minpoints <n> epsilon <e> [sievetoframe] [kdist <k> [kfile <prefix>]]]

[dpeaks epsilon <e> [noise] [dvdfile <density_vs_dist_file>]

[choosepoints {manual | auto}]
[distancecut <distcut>] [densitycut <densitycut>]
[runavg <runavg_file>] [deltafile <file>] [gauss]]

[kmeans clusters <n> [randompoint [kseed <seed>]] [maxit <iterations>]
[{readtxt|readinfo} infofile <file>]

Distance options:

{[[rms | srmsd] [<mask>] [mass] [nofit]] | [dme [<mask>]] |

[data <dset0>[,<dset1>,...]]}

[sieve <#> [random [sieveseed <#>]]] [loadpairdist] [savepairdist] [pairdist <file>]

[pairwisecache {mem | none}] [includesieveincalc] [pwrecalc]

Output options:

[out <cnumvtime>] [gracecolor] [summary <summaryfile>] [info <infofile>]
[summarysplit <splitfile>] [splitframe <comma-separated frame list>]

716

32.12. Analysis Commands

[bestrep {cumulative|centroid|cumulative_nosieve}] [savenreps <#>]
[clustersvtime <filename> cvtwindow <window size>]

[cpopvtime <file> [normpop | normframe] [lifetime]]

[sil <silhouette file prefix>] [assignrefs [refcut <rms>] [refmask <mask>]]

Coordinate output options:

[ clusterout <trajfileprefix> [clusterfmt <trajformat>] ]
[ singlerepout <trajfilename> [singlerepfmt <trajformat>] ]
[ repout <repprefix> [repfmt <repfmt>] [repframe] ]

[ avgout <avgprefix> [avgfmt <avgfmt>] ]

[crdset <crd set>] Name of previously generated COORDS data set. If not specified

the default COORDS set will be used unless nocoords has been specified.

[nocoords] Do not use a COORDS data set; distance metrics that require

coordinates and coordiante output will be disabled.

Algorithms:

hieragglo (Default) Use hierarchical agglomerative (bottom-up) approach.

[epsilon <e>] Finish clustering when minimum distance between clusters is

greater than <e>.

[clusters <n>] Finish clustering when <n> clusters remain.
[linkage] Single-linkage; use the shortest distance between members of two

clusters.

[averagelinkage] Average-linkage (default); use the average distance between

members of two clusters.

[complete] Complete-linkage; use the maximum distance between members of two

clusters.

[epsilonplot <ﬁle>] Write number of clusters vs epsilon to <file>.
[includesieved_cdist] Include sieved frames in final cluster distance

calculation (may be very slow).

dbscan Use DBSCAN clustering algorithm of Ester et al.[665]

minpoints <n> Minimum number of points required to form a cluster.
epsilon <e> Distance cutoff between points for forming a cluster.
[sievetoframe] When restoring sieved frames, compare frame to every frame in

a cluster instead of the centroid; slower but more accurate.

[kdist <k>] Generate K-dist plot for help in determining DBSCAN parameters

(see below).

[kﬁle <preﬁx>] Prefix for K-dist plot file.

dpeaks Use the density peaks algorithm of Rodriguez and Laio[666]
epsilon <e> Cutoff for determining local density in Angstroms.
[noise] If specified, treat all points within epsilon of another cluster as

noise.

[dvdﬁle <density_vs_dist_ﬁle>] File to write density versus minimum distance to

point with next highest density. This can be used to determine
appropriate cutoffs for distance and density in a subsequent step with
choosepoints manual.

[choosepoints {manual | auto}] Specify whether clusters will be chosen based on
If not specified

specified distance/density cutoffs, or automatically.
only the density vs distance file will be written and no clustering
will be performed. Currently manual is recommended.

717

32. cpptraj

[distancecut <distcut>] [densitycut <densitycut>] If choosepoints manual, points
with minimum distance greather than or equal to <distcut> and density
greater than or equal to <densitycut> will be chosen.

[runavg <runavg ﬁle>] If choosepoints automatic, the calculated running

average of density versus distance will be written to <runavg file>.

[deltaﬁle <ﬁle>] If choosepoints automatic, distance minus the running average

for each point will be written to this file.

[gauss] Calculate density with Gaussian kernels instead of using discrete

density.

kmeans Use K-means clustering algorithm.

clusters <n> Finish clustering when number of clusters is <n>.
[randompoint] Randomize initial set of points used (recommended).
[kseed <seed>] Random number generator seed for randompoint.
[maxit <iteration>] Algorithm will run until frames no longer change clusters

of <iteration> iterations are reached (default 100).

readtxt|readinfo No clustering - read in previous cluster results.

infoﬁle <ﬁle> Cluster info file to read.

Distance Metric Options:
[rms | srmsd[<mask>]] (Default rms) Distance between frames calculated via

best-fit coordinate RMSD using atoms in <mask>. If srmsd specified use
symmetry-corrected RMSD (see 32.11.78 on page 704).
[mass] Mass-weight the RMSD.
[noﬁt] Do not fit structures onto each other prior to calculating RMSD.

dme [<mask>] Distance between frames calculated using distance-RMSD (aka DME,

distrmsd) using atoms in <mask>.

[data <dset0>[,<dset1>,...] Distance between frames calculated using specified data

set(s) (Euclidean distance).

[sieve <#>] Perform clustering only for every <#> frame.

After clustering, all

other frames will be added to clusters.

[random] When sieve is specified, select initial frames to cluster randomly.
[sieveseed <#>] Seed for random sieving; if not set the wallclock time will be

used.

[pairdist <ﬁle>] File to use for loading/saving pairwise distances.
[loadpairdist] Load pairwise distances from <file> (CpptrajPairDist if pairdist

not specified).

[savepairdist] Save pairwise distances from <file> (CpptrajPairDist if pairdist

not specified). NOTE: If sieving was performed only the calculated
distances are saved.

[pairwisecache {mem | disk | none}] Cache pairwise distance data in memory

(default), to disk, or disable pairwise caching.
memory but be extremely slow. Caching to disk will likely be slow unless
writing to a fast storage device (e.g.
named ’CpptrajPairwiseCache’.

SSD) - data is saved to a file

No caching will save

[includesieveincalc] Include sieved frames when calculating within-cluster average

(may be very slow).

[pwrecalc] If a loaded pairwise distance file does not match the current setup,

force recalculation.

718

32.12. Analysis Commands

Output Options:
[out <cnumvtime>] Write cluster # vs frame to <cnumvtime>.

Algorithms that
calculate noise (e.g. DBSCAN) will assign noise points a value of -1.

[gracecolor] Instead of cluster # vs frame, write cluster# + 1 (corresponding to
Cluster #s larger than 15 are given the

colors used by XMGRACE) vs frame.
same color. Algorithms that calculate noise (e.g. DBSCAN) will assign
noise points a color of 0 (blank).

[summary <summaryﬁle>] Summarize each cluster with format ’#Cluster Frames Frac

AvgDist Stdev Centroid AvgCDist’:
#Cluster Cluster number starting from 0 (0 is most populated).
Frames # of frames in cluster.
Frac Size of cluster as fraction of total trajectory.
AvgDist Average distance between points in the cluster.
Stdev Standard deviation of points in the cluster.
Centroid Frame # of structure in cluster that has the lowest cumulative

distance to every other point.

AvgCDist Average distance of this cluster to every other cluster.

[info <infoﬁle>] Write ptraj-like cluster information to <infofile>.

This file

has format:
#Clustering: <X> clusters <N> frames
#Cluster <I> has average-distance-to-centroid <AVG>
...
#DBI: <DBI>
#pSF: <PSF>
#Algorithm: <algorithm-specific info>
<Line for cluster 0>
...
#Representative frames:
Where <X> is the number of clusters, <N> is the number of frames clustered,
<I> ranges from 0 to <X>-1, <AVG> is the average distance of all frames in
that cluster to the centroid, <DBI> is the Davies-Bouldin Index, <pSF> is
the pseudo-F statistic, and <representative frame list> contains the frame
# of the representative frame (i.e. closest to the centroid) for each
cluster. Each cluster has a line made up of characters (one for each
frame) where ’.’ means ’not in cluster’ and ’X’ means ’in cluster’.

<representative frame list>

FracX ... FirstX’:

[summarysplit <splitﬁle>] Summarize each cluster based on which of its frames fall
in portions of the trajectory specified by splitframe with format ’#Cluster
Total Frac C# Color NumInX ...
#Cluster Cluster number starting from 0 (0 is most populated).
Total # of frames in cluster.
Frac Size of cluster as a fraction of the total trajectory.
C# Grace color number.
Color Text description of the color (based on standard XMGRACE coloring).
NumInX Number of frames in Xth portion of the trajectory.
FracX Fraction of frames in Xth portion of the trajectory.
FirstX Frame in the Xth portion of the trajectory where the cluster is first

observed.

[splitframe <frame>] For summarysplit, frame or comma-separated list of frames to

split the trajectory at, e.g. ’100,200,300’.

719

32. cpptraj

[bestrep {cumulative|centroid|cumulative_nosieve}] Method for choosing cluster

representative frames.
cumulative Choose by lowest cumulative distance to all other frames in

cluster. Default when not sieving.

centroid Choose by lowest distance to cluster centroid.

Default when

sieving.

cumulative_nosieve Choose by lowest cumulative distance to all other frames,

ignoring sieved frames.

[savenreps <#>] Number of best representative frames to choose (default 1).
[clustersvtime <ﬁlename>] Write number of unique clusters observed in a given time

window to <filename>.

[cvtwindow <windowsize>] Window size for clustersvtime output.
[cpopvtime <ﬁle> [normpop | normframe]] Write cluster population vs time to <file>;
if normpop specified normalize each cluster to 1.0; if normframe specified
normalize cluster populations by number of frames.

[sil <preﬁx>] Write average cluster silhouette value for each cluster to

’<prefix>.cluster.dat’ and cluster silhouette value for each individual
frame to ’<prefix>.frame.dat’.

assignrefs In summary/summarysplit, assign clusters to loaded representative

structures if RMSD to that reference is less than specified cutoff.
[refcut <rms>] RMSD cutoff in Angstroms.
[refmask <mask>] Mask to use for RMSD calculation. If not specified the

default mask is all heavy atoms.

Coordinate Output Options:
clusterout <trajﬁlepreﬁx> Write frames in each cluster to files named

<trajfileprefix>.cX, where X is the cluster number.

clusterfmt <trajformat> Format keyword for clusterout (default Amber Trajectory).
singlerepout <trajﬁlename> Write all representative frames to single trajectory

named <trajfilename>.

singlerepfmt <trajformat> Format keyword for singlerepout (default Amber

Trajectory).

repout <reppreﬁx> Write representative frames to separate files named

<repprefix>.X.<ext>, where X is the cluster number and <ext> is a
format-specific filename extension.

repfmt <trajformat> Format keyword for repout (default Amber Trajectory).
repframe Include representative frame number in repout filename.
avgout <avgpreﬁx> Write average structure for each cluster to separate files
named <avgprefix>.X.<ext>, where X is the cluster number and <ext> is a
format-specific filename extension.

avgfmt <trajformat> Format keyword for avgout.
DataSet Aspects:
[Pop] Cluster population vs time; index corresponds to cluster number.

Note cluster population vs time data sets are not generated until the analysis has been run.

Cluster input frames using the speciﬁed clustering algorithm and distance metric. In order to speed up clus-
tering of large trajectories, the sieve keyword can be used. In addition, subsequent clustering calculations can be
sped up by writing/reading calculated pair distances between each frame to/from a ﬁle speciﬁed by pairdist (or
“CpptrajPairDist” if pairdist not speciﬁed).
Example: cluster on a speciﬁc distance:

720

32.12. Analysis Commands

distance endToEnd :1 :255
cluster data endToEnd clusters 10 epsilon 3.0 summary summary.dat info info.dat

Example: cluster on the CA atoms of residues 2-10 using average-linkage, stopping when either 3 clusters are
reached or the minimum distance between clusters is 4.0, writing the cluster number vs time to “cnumvtime.dat”
and a summary of each cluster to “avg.summary.dat”:

cluster C1 :2-10 clusters 3 epsilon 4.0 out cnumvtime.dat summary avg.summary.dat

Clustering Metrics

The Davies-Bouldin Index (DBI) measures sum over all clusters of the within cluster scatter to the between
cluster separation; the smaller the DBI, the better. The DBI is deﬁned as the average, for all clusters X, of fred,
where fred(X) = max, across other clusters Y, of (Cx + Cy)/dXY. Here Cx is the average distance from points in X
to the centroid, similarly Cy, and dXY is the distance between cluster centroids.

The pseudo-F statistic (pSF) is another measure of clustering goodness. It is intended to capture the ’tightness’
of clusters, and is in essence a ratio of the mean sum of squares between groups to the mean sum of squares within
group. High values are good. Generally, one selects a cluster-count that gives a peak in the pseudo-f statistic.
Formula: A/B, where A = (T - P)/(G-1), and B = P / (n-G). Here n is the number of points, G is the number of
clusters, T is the total distance from the all-data centroid, and P is the sum (for all clusters) of the distances from
the cluster centroid.

The cluster silhouette is a measure of how well each point ﬁts within a cluster. Values of 1 indicate the point is
very similar to other points in the cluster, i.e. it is well-clustered. Values of -1 indicate the point is dissimilar and
may ﬁt better in a neighboring cluster. Values of 0 indicate the point is on a border between two clusters.

Hints for setting DBSCAN parameters with ’kdist’

It is not always obvious what parameters to set for DBSCAN. You can get a rough idea of what to set ’mindist’

and ’epsilon’ to by generating a so-called "K-dist" plot with the ’kidst <k>’ option. The K-dist plot shows for
each point (X axis) the Kth farthest distance (Y axis), sorted by decreasing distance. You supply the same
distance metric and sieve parameters you want to use for the actual clustering, but nothing else. For example:

cluster C0 dbscan kdist 4 rms :1-4@CA sieve 10 loadpairdist pairdist CpptrajPairDist

The K-dist plot will be named <preﬁx>.<k>.dat, with the default preﬁx being ’Kdist’ (in this case the ﬁle name
would be Kdist.4.dat). The K-dist plot usually looks like a curve with an initially steep slope that gradually
decreases. Around where the initial part of the curve starts to ﬂatten out (indicating an increas in density) is around
where epsilon should be set; minpoints is set to whatever <k> was. It has been suggested that the shape of the
K-dist curve doesn’t change too much after Kdist=4, but users are encouraged to experiment.

Using ’dpeaks’ clustering

The ’dpeaks’ (density peaks) algorithm attempts to ﬁnd clusters by identifying points in high density regions
which are far from other points of high density[666]. There are two ways these points can be chosen. The
ﬁrst and recommended way is manually. In this method, clustering if ﬁrst run with choosepoints not speciﬁed
to generate a plot containing density versus minimum distance to point with next highest density (the decision
graph). Appropriate cut offs for distance and density can then be chosen based on visual inspection; cutoffs should
be chosen so that they select points that have both a high density and a high distance to point with next highest
density. Clustering can then be run again with distancecut and densitycut set.

The second way is automatically; cpptraj will attempt to identify outliers in the density vs distance plot based
on distance from the running average. Although this only requires a single pass, this method of choosing points is
not well-tested and currently not recommended.

721

32. cpptraj

The CpptrajPairDist ﬁle format

The CpptrajPairDist ﬁle is binary; the exact format depends on what version of cpptraj generated the ﬁle (since

earlier versions had no concept of ’sieve’). The CpptrajPairDist ﬁle starts with a 4 byte header containing the
characters ’C’ ’T’ ’M’ followed by the version number. A quick way to ﬁgure out the version is to use the linux
’od’ command to output the ﬁrst 4 bytes as hexadecimal, e.g.:

$ od -t x1 -N 4 CpptrajPairDist 0000000 43 54 4d 02

So the CpptrajPairDist ﬁle version in the above example is 2.

The next few numbers describe the matrix size and depend on the version.

Version 0: Two 4-byte integers: # of rows and # of elements.

Version 1: Two 8-byte unsigned integers (equivalent to size_t on most systems): # of rows and # of elements.

Version 2: Three 8 byte unsigned integers: original # of rows, actual # of rows, and sieve value.

This is followed by the actual matrix data, stored as a single array of ﬂoats (4 bytes). For versions 1 and 2 the
number of elements is explicitly stored. For version 2, to calculate the number of matrix elements you need to
read:

Elements = (actual_rows * (actual_rows - 1)) / 2

The cluster pair-distance matrix is an upper-right triangle matrix without the diagonal (in row-major order), so the
ﬁrst element is the distance between elements 0 and 1, the second is between elements 0 and 2, etc.

In version 2 ﬁles, if the sieve value is greater than 1 that means original_rows > actual_rows and there is an
additional array of characters original_nrows long, with ’T’ if the row is being ignored (i.e. it was sieved out) and
’F’ if the row is active (i.e. is active in the actual pairwise-distance matrix).

The code that cpptraj uses to read in CpptrajPairDist ﬁles is in ClusterMatrix::LoadFile() (ClusterMatrix.cpp).

32.12.5. cphstats

cphstats <pH sets> [name <name>] [statsout <statsfile>] [deprot]

[fracplot [fracplotout <file>]]

<pH sets> Previously read in pH data sets.

name <name> Output set name.

statsout <statsﬁle> Write pH statistics to <statsfile>

deprot If specified, calculate fraction deprotonated instead of protonated.

fracplot If specified, calculate fraction protonated/deprotonated vs pH.

fracplotout <ﬁle> File to write fraction plots to.

Data Sets Generated

<name>[Frac]:<idx> Fraction protonated/deprotonated for residue <idx>.

Calculate statistics for constant pH simulation data previously read in with readdata (see 32.6.11 on page 612).
Statistics are calculated for each residue at each input pH. Output format is as follows:

Solvent pH is <pH>
<res name> <res num> : Offset <off> Pred <pred> Frac Prot <frac> Transitions <#trans>
...
Average total molecular protonation: <avg>

722

32.12. Analysis Commands

Where <off> is offset from predicted, <pred> is predicted pH, and <#trans> is the number of transitions. A line
is printed for each residue. This functionality is similar to the cphstats utility that comes with Amber (see 24.7 on
page 521).

Note that data from constant pH REMD must be sorted prior to use with cphstats. See the readensembledata

( 32.8.20 on page 624) and sortensembledata ( 32.8.27 on page 626) commands for more details.

For example, to read in constant pH data from constant pH REMD, sort and analyze:

readensembledata ExplicitRemd/cpout.001 cpin ExplicitRemd/cpin name PH
sortensembledata PH
runanalysis cphstats PH[*] statsout stats.dat fracplot fracplotout frac.agr deprot

32.12.6. corr | correlationcoe

corr out <outfilename> <dataset1> [<dataset2>]

[lagmax <lag>] [nocovar] [direct]

out <outﬁlename> Write results to file named <outfilename>.

The datasets must

have the same # of data points.

<dataset1> [<dataset2>] Data set(s) to calculate correlation for.

If one dataset

or the same dataset is given twice, the auto-correlation will be
calculated, otherwise cross-correlation.

[lagmax] Maximum lag to calculate for. If not specified all frames are used.
[nocovar] Do not calculate covariance.
[direct] Do not use FFTs to calculate correlation; this will be much slower.

DataSet Aspects:
[<dataset1>] (Auto-correlation) The aspect will be the name of each of the input

data set.

[<dataset1>-<dataset2>] (Cross-correlation) The aspect will be the names of each

of the input data sets joined by a dash (’-’).

DataSet Aspects:
[coeff] Correlation coefficient.

Calculate the auto-correlation function for data set named <dataset1> or the cross-correlation function for data sets
named <dataset1> and <dataset2> up to <lagmax> frames (all if lagmax not speciﬁed), writing the result to ﬁle
speciﬁed by out. The two datasets must have the same # of datapoints.

32.12.7. crank | crankshaft

crank {angle | distance} <dsetname1> <dsetname2> info <string>

[out <filename>] [results <resultsfile>]

angle Analyze angle data sets.
distance Analyze distance data sets.
<dsetname1> Data set to analyze.
<dsetname2> Data set to analyze.
info <string> Title the analysis <string>.
[out <ﬁlename>] Write frame-vs-bin to <filename>.
[results <resultsﬁle>] Write results to <resultsfile>.

Calculate crankshaft motion between two data sets.

723

32. cpptraj

32.12.8. crdﬂuct

[crdset <crd set>] [<mask>] [out <filename>] [window <size>] [bfactor]

Calculate atomic positional ﬂuctuations for atoms in <mask> over windows of size <size>. If bfactor is speciﬁed,
the ﬂuctuations are weighted by 8
3π2(similar but not necessarily equivalent to crystallographic B-factor calcula-
tion). Units are Å, or Å2x 8

3π2 if bfactor speciﬁed.

32.12.9. crosscorr

crosscorr [name <dsetname>] <dsetarg0> [<dsetarg1> ...] [out <filename>]

[name <dsetname>] The resulting upper-triangle matrix is stored with name

<dsetname>.

<dsetarg0> [<dsetarg1> ...] Argument(s) specifying datasets to be used.
[out <ﬁlename>] Write results to file named <filename>.

Calculate the Pearson product-moment correlation coefﬁcients between all speciﬁed datasets.

32.12.10. curveﬁt

curvefit <dset> { <equation> |

name <dsname> {gauss | nexp <m> [form {mexp|mexpk|mexpk_penalty}} }

[AX=<value> ...] [out <outfile>] [resultsout <results>]
[maxit <max iterations>] [tol <tolerance>]
[outxbins <NX> outxmin <xmin> outxmax <xmax>]

<dset> Data set to fit.
<equation> Equation to fit of form <Variable> = <Equation>.

See 32.5.2 on

page 606 for more details on equations cpptraj understands.

name <dsname> Final data set name (required if using nexp or gauss).
gauss Fit to Gaussian of form A0 * exp( -((X - A1)^2) / (2 * A2^2) )
nexp <m> Fit to specified number of exponentials.
form <type> Fit to specified exponential form:

mexp Multi-exponential, SUM(m)[ An * exp(An+1 * X)]
mexpk Multi-exponential plus constant, A0 + SUM(m)[An * exp(An+1 * X)]
mexpk_penalty Same as mexpk except sum of prefactors constrained to 1.0

and exponential constants constrained to < 0.0.

AX=<value> Value of any constants in specified equation with X starting from 0

(can specify more than one).

out <outﬁle> Write resulting fit curve to <outfile>.
resultsout <results> Write details of the fit to <results> (default STDOUT).
maxit <max iterations> Number of iterations to run curve fitting algorithm

(default 50).

tol <tolerance> Curve-fitting tolerance (default 1E-4).
outxbins <NX> Number of points to use when generating final curve (default same

number of points as input data set).

outxmin <xmin> Minimum X value to use for final curve (default same number of

points as input data set).

724

32.12. Analysis Commands

outxmax <xmax> Maximum X value to use for final curve (default same number of

points as input data set).

Perform non-linear curve ﬁtting for the speciﬁed data set using the Levenberg-Marquardt algorithm. Any
equation form that cpptraj understands (see 32.5.2 on page 606) can be used, or several preset forms can be used.
Similar to Grace (http://plasma-gate.weizmann.ac.il/Grace/), an equation can contain constants for curve ﬁtting
termed AX (with X being a numerical digit, one for each constant), and is assigned to a variable which then
becomes a data set. For example, to ﬁt a curve to data from a ﬁle named Data.dat to a data set named ’FitY’:

readdata Data.dat
runanalysis curvefit Data.dat \

"FitY = (A0 * exp(X * A1)) + (A2 * exp(X * A3))" \
A0=1 A1=-1 A2=1 A3=-1 \
out curve.dat tol 0.0001 maxit 50

To perform the same ﬁt but to a multi-exponential curve with two exponentials:

readdata Data.dat
runanalysis curvefit Data.dat nexp 2 name FitY \

A0=1 A1=-1 A2=1 A3=-1 \
out curve1.dat tol 0.0001 maxit 50

32.12.11. diagmatrix

diagmatrix <name> [out <filename>] [thermo [outthermo <filename>]]

[vecs <#>] [name <modesname>] [reduce]
[nmwiz [nmwizvecs <#>] [nmwizfile <filename>]]

<name> Name of symmetric matrix to diagonalize.
[out <ﬁlename>] Write results to <filename>.
[thermo [outthermo <ﬁlename>]] Mass-weighted covariance (mwcovar) matrix only.

Calculate entropy, heat capacity, and internal energy from the structure of
a molecule (average coordinates, see above) and its vibrational frequencies
using standard statistical mechanical formulas for an ideal gas.
are written to <filename> if specified, otherwise results are written to
STDOUT. Note that this converts the units of the calculated eigenvalues to
frequencies (cm-1).

Results

[vecs <#>] Number of eigenvectors to calculate.

Default is 0, which is only

allowed when ’thermo’ is specified.

[name <modesname>] Store resulting modes data set with name <modesname>.
[reduce] Covariance (covar/mwcovar/distcovar) matrices only. For coordinate

covariance (covar/mwcovar) matrices, each eigenvector element is reduced
via Ei = Eix^2 + Eiy^2 + Eiz^2.
For distance covariance (distcovar) the
eigenvectors are reduced by taking the sum of the squares of each row. See
Abseher & Nilges, JMB 1998, 279, 911-920 for further details.
used to compare results from PCA in distance space with those from PCA in
cartesian-coordinate space.

They may be

[nmwiz] Generate output in .nmd format file for viewing with NMWiz[667]. See
http://prody.csb.pitt.edu/tutorials/nmwiz_tutorial/ for further details.
[nmwizvecs <#>] Number of vectors to write out for nmwiz output, starting

with the lowest frequency mode (default 20).

[nmwizﬁle <ﬁlename>] Name of nmwiz file to write to (default ’out.nmd’).

725

32. cpptraj

[nmwizmask <mask>] Mask of atoms corresponding to eigenvectors - should be

the same one used to generate the matrix.

Calculate eigenvectors and eigenvalues for the speciﬁed symmetric matrix. This is followed by Principal Com-
ponent Analysis (in cartesian coordinate space in the case of a covariance matrix or in distance space in the case
of a distance-covariance matrix), or Quasiharmonic Analysis (in the case of a mass-weighted covariance matrix).
Diagonalization of distance, correlation, idea, and ired matrices are also possible. Eigenvalues are given in cm−1
in the case of a mass-weighted covariance matrix and in the units of the matrix elements in all other cases. In the
case of a mass-weighted covariance matrix, the eigenvectors are mass-weighted.

For quasi-harmonic analysis the input must be a mass-weighted covariance matrix. Thermodynamic quantities
are calculated based on statistical mechanical formulae that assume the input system is oscillating in a single energy
well: see Statistical Thermodynamics by D. A. McQuarrie, particularly chapters 4, 5, and 6 for more details.[668]
For an in-depth discussion of the accuracy of thermodynamic parameters obtained via quasi-harmonic analysis see
Chang et al..[669]

Note that the maximum number of non-zero eigenvalues obtainable depends on the number of frames used to
generate the input matrix; the number of frames should be equal to or greater than the number of columns in the
matrix in order to obtain all eigenmodes.

Results may include average coordinates (in the case of covar, mwcovar, correl), average distances (in the case

of distcovar), main diagonal elements (in the case of idea and ired), eigenvalues, and eigenvectors.

For example, in the following a mass-weighted covariance matrix of all atoms is generated and stored
internally with the name mwcvmat; the matrix itself is written to mwcvmat.dat. Subsequently, the ﬁrst 20
eigenmodes of the matrix are calculated and written to evecs.dat, and quasiharmonic analysis is performed at
300.0 K, with the results written to thermo.dat.

matrix mwcovar name mwcvmat out mwcvmat.dat
diagmatrix mwcvmat out evecs.dat vecs 20 \

thermo outthermo thermo.dat temp 300.0

Output Format

The “modes” or “evecs” output ﬁle is a text ﬁle with the following format:

[Reduced] Eigenvector file: <Type> nmodes <#> width <width>

<# Avg Coords> <Eigenvector Size>

<Average Coordinates>

Where <Type> is a string identifying what kind of matrix the eigenvectors/eigenvalues were determined from,
nmodes is how many eigenvectors are in the ﬁle, and <Average Coordinates> are in lines 7 columns wide, with
each element having width speciﬁed by <width>. Then for each eigenvector:

****

<Eigenvector#> <Eigenvalue>
<Eigenvector Coordinates>
...

Where <Eigenvector Coordinates> are in lines 7 columns wide, with each element having width speciﬁed by
<width>.

32.12.12. divergence

divergence ds1 <ds1> ds2 <ds2>

Calculate Kullback-Leibler divergence between speciﬁed data sets.

726

32.12. Analysis Commands

32.12.13. fft

fft <dset0> [<dset1> ...] [out <outfile>] [name <outsetname>] [dt <samp_int>]

<dset0> [<dset1 ...] Argument(s) specifying datasets to be used.

[out <outﬁle>] Write results to file named <outfile>.

[name <outsetname>] The resulting transform will be stored with name

<outsetname>.

[dt <samp_int>] Set the sampling interval (default is 1.0).

Perform fast Fourier transform (FFT) on speciﬁed data set(s). If more than 1 data set, they must all have the same
size.

32.12.14. hausdorff

hausdorff <set arg0> [<set arg1> ...]

[outtype {basic|trimatrix nrows <#>|fullmatrix nrows <#> [ncols <#>]}]

[name <output set name>] [out <file>] [outab <file>] [outba <file>]

<set arg0> ... Input matrix data set(s) to calculate Hausdorff distance(s) for.

[outtype] Specify the output type.

basic Output the Hausdorff distance for each input matrix as scalar 1D

data.

trimatrix nrows <#> Output Hausdorff distances for each input matrix as a 2D

upper-triangular matrix with the given number of rows.
(nrows * (nrows-1)) / 2 input sets.

Must have

fullmatrix nrows <#> ncols <#> Output Hausdorff distances for each input matrix

as a full matrix with the given number of columns and rows.
is not given, use nrows. Must have nrows * ncols input sets.

If ncols

[name <output set name>] Name of output data sets.

[out <ﬁle>] File to write Hausdorff distances to.

[outab <ﬁle>] File to write directed A->B Hausdorff distances to.

[outba <ﬁle>] File to write directed B->A Hausdorff distances to.

Calculate the symmetric Hausdorff distance for one or more matrices. The results can be saved as an array or as a
full or upper-triangular matrix with the speciﬁed dimensions. The Hausdorff distance H is determined from:

H = max{dH(A,B), dH(B,A)]

Where dH(A,B) is the directed Hausdorff distance between sets A and B, etc. Colloquially speaking, the directed
Hausdorff distance between A and B is determined as follows:

1. What is the closest approach (distance) of each point in A to any point in B?

2. Choose the largest distance from among those distances.

If desired, the output can be formed into a matrix, which can be useful e.g. when doing multiple 2D rms
calculations on different regions of a trajectory. For example, the following input divides a 100 frame trajectory
into 10 frame chunks, calcultes the 2D RMS matrix for each chunk, then performs Hausdorff analysis on the
resulting matrices and forms a full output matrix.

727

32. cpptraj

parm ../DPDP.parm7
for beg=1;beg<100;beg+=10 end=10;end+=10 i=1;i++

loadcrd ../DPDP.nc \$beg \$end name Chunk\$i

done
# Do the 2drms in chunks
for i=1;i<11;i++

for j=1;j<11;j++

2drms crdset Chunk\$i reftraj Chunk\$j M\$i.\$j

done

done
hausdorff M* out hausdorff.fullmatrix.gnu title hausdorff.matrix.gnu \

outtype fullmatrix nrows 10

runanalysis

This type of calculation lends itself well to parallelization. The parallelanalysis command can be used to run all
the 2drms calculations in parallel with MPI-enabled cpptraj:

parm ../DPDP.parm7
for beg=1;beg<100;beg+=10 end=10;end+=10 i=1;i++

loadcrd ../DPDP.nc \$beg \$end name Chunk\$i

done
# Do the 2drms in chunks
for i=1;i<11;i++

for j=1;j<11;j++

2drms crdset Chunk\$i reftraj Chunk\$j M\$i.\$j

done

done
parallelanalysis sync
runanalysis hausdorff M* out hausdorff.fullmatrix.gnu title hausdorff.matrix.gnu \

outtype fullmatrix nrows 10

32.12.15. hist | histogram

hist <dataset_name>[,<min>,<max>,<step>,<bins>] ...
[free <temperature>] [norm | normint] [gnu] [circular] out <filename>
[amd <amdboost_data>] [name <outputset name>]

[traj3d <file> [trajfmt <format>] [parmout <file>]]

[min <min>] [max <max>] [step <step>] [bins <bins>] [nativeout]

<dataset_name>[,<min>,<max>,<step>,<bins>] Dataset(s) to be histogrammed.

Optionally, the min, max, step, and/or number of bins can be specified for
this dimension after the dataset name separated by commas.
necessary to specify the step or number of bins, an asterisk ’*’ indicates
the value should be calculated from available data.

It is only

[free <temperature>] If specified, estimate free energy from bin populations using

Gi = −kBT ln
, where KB is Boltzmann’s constant, T is the temperature
specified by <temperature>, Ni is the population of bin i and NMax is the
population of the most populated bin.
artificial barrier equivalent to a population of 0.5.

Bins with no population are given an

NMax

[norm] If specified, normalize bin populations so the sum over all bins equals

1.0.

[normint] Normalize bin populations so the integral over them is 1.0.

728

(cid:16) Ni

(cid:17)

32.12. Analysis Commands

[gnu] Internal output only; data will be gnuplot-readable, i.e. a space will be

printed after the highest order coordinate cycles.

[circular] Internal output only; data will wrap, i.e. an extra bin will be
Useful for e.g.

printed before min and after max in each direction.
dihedral angles.

out <ﬁlename> Write results to file named <filename>.
[amd <amdboost_data>] Reweight bins using AMD boost energies in data set

<amdboost_data> (in KT).

[name <outputset name>] Output histogram data set name.
[traj3d <ﬁle> [trajfmt <format>]] (3D histograms only) Write a pseudo-trajectory of

the 3 data sets (1 atom) to <file> with format <format>.

[parmout <ﬁle>] (3D histograms only) Write a topology corresponding to the

pseudo-trajectory to <file>.

[min <min>] Default minimum to bin if not specified.
[max <max>] Default max to use if not specified.
[step <step>] Default step size to use if not specified.
[bins <bins>] Default bin size to use if not specified.
[nativeout] Do not use cpptraj data file framework; only necessary for writing

out histograms with > 3 dimensions.

Create an N-dimensional histrogram, where N is the number of datasets speciﬁed. For 1-dimensional histograms
the xmgrace ’.agr’ ﬁle format is recommended; for 2-dimensional hisograms the gnuplot ’.gnu’ ﬁle format is
recommended; for all other dimensions plot formatting is disabled and the routine uses its own internal output
format; this is also enabled if gnu or circular is speciﬁed.

For example, to create a two dimensional histogram of two datasets ’phi’ and ’psi’:

dihedral phi :2@C :3@N :3@CA :3@C
dihedral psi :3@N :3@CA :3@C :4@N
hist phi,-180,180,*,72 psi,-180,180,*,72 out hist.gnu

In this case the number of bins (72) has been speciﬁed for each dimension and ’*’ has been given for the step size,
indicating it should be calculated based on min/max/bins. The following ’hist’ command is equivalent:

hist phi psi min -180 max 180 bins 72 out hist.gnu

32.12.16. integrate

integrate <dset0> [<dset1> ...] [out <outfile>] [intout <intfile>]

[name <name>]

<dset0> [<dset1> ...] Data set(s) to integrate.
[out <outﬁle>] If specified, write cumulative sum curves to <outfile>.
[intout <intﬁle>] If specified, write final integral values to <intfile>.
[name <name>] Output data set(s) name.
DataSets Created:
<name> Final integral values, 1 for each input data set (indexed from 0).
<name>[Sum]:<idx> Cumulative sum curves if out was specified, 1 for each input

data set (indexed from 0).

Integrate speciﬁed data set(s) using trapezoid integration. If ’out’ is speciﬁed write cumulative sum curves to
<outﬁle>. If ’intout’ is speciﬁed write ﬁnal integral values for each set to <intﬁle>.

729

32. cpptraj

32.12.17. ired

ired [relax freq <MHz> [NHdist <distnh>]] [order <order>]

tstep <tstep> tcorr <tcorr> out <filename> [norm] [drct]
modes <modesname> [name <output sets name>] [ds2matrix <file>]

[relax freq <MHz> [NHdist <distnh>]] Should only be used when ired vectors represent
N-H bonds; calculate correlation times τm for each eigenmode and relaxation
rates and NOEs for each N-H vector. ’freq <MHz>’ (required) is the Lamor
frequency of the measurement. ’NHdist <distnh>’ specifies the length of
the NH bond in Angstroms (default is 1.02).

order <order> Order of the Legendre polynomials to use when calculating

spherical harmonics (default 2).

tstep <tstep> Time between snapshots in ps (default 1.0).

tcorr <tcorr> Maximum time to calculate correlation functions for in ps (default

10000.0).

out <ﬁlename> Name of file to write output to.
[norm] Normalize all correlation functions, i.e., Cl(t = 0) = Pl(t = 0) = 1.0.
[drct] Use the direct method to calculate correlations instead of FFT; this will

be much slower.

modes <modesname> Name of previously calculated eigenmodes corresponding to

IRED vectors.

[name <name>] Output data set name.

[ds2matrix <ﬁle>] If specified, write full delta*S^2 matrix (# IRED vector rows

by # eigenmodes columns) to <file>.

DataSets Created:

<name>[S2] S2 order parameters for each vector.

<name>[Plateau] Plateau values for each vector.

<name>[TauM] TauM values for each vector.

<name>[dS2] Full delta*S^2 matrix.

<name>[T1] T1 relaxation values for each vector.

<name>[T2] T2 relaxation values for each vector.

<name>[NOE] NOEs for each vector.

<name>[Cm(t)]:X Cm(t) function for vector X.

<name>[Cj(t)]:X Cj(t) function for vector X.

Peform IRED[654] analysis on previously deﬁned IRED vectors (see vector ired) using eigenmodes calculated
from those vectors with a previous ’diagmatrix’ command. The number of deﬁned IRED vectors should match
the number of eigenmodes calculated. Autocorrelation functions for each mode and the corresponding correlation
time τm will be written to ﬁlename.cmt. Autocorrelation functions for each vector will be written to ﬁlename.cjt.
Relaxation rates and NOEs for each N-H vector will be written to <ﬁlename> or added to the the end of the standard
output. For the calculation of τm the normalized correlation functions and only the ﬁrst third of the analyzed time
steps will be used. For further information on the convergence of correlation functions see [Schneider, Brünger,
Nilges, J. Mol. Biol. 285, 727 (1999)].

730

32.12. Analysis Commands

Example of IRED in Cpptraj

In cpptraj, IRED analysis[654] can now be performed in one pass (as opposed to the two passes previously

required in ptraj). First, IRED vectors are deﬁned (in this case for N-H bonds) and an IRED matrix is calculated
and analyzed. The IRED vectors are then projected onto the calculated IRED eigenvectors in the ired analysis
command to calculate the time correlation functions. If the parameter order is speciﬁed, order parameters based
on IRED are calculated. By specifying the relax parameter, relaxation rates and NOEs can be obtained for each
N-H vector. Note that the order of the IRED matrix should be the same as the one speciﬁed for IRED analysis.

# Define N-H IRED vectors
vector v0 @5 ired @6
vector v1 @7 ired @8
...
vector v5 @15 ired @16
vector v6 @17 ired @18‘
# Define IRED matrix using all previous IRED vectors
matrix ired name matired order 2
# Diagonalize IRED matrix
diagmatrix matired vecs 6 out ired.vec name ired.vec
# Perform IRED analysis
ired relax NHdist 1.02 freq 500.0 tstep 1.0 tcorr 100.0 out v0.out \

noefile noe order 2

32.12.18. kde

kde <dataset> [bandwidth <bw>] [out <file>] [name <dsname>]

[min <min>] [max <max] [step <step>] [bins <bins>] [free]
[kldiv <dsname2> [klout <outfile>]] [amd <amdboost_data>]

[bandwidth <bw>] Bandwidth to use for KDE; if not specified bandwidth will be

estimated using the normal distribution approximation.

[out <ﬁle>] Output file name.
[name <dsname>] Output data set name.
[min <min>] Minimum bin.
[max <max>] Maximum bin.
[step <step>] Bin step.
[bins <bins>] Number of bins.
[free] Calculate free energy from bin population.
[kldiv <dsname2> [klout <outﬁle>]] Calculate Kullback-Leibler divergence over time
Output to <outfile>

of <dataset> distribution to <dsname2> distribution.
if klout specified.

[amd <amdboost_data>] Reweight histogram using AMD boost data from data set

<amdboost_data> (in KT).

Histogram 1D data set using a Gaussian kernel density estimator.

32.12.19. lifetime

lifetime [out <filename>] <dsetarg0> [ <dsetarg1> ... ]

[window <windowsize> [name <setname>]] [averageonly]
[cumulative] [delta] [cut <cutoff>] [greater | less] [rawcurve]

[fuzz <fuzzcut>] [nosort]

731

32. cpptraj

[out <ﬁlename>] Write results to file named <filename>, and lifetime curves to

If performing windowed lifetime analysis, <filename>

’crv.<filename>’.
contains the fraction present over time windows, and 2 additional files are
written: ’max.<filename>’, containing max lifetime over windows, and
’avg.<filename>’, containing average lifetime over windows.

<dsetarg0> [<dsetarg1> ...] Argument(s) specifying datasets to be used.
[window <windowsize>] Size of window (in frames) over which to calculate

lifetimes/averages.
over all frames.

If not specified lifetime/average will be calculated

[name <setname>] Store results in data sets with name <setname>.
[averageonly] Just calculate averages (no lifetime analysis).
[cumulative] Calculate cumulative lifetimes/averages over windows.
[delta] Calculate difference from previous window average.
[cut <cutoff>] Cutoff to use when determining if data is ’present’ (default 0.5).
[greater] Data is considered present when above the cutoff (default).
[less] Data is considered present when below the cutoff.
[rawcurve] Do not normalize lifetime curves to 1.0.
[fuzz <fuzzcut>] Ignore changes in lifetime state that are less than <fuzzcut>

frames.

[nosort] Do not sort data sets by name.

Data Sets Created:
<setname> Number of lifetimes for each set, or if window specified fraction

present over time windows.

<setname>[max] Maximum lifetime for each set, or if window specified maximum

lifetime over time windows.

<setname>[avg] Average lifetime for each set, or if window specified average

lifetime over time windows.
<setname>[curve] Lifetime curves.
The following are created only if window not specified:
<setname>[frames] Total number of frames lifetime present for each set.
<setname>[name] Name of each set.

Perform lifetime analysis for speciﬁed data sets. Lifetime data can either be determined for the entire set, or for
time windows of speciﬁed size within the set if window speciﬁed.

A “lifetime” is deﬁned as the length of time something remains ’present’; data is considered present when

above or below a certain cutoff (the default is greater than 0.5, useful for analysis of hbond time series data). For
example, in the case of a hydrogen bond ’series’ data set, if a hydrogen bond is present during a frame the value is
1, otherwise it is 0. Given the hbond time series data set {1 1 1 0 1 0 0 0 1 1}, the overall fraction present is 0.6.
However, there are 3 lifetimes of lengths 3, 1, and 2 ({1 1 1}, {1}, and {1 1}). The maximum lifetime is 3 and the
average lifetime is 2.0, i.e. (3 + 1 + 2) / 3 lifetimes = 2.0. One can also construct a “lifetime curve”, which is
constructed as the sum of all individual lifetimes. By default these curves are normalized to 1.0, but the raw curve
can be obtained using the rawcurve keyword. For the example data set here the raw lifetime curve would be 3
frames long:

1 1 1
1
1 1

Curve: 3 2 1

732

32.12. Analysis Commands

By default data sets are sorted by name unless nosort is speciﬁed. The lifetime command can calculate lifetimes
over speciﬁc time windows by using the window keyword. This can be particularly useful if one wants to get
a sense for how lifetimes are changing over the course of very long time series data. In addition, averages can
be calculated instead of lifetimes by specifying averageonly. Cumulative averages over windows can be obtained
using the cumulative keyword, or the change from the average value in the previous window can be obtained using
the delta keyword.

The fuzz keyword can be used to try and smooth the input data by ignoring changes in state that occur for fewer
frames than <fuzzcut>. For example, in the above example hbond time series data set there is a one frame change
in state between the ﬁrst and second lifetimes which could be interpreted as a transient breaking of the hydrogen
bond. Using a <fuzzcut> value of 1, this one frame change in state would be ignored, and the data set would
effectively appear to lifetime as {1 1 1 1 1 0 0 0 1 1}. The state change between the second and third lifetimes is
longer than <fuzzcut> (3 frames) and so it would remain.

If window is not speciﬁed, two ﬁles are output: <ﬁlename> and crv.<ﬁlename>. The ﬁle <ﬁlename> contains

overall lifetime stats for each set with format:

#Set <setname> <setname>[max] <setname>[avg] <setname>[frames] <setname>[name]

where <setname> denotes the total number of lifetimes, <setname>[max] denotes the maximum lifetime,
<setname>[avg] denotes the average lifetime, <setname>[frames] denotes the total number of frames present
in all lifetimes, and <setname>[name] is the data set name. The ﬁle crv.<ﬁlename> contains the lifetime curves
for each set.

If window is speciﬁed, four ﬁles are output: <ﬁlename>, max.<ﬁlename>, avg.<ﬁlename>, and crv.<ﬁlename>.
<ﬁlename> contains the fraction “present” over each time window for each set, max.<ﬁlename> contains the
maximum lifetime in each time window for each set, avg.<ﬁlename> contains the average lifetime over each
window for each set, and crv.<ﬁlename> contains the overall lifetime curves for each set. For window output,
Gnuplot format is recommended.

Example: hbond lifetime analysis

parm DPDP.parm7
trajin DPDP.nc
hbond HB out hbond.dat @N,H,C,O series uuseries solutehb.agr \

avgout hbavg.dat printatomnum

# ’run’ is used here to process the trajectory and generate hbond data
run
# Perform lifetime analysis
runanalysis lifetime HB[solutehb] out lifehb.dat

Calculate ion lifetimes from hbond over windows of size 100 frames:

hbond ION out ion.dat solventdonor :WAT solventacceptor :WAT@O series
run
lifetime HB[solventhb] out ion.lifetime.100.gnu window 100

32.12.20. lowestcurve

lowestcurve points <# lowest> [step <stepsize>] <dset0> [<dset1> ...]

[out <file>] [name <setname>]

<# lowest> Number of lowest points in each bin to average over.
[step <stepsize>] Bin step size
<dset0> [<dset1> ...] Data set(s) to use.
[out <ﬁle>] File to write lowest curve to.
[name <setname>] Output lowest curve set name.

733

32. cpptraj

Calculate a curve of the average of the # lowest points in bins of stepsize. Essentially each input data set is binned
over bins of stepsize, then the lowest <#> points are averaged over for each bin.

32.12.21. meltcurve

meltcurve <dset0> [<dset1> ...] [out <outfile>] [name <outsetname>] cut <cut>

Calculate melting curve from input data sets (i.e. fraction ’folded’ for each data set) assuming a simple 2-state
transition model, using data below <cut>as ’folded’ and data above <cut> as ’unfolded’.

32.12.22. modes

modes {fluct|displ|corr|eigenval|trajout|rmsip} name <modesname> [name2 <modesname>]

[beg <beg>] [end <end>] [bose] [factor <factor>] [calcall]
[out <outfile>] [setname <name>]

Options for ’trajout’: (Generate pseudo-trajectory)

[trajout <name> parm <name> | parmindex <#>

[trajoutfmt <format>] [trajoutmask <mask>]

[pcmin <pcmin>] [pcmax <pcmax>] [tmode <mode>]]
Options for ’corr’: (Calculate dipole correlation)

{ maskp <mask1> <mask2> [...] | mask1 <mask> mask2 <mask> }
parm <name> | parmindex <#>

Types of Calculations:

ﬂuct RMS fluctuations (X, Y, Z, and total) for each atom across specified

normal modes.

displ Displacement of cartesian coordinates in the X, Y and Z directions for

each atom across specified normal modes.

corr Dipole-dipole correlation functions.
eigenval Calculate eigenvalue fractions.
trajout Create a pseudo-trajectory along the given mode from the average

Must also specify maskp (see below).

structure.

rmsip Calculate the root-mean-square inner product between modes specified by

name and name2.

Options:

name <modesname> Previously read-in or generated Modes data set name.
[beg <beg>] [end <end>] If modes taken from datafile, beginning and end modes to
read. Default for beg is 7 (which skips the first 6 zero-frequency modes
in the case of a normal mode analysis); for end it is 50.

[bose] Use quantum (Bose) statistics in populating the modes.
[factor <factor>] multiplicative constant on the amplitude of

displacement/pseudo-trajectory, default 1.0.

[calcall] If specified use all eigenvectors; otherwise eigenvectors associated

with zero or negative eigenvalues will be skipped.

[out <outﬁle>] File to write data results to.

If not given results are written

to STDOUT.

[setname <name>] Output data set name.
Options for ’trajout’:

734

32.12. Analysis Commands

<name> Output trajectory file name.
[parm <parmﬁle/tag>|parmindex <#>] Topology file to use (default first Topology

loaded).

[trajoutfmt <format>] Output trajectory format.
[trajoutmask <mask>] Mask of atoms that correspond to how modes were originally

generated.

[pcmin <pcmin>] Lowest principal component projection value to use for output

trajectory.

[pcmax <pcmax>] Highest principal component projection value to use for output

trajectory.

[tmode <mode>] Mode to generate pseudo-trajectory for.
Options for ’corr’:
[maskp <mask1> <mask2> [...]] If corr, pairs of atom masks (mask1, mask2; each

pair preceded by “maskp” and each mask defining only a single atom) have to
be given that specify the atoms for which the correlation functions are
desired.

mask1 <mask> mask2 <mask> Instead of maskp, specify two masks; atoms from the

first mask will be paired up with atoms from the second mask.

DataSets Created (fluct)
<name>[rmsX] RMS fluctuations in the X direction.
<name>[rmsY] RMS fluctuations in the Y direction.
<name>[rmsZ] RMS fluctuations in the Z direction.
<name>[rms] Total RMS fluctuations.
DataSets Created (displ)
<name>[displX] Displacement in X direction.
<name>[displY] Displacement in Y direction.
<name>[displZ] Displacement in Z direction.
DataSets Created (eigenval)
<name>[Frac] Fraction eigenvalue contributes to overall motion.
<name>[Cumulative] Cumulative fraction.
<name>[Eigenval] Value of eigenvlue.
DataSets Created (rmsip)
<name> Result of RMSIP calculation.

Analyze previously calculated eigenmodes obtained from principal component analyses (of covariance matrices)
or quasiharmonic analyses (diagmatrix analysis command). Modes are taken from a previously generated data set
(i.e. from diagmatrix) or read in from a data ﬁle with readdata. By default, classical (Boltzmann) statistics are
used in populating the modes. A possible series of commands would be “matrix covar | mwcovar ...” to generate
the matrix, “diagmatrix ...” to calculate the modes, and, ﬁnally, “modes ...”.

For example, to calculate the RMS ﬂuctuations or displacements of the ﬁrst 3 eigenmodes caluclated from a

mass-weighted covariance matrix:

matrix mwcovar name mwcvmat out mwcvmat.dat
diagmatrix mwcvmat name evecs vecs 5
modes fluct out rmsfluct.dat name evecs beg 1 end 3
modes displ out resdispl.dat name evecs beg 1 end 3

735

32. cpptraj

Additionally, dipole-dipole correlation functions for modes obtained from principle component analysis or
quasiharmonic analysis can be computed.

modes corr out cffromvec.dat name evecs beg 1 end 3 \

maskp @1 @2 maskp @3 @4 maskp @5 @6

or

mode corr out cffromvec.dat name evecs beg 1 end 3 mask1 @1,3,5 mask2 @2,4,6

If eigenval is speciﬁed, the fraction contribution of each eigenvector to the total motion is calculated and output
with format:

#Mode Frac. Cumulative Eigenval

where #Mode is the eigenvector number, Frac. is the eigenvalue over the sum of all eigenvalues, Cumulative is
the cumulative sum of Frac., and Eigenval is the eigenvalue itself. Note that in order to get an idea for how much
each eigenvector contributes to all motion, this is best used when all possible eigenvectors have been determined
for a system.

In order to visualize eigenvectors, pseudo-trajectories along eigenvectors can be created using average

coordinates with the trajout keyword. For example, to write a pseudo-trajectory of the ﬁrst principal component
from principal component value of -100 to 100 for a previously calculated Modes data set corresponding to heavy
atoms (no hydrogens) for residues 1 to 36:

parm ../GAAC.nowat.parm7
readdata evecs.dat
runanalysis modes name evecs.dat trajout test.nc trajoutfmt netcdf \

trajoutmask :1-36&!@H= pcmin -100 pcmax 100 tmode 1

32.12.23. multicurve

multicurve set <dset> [set <dset> ...]

<dset> { <equation> |

name <dsname> nexp <m> [form {mexp|mexpk|mexpk_penalty} }

[AX=<value> ...] [out <outfile>] [resultsout <results>]
[maxit <max iterations>] [tol <tolerance>]
[outxbins <NX> outxmin <xmin> outxmax <xmax>]

set <dset> [set <dset> ...] Data set(s) to fit.
<equation> Equation to fit of form <Variable> = <Equation>. See 32.5.2 on

page 606 for more details on equations cpptraj understands.

name <dsname> Name of output data sets (required if using nexp).
nexp <m> Fit to specified number of exponentials.
form <type> Fit to specified exponential form:

mexp Multi-exponential, SUM(m)[ An * exp(An+1 * X)]
mexpk Multi-exponential plus constant, A0 + SUM(m)[An * exp(An+1 * X)]
mexpk_penalty Same as mexpk except sum of prefactors constrained to 1.0 and

exponential constants constrained to < 0.0.

AX=<value> Value of any constants in specified equation with X starting from 0

(can specify more than one).

out <outﬁle> Write resulting fit curve to <outfile>.
resultsout <results> Write details of the fit to <results> (default STDOUT).
maxit <max iterations> Number of iterations to run curve fitting algotrithm

(default 50).

736

32.12. Analysis Commands

tol <tolerance> Curve-fitting tolerance (default 1E-4).
outxbins <NX> Number of points to use when generating final curve (default same

number of points as input data set).

outxmin <xmin> Minimum X value to use for final curve (default same number of

points as input data set).

outxmax <xmax> Maximum X value to use for final curve (default same number of

points as input data set).

Fit each input data set <dset> to <equation>. See the curveﬁt command on page 724 for more details.

32.12.24. multihist

multihist [out <filename>] [name <dsname>] [norm | normint] [kde]

[min <min>] [max <max>] [step <step>] [bins <bins>] [free <T>]
<dsetarg0> [ <dsetarg1> ... ]

out <ﬁlename> Output file.
name <dsname> Name for resulting histogram data sets.
norm (Only used if not kde) Normalize so that max bin is 1.0.
normint (Default for kde) Normalize integral over histogram to 1.0.
kde Use kernel density estimator to construct histogram.
min <min> Histogram minimum (default data set minimum).
max <max> Histogram maximum (default data set maximum).
step <step> Histogram step.
bins <bins> Number of histogram bins.
free <T> Calculate free energy from bin populations as G = -R * <T> * ln( Ni /

Nmax ).

<dsetargX> Data set argument - may specify more than one.

Histogram each data set separately in 1D. Must specify at least bins or step.

32.12.25. phipsi

phipsi <dsarg0> [<dsarg1> ...] resrange <range> [out <file>]

<dsargX> Argument selecting data sets. Can specify more than 1.
resrange <range> Residue range to use (actually uses data set index).
[out <ﬁle>] Output file.

Calculate the average and standard deviation of [phi] and [psi] data set pairs, write to <ﬁle> with format:

#Phi Psi SD(Phi) SD(Psi) Legend

Where Phi is the average value of phi, Psi is the average value of psi, SD(Phi) is the standard deviation of phi,
SD(psi) is the standard deviation of psi, and Legend contains text describing the phi and psi data sets used in the
calculation. Periodicity is taken into account during averaging. The data sets must have been internally labeled as
type ’phi’/’psi’ and must have a data set index set (actions like dihedral and multidihedral do this automatically).
For example:

parm ../DPDP.parm7
trajin ../DPDP.nc
multidihedral DPDP phi psi
run
phipsi DPDP[phi] DPDP[psi] out phipsi.dat resrange 1-22

737

32. cpptraj

32.12.26. regress

regress <dset0> [<dset1> ...] [name <name>] [nx <nxvals>]

[out <filename>] [statsout <filename>]

dsetX Data set(s) to perform linear regression for.
name <name> Data set name for resulting linear fits.
nx <nxvals> Number of X values to use in output data set(s) (ranging from input

set min to max X). If not specified, input X values used.

out <ﬁlename> File to write fit lines to.
statsout <ﬁlename> File to write fit statistics to.

DataSets Generated:
<name>:<idx> Output fit line(s) (indexed by input set order if more than one

input set).

<name>[slope]:<idx> Output fit line slope(s).
<name>[intercept]:<idx> Output fit line intercept(s).

Perform linear regression on the speciﬁed data set(s). The ﬁt line is calculated using either the input X values or
<nxvals> values ranging from the input set minimum to maximum X. Statistics for the ﬁt(s) are saved to the ﬁle
speciﬁed by statsout or reported to STDOUT.

For example, to ﬁt data read in from a ﬁle and then create a set using the ﬁt parameters:

readdata esurf_vs_rmsd.dat.txt index 1 name XY
runanalysis regress XY name FitXY statsout statsout.dat
createset "Y = FitXY[slope] * X + FitXY[intercept]" xstep .2 nx 100
writedata Y.dat Y

32.12.27. remlog

remlog {<remlog dataset> | <remlog filename>} [out <filename>] [crdidx | repidx]

[stats [statsout <file>] [printtrips] [reptime <file>]] [lifetime <file>]
[reptimeslope <n> reptimeslopeout <file>] [acceptout <file>] [name <setname>]

[edata [edataout <file>]]

<remlog dataset> Previously read-in REM log data.
<remlog ﬁlename> REM log file name to read in.
[out <ﬁlename>] Write replica/coordinate index versus time to <filename>.

crdidx Print coordinate index vs exchange; output sets contain replica

indices.

repidx Print replica index vs exchange; output sets contain coordinate

indices.

stats [statsout <ﬁle>] Calculate round-trip statistics and optionally write to

<file>.

printtrips Print details of each individual round trip.
[reptime <ﬁle>] Write time spent at each replica to <file>.
[lifetime <ﬁle>] Print lifetime data at each replica to <file>.
[reptimeslope <n>] Calculate the slope of time spent at each replica every <n>

exchanges.

[reptimeslopeout <ﬁle>] File to write reptimeslope output to.

738

32.12. Analysis Commands

[acceptout <ﬁle>] Write overall exchange acceptances to <file>.

[name <setname>] Output data set name.

[edata [edataout <ﬁle>]] Extract energy data from replica log, optionally write to

file.

DataSets created:

<setname>:<idx> Replica/coordinate index vs exchange.

<setname>[E]:<idx> If ’edata’ specified, energy data from replica log.

Analyze previously read in (via readdata) M-REMD/T-REMD/H-REMD replica log data. Statistics calculated
include round-trip time, which is the time needed for a coordinate set to travel from the lowest replica to the
highest and back, and the number of exchanges each coordinate spent at each replica. For example, to read in
REM log data from an Amber M-REMD run and analyze it:

readdata rem.log.1.save rem.log.2.save dimfile remd.dim as remlog nosearch
remlog rem.log.1.save stats reptime mremdreptime.dat

For an example of remlog analysis applied to actual REMD data, see Roe et al.[670].

32.12.28. rms2d | 2drms

rms2d [crdset <crd set>] [<name>] [<mask>] [out <filename>]

[dme | nofit | srmsd] [mass]
[reftraj <traj> [parm <parmname> | parmindex <parm#>] [<refmask>]]
[corr <corrfilename>]

[crdset <crd set>] Name of previously generated COORDS DataSet. If not specified

the default COORDS set will be used.

[<mask>] Mask of atoms to calculate 2D-RMSD for.

Default is all atoms.

[out <ﬁlename>] Write results to <filename>.

[dme] Calculate distance RMSD instead of coordinate RMSD; this is substantially

slower.

[noﬁt] Calculate RMSD without fitting.

[srmsd] Calculate symmetry-corrected RMSD (see 32.11.78 on page 704).

[mass] Mass-weight RMSD.

[reftraj <traj>] Calculate 2D RMSD to frames in trajectory <traj> instead (can also

be another COORDS set).

[parm <parmname> | parmindex <#>] Topology to use for <traj>; only useful in

conjunction with reftraj.

[<refmask>] Mask of atoms in reference; only useful in conjunction with reftraj.

[corr <corrﬁlename>] Calculate pseudo-auto-correlation C for 2D-RMSD as

∑ j<N−i

j=0

exp(−RMSD( j, j+i))

N−i

C(i) =
the total number of frames. An exponential is used to weight the RMSD
since 0.0 RMSD is equivalent to correlation of 1.0.
if reftraj is not used.

, where i is the lag, j is the frame #, and N is

This can only be done

DataSet Aspects:

[Corr] (corr only) Pseudo-auto-correlation.

739

32. cpptraj

Note: For backwards compatibility with ptraj the command ’2drms’ will also work.

Calculate the best-ﬁt RMSD of each frame in <crd set> (the default COORDS set if none speciﬁed) to each

other frame. This creates an upper-triangle matrix named <name> (or a full matrix if reftraj speciﬁed). The
output of the rms2d command can be best-viewed using gnuplot; a gnuplot-formatted ﬁle can be produced by
giving <ﬁlename> a ’.gnu’ extension. For example, to calculate the RMSD of non-hydrogen atoms of each frame
in trajectory “test.nc” to each other frame, writing to a gnuplot-viewable ﬁle “test.2drms.gnu”:

trajin test.nc
rms2d !(@H=) out test.2drms.gnu

To calculate the RMSD of atoms named CA of each frame in trajectory “test.nc” to each frame in “ref.nc”
(assuming test.nc and ref.nc are using the default topology ﬁle):

trajin test.nc
rms2d @CA out test.2drms.gnu reftraj ref.nc

32.12.29. rmsavgcorr

rmsavgcorr [crdset <crd set>] [<name>] [<mask>] [out <filename>] [mass]

[stop <maxwindow>] [offset <offset>]
{reference <ref file> parm <parmfile> | first}

[crdset <crd set>] COORDS data set to use (if not specified the default COORDS set

will be used).

[<name>] Output data set name.
[<mask>] Atoms to calculate RMS average correlation for.
[out <ﬁlename>] Output filename.
[mass] Mass weight the RMSD calculation.
[stop <maxwindow>] Only calculate RMS average correlation up to <maxwindow>.
[offset <offset>] Skip every <offset> windows in calculation.
[ﬁrst] Use first averaged frame as reference for each window (default).
[reference <ref ﬁle> [parm <parmﬁle>] Use reference file (with specified parm) as

reference for each window.

The RMS average correlation[643] (RAC) is calculated as the average RMSD of running-averaged coordinates
over increasing window sizes (or lag). Output has format:

<WindowSize> <RAC>

The ﬁrst entry has a window size of 1, and so is just the average RMSD of all frames to the speciﬁed reference
structure. The second entry has a window size of two, so it is the average RMSD of all frames averaged over two
adjacent windows to the speciﬁed reference, and so on. The RAC will be calculated up to the number of frames
minus 1 or the value speciﬁed by stop, whichever is lower. The offset can be used to speed up the calculation by
skipping window sizes. To calculate mass-weighted RMSD specify mass. Note that to reduce memory costs it
can be useful to strip all coordinates not involved in the RMS ﬁt from the system prior to specifying ’rmsavgcorr’.
For example, to calculate the correlation of C-alpha RMSD of residues 2 to 12:

strip !(:2-12@CA)
rmsavgcorr out rmscorr.dat

The curve generated by RAC decays towards zero due to the way RAC is deﬁned. By the time the "lag" is N-1
(where N is the total number of frames) you have only two averaged coordinates: call them Avg1 (averaged over
1 though N-1 frames) and Avg2 (averaged over 2 through N frames). Barring any extraordinary circumstances the
RMSD between Avg1 and Avg2 will almost certainly be quite low.

740

32.12. Analysis Commands

The RAC is a way to probe the time scales of interesting events. Any deviation from a smoothly decaying curve
is an indication that there are some signiﬁcant structural differences occurring over that time interval. RAC curves
can be particularly useful when comparing independent simulations of the same system.

One thing to keep in mind that since the underlying metric is RMSD, it can be sensitive to the reference frame
you choose. It may be useful to try looking at both RAC from the ﬁrst frame, as well as an averaged reference
frame. For an example of use see Galindo-Murillo et al.[671], in particular Figure 2.

32.12.30. rotdif

rotdif [outfile <outfilename>] [usefft]

Options for generating random vectors:

[nvecs <nvecs>] [rvecin <randvecIn>] [rseed <random seed>]
[rvecout <randvecOut>] [rmatrix <set name> [rmout <rmOut>]]

Options for calculating vector time correlation functions:

[order <olegendre>] [ncorr <ncorr>] [corrout <corrOut>]

*** The options below only apply if ’usefft’ IS NOT specified. ***
Options for calculating local effective D, small anisotropy:

[deffout <deffOut>] [itmax <itmax>] [tol <tolerance>] [d0 <d0>]
[nmesh <NmeshPoints>] dt <tfac> [ti <ti>] tf <tf>
Options for calculating D with full anisotropy:

[amoeba_tol <tolerance>] [amoeba_itmax <iterations>]
[amoeba_nsearch <n>] [scalesimplex <scale>] [gridsearch]

*** The options below only apply if ’usefft’ IS specified. ***
Options for curve-fitting:

[fit_tol <tolerance>] [fit_itmax <max # iterations>]

outﬁle <outﬁlename> File to write all output from rotdif command to.
Options for generating random vectors:
nvecs <nvecs> Number of random vectors to generate (default 1000).
rvecin <randvecIn> File to read random vectors from (format is 1 per line, 4

columns, <#> <VX> <VY> <VZ>).

rseed <random seed> Seed for random number generator (default 80531).

Specify

-1 to use wallclock time.

rvecout <randvecOut> File to write random vectors to (format is 1 per line, 4

columns, <#> <VX> <VY> <VZ>).

rmatrix <set name> Data set to read rotation matrices from.

Rotation matrices

will be used to rotate random vectors.

rmout <rmOut> Write rotation matrices to file, 1 per line, frame # followed by

matrix in row-major order.

Options for calculating vector time correlation functions:
order <olegendre> The order of Legendre polynomials to use when calculating

vector time correlation functions (default 2).

ncorr <ncorr> Maximum length of time correlation functions in frames.
is not specified it will be set to (tf - ti) / dt (recommended).

If this

corrout <corrOut> If specified write vector time correlation functions to

<corrOut>.X with format: <Time> <Px>

Options for calculating local effective D, small anisotropy:
deffout <deffOut> File to write out local effective diffusion constants

determined in the limit of small anisotropy.

741

32. cpptraj

itmax <itmax> Maximum number of iterations to determine each local effective

diffusion constant (small anisotropy) assuming fit to single exponential
form (default 500).

tol <tolerance> Tolerance for determining local effective diffusion constant

(small anisotropy) assuming fit to single exponential form (default 1E-6).

d0 <d0> Initial guess for small anisotropy diffusion constant in radians^2/ns

(default 0.03).

nmesh <NmeshPoints> Number of points per frame to use when creating

cubic-splined-smoothed forms of vector time correlation curves (default 2).

dt <tfac> Time interval between frames (used in integrating vector time

correlation curves) in ns.

ti <ti> Initial time value in ns for integrating the time correlation functions

(default 0.0).

tf <tf> Final time value in ns for integrating the time correlation functions.

It is recommended this be less than the maximum simulation time since the
tails of time correlation functions tend to be noisy.

Options for calculating D with full anisotropy:

amoeba_tol <tolerance> Tolerance for downhill-simplex minimizer (default 1E-7).
amoeba_itmax <iterations> Number of iterations to run downhill-simplex minimizer

(default 10000).

amoeba_nsearch <n> Number of searches to perform with downhill-simplex

minimizer (default 1).

scalesimplex <scale> Factor to use when scaling simplexes (default 0.5).
gridsearch If specified, perform a brute-force grid search to attempt to find a

better solution for diffusion tensor with full anisotropy (may be
expensive).

Evaluate rotational diffusion properties of a molecule over a trajectory according to an expanded version of the
procedure laid out by Wong & Case[672]. Brieﬂy, random vectors (representing the orientation of the molecule)
are rotated according to rotation matrices obtained from an RMS ﬁt to a reference structure (typically an averaged
structure). For each random vector the time correlation function of the rotated vector is calculated using Legendre
polynomials of the speciﬁed order. The integral over this time correlation function (which may be smoothed using
cubic splines to improve the integration) is then used to ﬁnd the effective diffusion constant (D) in the limit of
small anisotropy. Then, using each calculated D, the diffusion tensor is determined with full anisotropy. Finally,
a downhill simplex minimizer is used to optimize D with full anisotropy; (this last step is not described in the
original paper).

Rotation matrices are generated via an RMS ﬁt to a reference structure (see 32.11.64 on page 696). It is recom-
mended that the RMS ﬁt be done to an average structure (see 32.11.8 on page 650). These rotation matrices are
used to rotate each random vector M times (where M is the total number of frames), which creates a time series
for each random vector. The time correlation functions are calculated for each random vector time series using
Legendre polynomials of the speciﬁed order (default 2). The maximum length of the correlation function (or lag)
can be speciﬁed by ncorr (in frames). If ncorr is not speciﬁed it will be set internally based on the speciﬁed values
of ti, tf, and dt; this is recommended. Note that if ncorr is speciﬁed it should be set to a number less than the
total number of frames since noise in time correlation functions increases as ncorr approaches the # of frames.
The integration over the correlation function is from ti (in whatever units are used of dt, generally ns; 0.0 ns if not
speciﬁed) to tf (same units as ti), with the time between frames speciﬁed by dt; the ﬁnal time should be less than
the total simulation time (see example below). The relative size of the mesh used with cubic spline interpolation for
integration is controlled by nmesh (size of the mesh is ncorr points * nmesh); nmesh = 1 means no interpolation,

742

32.12. Analysis Commands

default is 2. Note that if the integral of the correlation function for a vector is negative, that vector will be skipped
in subsequent calculations (since it would imply a negative value for effective diffusion).

The iterative solver for effective value of the diffusion constant from the correlation functions is controlled
by itmax, tol, and d0, where itmax speciﬁes the number of iterations to perform (default 500), tol speciﬁes the
tolerance (default 1E-6), and d0 speciﬁes the initial guess for the diffusion constant in radians^2 / ns (default 0.03).
Effective diffusion constants for each random vector can be written out to a ﬁle speciﬁed by deffout. Results are
printed to the ﬁle speciﬁed by outﬁle. Details on the Q and D tensors are given, as well as observed and calculated
tau for each random vector. First, results are printed for analysis in the limit of small anisotropy. Next, results are
printed for analysis with full anisotropy. The results of the full anisotropic calculation are ﬁrst given using results
from the small anisotropic analysis as an initial guess, followed by the ﬁnal results after minimization using the
downhill simplex (amoeba) minimizer.

Example

There are two important things to keep in mind when using rotdif analysis:

1. When calculating any kind of diffusive property it is best to simulate in the microcanonical (NVE) ensemble
with a shorter time step and increased SHAKE tolerance; thermostats and barostats will effect diffusion
calculations.

2. Time correlation functions become noisier as the length of the function approaches the maximum. Therefore
in general one should choose parameters for the time correlation function that are much shorter than the total
simulation length.

For example, given a trajectory ’mdcrd.nc’ containing 10000 frames with a total simulation time of 200 ns (so the
time between frames is 0.02 ns), to calculate rotational diffusion using 100 vectors using rotation matrices
generated via an RMS ﬁt to ’avgstruct.pdb’, computing and integrating the time correlation function for each
vector from 0 to 5 ns (1/40th of the simulation), and writing out the effective diffusion constants and results to
’deffs.dat’ and ’rotdif.out’ respectively:

reference avgstruct.pdb [avg]
rms R0 @CA,C,N,O ref [avg] savematrices
trajin mdcrd.nc
rotdif nvecs 100 rmatrix R0[RM] \

ti 0.0 tf 5.0 dt 0.02 deffout deffs.dat \
outfile rotdif.out

32.12.31. runningavg

runningavg <dset1> [<dset2> ...] [name <dsetname>] [out <filename>]

[ [cumulative] | [window <window>] ]

<dset1> [<dset2> ...] Data set(s) to calculate running average for.

[name <dsetname>] Output running average data set name.

[out <ﬁlename>] File to write results to.

[cumulative] Calculate cumulative running average instead.

[window <window>] Size in frames of window over which to calculate running

average.

Calculate running average over windows of given size for data in selected data set(s).

743

32. cpptraj

32.12.32. slope

slope <dset0> [<dset1> ...] [out <outfile>] [name <name>]

[type {forward|backward|central}]

<dset0> [<dset1> ...] Data set(s) to calculate finite difference for.
[out <outﬁle>] File to write finite difference curves to.
[name <name>] Output data set(s) name.
[type {forward|backward|central}] Specify type of finite difference to calculate

(default forward).

DataSets generated:

<name>:<idx> Output finite difference curves for each input data set (indexed

from 0).

Calculate ﬁnite differences for each input data set.

32.12.33. spline

spline <dset0> [<dset1> ...] [out <outfile>] [meshsize <n> | meshfactor <x>]
[meshmin <mmin>] [meshmax <mmax>]

<dsetX> Data set(s) to perform splining on.
[out <outﬁle>] Write splined data to <outfile>.
[meshsize<n>] Size of the mesh to use for splining.
[meshfactor <x>] If meshsize is not given, use a mesh of data set size * <x>.
[meshmin <mmin>] Mesh X minimum value.
[meshmax <mmax>] Mesh X maximum value.

Apply cubic splines to the given input data sets to create new data sets.

32.12.34. statistics | stat

stat {<name> | ALL} [shift <value>] [out <filename>] [noeout <filename>]

[ignorenv] [name <noe setname>]

<name> Name of data set to analyze.
ALL analyze all data sets.
shift <value> Subtract <value> from all elements in each data set.
[out <ﬁlename>] Write analysis results to <filename> (STDOUT if not specified).
[noeout <ﬁlename>] (Type ’noe’ only) Write summary of NOE results to <filename>.
[ignorenv] (Type ’noe’ only) Ignore negative NOE violations (i.e.

shorter-than-expected distances).

[name <noe setname>] (Type ’noe’ only) Name for output NOE data sets.

DataSet Aspects for type ’noe’ output:
[R6] Averaged 1/r6distance for each set.
[NViolations] Number of violations based on given bounds for each set.
[AvgViolation] 1/r6 averaged distance minus expected distance for each set.
[NOEnames] Name of each set.

744

Analyze angles, dihedrals, distances, and/or puckers and calculate various properties. More speciﬁc analyses can
be obtained by labelling distances/dihedrals/puckers (from e.g. the distance, dihedral, pucker commands or with
the dataset command) with the ’type <label>’ keyword:

dihedral type labels: alpha, beta, gamma, delta, epsilon, zeta, chi, c2p h1p, phi, psi, omega, pchi

32.12. Analysis Commands

distance type labels: noe

pucker type labels: pucker

For each input data set, the average, standard deviation, initial and ﬁnal values will be reported. The cyclic nature
of dihedral/pucker data sets is taken into consideration when averaging.

32.12.34.1. Torsion Analysis

A table will be written in ASCII format showing the distribution of torsion values for each data set. More speciﬁc
information may be printed based on the set type. Values in the output marked SNB are from those deﬁned by
Schneider, Neidle, and Berman.[673] For more information on nucleic acid torsion as pertains to RNA see further
work by Schneider et al..[674]

For example, to perform in-depth analysis on some nucleic acid dihedral angles:

dihedral g0 out dihedrals.dat :1@O5’ :1@C5’ :1@C4’ :1@C3’ type gamma
dihedral d0 out dihedrals.dat :1@C5’ :1@C4’ :1@C3’ :1@O3’ type delta
dihedral c0 out dihedrals.dat :1@O4’ :1@C1’ :1@N9 :1@C4 type chi
analyze statistics all out stat.dat

32.12.34.2. Distance Analysis

A table will be written in ASCII format showing the distribution of distance values < 6.5. If a distance is labled

as ’type noe’ a compact time series will be printed in ASCII format showing the NOE as strong, medium, or
weak. In addition the <r^-6>^(-1/6) averaged value will be reported, as well as the number of upper/lower bound
violations. If ’noeout’ is speciﬁed, a summary of these results will be written with format:

<#NOE> <R6> <Nviolation> <AvgViolation> <Name>

Where <#NOE> is an index, <R6> is the <r^-6>^(-1/6) averaged distance, <Nviolation> is the total number of
bounds violations, <AvgViolation> is the average difference from expected distance Rexp when the distance is
violated (note that if not explicitly set, Rexp is set to the upper bound when the lower bound is 0.0, or the average
of upper and lower bounds otherwise), and <Name> is the data set legend.

For example, the following input could be used to check certain distances for NOE violations:

distance :3@HB= :10@HG= type noe noe_medium
distance :3@HE= :10@HG= type noe noe_strong
distance :3@HA :12@HA type noe noe_medium
distance :3@HD= :12@HG= type noe noe_medium
distance :3@HE= :12@HA type noe noe_strong
analyze statistics all out dpdp.noe.dat noeout noe_graph.dat name Res3_NOE

32.12.34.3. Pucker Analysis

A table will be written in ASCII format showing the distribution of pucker phases for each data set.

745

32. cpptraj

32.12.35. ti

ti <dset0> [<dset1> ...] {nq <n quad pts> | xvals <x values>}
[name <set name>] [out <file>] [curveout <ti curve file>]
[nskip <#s to skip>]
[avgincrement <#> [avgmax <#>] [avgskip <#>]]
[bs_samples <samples> [bs_points <points>] [bs_seed <#>]

[bs_fac <factor>]]

<dset0> [<dset1> ...] Data set arguments specifying input DV/DL values.

nq <n quad pts> Number of points for Gaussian quadrature integration. Expect

one data set per point.

xvals <x values> Comma-separated list of X values for integration.

Expect one

data set per value.

name <set name> Output data set name.

out <ﬁle> File to write results of integration to.

curveout <ti curve ﬁle> File to write TI curves to.

nskip <#s to skip> Comma separated list of number of points to skip.

For each

number given, the TI integration will be repeated.

avgincrement <#> [avgmax <#>] [avgskip <#>] Starting from point ’avgskip’ (default

0), repeat the TI integration calculation in increments of <#> up to
’avgmax’ (default all points), so ’avgincrement 10’ will do points 0-10,
0-20, etc.

bs_samples <samples> [bs_points <points>] [bs_seed<#>] [bs_fac <factor>] Estimate error
via bootstrap analysis, repeating the TI integration <samples> times using
<points> points or <factor> times the total number of points.
with given seed.

Randomize

DataSet Aspects:

[TIcurve] Raw TI curve. If ’nskip’ index is number of points skipped.

If

bootstrapping, index is sample index. If ’avgincrement’ the index is the
number of points.

[SD] For bootstrap analysis, standard deviation of average free energy over

samples.

Calculate free energy using DV/DL energies from thermodynamic integration. The results of integration of the
DV/DL curve will be written to <ﬁle>, while the curves themselves will be written to <ti curve ﬁle>. Use nq to
specify number of Gaussian quadrature points; otherwise the lambda values should be speciﬁed by xvals, where
<x values> is a comma-separated list.

For example, to perform Gaussian quadrature integration using data sets named ’TIdata’, repeating the

calculation for various number of skipped data points:

ti TIdata nq 9 name Curve out skip.agr curveout curve.agr nskip 0,5,10,15,20,30,40,50

32.12.36. timecorr

timecorr vec1 <vecname1> [vec2 <vecname2>] out <filename>

[order <order>] [tstep <tstep>] [tcorr <tcorr>]
[dplr] [norm] [drct] [dplrout <dplrfile>] [ptrajformat]

746

32.12. Analysis Commands

vec1 <vecname1> [vec2 <vecname2>] Vector(s) on which to operate.

By default the

auto-correlation function will be calculated if one vector is specified,
and the cross-correlation function will be calculated if two vectors are
specified.

out <ﬁlename> Name of file to write output to.
[order <order>] Order of Legendre polynomials to use; default 2.
[tstep <tstep>] Time between snapshots (default 1.0).
[tcorr <tcorr>] Maximum time to calculate correlation functions for (default

10000.0).

[dplr] Output correlation functions Cl ≡< Pl/(r(0)3r(τ)3) > and < 1/(r(0)3r(τ)3) > in

addition to the Pl correlation function.

[norm] Normalize all correlation functions, i.e., Cl(t = 0) = Pl(t = 0) = 1.0.
[drct] Use the direct method to calculate correlations instead of FFT; this will

be much slower.

[dplrout] (dplr only) Write extra information for each vector related to dplr

option to <dplrfile>.

[ptrajformat] Write output in ptraj style (prevents use of data formatting

options).

DataSet Aspects:

[P] P<order> correlation function.
[C] C<order> correlation function (dplr only).
[R3R3] <1/(r(0)3r(t)3> correlation function (dplr only).
[R] (_TC_DIPOLAR_) Average magnitude (<R>).
[RRIG] (_TC_DIPOLAR_) Sqrt( <R^2> ).
[R3] (_TC_DIPOLAR_) <1/R^3>.
[R6] (_TC_DIPOLAR_) <1/R^6>.
[Name] (_TC_DIPOLAR_) Vector name.

Calculate time auto/cross-correlation functions for vectors using spherical harmonics theory. NOTE: To calculate
direct correlation functions for vectors just use the corr analysis command. The norm keyword will normalize the
resulting correlation functions. Note that if dplr is speciﬁed, a new global data set named _TC_DIPOLAR_ will
be created, containing extra data for each vector analyzed with a ’timecorr dplr’ command.

Examples

Vectors between atoms 5 and 6 as well as 7 and 8 are calculated below, for which auto and cross time

correlation functions are obtained.

vector v0 @5 @6
vector v1 @7 @8
timecorr vec1 v0 tstep 1.0 tcorr 100.0 out v0.out order 2
timecorr vec1 v1 tstep 1.0 tcorr 100.0 out v1.out order 2
timecorr vec1 v0 vec2 v1 tstep 1.0 tcorr 100.0 out v0_v1.out order 2

Similarly, a vector perpendicular to the plane through atoms 18, 19, and 20 is obtained and further analyzed.

vector v2 @18,@19,@20 corrplane
timecorr vec1 v3 tstep 1.0 tcorr 100.0 out v2.out order 2

747

32. cpptraj

32.12.37. vectormath

vectormath vec1 <vecname1> vec2 <vecname2> [out <filename>] [norm] [name <setname>]

[ dotproduct | dotangle | crossproduct ]

vec1 <vecname1> vec2 <vecname2> Vector(s) on which to operate.
[out <ﬁlename>] Name of file to write output to.
[dotproduct] (Default) Calculate the dot-product of the two vectors.
[dotangle] Calculate angle from dot-product between the two vectors; vectors

will be normalized.

[crossproduct] Calculate cross-product of the two vectors.
[norm] Normalize the vectors; this will affect any subsequent calculations with

the vectors. This is turned on automatically if dotangle specified.

Calculate dot product, angle from dot product (degrees), or cross product for speciﬁed vectors. Note that norm
normalizes the vectors themselves; the vectors will remain normalized for subsequent calculations or output. Either
vec1 or vec2 can be of size 1; in that case each vector in the set with N frames operates on the single vector. For
example, if vec1 is size N and vec2 is size 1, then each frame of vec1 is operated on the single vector from vec2.

For example, to get the angles between two previously calculated vectors v1 and v2:

vectormath vec1 v1 vec2 v2 dotangle out dotproduct.dat name acos(|V1|*|V2|)

32.12.38. wavelet

wavelet [crdset <set name>] nb <n scaling vals> [s0 <s0>] [ds <ds>]

[correction <correction>] [chival <chival>] [type <wavelet>]
[out <filename>] [name <setname>]
[cluster [minpoints <#>] [epsilon <value>] [clusterout <file>]

[clustermapout <file>] [cmapdetail] [kdist] [cprefix <PDB prefix>]
[overlay <trajfile>] [overlayparm <parmfile>]]

[crdset <set name>] COORDS data set to use
nb <n scaling vals> Number of scales. The smaller the number the better

resolution, but slower to plot.

[s0 <s0>] The smallest scale of the wavelet function (default 2dt where dt is

time between snapshots in ps )

[ds <ds>] Spacing between discrete scales. (Default is 0.25. Smaller value of
ds gives finer resolution. The largest values that give adequate sampling
in scale for Morlet and Paul are 0.5 and 1.5, respectively)

[correction <correction>] The scale-to-wavelength parameter (1.01 for Morlet, 1.389
for Paul). Automatically set based on wavelet if not otherwise specified.

2 at a particular confidence level

[chival <chival>] The value of χ2
[type <wavelet>] Type of wavelet function to use <morlet> or <paul>
[out <ﬁlename>] Write results to file named <filename>
[name <setname>] Store results in data set with name <setname>
[cluster] Perform wavelet clustering i.e. wavelet feature extraction analysis.

[minpoints <#>] Minimum number of points necessary to form a region of

interest.

[epsilon <value>] Minimum region of interest size.

748

32.12. Analysis Commands

[clusterout <ﬁle>] Output for clustering (see below).
[clustermapout <ﬁle>] Output cluster map (recommended gnuplot format, see

below).

[cmapdetail] Instead of the map being smoothed to cluster regions, show full

detail.

[kdist] Can be used to determine minpoints and epsilon - see below.
[cpreﬁx <PDB preﬁx>] Output cluster region PDBs (only containing from
minimum to maximum atom and minimum to maximum frame) with given
prefix.

[overlay <trajﬁle>] Create a trajectory that can be overlaid with the original

trajectory to highlight atoms of interest.
Atoms in cluster regions
will get their normal coordinates - all others are set to the common
center of mass.

[overlayparm <parmﬁle>] Topology that can be used with the overlay

trajectory.

<wavelet>: morlet, paul

Perform the wavelet analysis using fast Fourier transform (FFT) algorithm on speciﬁed trajectory and write out to
a gnuplot-formatted ﬁle named <name.gnu>. The created Wavelet map provides a clear picture of the signiﬁcant
motions which are characterized both in time and space. Note that typically the trajectory in question should have
rotational and translational movement removed (via e.g. the rms command); otherwise these will be reﬂected in
the wavelet analysis results.

Wavelet analysis contains two main steps which performs continues wavelet transform (CWT) and statistical
signiﬁcance testing as proposed by Torrence and Compo[675]. Analysis is executed on one dimensional (1-D)
coordinate which is deﬁned as the displacement from the starting position. For each atom, CWT is calculated over
a speciﬁed range of scales from S0up to S02(nb−1)ds. To obtain the CWT of the trajectory the Fourier transform
of atom’s displacement and wavelets which scaled by S ( S is calculated from: S = S02 jds; j = 0,1,2, . . . ,nb− 1)
is computed and then the inverse Fourier transform of the product of Fourier transforms will be calculated as the
CWT. After calculating the wavelet coordinates for all atoms, a signiﬁcance testing is performed to determine the
signiﬁcance of each wavelet coordinate. For doing this test we need to have an appropriate background spectrum
to consider as a mean or expected spectrum and compare our wavelet coordinates against this background. In order
to calculate the background spectrum since wavelet spectrum (according to the convolution theorem) follows the
Fourier spectrum, the Fourier coefﬁcients over every atom’s displacement is calculated using the following formula
and a model (µk) is constructed on average which Fourier coefﬁcients ﬁt (Xn) is the time series which is the atom’s
displacement and k is the frequency index[676].

(cid:18)−2πikn

(cid:19)

Xn

N

N−1
∑

n=0

exp

fk= 1

N

This test is implemented based on the null hypothesis that the assumption is that Fourier coordinates normally
distributed around the expected value, then the wavelet coordinates should also be normally distributed. Assuming
the expected background spectrum and since the square of a normally distributed variable is chi-square distributed,
then the distribution for the square of the absolute values of wavelet coordinates (|Wi,k|2 is as follows (σ 2is the
variance of the atom’s displacement).

Then choosing a conﬁdence level we can determine the minimum acceptable value for |Wi,k|2to be considered
In the ﬁnal map the scales of only those wavelet

as a signiﬁcant coordinates at that certain conﬁdence level.
coordinates which are signiﬁcantly above the expected distribution are stored.

σ 2µkχ2

2 /2

For example, to perform wavelet analysis on residues 1 to 17 with 40 scaling values starting from scaling of 0.2

with a spacing of 0.25 using the Morlet wavelet:

749

32. cpptraj

parm nowat.withions.parm7
trajin nowat.image.nc
rms :1-17@C*,N*,O*,P* first mass
wavelet nb 40 s0 0.2 ds 0.25 correction 1.01 chival 1.6094 type morlet \

:1-17 out wavelet.gnu usemap

Wavelet Analysis Feature Extraction

Wavelet analysis feature extraction (WAFEX)[677] uses a density-based clustering algorithm (a modiﬁed

version of the DBSCAN algorithm) to highlight physical and temporal regions that have signiﬁcant motions from
wavelet mapsand can extract the speciﬁc atoms and frames involved in these motions for further analysis. Cluster
regions shown in the map will be smoother by default for easier visualization (unless cmapdetail is speciﬁed).
Details of the clustering are provided via the clusterout keyword with format:

#Cluster [points] [minatm] [maxatm] [minfrm] [maxfrm] [avgval]

#Cluster Cluster region number.

points Number of points in the cluster.

minatm Starting atom of the region.

maxatm End atom of the region.

minfrm Starting frame of the region.

maxfrm End frame of the region.

avgval Average value of points in the region.

For example, to create a 2D gnuplot map highlight regions of interest called ’cluster.gnu’ one could use the
following input.

parm ../DPDP.parm7
trajin ../DPDP.nc
rms @C,CA,N first
wavelet nb 10 s0 2 ds 0.25 type morlet correction 1.01 chival 0.25 \

:1-22 name DPDP \
cluster clustermapout cluster.gnu clusterout cluster.dat \

minpoints 66 epsilon 10.0

datafile cluster.gnu usemap palette kbvyw

Some experimentation with kdist may be required to obtain reasonable values for minpoints and epsilon.
See 32.12.4 on page 721 as well as the Heidari et al paper for further discussion.

32.13. Analysis Examples

Please note that typically for principal component analysis (PCA) the trajectory needs to be aligned against a

reference structure to remove overall global and translation motion. Use the rms command for this.

32.13.1. Cartesian covariance matrix calculation and projection (PCA)

After calculating modes, snapshots can be projected onto these in an additional pass through the trajectory. It is
very important that the snapshots used when projecting are exactly the same as those used to generate the original
covariance matrix. This example takes advantage of the COORDS data set functionality in cpptraj to save
snapshots for the purposes of projection.

750

32.13. Analysis Examples

# Step one. Generate average structure.
# RMS-Fit to first frame to remove global translation/rotation.
parm myparm.parm7
trajin mytraj.nc
rms first !@H=
average crdset AVG
run
# Step two. RMS-Fit to average structure. Calculate covariance matrix.
# Save the fit coordinates.
rms ref AVG !@H=
matrix covar name MyMatrix !@H=
createcrd CRD1
run
# Step three. Diagonalize matrix.
runanalysis diagmatrix MyMatrix vecs 2 name MyEvecs
# Step four. Project saved fit coordinates along eigenvectors 1 and 2
crdaction CRD1 projection evecs MyEvecs !@H= out project.dat beg 1 end 2

32.13.2. Dihedral covariance matrix calculation and projection for backbone phi/psi

(PCA)

parm ../1rrb_vac.prmtop
trajin ../1rrb_vac.mdcrd
# Generation of phi/psi dihedral data
multidihedral BB phi psi resrange 2
run
# Calculate dihedral covariance matrix and obtain eigenvectors
matrix dihcovar dihedrals BB[*] out dihcovar.dat name DIH
diagmatrix DIH vecs 4 out modes.dihcovar.dat name DIHMODES
run
# Project along eigenvectors
projection evecs DIHMODES out dih.project.dat beg 1 end 4 dihedrals BB[*]
run

751

33. pytraj

33.1. Introduction

pytraj [678] is Python front end of cpptraj. It is written to introduce more ﬂexibility in data analysis by combin-
ing with Python’s rich ecosystems (such as numpy, scipy, pandas, scikit-learn, ipython-notebook, etc.). It is aimed
at users who are familiar with Python and want to combine cpptraj’s functionality with the ﬂexibility of Python. It
is still very new, and in active development, and users should be aware that some of the syntax (i.e., the API) may
change in future versions.

This project is not intended to replace cpptraj, but rather to extend its functionality by placing allowing seamless
and efﬁcient data interchange between cpptraj and Python. Therefore, this project is aimed at users who are either
comfortable and familiar with the Python programming language or wish to become so. You should be familiar
with basic programming concepts (like conditionals, loops, and arrays) and preferably Python syntax before trying
to use pytraj. Note: there is no program called pytraj; that term is rather a shorthand for using “import pytraj”
within a python driver script.

33.2. Development

If you are interested in contributing to the development of pytraj, or you want to build the source code
directly, either fork or clone the repository from Github at https://github.com/amber-md/pytraj. Note
that this method of installation is more complex, as you will need to obtain and build an updated version
of libcpptraj (instructions can be found in the pytraj Github project). Also, you can check developer guide
http://amber-md.github.io/pytraj/latest/developer_guide.html.

33.3. Documentation and examples

Useful links are listed below.

• The pytraj Github repository: https://github.com/amber-md/pytraj

• Comprehensive documents and tutorials can be found in https://amber-md.github.io/pytraj

• Example scripts: https://github.com/amber-md/pytraj/tree/master/examples

• We highly suggest user to use Jupyter notebook for interactive computing: http://jupyter.org/

33.3.1. Minimal examples

Only several highlight features of pytraj are shown here.



33.3.1.1. Loading trajectories to memory

import pytraj as pt

# load all frames into memory if filesize is small
traj = pt.load('tz2.nc', top='tz2.parm7')

# load but skip every 10 frames

752



traj = pt.load('tz2.nc', top='tz2.parm7', stride=10)

33.3. Documentation and examples

# load specific frame numbers
traj = pt.load('tz2.nc', top='tz2.parm7', frame_indices=[0, 8, 10, 20])

# load with given mask
traj = pt.load('tz2.nc', top='tz2.parm7', mask='@CA')

33.3.1.2. Lazy loading trajectories

Sometimes the trajectories are to large to load to memory, users can use pytraj.iterload method.

Please check http://amber-md.github.io/pytraj/latest/trajectory_exercise.html for further in-










import pytraj as pt

traj = pt.iterload('tz2.nc', 'tz2.parm7')

# load several files
traj = pt.iterload('tz2.*.nc', 'tz2.parm7')

# load several files by explicitly giving filenames
traj = pt.iterload(['tz2.0.nc', 'tz2.1'.nc'], 'tz2.parm7')

formation.

33.3.1.3. Perform calculation

# radgyr
data = pt.radgyr(traj, mask='@CA')

# rmsd to 1st frame, mask='@CA'
data = pt.rmsd(traj, ref=0, mask='@CA')

# rmsd to specific reference
ref = traj[3]
data = pt.rmsd(traj, ref=ref, mask='@CA')

# compute distance
pt.distance(traj, ':1-3 :5-8')

# load pdb from RCSB website then perform hbond calculation
traj = pt.fetch_pdb('1l2y')
hbond_data = pt.hbond(traj)
print(hbond_data.donor_acceptor)



all_actions.html.

33.3.1.4. Writing trajectory

More analysis commands can be found in http://amber-md.github.io/pytraj/latest/_api/pytraj.

import pytraj as pt

# write whole trajectory
pt.write_traj('output.nc', traj, overwrite=True)

753












33. pytraj

# write specific frames
pt.write_traj('output.nc', traj, frame_indices=[0, 8, 9], overwrite=True)

# user can use save method
traj.save('output.nc')

# if you are using Ipython/Jupyter notebook (or interactive terminal), you can get help by
pt.write_traj?
# the hit <Enter>

# converting netcdf format to DCD
traj = pt.iterload('tz2.nc', 'tz2.parm7')
traj.save('tz2.dcd')

33.3.1.5. Combine pytraj with pysander for energy evaluation

import pytraj as pt
traj = pt.iterload('tz2.nc', 'tz2.parm7')

# compute energies (potential, bond, angle, dihedral, GB, ...), use igb=8 model
energy_dict = pt.energy_decomposition(traj, igb=8)

# get energy for different component
energy_dict['tot']
energy_dict['gb']

33.3.1.6. Parallel calculation

pytraj supports parallel calculation through multiprocessing (python) or MPI (require mpi4py)

import pytraj as pt

# for parallel calculation, pytraj only supports `iterload` method.
traj = pt.iterload('tz2.nc', top='tz2.parm7')

# serial version
data = pt.radgyr(traj, '@CA')

# multiprocessing
data = pt.pmap(pt.radgyr, traj, '@CA', n_cores=6)
energy_dict = pt.pmap(pt.energy_decomposition, traj, igb=8, n_cores=6)

# user can chain a series of cpptraj commands for parallel calculation too
data = pt.pmap(['rms', 'radgyr @CA nomax', 'surf @CA'], traj, n_cores=8)

# mpi
data = pt.pmap_mpi(pt.radgyr, traj, '@CA')

Please check: http://amber-md.github.io/pytraj/latest/tutorials/tutorial_parallel.html

33.3.1.7. Simplify Principal Component Analysis (PCA) caculation



















traj = pt.load('tz2.nc', 'tz2.parm7')
data = pt.pca(traj, mask='@CA', n_vecs=2)
# get document for this method

754

33.3. Documentation and examples

Figure 33.1.: Example of trajectory viewer in Jupyter notebook




print(pt.pca.__doc__)

Please also check: http://amber-md.github.io/pytraj/latest/.

33.3.1.8. Fancy indexing of trajectory

# get new Trajectory by skipping every 2 frames
traj[::2]

# get new Trajectory but only keeping coordinates of CA atoms
traj['@CA']

# get new Trajectory with given frame numbers
framelist =[0, 3, 7]
traj[framelist]



Please see also: http://amber-md.github.io/pytraj/latest/trajectory_slice.html

33.3.1.9. Trajectory Viewer

Trajectory can be quickly viewed in Jupyter notebook by using pytraj and nglview[679] (https://github.

com/arose/nglview).

755






34. MMPBSA.py

Note: Historically, Amber has supported several scripts to carry out MM-PBSA-like calculations. The one
described here (the “python” version) is more recent, generally simpler to use, and has a more active support
community for answering questions. An older, “perl”, version is still in the AmberTools20 distribution, but we
have removed information about it in this Reference Manual. If you have need to run this older, perl-based version,
please consult the Amber 2019 Reference Manual.

Neither of these should be considered as a “black-box”, and users should be familiar with Amber before at-
tempting these sorts of calculations. These scripts automate a series of calculations, and cannot trap all the types
of errors that might occur. You should be sure that you know how to carry out an MM-PBSA calculation “by
hand” (i.e., without using the scripts); if you don’t understand in detail what is going on, you will have no good
reason to trust the results. Also, if something goes awry (and this is not all that uncommon), you will need to run
and examine the individual steps to carry out useful debugging.

34.1. Introduction

This section describes the use of the python script MMPBSA.py [680] to perform Molecular Mechanics / Pois-
son Boltzmann (or Generalized Born) Surface Area (MM/PB(GB)SA) calculations. This is a post-processing
method in which representative snapshots from an ensemble of conformations are used to calculate the free energy
change between two states (typically a bound and free state of a receptor and ligand). Free energy differences are
calculated by combining the so-called gas phase energy contributions that are independent of the chosen solvent
model as well as solvation free energy components (both polar and non-polar) calculated from an implicit solvent
model for each species. Entropy contributions to the total free energy may be added as a further reﬁnement. The
entropy calculations can be done in either a HCT Generalized Born solvation model [185, 196] or in the gas phase
using a mmpbsa_py_nabnmode program written in the nab programming language, or via the quasi-harmonic
approximation in ptraj.

The gas phase free energy contributions are calculated by sander within the Amber program suite or
mmpbsa_py_energy within the AmberTools package according to the force ﬁeld with which the topology ﬁles were
created. The solvation free energy contributions may be further decomposed into an electrostatic and hydrophobic
contribution. The electrostatic portion is calculated using the Poisson Boltzmann (PB) equation, the Generalized
Born method, or the Reference Interaction Site Model (RISM). The PB equation is solved numerically by either the
pbsa program included with AmberTools or by the Adaptive Poisson Boltzmann Solver (APBS) program through
the iAPBS interface[446] with Amber (for more information, see http://www.poissonboltzmann.org/apbs). The
hydrophobic contribution is approximated by the LCPO method [170] implemented within sander or the molsurf
method as implemented in cpptraj.

MM/PB(GB)SA typically employs the approximation that the conﬁgurational space explored by the systems are
very similar between the bound and unbound states, so every snapshot for each species is extracted from the same
trajectory ﬁle, although MMPBSA.py will accept separate trajectory ﬁles for each species. Furthermore, explicit
solvent and ions are stripped from the trajectory ﬁle(s) to hasten convergence by preventing solvent-solvent inter-
actions from dominating the energy terms. A more detailed explanation of the theory can be found in Srinivasan,
et. al.[681] You may also wish to refer to reviews summarizing many of the applications of this model,[682–684]
as well as to papers describing some of its applications.[685–689]

34.2. Preparing for an MM/PB(GB)SA calculation

MM/PB(GB)SA is often a very useful tool for obtaining relative free energies of binding when comparing
ligands. Perhaps its biggest advantage is that it is very computationally inexpensive compared to other free energy

756

34.2. Preparing for an MM/PB(GB)SA calculation

calculations, such as TI or FEP. Following the advice given below before any MD simulations are run will make
running MMPBSA.py successfully much easier.

34.2.1. Building Topology Files

MMPBSA.py requires at least three, usually four, compatible topology ﬁles. If you plan on running MD in

explicit water, you will need a solvated topology ﬁle of the entire complex, and you will always need a topology
for the entire complex, one for just the receptor, and a ﬁnal one for just the ligand. Moreover, they must be
compatible with one another (i.e., each must have the same charges for the same atoms, the same force ﬁeld must
be used for all three of the required prmtops, and they must have the same PBRadii set, see LEaP for description
of pbradii). Thus, it is strongly advised that all prmtop ﬁles are created with the same script. We run through a
typical example here, though leave some of the details to other sections and other tutorials. We will start with a
system that is a large protein binding a small, one-residue ligand. We will assume that a docked structure has
already been obtained as a PDB and that two separate PDBs have been constructed, receptor.pdb and LIG.pdb.
We will also assume that a MOL2 ﬁle was created from LIG.pdb, residue name ’LIG’, was built with charges
already derived (either through antechamber or some other method), and an frcmod ﬁle for ’LIG’ that contains all
missing parameters have already been created. Furthermore, we will use the FF14SB force ﬁeld for this example.
A sample script ﬁle called, for instance, mmpbsa_leap.in, is shown below

source leaprc.protein.ff14SB
source leaprc.water.tip3p
loadAmberParams LIG.frcmod
LIG = loadMol2 LIG.mol2
receptor = loadPDB receptor.pdb
complex = combine {receptor LIG}
set default PBRadii mbondi2

saveAmberParm LIG lig.top lig.crd
saveAmberParm receptor rec.top rec.crd
saveAmberParm complex com.top com.crd

solvateOct complex TIP3PBOX 15.0
saveAmberParm complex com_solvated.top com_solvated.crd
quit

The above script, when executed using the command

tleap -f mmpbsa_leap.in

should produce four prmtop ﬁles, lig.top, rec.top, com.top, and com_solvated.top. Topology ﬁles created in this
manner will make running MMPBSA.py far easier. This is, of course, the simplest case, but we brieﬂy describe
some other examples. MMPBSA.py will guess the mask for both the receptor and ligand inside the complex
topology ﬁle as long as the ligand residues appear continuously in the complex topology ﬁle. Therefore, if you’re
adding two ligands, combine them consecutively in the complex (rather than one residue at the beginning and one
at the end, for instance). If you have done this, you should allow MMPBSA.py to guess the masks since it provides
a good error check.

34.2.2. Using ante-MMPBSA.py

ante-MMPBSA.py is a python utility that allows you to create compatible complex, receptor, and ligand

topology ﬁles from a solvated topology ﬁle, or compatible receptor and ligand topology ﬁles from a complex
topology ﬁle. The usage statement for ante-MMPBSA.py is

Usage: ante-MMPBSA.py [options]
Options:

757

34. MMPBSA.py

-h, --help
-p PRMTOP, --prmtop=PRMTOP

show this help message and exit

Input "dry" complex topology or solvated complex
topology

-c COMPLEX, --complex-prmtop=COMPLEX

Complex topology file created by stripping PRMTOP of
solvent

-r RECEPTOR, --receptor-prmtop=RECEPTOR

Receptor topology file created by stripping COMPLEX of
ligand

-l LIGAND, --ligand-prmtop=LIGAND

Ligand topology file created by stripping COMPLEX of
receptor

-s STRIP_MASK, --strip-mask=STRIP_MASK

-m RECEPTOR_MASK, --receptor-mask=RECEPTOR_MASK

Amber mask of atoms needed to be stripped from PRMTOP
to make the COMPLEX topology file

Amber mask of atoms needed to be stripped from COMPLEX
to create RECEPTOR. Cannot specify with -n/--ligand-
mask

-n LIGAND_MASK, --ligand-mask=LIGAND_MASK

--radii=RADIUS_SET

Amber mask of atoms needed to be stripped from COMPLEX
to create LIGAND. Cannot specify with -m/--receptor-
mask
PB/GB Radius set to set in the generated topology
files. This is equivalent to "set PBRadii <radius>" in
LEaP. Options are bondi, mbondi2, mbondi3, amber6, and
mbondi and the default is to use the existing radii.

The input prmtop is required. It can either be a solvated, complex topology ﬁle or a complex topology ﬁle with
no solvent present. If a strip_mask is given, you must also provide a complex topology ﬁle, and that complex
topology ﬁle will be created by stripping strip_mask from the input prmtop. If you wish to create receptor and
ligand topology ﬁles (you must create both or neither), provide BOTH a –receptor-prmtop and a –ligand-prmtop
ﬁle name, as well as only ONE of either –receptor-mask or –ligand-mask. Whichever mask you do NOT deﬁne
will be deﬁned as the negated mask that you DID provide.

In short, you can use ante-MMPBSA.py to strip solvent from your prmtop for 3 applications.

1. Strip solvent from a solvated topology ﬁle and write out a non-solvated topology ﬁle.

2. Create ligand and receptor topologies from a complex topology by removing a given ligand or receptor mask.

3. A combination of 1 and 2 in the same command.

34.2.3. Running Molecular Dynamics

Not many details will be given here because MM/PB(GB)SA is a post-processing trajectory analysis technique.
Molecular dynamics are run to generate an ensemble of snapshots upon which to calculate the binding energy. This
technique is most effective when the structures are not correlated, which means that the simulated time between
extracted snapshots should be sufﬁciently large to avoid such correlation.

There are two techniques that can be employed when running these simulations with respect to MMPBSA.py.
The ﬁrst is what’s called the “single trajectory protocol” and the second of which is called the “multiple trajectory
protocol”. The ﬁrst method will extract the snapshots for the complex, receptor, and ligand from the same trajec-
tory. This is a faster method because it requires the simulation of only a single system, but makes the assumption
that the conﬁgurational space explored by the receptor and ligand is unchanged between the bound and unbound

758

states. The latter method eliminates this assumption at the cost of more simulations. MMPBSA.py requires a
complex trajectory, but will accept a receptor and/or ligand trajectory as well. Any trajectory not given to the script
will be extracted from the complex trajectory.

34.3. Running MMPBSA.py

34.3. Running MMPBSA.py

34.3.1. The input ﬁle

The input ﬁle was designed to be as syntactically similar to other programs in Amber as possible. The input
ﬁle has the same namelist structure as both sander and pmemd. The allowed namelists are &general, &gb, &pb,
&rism, &alanine_scanning, &nmode, and &decomp. The input variables recognized in each namelist are described
below, but those in &general are typically variables that apply to all aspects of the calculation. The &gb namelist
is unique to Generalized Born calculations, &pb is unique to Poisson Boltzmann calculations, &rism is unique to
3D-RISM calculations, &alanine_scanning is unique to alanine scanning calculations, &nmode is unique to the
normal mode calculations used to approximate vibrational entropies, and &decomp is unique to the decomposition
scheme. All of the input variables are described below according to their respective namelists. Integers and ﬂoating
point variables should be typed as-is while strings should be put in either single- or double-quotes. All variables
should be set with “variable = value” and separated by commas. See the examples below. Variables will usually
be matched to the minimum number of characters required to uniquely identify that variable within that namelist.
Variables require at least 4 characters to be matched unless that variable name has fewer than 4 characters (in which
case the whole variable name is required). For example, “star” in &general will match “startframe”. However,
“stare” and “sta” will match nothing.

&general namelist variables

debug_printlevel MMPBSA.py prints errors by raising exceptions, and not catching fatal errors.

If de-
bug_printlevel is set to 0, then detailed tracebacks (effectively the call stack showing exactly where in the
program the error occurred) is suppressed, so only the error message is printed. If debug_printlevel is set to
1 or higher, all tracebacks are printed, which aids in debugging of issues. Default: 0. (Advanced Option)

endframe The frame from which to stop extracting snapshots from the full, concatenated trajectory comprised of

every trajectory ﬁle supplied on the command-line. (Default = 9999999)

entropy Speciﬁes whether or not a quasi-harmonic entropy approximation is made with ptraj. Allowed values are

0: Don’t. 1: Do (Default = 0)

interval The offset from which to choose frames from each trajectory ﬁle. For example, an interval of 2 will pull

every 2nd frame beginning at startframe and ending less than or equal to endframe. (Default = 1)

keep_ﬁles The variable that speciﬁes which temporary ﬁles are kept. All temporary ﬁles have the preﬁx
“_MMPBSA_” prepended to them (unless you change the preﬁx on the command-line—see subsection
Subsection 34.3.2 for details). Allowed values are 0, 1, and 2.
0: Keep no temporary ﬁles
1: Keep all generated trajectory ﬁles and mdout ﬁles created by sander simulations
2: Keep all temporary ﬁles. Temporary ﬁles are only deleted if MMPBSA.py completes successfully
(Default = 1) A verbose level of 1 is sufﬁcient to use -rewrite-output and recreate the output ﬁle without
rerunning any simulations.

ligand_mask The mask that speciﬁes the ligand residues within the complex prmtop (NOT the solvated prmtop
if there is one). The default guess is generally sufﬁcient and will only fail as stated above. You should
use the default mask assignment if possible because it provides a good error catch. This follows the same
description as the receptor_mask above.

netcdf Speciﬁes whether or not to use NetCDF trajectories internally rather than writing temporary ASCII trajec-
tory ﬁles. NOTE: NetCDF trajectories can be used as input for MMPBSA.py regardless of what this variable

759

34. MMPBSA.py

is set to, but NetCDF trajectories are faster to write and read. For very large trajectories, this could offer
signiﬁcant speedups, and requires less temporary space. However, this option is incompatible with alanine
scanning. Default value is 0.
0: Do NOT use temporary NetCDF trajectories
1: Use temporary NetCDF trajectories

receptor_mask The mask that speciﬁes the receptor residues within the complex prmtop (NOT the solvated prm-
top if there is one). The default guess is generally sufﬁcient and will only fail if the ligand residues are not
found in succession within the complex prmtop. You should use the default mask assignment if possible
because it provides a good error catch. It uses the “Amber mask” syntax described elsewhere in this manual.
This will be replaced with the default receptor_mask if ligand_mask (below) is not also set.

search_path Advanced option. By default, MMPBSA.py will only search for executables in $AMBERHOME/bin.
To enable it to search for binaries in your full PATH if they can’t be found in $AMBERHOME/bin, set
search_path to 1. Default 0 (do not search through the PATH). This is particularly useful if you are using
an older version of sander that is not in AMBERHOME.

startframe The frame from which to begin extracting snapshots from the full, concatenated trajectory comprised

of every trajectory ﬁle placed on the command-line. This is always the ﬁrst frame read. (Default = 1)

strip_mask The variable that speciﬁes which atoms are stripped from the trajectory ﬁle if a solvated_prmtop is

provided on the command-line. See 34.3.2. (Default = “:WAT:CL:CIO:CS:IB:K:LI:MG:NA:RB”)

use_sander Forces MMPBSA.py to use sander for energy calculations, even when mmpbsa_py_energy will suf-

ﬁce (Default 0)
0 - Use mmpbsa_py_energy when possible
1 - Always use sander

full_traj This variable is for calculations performed in parallel to control whether complete trajectories are made of
the complex, receptor, and ligand. In parallel calculations, a different trajectory is made for each processor to
analyze only the selected frames for that processor. A value of 0 will only create the intermediate trajectories
analyzed by each processor, while a value of 1 will additionally combine those trajectories to make a single
trajectory of all frames analyzed across all processors for the complex, receptor, and ligand. (Default = 0)

verbose The variable that speciﬁes how much output is printed in the output ﬁle. There are three allowed values:
0, 1, and 2. A value of 0 will simply print difference terms, 1 will print all complex, receptor, and ligand
terms, and 2 will also print bonded terms if one trajectory is used. (Default = 1)

&gb namelist variables

ifqnt Speciﬁes whether a part of the system is treated with quantum mechanics. 1: Use QM/MM, 0: Potential

function is strictly classical (Default = 0). This functionality requires sander

igb Generalized Born method to use (seeSection 4). Allowed values are 1, 2, 5, 7 and 8. (Default = 5) All models

are now available with both mmpbsa_py_energy and sander

qm_residues Comma- or semicolon-delimited list of complex residues to treat with quantum mechanics. All
whitespace is ignored. All residues treated with quantum mechanics in the complex must be treated with
quantum mechanics in the receptor or ligand to obtain meaningful results. If the default masks are used,
then MMPBSA.py will ﬁgure out which residues should be treated with QM in the receptor and ligand.
Otherwise, skeleton mdin ﬁles will be created and you will have to manually enter qmmask in the ligand and
receptor topology ﬁles. There is no default, this must be speciﬁed.

qm_theory Which semi-empirical Hamiltonian should be used for the quantum calculation. No default, this must

be speciﬁed. See its description in the QM/MM section of the manual for options.

qmcharge_com The charge of the quantum section for the complex. (Default = 0)

760

34.3. Running MMPBSA.py

qmcharge_lig The charge of the quantum section of the ligand. (Default = 0)

qmcharge_rec The charge of the quantum section for the receptor. (Default = 0)

qmcut The cutoff for the qm/mm charge interactions. (Default = 9999.0)

saltcon Salt concentration in Molarity. (Default = 0.0)

surfoff Offset to correct (by addition) the value of the non-polar contribution to the solvation free energy term

(Default 0.0)

surften Surface tension value (Default = 0.0072). Units in kcal/mol/ ˚A2

molsurf When set to 1, use the molsurf algorithm to calculate the surface area for the nonpolar solvation term.

When set to 0, use LCPO (Linear Combination of Pairwise Overlaps). (Default 0)

probe Radius of the probe molecule (supposed to be the size of a solvent molecule), in Angstroms, to use when

determining the molecular surface (only applicable when molsurf is set to 1). Default is 1.4.

msoffset Offset to apply to the individual atomic radii in the system when calculating the molsurf surface. See

the description of the molsurf action command in cpptraj. Default is 0.

&pb namelist variables

inp Nonpolar optimization method (Default = 2).

cavity_offset Offset value used to correct non-polar free energy contribution (Default = -0.5692) This is not used

for APBS.

cavity_surften Surface tension. (Default = 0.0378 kcal/mol Angstrom2). Unit conversion to kJ done automati-

cally for APBS.

exdi External dielectric constant (Default = 80.0).

indi Internal dielectric constant (Default = 1.0).

ﬁllratio The ratio between the longest dimension of the rectangular ﬁnite-difference grid and that of the solute

(Default = 4.0).

scale Resolution of the Poisson Boltzmann grid. It is equal to the reciprocal of the grid spacing. (Default = 2.0)

istrng Ionic strength in Molarity. It is converted to mM for PBSA and kept as M for APBS. (Default = 0.0)

linit Maximum number of iterations of the linear Poisson Boltzmann equation to try (Default = 1000)

prbrad Solvent probe radius in Angstroms. Allowed values are 1.4 and 1.6 (Default = 1.4)

radiopt The option to set up atomic radii according to 0: the prmtop, or 1: pre-computed values (see Amber

manual for more complete description). (Default = 1)

sander_apbs Option to use APBS for PB calculation instead of the built-in PBSA solver. This will work only
through the iAPBS interface[446] built into sander.APBS. Instructions for this can be found online at the
iAPBS/APBS websites. Allowed values are 0: Don’t use APBS, or 1: Use sander.APBS. (Default = 0)

memopt Turn on membrane protein support (Default = 0).

emem Membrane dielectric constant (Default = 1.0).

mthick Membrane thickness (Default = 40.0).

mctrdz Absolute membrane center in the z-direction (Default=0.0, use protein center as the membrane center).

761

34. MMPBSA.py

poretype Turn on the automatic membrane channel/pore ﬁnding method (Default=1).

A more thorough description of these and other options can be found in Chapter 6. Please also note that the default
options have changed over time. For a detailed discussion of all related options on the quality of the MM/PBSA
calculations, please refer to our recent publication [234].

&alanine_scanning namelist variables

mutant_only Option to perform speciﬁed calculations only for the mutants. Allowed values are 0: Do mutant and

original or 1: Do mutant only (Default = 0)

Note that all calculation details are controlled in the other namelists, though for alanine scanning to be performed,
the namelist must be included (blank if desired)

&nmode namelist variables

dielc Distance-dependent dielectric constant (Default = 1.0)

drms Convergence criteria for minimized energy gradient. (Default = 0.001)

maxcyc Maximum number of minimization cycles to use per snapshot in sander. (Default = 10000)
nminterval∗ Offset from which to choose frames to perform nmode calculations on (Default = 1)
nmendframe∗ Frame number to stop performing nmode calculations on (Default = 1000000)
nmode_igb Value for Generalized Born model to be used in calculations. Options are 0: Vacuum, 1: HCT GB

model [185, 196] (Default 1)

nmode_istrng Ionic strength to use in nmode calculations. Units are Molarity. Non-zero values are ignored if

nmode_igb is 0 above. (Default = 0.0)

nmstartframe∗ Frame number to begin performing nmode calculations on (Default = 1)

* These variables will choose a subset of the frames chosen from the variables in the &general namelist. Thus, the
“trajectory” from which snapshots will be chosen for nmode calculations will be the collection of snapshots upon
which the other calculations were performed.

&decomp namelist variables

csv_format Print the decomposition output in a Comma-Separated-Variable (CSV) ﬁle. CSV ﬁles open natively
in most spreadsheets. If set to 1, this variable will cause the data to be written out in a CSV ﬁle, and standard
error of the mean will be calculated and included for all data. If set to 0, the standard, ASCII format will be
used for the output ﬁle. Default is 1 (CSV-formatted output ﬁle)

dec_verbose Set the level of output to print in the decmop_output ﬁle.

0 - DELTA energy, total contribution only
1 - DELTA energy, total, sidechain, and backbone contributions
2 - Complex, Receptor, Ligand, and DELTA energies, total contribution only
3 - Complex, Receptor, Ligand, and DELTA energies, total, sidechain, and backbone contributions
Note: If the values 0 or 2 are chosen, only the Total contributions are required, so only those will be printed
to the mdout ﬁles to cut down on the size of the mdout ﬁles and the time required to parse them. However,
this means that -rewrite-output cannot be used to change the default verbosity to print out sidechain and/or
backbone energies, but it can be used to reduce the amount of information printed to the ﬁnal output. The
parser will extract as much information from the mdout ﬁles as it can, but will complain and quit if it cannot
ﬁnd everything it’s being asked for.
Default = 0

762

34.3. Running MMPBSA.py

idecomp Energy decomposition scheme to use:

1 - Per-residue decomp with 1-4 terms added to internal potential terms
2 - Per-residue decomp with 1-4 EEL added to EEL and 1-4 VDW added to VDW potential terms.
3 - Pairwise decomp with 1-4 terms added to internal potential terms
4 - Pairwise decomp with 1-4 EEL added to EEL and 1-4 VDW added to VDW potential terms
(No default. This must be speciﬁed!) This functionality requires sander.

print_res Select residues from the complex prmtop to print. The receptor/ligand residues will be automatically
ﬁgured out if the default mask assignments are used. If you specify your own masks, you will need to
modify the mdin ﬁles created by MMPBSA.py and rerun MMPBSA.py with the -use-mdins ﬂag. Note that
the DELTAs will not be computed in this case. This variable accepts a sequence of individual residues and/or
ranges. The different ﬁelds must be either comma- or semicolon-delimited. For example: print_res = “1,
3-10, 15, 100”, or print_res = “1; 3-10; 15; 100”. Both of these will print residues 1, 3 through 10, 15, and
100 from the complex prmtop and the corresponding residues in either the ligand and/or receptor prmtops.
(Default: print all residues)*

* Please note: Using idecomp=3 or 4 (pairwise) with a very large number of printed residues and a large number
of frames can quickly create very, very large temporary mdout ﬁles. Large print selections also demand a large
amount of memory to parse the mdout ﬁles and write decomposition output ﬁle (~500 MB for just 250 residues,
since that’s 62500 pairs!) It is not unusual for the output ﬁle to take a signiﬁcant amount of time to print if you
have a lot of data. This is most applicable to pairwise decomp, since the amount of data scales as O(N2).

&rism namelist variables*

buffer Minimum distance between solute and edge of solvation box. Specify this with grdspc below. Mutually

exclusive with ng and solvbox. Set buffer < 0 if you wish to use ng and solvbox. (Default = 14 Å)

closure The approximation to the closure relation. Allowed choices are kh (Kovalenko-Hirata), hnc (Hypernetted-
chain), or psen (Partial Series Expansion of order-n) where “n” is a positive integer (e.g., “pse3”). (Default
= ‘kh’)

closureorder (Deprecated) The order at which the PSE-n closure is truncated if closure is speciﬁed as “pse” or

“psen” (no integers). (Default = 1)

grdspc Grid spacing of the solvation box. Specify this with buffer above. Mutually exclusive with ng and solvbox.

(Default = 0.5 Å)

ng Number of grid points to use in the x, y, and z directions. Used only if buffer < 0. Mutually exclusive with
buffer and grdspc above, and paired with solvbox below. No default, this must be set if buffer < 0. Deﬁne
like “ng=1000,1000,1000”

polardecomp Decompose the solvation free energy into polar and non-polar contributions. Note that this will
increase computation time by roughly 80%. 0: Don’t decompose solvation free energy. 1: Decompose
solvation free energy. (Default = 0)

rism_verbose Level of output in temporary RISM output ﬁles. May be helpful for debugging or following con-
vergence. Allowed values are 0 (just print the ﬁnal result), 1 (additionally prints the total number of iterations
for each solution), and 2 (additionally prints the residual for each iteration and details of the MDIIS solver).
(Default = 0)

solvbox Length of the solvation box in the x, y, and z dimensions. Used only if buffer < 0. Mutually exclusive
with buffer and grdspc above, and paired with ng above. No default, this must be set if buffer < 0. Deﬁne
like “solvbox=20,20,20”

solvcut Cutoff used for solute-solvent interactions. The default is the value of buffer. Therefore, if you set buffer
< 0 and specify ng and solvbox instead, you must set solvcut to a nonzero value or the program will quit in
error. (Default = buffer)

763

34. MMPBSA.py

thermo Which thermodynamic equation you want to use to calculate solvation properties. Options are “std”, “gf”,
or “both” (case-INsensitive). “std” uses the standard closure relation, “gf” uses the Gaussian Fluctuation
approximation, and “both” will print out separate sections for both. (Default = “std”). Note that all data are
printed out for each RISM simulation, so no choice is any more computationally demanding than another.
Also, you can change this option and use the -rewrite-output ﬂag to obtain a different printout after-the-fact.

tolerance Upper bound of the precision requirement used to determine convergence of the self-consistent solution.

This has a strong effect on the cost of 3D-RISM calculations. (Default = 1e-5).

* 3D-RISM calculations are performed with the rism3d.snglpnt program built with AmberTools, written by
Tyler Luchko. It is the most expensive, yet most statistical mechanically rigorous solvation model available in
MMPBSA.py. See Chapter 7 for a more thorough description of options and theory. A list of references can be
found there, too. One advantage of 3D-RISM is that an arbitrary solvent can be chosen; you just need to change
the xvvﬁle speciﬁed on the command line (see 34.3.2).

Sample input ﬁles

Sample input file for GB and PB calculation
&general

startframe=5, endframe=100, interval=5,
verbose=2, keep_files=0,

/
&gb

/
&pb

igb=5, saltcon=0.150,

istrng=0.15, fillratio=4.0

/
--------------------------------------------------------
Sample input file for Alanine scanning
&general

verbose=2,

/
&gb

igb=2, saltcon=0.10

/
&alanine_scanning
/
--------------------------------------------------------
Sample input file with nmode analysis
&general

startframe=5, endframe=100, interval=5,
verbose=2, keep_files=2,

/
&gb

igb=5, saltcon=0.150,

/
&nmode

nmstartframe=2, nmendframe=20, nminterval=2,
maxcyc=50000, drms=0.0001,

/
--------------------------------------------------------
Sample input file with decomposition analysis
&general

764

34.3. Running MMPBSA.py

startframe=5, endframe=100, interval=5,

/
&gb

igb=5, saltcon=0.150,

/
&decomp

idecomp=2, dec_verbose=3,
print_res="20, 40-80, 200"

/
--------------------------------------------------------
Sample input file for QM/MMGBSA
&general

startframe=5, endframe=100, interval=5,

/
&gb

igb=5, saltcon=0.100, ifqnt=1, qmcharge=0,
qm_residues="100-105, 200", qm_theory="PM3"

/
--------------------------------------------------------
Sample input file for MM/3D-RISM
&general

startframe=5, endframe=100, interval=5,

/
&rism

polardecomp=1, thermo="gf"

/
--------------------------------------------------------
Sample input file for MMPBSA with membrane proteins
&general

use_sander=1,
startframe=1, endframe=100, interval=1,
keep_files=0, debug_printlevel=2

/
&pb

/

radiopt=0, indi=20.0, istrng=0.150,
fillratio=1.25, ipb=1, nfocus=1,
bcopt=10, eneopt=1, cutfd=7.0, cutnb=99.0,
npbverb=1, solvopt=2, inp=1,
memopt=1, emem=7.0, mctrdz=-10.383, mthick=36.086, poretype=1,
maxarcdot=15000

A few important notes about input ﬁles. Comments are allowed by placing a # at the beginning of the line (whites-
pace is ignored). Variable initialization may span multiple lines. In-line comments (i.e., putting a # for a comment
after a variable is initialized in the same line) is not allowed and will result in an input error. Variable declarations
must be comma-delimited, though all whitespace is ignored. Finally, all lines between namelists are ignored, so
comments may be put before each namelist without using #.

34.3.2. Calling MMPBSA.py from the command-line
MMPBSA.py is invoked through the command line as follows:

Usage: MMPBSA.py [Options]
Options:

765

34. MMPBSA.py

--help, -h, --h, -H

show this help message and exit

-O

-i

-o

-sp

-cp

-rp

-lp

-y

-do

Overwrite existing output files

input_file

MM/PBSA input file

output_file

Final MM/PBSA statistics file. Default
FINAL_RESULTS_MMPBSA.dat

solvated_prmtop

Solvated complex topology file

complex_prmtop

Complex topology file. Default “complex_prmtop”

receptor_prmtop

Receptor topology file

ligand_prmtop

Ligand topology file

mdcrd1,mdcrd2,...,mdcrdN

Input trajectories to analyze. Default mdcrd

decompout

Decomposition statistics summary file. Default
FINAL_DECOMP_MMPBSA.dat

-eo

energyout

CSV-format output of all energy terms for every frame in
every calculation. File name forced to end in .csv

-deo

dec_energies

CSV-format output of all decomposition energy terms for
every frame. File name forced to end in .csv

receptor_mdcrd1,receptor_mdcrd2,...,receptor_mdcrdN

Receptor trajectory file for multiple trajectory approach

ligand_mdcrd1,ligand_mdcrd2,...,ligand_mdcrdN

Ligand trajectory file for multiple trajectory approach

mutant_complex_prmtop

Alanine scanning mutant complex topology file

mutant_ligand_prmtop

Alanine scanning mutant ligand topology file

mutant_receptor_prmtop

Alanine scanning mutant receptor topology file

-yr

-yl

-mc

-ml

-mr

-slp

-srp

solvated_ligand_prmtop

Solvated ligand topology file
solvated_receptor_prmtop

Solvated receptor topology file

-xvvfile

xvvfile

XVV file for 3D-RISM. Default
$AMBERHOME/dat/mmpbsa/spc.xvv

-prefix

prefix

Beginning of every intermediate file name generated

-make-mdins

Create the Input files for each calculation and quit

-use-mdins

Use existing input files for each calculation

-rewrite-output

Don’t rerun any calculations, just parse existing output

766

34.3. Running MMPBSA.py

files

--clean

Clean temporary files from previous run

-make-mdins and -use-mdins are intended to give added ﬂexibility to user input. If the MM/PBSA input ﬁle does
not expose a variable you require, you may use the -make-mdins ﬂag to generate the MDIN ﬁles and then quit.
Then, edit those MDIN ﬁles, changing the variables you need to, then running MMPBSA.py with -use-mdins to
use those modiﬁed ﬁles.

--clean will remove all temporary ﬁles created by MMPBSA.py in a previous calculation.
--version will display the program version and exit.

34.3.3. Running MMPBSA.py

34.3.3.1. Serial version

This version is installed with Amber during the serial install of AmberTools. AMBERHOME must be set, or it will
quit on error. If any changes are made to the modules, MMPBSA.py must be remade so the updated modules are
found by MMPBSA.py. An example command-line call is shown below:

MMPBSA.py -O -i mmpbsa.in -cp com.top -rp rec.top -lp lig.top -y traj.crd

The tests, found in ${AMBERHOME}/test/mmpbsa_py provide good examples for running MMPBSA.py calcula-
tions.

34.3.3.2. Parallel (MPI) version

This version is installed with Amber during the parallel install. The python package mpi4py is included with

the MMPBSA.py source code and must be successfully installed in order to run the MPI version of MMPBSA.py.
It is run in the same way that the serial version is above, except MPI directions must be given on the command
line as well. Note, if mpi4py does not install correctly, you must install it yourself in order to use
MMPBSA.py.MPI. One note: at a certain level, running RISM in parallel may actually hurt performance, since
previous solutions are used as an initial guess for the next frame, hastening convergence. Running in parallel loses
this advantage. Also, due to the overhead involved in which each thread is required to load every topology ﬁle
when calculating energies, parallel scaling will begin to fall off as the number of threads reaches the number of
frames. A usage example is shown below:

mpirun -np 2 MMPBSA.py.MPI -O -i mmpbsa.in -cp com.top -rp rec.top \

-lp lig.top -y traj.crd

34.3.4. Types of calculations you can do

There are many different options for running MMPBSA.py. Among the types of calculations you can do are:

1. Normal binding free energies, with either PB or GB implicit solvent models. Each can be done with either
1, 2, or 3 different trajectories, but the complex, receptor, and ligand topology ﬁles must all be deﬁned. The
complex mdcrd must always be provided. Whichever trajectories of the receptor and/or ligand that are NOT
speciﬁed will be extracted from the complex trajectory. This allows a 1-, 2-, or 3-trajectory analysis. All PB
calculations and GB models can be performed with just AmberTools via the mmpbsa_py_energy program
installed with MMPBSA.py.

2. Stability calculations with any calculation type. If you only specify the complex prmtop (and leave receptor
and ligand prmtop options blank), then a “stability” calculation will be performed, and you will get statistics
based on only a single system. Any additional receptor or ligand information given will be ignored, but note
that if receptor and/or ligand topologies are given, it will no longer be considered a stability calculation. The
previous statement refers principally to mutated receptor/ligand ﬁles or extra ligand/receptor trajectory ﬁles.

767

34. MMPBSA.py

3. Alanine scanning with either PB or GB implicit solvent models. All trajectories will be mutated to match
the mutated topology ﬁles, and whichever calculations that would be carried out for the normal systems are
also carried out for the mutated systems. Note that only 1 mutation is allowed per simulation, and it must
be to an alanine. If mutant_only is not set to 1, differences resulting from the mutations are calculated. This
option is incompatible with intermediate NetCDF trajectories (see the netcdf = 1 option above). This has the
same program requirements as option 1 above.

4. Entropy corrections. An entropy term can be added to the free energies calculated above using either the
quasi-harmonic approximation or the normal mode approximation. Calculations will be done for the nor-
mal and mutated systems (alanine scanning) as requested. Normal mode calculations are done with the
mmpbsa_py_nabnmode program included with AmberTools.

5. Decomposition schemes. The energy terms will be decomposed according to the decomposition scheme
outlined in the idecomp variable description. This should work with all of the above, though entropy terms
cannot be decomposed. APBS energies cannot be decomposed, either. Neither can PBSA surface area terms.
This functionality requires sander from the Amber 11 (or later) package.

6. QM/MMGBSA. This is a binding free energy (or stability calculation) using the Generalized Born solvent
model allowing you to treat part of your system with a quantum mechanical Hamiltonian. See “Advanced
Options” for tips about optimizing this option. This functionality requires sander from the Amber package.

7. MM/3D-RISM. This is a binding free energy (or stability calculation) using the 3D-RISM solvation model.

This functionality is performed with rism3d.snglpnt built with AmberTools.

8. Membrane Protein MMPBSA. Calculate the MMPBSA binding free energy for a ligand bound to a protein

that is embedded into a membrane. Only use_sander=1 is supported.

34.3.5. The Output File

The header of the output ﬁle will contain information about the calculation. It will show a copy of the input
ﬁle as well as the names of all ﬁles that were used in the calculation (topology ﬁles and coordinate ﬁle(s)). If the
masks were not speciﬁed, it prints its best guess so that you can verify its accuracy, along with the residue name of
the ligand (if it is only a single residue).

The energy and entropy contributions are broken up into their components as they are in sander and nmode or
ptraj. The contributions are further broken into Ggas and Gsolv. The polar and non-polar contributions are EGB (or
EPB) and ESURF (or ECAVITY / ENPOLAR), respectively for GB (or PB) calculations.

By default, bonded terms are not printed for any one-trajectory simulation. They are computed and their dif-
ferences calculated, however. They are not shown (nor included in the total) unless speciﬁcally asked for because
they should cancel completely. A single trajectory does not produce any differences between bond lengths, angles,
or dihedrals between the complex and receptor/ligand structures. Thus, when subtracted they cancel completely.
This includes the BOND, ANGLE, DIHED, and 1-4 interactions. If inconsistencies are found, these values are
displayed and inconsistency warnings are printed. When this occurs the results are generally useless. Of course
this does not hold for the multiple trajectory protocol, and so all energy components are printed in this case.

Finally, all warnings generated during the calculation that do not result in fatal errors are printed after calculation

details but before any results.

34.3.6. Temporary Files

MMPBSA.py creates working ﬁles during the execution of the script beginning with the preﬁx _MMPBSA_.
The variable “keep_ﬁles” controls how many of these ﬁles are kept after the script ﬁnishes successfully. If the
script quits in error, all ﬁles will be kept. You can clean all temporary ﬁles from a directory by running MMPBSA
–clean described above.

If MMPBSA.py does not ﬁnish successfully, several of these ﬁles may be helpful in diagnosing the problem.
For that reason, every temporary ﬁle is described below. Note that not every temporary ﬁle is generated in every

768

34.3. Running MMPBSA.py

simulation. At the end of each description, the lowest value of “keep_ﬁles” that will retain this ﬁle will be shown
in parentheses.

_MMPBSA_gb.mdin Input ﬁle that controls the GB calculation done in sander. (2)

_MMPBSA_pb.mdin Input ﬁle that controls the PB calculation done in sander. (2)

_MMPBSA_gb_decomp_com.mdin Input ﬁle that controls the GB decomp calculation for the complex done in

sander. (2)

_MMPBSA_gb_decomp_rec.mdin Input ﬁle that controls the GB decomp calculation for the receptor done in

sander. (2)

_MMPBSA_gb_decomp_lig.mdin Input ﬁle that controls the GB decomp calculation for the ligand done in sander.

(2)

_MMPBSA_pb_decomp_com.mdin Input ﬁle that controls the PB decomp calculation for the complex done in

sander. (2)

_MMPBSA_pb_decomp_rec.mdin Input ﬁle that controls the PB decomp calculation for the receptor done in

sander. (2)

_MMPBSA_pb_decomp_lig.mdin Input ﬁle that controls the PB decomp calculation for the ligand done in sander.

(2)

_MMPBSA_gb_qmmm_com.mdin Input ﬁle that controls the GB QM/MM calculation for the complex done in sander.

(2)

_MMPBSA_gb_qmmm_rec.mdin Input ﬁle that controls the GB QM/MM calculation for the receptor done in sander.

(2)

_MMPBSA_gb_qmmm_lig.mdin Input ﬁle that controls the GB QM/MM calculation for the ligand done in sander.

(2)

_MMPBSA_complex.mdcrd.# Trajectory ﬁle(s) that contains only those complex snapshots that will be processed

by MMPBSA.py. (1)

_MMPBSA_ligand.mdcrd.# Trajectory ﬁle(s) that contains only those ligand snapshots that will be processed by

MMPBSA.py. (1)

_MMPBSA_receptor.mdcrd.# Trajectory ﬁle(s) that contains only those receptor snapshots that will be processed

by MMPBSA.py. (1)

_MMPBSA_complex_nc.# Same as _MMPBSA_complex.mdcrd.#, except in the NetCDF format. (1)

_MMPBSA_receptor_nc.# Same as _MMPBSA_receptor.mdcrd.#, except in the NetCDF format. (1)

_MMPBSA_ligand_nc.# Same as _MMPBSA_ligand.mdcrd.#, except in the NetCDF format. (1)

_MMPBSA_dummycomplex.inpcrd Dummy inpcrd ﬁle generated by _MMPBSA_complexinpcrd.in for use with

imin=5 functionality in sander. (1)

_MMPBSA_dummyreceptor.inpcrd Same as above, but for the receptor. (1)

_MMPBSA_dummyligand.inpcrd Same as above, but for the ligand. (1)

_MMPBSA_complex.pdb Dummy PDB ﬁle of the complex required to set molecule up in nab programs

_MMPBSA_receptor.pdb Dummy PDB ﬁle of the receptor required to set molecule up in nab programs

_MMPBSA_ligand.pdb Dummy PDB ﬁle of the ligand required to set molecule up in nab programs

769

34. MMPBSA.py

_MMPBSA_complex_nm.mdcrd.# Trajectory ﬁle(s) for each thread with snapshots used for normal mode calcula-

tions on the complex. (1)

_MMPBSA_receptor_nm.mdcrd.# Trajectory ﬁle for each thread with snapshots used for normal mode calcula-

tions on the receptor. (1)

_MMPBSA_ligand_nm.mdcrd.# Trajectory ﬁle for each thread with snapshots used for normal mode calculations

on the ligand. (1)

_MMPBSA_ptrajentropy.in Input ﬁle that calculates the entropy via the quasi-harmonic approximation. This

ﬁle is processed by ptraj. (2)

_MMPBSA_avgcomplex.pdb PDB ﬁle containing the average positions of all complex conformations processed by
_MMPBSA_cenptraj.in. It is used as the reference for the _MMPBSA_ptrajentropy.in ﬁle above.
(1)

_MMPBSA_complex_entropy.out File into which the entropy results from _MMPBSA_ptrajentropy.in analysis

on the complex are dumped. (1)

_MMPBSA_receptor_entropy.out Same as above, but for the receptor. (1)

_MMPBSA_ligand_entropy.out Same as above, but for the ligand. (1)

_MMPBSA_ptraj_entropy.out Output from running ptraj using _MMPBSA_ptrajentropy.in. (1)

_MMPBSA_complex_gb.mdout.# sander output ﬁle containing energy components of all complex snapshots done

in GB. (1)

_MMPBSA_receptor_gb.mdout.# sander output ﬁle containing energy components of all receptor snapshots done

in GB. (1)

_MMPBSA_ligand_gb.mdout.# sander output ﬁle containing energy components of all ligand snapshots done in

GB. (1)

_MMPBSA_complex_pb.mdout.# sander output ﬁle containing energy components of all complex snapshots done

in PB. (1)

_MMPBSA_receptor_pb.mdout.# sander output ﬁle containing energy components of all receptor snapshots done

in PB. (1)

_MMPBSA_ligand_pb.mdout.# sander output ﬁle containing energy components of all ligand snapshots done in

PB. (1)

_MMPBSA_complex_rism.out.# rism3d.snglpnt output ﬁle containing energy components of all complex snap-

shots done with 3D-RISM (1)

_MMPBSA_receptor_rism.out.# rism3d.snglpnt output ﬁle containing energy components of all receptor snap-

shots done with 3D-RISM (1)

_MMPBSA_ligand_rism.out.# rism3d.snglpnt output ﬁle containing energy components of all ligand snapshots

done with 3D-RISM (1)

_MMPBSA_pbsanderoutput.junk.# File containing the information dumped by sander.APBS to STDOUT. (1)

_MMPBSA_ligand_nm.out.# Output ﬁle from mmpbsa_py_nabnmode that contains the entropy data for the ligand

for all snapshots. (1)

_MMPBSA_receptor_nm.out.# Output ﬁle from mmpbsa_py_nabnmode that contains the entropy data for the

receptor for all snapshots. (1)

770

34.4. Python API

_MMPBSA_complex_nm.out.# Output ﬁle from mmpbsa_py_nabnmode that contains the entropy data for the com-

plex for all snapshots. (1)

_MMPBSA_mutant_... These ﬁles are analogs of the ﬁles that only start with _MMPBSA_ described above, but

instead refer to the mutant system of alanine scanning calculations.

_MMPBSA_*out.# These ﬁles are thread-speciﬁc ﬁles. For serial simulations, only #=0 ﬁles are created. For

parallel, #=0 through NUM_PROC - 1 are created.

34.3.7. Advanced Options

The default values for the various parameters as well as the inclusion of some variables over others in the
general MMPBSA.py input ﬁle were chosen to cover the majority of all MM/PB(GB)SA calculations that would
be attempted while maintaining maximum simplicity. However, there are situations in which MMPBSA.py may
appear to be restrictive and ill-equipped to address. Attempts were made to maintain the simplicity described above
while easily providing users with the ability to modify most aspects of the calculation easily and without editing
the source code.

-make-mdins This ﬂag will create all of the mdin and input ﬁles used by sander and nmode so that additional
control can be granted to the user beyond the variables detailed in the input ﬁle section above. The ﬁles
created are _MMPBSA_gb.mdin which controls GB calculation; _MMPBSA_pb.mdin which controls the
PB calculation; _MMPBSA_sander_nm_min.mdin which controls the sander minimization of snapshots to
be prepared for nmode calculations; and _MMPBSA_nmode.in which controls the nmode calculation. If
no input ﬁle is speciﬁed, all ﬁles above are created with default values, and _MMPBSA_pb.mdin is created
for AmberTools’s pbsa. If you wish to create a ﬁle for sander.APBS, you must include an input ﬁle with
“sander_apbs=1” speciﬁed to generate the desired input ﬁle. Note that if an input ﬁle is speciﬁed, only those
mdin ﬁles pertinent to the calculation described therein will be created!

-use-mdins This ﬂag will prevent MMPBSA.py from creating the input ﬁles that control

the vari-
ous calculations (_MMPBSA_gb.mdin, _MMPBSA_pb.mdin, _MMPBSA_sander_nm_min.mdin, and
_MMPBSA_nmode.in).
It will instead attempt to use existing input ﬁles (though they must have those
names above!) in their place. In this way, the user has full control over the calculations performed, however
care must be taken. The mdin ﬁles created by MMPBSA.py have been tested and are (generally) known to
be consistent. Modifying certain variables (such as imin=5) may prevent the script from working, so this
should only be done with care. It is recommended that users start with the existing mdin ﬁles (generated by
the -make-mdins ﬂag above), and add and/or modify parameters from there.

strip_mask This input variable allows users to control which atoms are stripped from the trajectory ﬁles associated
with solvated_prmtop. In general, counterions and water molecules are stripped, and the complex is centered
and imaged (so that if iwrap caused the ligand to “jump” to the other side of the periodic box, it is replaced
inside the active site). If there is a speciﬁc metal ion that you wish to include in the calculation, you can
prevent ptraj from stripping this ion by NOT specifying it in strip_mask. Note that strip_mask does nothing
if no solvated_prmtop is provided.

QM/MMGBSA There are a lot of options for QM/MM calculations in sander, but not all of those options were
made available via options in the MMPBSA.py input ﬁle. In order to take advantage of these other options,
you’ll have to make use of the -make-mdins and -use-mdins ﬂags as detailed above and change the resulting
_MMPBSA_gb_qmmm_com/rec/lig.mdin ﬁles to ﬁt your desired calculation. Additionally, MMPBSA.py
suffers all shortcomings of sander, one of those being that PB and QM/MM are incompatible. Therefore,
only QM/MMGBSA is a valid option right now.

34.4. Python API

The aim of the MMPBSA.py API is to provide you with direct access to the raw data produced during a
MMPBSA.py calculation. By default, MMPBSA.py calculates an average, standard deviation, and standard er-

771

34. MMPBSA.py

Table 34.1.: List and description of calc_key dict keys that may be present in instances of the mmpbsa_data class.

Dictionary Key (calc_key)

Calculation Type

’gb’
’pb’

’rism gf’
’rism std’

’nmode’

’qh’

Generalized Born Results
Poisson-Boltzmann Results

Gaussian Fluctuation 3D-RISM Results

Standard 3D-RISM Results

Normal Mode Analysis Results

Quasi-harmonic Approximation Results

ror of the mean for all of the generated data sets, but does not support custom analyses. The API reads an
_MMPBSA_info ﬁle, from which it will determine what kind of calculation you performed, then automatically
parse the output ﬁles and load the data into arrays.

The keep_files variable in the &general section must be set to 1 or 2 in order to keep enough ﬁles for the API
to work. It currently does NOT load decomposition data into available data structures. The topology ﬁles you used
in the MMPBSA.py calculation must also be available in the location speciﬁed in the _MMPBSA_info ﬁle.

Using the API

The function load_mmpbsa_info takes the name of an MMPBSA.py info ﬁle (typically _MMPBSA_info) and

returns a populated mmpbsa_data instance with all of the parsed data. An example code snippet that creates a
mmpbsa_data instance from the information in _MMPBSA_info is shown below.

from MMPBSA_mods import API as MMPBSA_API
data = MMPBSA_API.load_mmpbsa_info("_MMPBSA_info")

Properties of mmpbsa_data

The mmpbsa_data class is a nested dictionary structure (mmpbsa_data is actually derived from dict). The

various attributes of mmpbsa_data are described below followed by the deﬁned operators.

Attributes

If the numpy package is installed and available, all data arrays will be numpy.ndarray instances. Otherwise, all
data arrays will be array.array instances with the ’d’ data type speciﬁer (for a double precision ﬂoat). The data
is organized in an mmpbsa_data instance in the following manner:

mmpbsa_data_instance[calc_key][system_component][energy_term]

In this example, calc_key is a dict key that is paired to another dict (mmpbsa_data_instance is the ﬁrst-level
dict, in this case). The keys of these second-level dict instances (system_component) pair to another dict.
The keys of these inner-most (third-level) dict instances are paired with the data arrays for that energy term. The
various dictionary keys are listed below for each level. If alanine scanning was performed, the
mmpbsa_data_instance also has a “mutant” attribute that contains the same dictionary structure as
mmpbsa_data does for the normal system. The only difference is that the data is accessed as follows:

mmpbsa_data_instance.mutant[calc_key][system_component][energy_term]

Note, all keys are case-sensitive, and if a space appears in the key, it must be present in your program. Also, if
polar/non-polar decomposition is not performed for 3D-RISM, then the ’POLAR SOLV’ and ’APOLAR SOLV’ keys
are replaced with the single key ’ERISM’

772

34.4. Python API

Table 34.2.: List and description of system_component keys that may be present in instances of the mmpbsa_data

class.

Dictionary Key (system_component)

Description

’complex’
’receptor’

’ligand’

Data sets for the complex. (Stability & Binding)

Data sets for the receptor. (Binding only)
Data sets for the ligand. (Binding only)

Table 34.3.: List and description of energy_term keys that may be present in instances of the mmpbsa_data class.
The allowed values of energy_term depend on the value of calc_key above in Table 34.1. The
energy_term keys are listed for each calc_key enumerated above, accompanied by a description.
The RISM keys are the same for both ’rism gf’ and ’rism std’ although the value of ’POLAR
SOLV’ and ’APOLAR SOLV’ will differ depending on the method chosen. Those keys marked with *
are speciﬁc to the CHARMM force ﬁeld used through chamber. Those arrays are all 0 for normal
Amber topology ﬁles.

Description
Bond energy
Angle energy

Dihedral Energy
Urey-Bradley*

Improper Dihedrals*

Correction Map*

1-4 van der Waals energy
1-4 Electrostatic energy
van der Waals energy
Electrostatic energy
Polar solvation energy

Non-polar solvation energy
Total solvation free energy
Total gas phase free energy

Total energy

’gb’

’pb’

’BOND’
’ANGLE’
’DIHED’

’UB’
’IMP’
’CMAP’

’BOND’
’ANGLE’
’DIHED’

’UB’
’IMP’
’CMAP’

’1-4 VDW’
’1-4 EEL’
’VDWAALS’

’1-4 VDW’
’1-4 EEL’
’VDWAALS’

’EEL’
’EGB’

’ESURF’
’G solv’
’G gas’
’TOTAL’

’EEL’
’EPB’

’ENPOLAR’
’G solv’
’G gas’
’TOTAL’

RISM

’BOND’
’ANGLE’
’DIHED’

—
—
—

’1-4 VDW’
’1-4 EEL’
’VDWAALS’

’EEL’

’POLAR SOLV’
’APOLAR SOLV’

’G solv’
’G gas’
’TOTAL’

Description

Translational entropy
Rotational entropy
Vibrational entropy

Total entropy

Table 34.4.: Same as Table 34.3 for the entropy data.
’nmode’

’qh’

’Translational’

’Translational’

’Rotational’
’Vibrational’

’Rotational’
’Vibrational’

’Total’

’Total’

773

34. MMPBSA.py

Deﬁned operators

In-place addition: It extends all of the arrays that are common to both mmpbsa_data instances. This is useful if,

for instance, you run two MMPBSA.py calculations, and you use -prefix <new_prefix> for the second
simulation. Assuming that <new_prefix> is _MMPBSA2_ for the second MMPBSA.py calculation, the following
pseudo-code will generate an mmpbsa_data instance with all of the data in concatenated arrays. The pseudo-code
assumes MMPBSA_mods.API was imported as demonstrated in Subsection 34.4.

data = MMPBSA_API.load_mmpbsa_info("_MMPBSA_info")
data += MMPBSA_API.load_mmpbsa_info("_MMPBSA2_info")

Example API Usage

In many cases, the autocorrelation function of the energy can aid in the analysis of MM/PBSA data, since it
provides a way of determining the statistical independence of your data points. For example, 1000 correlated
snapshots provide less information, and therefore less statistical certainty, than 1000 uncorrelated snapshots. The
standard error of the mean calculation performed by MMPBSA.py assumes a completely uncorrelated set of snap-
shots, which means that it is a lower bound of the true standard error of the mean, and a plot of the autocorrelation
function may help determine the actual value.

The example program below will calculate the autocorrelation function of the total energy (complex only for
both the normal and alanine mutant systems) from a GB calculation and plot the resulting code using matplotlib.



import os
import sys
# append AMBERHOME/bin to sys.path
sys.path.append(os.path.join(os.getenv('AMBERHOME'), 'bin'))
# Now import the MMPBSA API
from MMPBSA_mods import API as MMPBSA_API
import matplotlib.pyplot as plt
import numpy as np

data = MMPBSA_API.load_mmpbsa_info('_MMPBSA_info')
total = data['gb']['complex']['TOTAL'].copy()

data = MMPBSA_API.load_mmpbsa_info('_MMPBSA_info')
total_mut = data.mutant['gb']['complex']['TOTAL'].copy()

# Create a second copy of the data set. The np.correlate function does not
# normalize the correlation function, so we modify total and total2 to get
# that effect
total -= total.mean()
total /= total.std()
total2 = total.copy() / len(total)
acor = np.correlate(total, total2, 'full')

total_mut -= total_mut.mean()
total_mut /= total_mut.std()
total2_mut = total_mut.copy() / len(total_mut)
acor_mut = np.correlate(total_mut, total2_mut, 'full')

# Now generate the 'lag' axis
xdata = np.arange(0, len(total))

# The acor data set is symmetric about the origin, so only accept the
# positive lag times. Graph the result
plt.plot(xdata, acor[len(acor)//2:], xdata, acor_mut[len(acor)//2:])
plt.show()



774





34.4. Python API

Decomposition Data

When performing decomposition analysis, the various decomp data is stored in a separate tree of dicts refer-
enced with the ‘decomp’ key. The key sequence is similar to the sequence for the ‘normal’ data described above,
where decomp is followed by the solvent model (GB or PB), followed by the species (complex, receptor, or ligand),
followed by the decomposition components (total, backbone, or sidechain), followed by the residue number (or
residue pair for pairwise decomposition), ﬁnally followed by the contribution (internal, van der Waals, electrostat-
ics, etc.) The available keys are shown in Figure 34.1 on page 776 (and each key is described afterwards).

Decomp Key Descriptions

gb All Generalized Born results

pb All Poisson-Boltzmann results

complex All results from the complex trajectory

receptor All results from the receptor trajectory

ligand All results from the ligand trajectory

TDC All results from the total decomposition

SDC All results from the sidechain decomposition

BDC All results from the backbone decomposition

# All data from residue number “#” in per-residue decomposition (same residue numbering scheme as in each

respective topology ﬁle)

#-## All interaction energies between residues “#” and “##” (same residue numbering scheme as in each respective

topology ﬁle)

int Internal energy contributions (see the idecomp variable description above)

vdw van der Waals energy contributions

eel Electrostatic energy contributions

pol Polar solvation free energy contributions

sas Non-polar solvation free energy contributions

tot Total free energy contributions (sum of previous 5).

775

34. MMPBSA.py

Figure 34.1.: Tree of dict keys following the ‘decomp’ key in a mmpbsa_data instance.

776

35. FEW

The Free Energy Workﬂow (FEW) is a tool for automated calculation of the binding free energy of a set of
ligands binding to the same receptor using modules provided in the AMBER suite of programs. Prerequisite for
calculations with FEW is the existence of 3D complex structures of a receptor and ligands. Generally, the more
accurate the complex structures are the more accurate results can be expected.

FEW provides functions for setup of three types of binding free energy calculations: implicit solvent calculations
by the MM-PBSA or MM-GBSA methods, linear interaction energy analyses (LIE), and thermodynamic integra-
tion (TI) calculations. These three binding free energy calculation approaches are available via three program
modules provided in FEW:

• WAMM: Workﬂow for automated MM-PBSA & MM-GBSA

• LIEW: Linear interaction energy workﬂow

• TIW: Thermodynamic integration workﬂow

35.1. Installation

The program FEW consists of the main Perl script “FEW.pl” and a set of Perl modules stored in the folder “libs”

provided in the main FEW directory.

A perl installation (version 5.10 or newer) needs to be available on the system where FEW shall be executed. For
running the program some additional Perl modules are needed (Table 35.1), which are provided under the terms of
the respective license in the folder “additional_libs”. Please ensure that the “additional_libs” folder is located in
the same directory in which the FEW.pl script resides.

FEW can be used with Amber and AmberTools. To enable access of the program FEW to AmberTools, the tools
need to be executable on the system by just calling their names, e.g., “antechamber” should invoke the antechamber
program. The following tools and programs are used by FEW directly: ambpdb, tleap, antechamber, cpptraj,
parmchk, mm_pbsa.pl and Babel (in case SDF-input ﬁles are provided). In addition, the AMBER programs sander
and/or PMEMD are required, and if charges shall be calculated by the RESP procedure also access to the program
Gaussian03 is needed. The later programs can be installed on a different system or a compute cluster.

Table 35.1.: Perl modules from CPAN used by FEW.

Functionality
Read and manage atom information
Interconversion between Perl structures and strings
Read ﬁle line by line from end of ﬁle

Module name1)
PerlMol
FreezeThaw
File::ReadBackwards
Statistics::Normality
Statistics::PointEstimation
Statistics::Descriptive
Statistics::Smoother
Statistics::Distributions
1) Modules are provided with FEW under the terms of the respective license.

Modules for statistical analysis

777

35. FEW

Basic program call

perl FEW.pl <procedure> <command-ﬁle>

Table 35.2.: Overview of procedures and corresponding modules available in FEW.
Program module used Key phrase in command ﬁle1)

Procedure name

MMPBSA or MMGBSA2)

LIE
TI

WAMM
LIEW
TIW

@WAMM
@LIEW
@TIW

1) Expression that needs to be provided in the ﬁrst line of the command ﬁle to ensure that the requested procedure and the

provided command ﬁle match.

2) Either MMPBSA or MMGBSA can be speciﬁed.

Figure 35.1.: Overview of program modules and functionality provided in FEW. All three free energy calculation

workﬂows available in FEW have a MD setup step in common.

The procedures that can be chosen are listed in Table 35.2, and an overview of the functionality provided in the
individual free energy calculation modules is shown in Figure 35.1. Example command ﬁles can be found in the
folder $AMBERHOME/AmberTools/src/FEW/examples/command_files. Please ensure that in each command ﬁle the
program module that shall be used for calculation is speciﬁed via a key phrase in the ﬁrst line (Table 35.2).

In addition,

template ﬁles, e.g.,

input ﬁles with parameters for MD simulations, are available under
examples/input_info. It is strongly recommended that non-experts use these template ﬁles for analysis and make
only those system and/or computing resource speciﬁc modiﬁcations that are requested below.

A complete example analysis corresponding to the show case example presented in ref. [690] including all
input ﬁles for setup and the ﬁnal result ﬁles with the computed binding free energies can be obtained from
http://cpclab.uni-duesseldorf.de/software. The current version of FEW uses per default the ff12SB force
ﬁeld of AMBER. Earlier FEW versions, as the one used for the generation of the case study data, employed the
ff99SB force ﬁeld. For backwards compatibility with previous FEW versions set the ﬂag backwards to 1.

778

 35.2. Overview of workﬂow steps and minimal input

35.2. Overview of workﬂow steps and minimal input

A detailed description of FEW and its functionality is provided in ref. [690]. We strongly encourage the user to

run the FEW tutorial ﬁrst that is available at http://ambermd.org/tutorials.

For the setup of free energy calculations with FEW a 3D receptor structure in PDB format and 3D lig-
and structures with coordinates of the ligand bound position in mol2 format are required (see section 35.3.1).
FEW provides besides the general setup functionality a lot of additional system / computing architecture spe-
ciﬁc and expert options that can be requested by setting parameters / ﬂags in the command ﬁle. All avail-
able options are described in the following sections, where essential parameters are marked in bold, while op-
tional additional parameters are shown in normal writing. For a typical system it is usually sufﬁcient to deﬁne
the essential ﬂags. Example ﬁles containing only those ﬂags that are commonly needed can be found under
$AMBERHOME/AmberTools/src/FEW/examples/command_files/minimalistic_files. Please use these ﬁles only if
your ligands are available as single structure mol2 ﬁles and if the receptor contains only standard residues deﬁned
in the ff12SB force ﬁeld.

The setup of free energy calculations with FEW is conducted in a multi-step procedure, i.e., FEW is called
several times using a command ﬁle with the parameters for the respective setup step. The Table 35.3 shows
the minimum number of FEW calls required for preparation and analysis of the individual free energy calcu-
lations. The individual setup steps can be further devided into individual tasks, such that each setup task can
be tracked and checked. The later is generally recommended if any problems are encountered in the setup
procedure.
In this case it should also be thoroughly checked, whether additional parameters might need to
be speciﬁed for the the speciﬁc system. Example command ﬁles of the individual setup steps of the differ-
ent setup procedues containing all available parameters can be found in the procedure speciﬁc folders under
$AMBERHOME/AmberTools/src/FEW/examples/command_files

Table 35.3.: Overview of steps required for setup, execution, and analysis of MM-PB(GB)SA, LIE, and TI calcula-

tions with FEW 1).

Call 2)

MM-PB(GB)SA (Section 35.4)

MD simulations (Section 35.3)

RESP charges

LIE (Section 35.5)

AM1-BCC charges

X

X

X

Preparation of Gaussian input ﬁles (35.3.2)

Calculation of ESP with Gaussian

Charge calculation & setup of MD simulations (35.3.2)

Charge calculation & setup of MD simulations

(35.3.2)

Running MD simulations
Free energy calculations

Setup of MM-PB(GB)SA calculations (35.4)

Running MM-PB(GB)SA calculations

Setup of LIE analysis (35.5)
Running LIE calculations

Preparation of MM-PB(GB)SA results for analysis (35.4)

Preparation of LIE results for analysis (35.5)

35.3. Common setup of molecular dynamics simulations

The setup of molecular dynamics (MD) simulations with FEW can be used in connection with all three available

free energy calculation procedures (cf. Figure 35.1).

779

35. FEW

Figure 35.2.: Graphical illustration of the steps conducted for setup of MD simulations. Steps that can be executed
independently by separate calls of FEW.pl are indicated by numbers. However, the individual steps
can be combined, so that the whole MD simulation setup can be conducted in 1 or 2 steps for the
AM1-BCC and RESP charge option, respectively (see 35.3).

MM-PB/GBSA and LIE calculations require the existence of MD trajectories from which snapshots can be
extracted, so that a MD setup is needed. For TI calculations it is recommended to use structures pre-equilibrated
with the common MD setup functionality of FEW as input structures. Expert users may also provide structures
directly, i.e. without using the MD equilibration preparation functionality of FEW. In the later case the structures
for TI input must be prepocessed using the structure preparation workﬂow available in the MD setup procedure
(see Section 35.3.2). As the MD setup functionality requires the same input for all three procedures, it is discussed
here separately from the procedure speciﬁc features. The setup of MD simulations is conducted in 3 consecutive
steps (see Figure 35.2), which can be initiated by a minimum of 1 or 2 FEW calls in the case of a setup of MD
simulations with AM1-BCC charges or RESP charges for the ligands, respectively (cf. Table 35.3).

35.3.1. Input structures
Ligand structures: 3D coordinates of ligand structures in the bound position and with the correct protonation
state need to be provided in one of the following formats:

• A) SDF ﬁle containing multiple ligand structures (requires the program Babel)

• B) mol2 ﬁle with multiple ligand structures

• C) mol2 ﬁles with one structure per ﬁle

In the case of A) and B) a structure separation needs to be requested using the ﬂag structure_separation in the
command ﬁle. This will result in a set of structures in format C), which is required for MD setup and all further
calculations. Ligands must consist of no more than one residue, and mol2 ﬁles must obey the formatting rules
deﬁned by TRIPOS (see http://www.tripos.com/data/support/mol2.pdf). In addition to the information obligatory
according to these rules for the entries in the ATOM section of mol2 ﬁles, FEW requires the substructure ID and
the substructure name, i.e., the residue ID and name. As residue names will be shortend to three characters, it
is recommended to use ligand residue names that consist of three characters only. Residue names can consist of
letters and numbers, but should not start with a number nor contain special characters.

780

2Ligand structureReceptor structureStructure separationCharge calculationRESP chargesAM1-BCC chargesPreparation of filesfor ESP calculationA)ESP calculation withGaussianB)Preparation of libraryfile with chargesC)Calculation of chargesusing antechamber andpreparation of library filewith chargesPreparation of LEaP input filesSetup of MD equilibration & production13Generation of coordinate and topology files35.3. Common setup of molecular dynamics simulations

Receptor structure: A structure of the receptor in PDB format with all atoms that shall be considered in the
calculation, i.e., including protons, is required. This structure can contain crystal water and / or non-standard
residues. The residues of the receptor need to be consecutively numbered starting from residue number 1. To
ensure that the atom names of the PDB structure can be recognized by LEaP, it is recommended to load the
prepared PDB ﬁle ﬁrst into LEaP and then re-save it. By this the residues are also automatically re-numbered
according to the requirements of FEW. If there are different chains or missing residues in the receptor structure,
those parts of the structure that are not directly connected need to be separated by a TER card in the PDB ﬁle
(see http://deposit.rcsb.org/adit/docs/pdb_atom_format.html). The residue name of all atoms that belong to water
molecules must be either “WAT” or “HOH”.

35.3.2. Flags for MD setup

The following ﬂags are available for MD setup. Flags and corresponding options are given. Essential ﬂags are
marked in bold and optional ones are shown in normal writing. Statements in "<" and ">" brackets denote place
holders. For example input ﬁles see $AMBERHOME/AmberTools/src/FEW/examples/command_files/commonMDsetup.
MD simulations are setup with a cubic water box extending at least 11 ˙A in each direction from the solute. Trun-
cated octahedrons are currently not supported. The normal ﬁle extensions of MD input and output ﬁles are short-
ened: *.inpcrd to *.crd and *.prmtop to *.top. An overview of the folder structure created upon MD setup is shown
in Figure 35.3.

Speciﬁcation of input / output directories and formats:

lig_struct_path <path>

Path to folder containing the ligand structures. For ligands provided in for-
mat C) a folder containing exclusively all ligand structures that shall be re-
garded needs to be manually created and speciﬁed under lig_struct_path.
If ligand structures are provided in input format A) or B) and a separation
is requested a folder called structs containing the separated structures is
created in the basic output directory. This folder needs to be speciﬁed in all
subsequent setup steps.

output_path <path>

Path to main output directory in which all new folders will be generated.

rec_structure <structure>

Full path and name of receptor structure ﬁle in PDB format.

lig_format_sdf 0 | 1

Set to 1, if multi-ligand ﬁle in sdf-format is provided; format A).

lig_format_mol2 0 | 1

Set to 1, if ligand structure ﬁles are provided in format B) or C).

water_in_rec 0 | 1

multi_structure_lig_ﬁle <name>

bound_rec_structure <structure>

Optional: 1: Crystal water present in receptor structure. Water molecules
need to be provided after the solute and should carry the residue name
"WAT" or “HOH”. 0: PDB structure of the receptor contains only the so-
lute and no crystal water molecules.

Only relevant for ligands in input formats A) or B): Basic name of ligand
input ﬁle if multi-structure ﬁle is provided in input formats A) or B). File
extension can be omitted.

Optional: Absolute path and name of the receptor PDB structure in the
bound state, in case two different receptor structures shall be used for setup
of complex and receptor in the 3-trajectory approach.

membrane_ﬁle <structure>

Optional: Absolute path and name of a PDB ﬁle containing lipids, ions,
and water molecules. This ﬁle is only required if a MD simulation with

781

35. FEW

an explicit membrane shall be performed. The ﬁle needs to be gener-
the CHARMM-GUI Membrane Builder
ated using external tools, e.g.
(http://www.charmm-gui.org/?doc=input/membrane) [691–694].
It is rec-
ommended to use the latter tool for preparing a PDB ﬁle of the membrane,
water, and ions, if the Lipid14 force ﬁeld [84] shall be used for the MD sim-
ulations. The ﬁles generated with the CHARMM-GUI Membrane Builder
can be converted with the charmmlipid2amber.py script provided with AM-
BER in order to obtain the required Lipid14 speciﬁc lipid naming scheme. If
the ﬁle containing lipids, ions, and water is generated with another program,
the user needs to ensure that the ﬁle formatting and lipid naming scheme is
consistent with AMBER and the force ﬁelds that shall be used.

Structure separation

structure_separation 0 | 1

Only relevant if ligands are in input formats A) or B): Set to 1 in case of ligand
input format A) or B). If set to 1, structure separation is conducted, and the result-
ing single structure ﬁles are stored in mol2 format in a folder called structs under
<output_path>. Default = 0.

Generation of ﬁles for setup of system with LEaP

prepare_leap_input 0 | 1

non_neutral_ligands 0 | 1

lig_charge_ﬁle <ﬁle>

am1_lig_charges 0 | 1

resp_lig_charges 0 | 1

resp_setup_step1 0 | 1

resp_setup_step2 0 | 1

782

The parameters in this section will only be regarded if this ﬂag is set to 1. If the
ﬂag is switched on, the ﬁles needed for the preparation of the system with LEaP
are generated.

Set to 1, if the total charge of at least one ligand molecule is not equal to zero.
In this case the total charge of each non-neutral ligand molecule needs to be
deﬁned in a separate ﬁle lig_charge_file.

If the total charge of at least one ligand molecule is not equal to zero, spec-
ify the full path and name of a ﬁle in which the names, the total charge, and
the multiplicity of the non-neutral ligands is stored in tab-separated format; see
examples/input_info/charge.txt.

Set to 1 if ligand charges shall be calculated according to the AM1-BCC method
[385, 386]. Please note: Only one charge calculation method can be used at a
time.

Set to 1 if ligand charges shall be calculated according to the "Restraint electro-
static potential ﬁt" (RESP) method [387]. Please note: Only one charge calcu-
lation method can be used at a time.

Request step one of the RESP charge calculation. The RESP charges are cal-
culated in two steps. First, the ﬁles needed for ligand structure optimization
and the calculation of the electrostatic potential with the program Gaussian are
generated. If this step is carried out, a folder called “gauss” containing all input
ﬁles for the Gaussian calculation is generated in the <output_path> directory.
This folder can be copied to a compute cluster, where the program Gaussian is
available. It is then possible to run the Gaussian jobs for all ligands at the same
time.

in which the atomic
Request step two of the RESP charge calculation,
charges are calculated based on the ESP computed with Gaussian.
If this
ﬂag is set to 1, the Gaussian output ﬁles need to be available in the folder
<output_path>/gauss.

gauss_batch_ﬁle 0 | 1

Optional: Request setup of batch scripts for Gaussian jobs. Default = 0.

35.3. Common setup of molecular dynamics simulations

gauss_batch_template <ﬁle>

gauss_batch_path <path>

average_charges <ﬁle>

calc_charges 0 | 1

prepare_membrane 0 | 1

ligand_water_cutoff <no.>

Setup of MD simulations

setup_MDsimulations 0 | 1

traj_setup_method 1 | 3

MD_am1 0 | 1

MD_resp 0 | 1

SSbond_ﬁle <ﬁle>

In case resp_lig_charges=1, resp_setup_step1=1, and gauss_batch_file=1,
then the full path and name of the template ﬁle for the generation of the
Gaussian batch-script needs to be speciﬁed here. Example template ﬁle:
examples/input_info/gaussian.pbs. Please adapt the ﬁle according to the
needs of your queuing system, but keep the variables and the format in the sec-
tion "Fix variables" and ensure that the line for job naming ends with "-N".

If the basis working directory for the Gaussian calculations differs from the
<output_path> directory the new basis directory can be speciﬁed here. For ex-
ample, this might be the case if the calculations shall be run on a compute cluster.
Optional: If the charges of two enantiomers shall be averaged, such that the two
molecules obtain the same atomic charges, a ﬁle in which the enantiomer pairs
are deﬁned needs to be speciﬁed here. Prerequisite: The atom order and naming
in the input mol2-ﬁles of the ligand isomers is identical. An example ﬁle can be
found under examples/input_info/isomer_pairs.txt

Optional: This ﬂag determines whether charges are calculated. If set to 0, only
LEaP input ﬁles that do not require charge calculation are generated. Default =
1.

Optional: Request setup of MD simulation with explicit membrane. Only
if prepare_membrane=1 the lipids, ions, and water molecules speciﬁed in the
membrane_file will be considered. Default = 0.

Optional: Relevant only if prepare_membrane=1. Cutoff distance from the ligand
within which all water molecules will be removed upon ligand insertion in order
to avoid clashes between the ligand and water molecules. Default = 1 Å.

Request generation of input ﬁles for MD simulations by setting this
ﬂag to 1. All other ﬂags in this section are only taken into account if
setup_MDsimulations=1.

Specify whether simulations shall be setup according to the 1-trajectory
or the 3-trajectory protocol for MM-PBSA or MM-GBSA. For LIE anal-
yses, only the 3-trajectory setup, i.e., separate simulations for the ligand
bound to the complex and for the ligand free in solution, works. For the
TI approach preparation of an equilibration according to the 3-trajectory
setup can be performed.

Set to 1 if MD simulation setup shall be conducted using previously
calculated AM1-BCC charges.

Set to 1 if setup of MD simulations shall be carried out using previously
calculated RESP charges.
If your receptor contains disulﬁde bridges the S-S bond connectivi-
ties need to be deﬁned in a separate ﬁle. The full path and name
of the ﬁle containing the disulﬁde bridge deﬁnitions should be pro-
vided here. In this ﬁle the numbers of those residues involved in S-S
bonds should be speciﬁed in tab-separated format. Please note, all cys-
teine residues involved in S-S bonds should be named CYX in the pro-
vided receptor PDB structure. For an example S-S connectivity ﬁle see
examples/input_info/SSbridges.txt

783

35. FEW

total_MDequil_time <time>

MDequil_batch_template <ﬁle>

Total equilibration time in [ps]. The simulation time requested in
all template ﬁles provided for equilibration needs to sum up to the
time provided here.
In case the ﬁles provided in the example
MDequil_template_folder are used this keyword does not need to be
speciﬁed. Default = 400 ps.

Absolute path and name of the batch template ﬁle for the equilibration.
This ﬁle should contain calls for all equilibration steps. For an example
template ﬁle see examples/input_info/equi.pbs. Please adapt this ﬁle
according to your needs, but keep the variables and the format in the
section "Fix variables" and ensure that the line for job naming ends with
"-N".

total_MDprod_time <time>

Total simulation time of MD production in [ns].

MD_prod_batch_template <ﬁle>

no_of_rec_residues <no.>

restart_ﬁle_for_MDprod <ﬁle>

additional_library <library ﬁle>

additional_frcmod <ﬁle>

MD_batch_path <path>

MDequil_template_folder <folder>

MDprod_template <ﬁle>

784

Absolute path and name of the batch template ﬁle for MD produc-
tion. For an example template ﬁle see examples/input_info/prod.pbs.
Please adapt this ﬁle according to the needs of your queuing system, but
do not change anything from the section "Fix variables" up to the section
"Re-queue" and ensure that the line for job naming ends with "-N".

Actual number of residues in the receptor structure when all residues in
the receptor are consecutively numbered starting from 1. Structurally
bound ions should be treated as part of the receptor.

Basename of restart ﬁle from equilibration that shall be used as initial
ﬁle for MD production.

Absolute path and name of additional library ﬁle. If your receptor struc-
ture contains non-standard residues or ions, an AMBER library ﬁle for
these residues / ions needs to be provided here.

Absolute path and name of additional parameter ﬁle. If your receptor
structure contains residues or ions for which no parameters are available
in the ff12SB force ﬁeld, a parameter ﬁle in which the missing parame-
ters are deﬁned needs to be provided here.

If the simulations need to be conducted on another system / machine
than the one used for setup, the <output_path> during the simulations
may differ from the one used for setup. If this is the case, please specify
here the basis directory for the MD simulations. If no path is deﬁned, it
is assumed that the path is equal to <output_path>.

Absolute path to the folder containing the template ﬁles for equilibration.
All ﬁles provided in this folder will be considered for equilibration setup.
Example equilibration ﬁles that will be used per default can be found
under examples/input_info/equi. If you change the template ﬁles or
create additional ﬁles, please keep the format for the deﬁnition of the
residues that shall be restraint.

Please specify the absolute path and name of the template ﬁle for pro-
duction run.
In this ﬁle all the ﬂags you would like to use in your
MD simulation should be set according to the sander | PMEMD deﬁ-
nitions. The assignment should have the form ﬂag = <value>, and in-
dividual ﬂags should be separated by commas. For an example ﬁle see
examples/input_info/MD_prod.in. Per default this ﬁle will be used as
template if no template ﬁle is speciﬁed.

water_model TIP3P | OPC

Water model that shall be used for the MD simulations. Currently the
water models TIP3P and OPC are available.

35.3. Common setup of molecular dynamics simulations

Additional parameters for setup of MD simulations with explicit membrane

prepare_membrane 0 | 1

use_lipid14_ff 0 | 1

use_gaff_lipid_ff 0 | 1

restrain_membrane_residues <no.>

Optional: Request setup of MD simulation with explicit membrane. De-
fault = 0.

If set to 1, the Lipid14 force ﬁeld will be used for the lipids in the explicit
membrane simulation. In case a setup of a MD simulation with explicit
membrane is requested (prepare_membrane=1) although use_lipid14_ff
is not speciﬁed or use_lipid14_ff=0 and use_gaff_lipid_ff=0, then
use_lipid14_ff is set to 1 per default.

If use_gaff_lipid_ff=1 parameters from the GaffLipid force ﬁeld will
be used. Please note that in this case library and parameter ﬁles
for the lipids need to be provided under additional_library and
additional_frcmod ﬁle (see above). These ﬁles can be obtained from
the Lipidbook repository at http://lipidbook.bioch.ox.ac.uk [695].

Membrane residues that shall be restrained during the equilibration
phase of the MD simulations. This parameter needs only to be provided
if prepare_membrane=1. Attention: The number of membrane residues
differs from the number of lipids if the Lipid14 force ﬁeld is used. In
this case usually residue number = 3 × lipid number. Default = 0.

785

35. FEW

Figure 35.3.: Directory structure and ﬁles created during the common MD setup step of FEW.

35.4. Workﬂow for automated MM-PBSA & MM-GBSA calculations

(WAMM)

The module WAMM allows to calculate binding free energies of ligands according to four ﬂavors of the
Molecular Mechanics Poisson-Boltzmann Surface Area (MM-PBSA) approach and three types of the Molecular
Mechanics Generalized Born Surface Area (MM-GBSA) approach. All energies are calculated based on confor-
mational ensembles generated by MD simulations that have been conducted using the common MD setup func-
tionality of FEW (Section 35.3). An overview of the available binding free energy calculation options is given
in Table 35.4. All binding free energy calculation methods except method PB2 can be applied to the 1- and the
3-trajectory approach. PB2 can only be used in conjunction with the 3-trajectory approach. Residue-wise and
pair-wise decomposition of the effective energy (decomposition keyword) is currently only possible with PB=4 &
GB=1. The solvent accessible surface area is calculated according to the ICOSA method in this case.

The availability of trajectories from MD productions for the complex (1-trajectory approach) or for com-
plex, receptor, and ligand (3-trajectory approach) is prerequisite for the setup of free energy calculations
according to the MM-PBSA / MM-GBSA method. These trajectories should be prepared with the MD
setup functionality of FEW (cf.
section 35.3). Example ﬁles for WAMM analysis setup can be found in
$AMBERHOME/AmberTools/src/FEW/examples/command_files/MMPBSA. Besides the common section for input / out-
put directories and format deﬁnitions, the WAMM module considers several speciﬁc ﬂags (see below). An
overview of the folder structure created by the MM-PB(GB)SA workfow is shown in Figure 35.4.

786

output_pathfolder1structsFolder(cid:3)containing(cid:3)the(cid:3)ligand(cid:3)structures(cid:3)in(cid:3)mol2(cid:882)format.(cid:3)All(cid:3)structures(cid:3)provided(cid:3)in(cid:3)this(cid:3)folder(cid:3)are(cid:3)automatically(cid:3)regarded(cid:3)in(cid:3)the(cid:3)calculation(cid:3)setup.(cid:3)2<Ligand(cid:3)name><Lid>gaussInput(cid:3)and(cid:3)output(cid:3)files(cid:3)of(cid:3)ESP(cid:3)calculation(cid:3)with(cid:3)the(cid:3)program(cid:3)Gaussian2…<Ligand(cid:3)name><Ligand(cid:3)name><Ligand(cid:3)name>leapLibrary(cid:3)and(cid:3)parameter(cid:3)files(cid:3)&(cid:3)PDB(cid:3)files(cid:3)prepared(cid:3)for(cid:3)complex,(cid:3)receptor(cid:3)and(cid:3)ligand…g3<Ligand(cid:3)name><Ligand(cid:3)name>MD_<charge(cid:3)method>crystequiStructure(cid:3)related(cid:3)informationEquilibration(cid:3)fl…equiprodinput(cid:3)filesMD(cid:3)production(cid:3)input(cid:3)files35.4. Workﬂow for automated MM-PBSA & MM-GBSA calculations (WAMM)

Table 35.4.: Overview of ﬂavors of MM-PBSA and MM-GBSA calculation procedures available in the WAMM

module.

Alias

Radii 1)

Calculation of polar

solvation energy

Method for calculation of the non-polar

solvation energy

GB1

GB2

GB5

GB6

PB1

PB2

PB3

PB4

mbondi [198]

mbondi2 [182]

mbondi2 [182]

bondi

Tan&Luo +

mbondi6) [198, 236]

Tan&Luo +

mbondi6) [198, 236]

Parse [202]

mbondi [198]

dec 11) mbondi [198]

GB HTC

[185, 196, 198]

GBOBCmodel I [182]
GBOBCmodel II [182]
GBNSR6 [696], 5.1

PBSA7)

Hybrid

PBSA9) [697]
PBSA7)
PBSA7)
PBSA7)+

GBHTC [185, 196, 198]

SASA2)

Enonpolar

3)

γ4)

b5)

LCPO [170]

γ SASA + b

0.00720

0.0000

LCPO [170]

LCPO [170]

GBNSR6

PBSA8) [221]

Molsurf [655]

+ PBSA

Molsurf [655]

Molsurf [655]

γ SASA + b
γ SASA + b
γ SASA + b
γ SASA + b
+ Edispersion.
γ MSA + b
10)
+ EvdW
γ SASA + b
γ SASA + b

0.00500

0.00500

0.00500

0.0000

0.0000

0.0000

0.03780

- 0.5692

0.06900

0.00542

0.00720

0.0000

0.9200

0.0000

ICOSA 12)

γ SASA + b

0.00720

0.0000

1) Radii used for the calculation of the polar solvation free energy.
2) Program or method used for the calculation of the solvent accessible surface area
3) Equation used for the calculation of the nonpolar part of the solvation free energy
4) Surface tension (SURFTEN) term in MM-PBSA / MM-GBSA calculations
5) Offset (SURFOFF) term in MM-PBSA / MM-GBSA calculations
6) Tan&Luo radii for the protein and mbondi radii for the ligand (per default). Radii optimized according to Tan&Luo [236] can be

provided in the topology ﬁle and will then be regarded in the calculation setup.

7) Calculations are conducted with the PBSA module using the “Modiﬁed Incomplete Choleski Conjugate Gradient”

Poisson-Boltzmann solver.

8) Edispersion is calculated by a numerical determination of the solvent accessible surface area.
9) Hybrid solvent MM-PBSA calculation according to Metz & Gohlke 2006. Please refer to the respective mm_pbsa.pl execution

example provided in Amber 14 for a detailed explanation of the results and their correct interpretation.

10) The nonpolar solvation free energy is calculated as the sum of the cavity free energy γ MSA + b (where MSA = molecular surface

area) and the van der Waals interaction energy between solute and solvent atoms.

11) Decomposition of effective binding free energies requested by the decomposition option.
12) SASA is calculated by a recursive approximation of a sphere around an atom, starting from an icosahedron.

Speciﬁcation of input / output directories and formats

lig_struct_path <path>

Path to folder containing the ligand structures. All ligand structures should now be
available in mol2 format, since the conversion should have been carried out in the
MD simulation preparation step.

output_path <path>

Path to the basic output directory. This path should be identical to the <output_path>
speciﬁed in the common MD setup step.

water_in_rec 0 | 1

Set to 1 if crystal water molecules were present in the receptor structure used for MD
simulation setup.

General parameters for MM-PBSA / MM-GBSA calculation setup

mmpbsa_calc 0 | 1

Request setup of ﬁles for MM-PBSA or MM-GBSA calculations.

787

35. FEW

1_or_3_traj 1 | 3

charge_method am1 | resp

additional_library <ﬁle>

additional_frcmod <ﬁle>

mmpbsa_pl <ﬁle>

Speciﬁcation of
1-trajectory approach:
traj_setup_method=1 in the MD setup step.
Requires trajectories of
traj_setup_method=3 in the MD setup step.

the method that shall be used for calculation setup.
Requires complex trajectories prepared using
3-trajectory approach:
receptor, and complex prepared with

ligand,

Charge method that shall be used for the calculations. MD trajectories in which
the corresponding charge method was employed for the ligand need to be avail-
able. See section 35.3 on how to setup the MD simulations.

Optional: Absolute path and name of additional library ﬁle. Such a library ﬁle
is only required if the receptor structure contains non-standard residues.

Optional: Absolute path and name of additional parameter ﬁle. Such a ﬁle is
only needed, if not all parameters required to describe the receptor are available
in the ff12SB force ﬁeld.

Absolute path and name of mm_pbsa.pl executable that shall be used for the
calculations. Also a path relative to the AMBERHOME directory can be spec-
iﬁed. Note that in the latter case the AMBERHOME variable needs to be set
in the mmpbsa_batch_template batch template script. Per default it is assumed
that mm_pbsa.pl can be called by $AMBERHOME/bin/mm_pbsa.pl

Snapshot extraction

extract_snapshots 0 | 1

Request coordinate extraction.

ﬁrst_snapshot <number>

last_snapshot <number>

Number of the ﬁrst structure that shall be extracted. Please consider that
<number> is equivalent to the sum of the number of the structure in the cor-
responding trajectory and the number of structures present in all trajectories
read in before.

Number of last structure that shall be extracted. Please consider that <num-
ber> is equivalent to the sum of the number of the structure in the correspond-
ing trajectory and the number of structures present in all trajectories read in
before.

offset_snapshots <number>

Frequency of snapshot extraction. Every <number>th structure will be ex-
tracted from the trajectory.

trajectory_ﬁles all | <ﬁle>

snap_extract_template <ﬁle>

image_trajectories 1 | 0

788

Trajectory that shall be considered in snapshot extraction. For a consistent
numbering and addressing of the snapshots request consideration of all tra-
jectories by specifying all. The interval from which snapshots shall be
extracted can be deﬁned via the ﬂags first_snapshot, last_snapshot, and
offset_snapshots. If individual trajectories shall be used, specify each tra-
jectory ﬁle in a separate line starting with the ﬂag trajectory_files. Default
= all.

Optional: Absolute path and name of input-ﬁle for mm_pbsa.pl that shall be
used for coordinate extraction. If no ﬁle is speciﬁed, it is assumed that the
default ﬁle examples/input_info/extract_snaps.in shall be used.

If set to 1, snapshots of the speciﬁed trajectories will be imaged to the origin
before coordinate extraction. It is strongly recommended to use this option
for all MM-PBSA / MM-GBSA calculations. Attention: Imaging may require
a large amount of additional disk space. Default = 1.

35.4. Workﬂow for automated MM-PBSA & MM-GBSA calculations (WAMM)

use_imaged_trajectories 1 | 0

image_mass_origin 1 | 0

MM-PBSA / MM-GBSA Analysis

PB 0 | 1 | 2 | 3 | 4

GB 0 | 1 | 2 | 5 | 6

decomposition 0 | 1 | 2 | 3 | 4

If imaged trajectories were generated in a previous FEW run, then these will
be re-used for snapshot extraction if use_imaged_trajectories=1. In case im-
aged trajectories already exist and use_imaged_trajectories=0 the existing
trajectories will be renamed and new imaged trajectories will be generated
from which then snapshots are extracted. Default = 1.

Optional: If set to 1, the receptor is imaged relative to the mass origin instead
of the coordinate origin. Switching this ﬂag on ensures compartibility of the
imaging procedure with the one of the Amber FEW version. Default = 0.

Type of Poisson-Boltzmann calculation (cf. Table 35.4 for an overview
of the available calculation options). Please consider that only PB and
GB methods requiring the same radii can be run together, i.e. PB=4 and
GB=1. All other PB methods can only be run with GB=0.

Type of generalized Born calculation (cf. Table 35.4 for an overview of
the available calculation options).

If larger than 0 energy decomposition of the speciﬁed type is performed
(cf. idecomp in Chapter 19 for decomposition options). Decomposition
only works with PB=4 and GB=1.

no_of_rec_residues <number>

Actual number of residues in the receptor structure.

total_no_of_intervals <number>

Total number of intervals that shall be analyzed. Please note that specify-
ing more than one interval is only reasonable, if different offsets between
structures shall be considered. Otherwise the energies for subsets of the
analyzed snapshots can be calculated using the mm_pbsa_statistics.pl
script provided in AMBER. Default = 1.

ﬁrst_PB_snapshot <number>

Number of the ﬁrst structure to be considered in the analysis.

last_PB_snapshot <number>

Number of the last structure to be considered in the analysis.

offset_PB_snapshots <number>

mmpbsa_batch_template <ﬁle>

mmpbsa_batch_path <path>

mmpbsa_sander_exe <ﬁle>

parallel_mmpbsa_calc <number>

Offset between structures that shall be considered in the MM-PBSA /
MM-GBSA analysis. Every <number>th snapshot will be taken into ac-
count.

Absolute path and name of batch template ﬁle for the MM-PBSA / MM-
GBSA calculations. Example ﬁle: examples/input_info/MMPBSA.pbs.
Please adjust the template according to your computing environment,
but keep everything from the section "Prepare calculation" onward and
ensure that the line for job naming ends with "-N". The ﬁles generated
during the calculation will be temporarily stored in the /tmp folder of the
machine used for the calculation. Thus, not more than one node should
be used per calculation.

Optional: If the calculations shall be conducted using a different path
than the one used for setup, this path can be speciﬁed here. In case no
path is given the <output_path> will be used.

Optional: Absolute path and name of sander executable that shall be
used instead of the default executable in $AMBERHOME/bin

Number of processors to use in parallel run. This ﬂag sets the PARAL-
LEL ﬂag in the mmpbsa.in ﬁle, i.e. <number> of threads will be run.
Default = 1 (serial).

789

35. FEW

mmpbsa_template <ﬁle>

Optional: Absolute path and name of the input ﬁle for mm_pbsa.pl that
shall be used for the MM-PBSA / MM-GBSA calculations. If no ﬁle is
speciﬁed, the default ﬁle located under examples/input_info/mmpbsa.in
is taken.
The default ﬁle can be modiﬁed by expert users, but
only the following parameters may be changed: VERBOSE, DIELC,
INDI, EXDI, SCALE, LINIT, ISTRNG, SALTCON, INTDIEL, and/or
EXTDIEL.

Parameters for MM-PBSA calculations with implicit membrane

Implicit membrane MM-PBSA calculations are currently only possible if the Adaptive Poisson-Boltzmann Solver
APBS [698–702] is installed on the system where the calculations shall be performed. Furthermore exclu-
sively the combination PB=3, i.e. Poisson-Boltzmann calculation with Parse radii [202], and GB=0, i.e. no gen-
eralized Born calculation, is available (see options for PB and GB above).
In addition, in order to avoid path
inconsistencies, the setup of the calculations should be conducted with FEW on the same system were the
calculations shall be run. The MM-PBSA calculations with implicit membrane are carried out with the Perl
script $AMBERHOME/AmberTools/src/FEW/miscellaneous/mmpbsa_FEWmem.pl. For the calculations also the ﬁles
apbs_mem_dummy.in and apbs_mem_solv.in or apbs_mem_dummy_focus.in and apbs_mem_solv_focus.in provided
in the miscellaneous directory are required. Therefore the path of the FEW version used for the setup of the calcu-
lations should not differ from the path under which FEW can be found during the calculations. The parameters for
the implicit membrane can be selected and tested with APBSmem (http://apbsmem.sourceforge.net) [703]. If you
use the implicit solvent, implicit membrane MM-PBSA calculation functionality of FEW please cite APBS [698]
as well as draw_membrane2 [704] and the extension of FEW for handling membrane systems [705].

membrane_residue_no <number>

implicit_membrane 1 | 0

Number of residues in the explicit membrane present in the MD simula-
tion that serves as basis for the MM-PBSA calculation. Please consider
all residues that are part of the membrane and not only the number of
lipids. In the Lipid14 force ﬁeld for example the lipids are split into
head and tail groups, which are treated as separate residues.

If set to 1, an implicit membrane is considered in the MM-PBSA calcu-
lation, i.e. the system is embedded in an membrane slab with a lower
dielectric constant than water.

apbs_executable 1 | 0

Full path to APBS executable, e.g. /home/Software/iAPBS/bin/apbs.

epsilon_solute 1 | 0

bottom_membrane_boundary <no.>

membrane_thickness <no.>

790

Dielectric constant of the solute, i.e. the protein and the ligand, in the
MM-PBSA calculation. Please note, that the variable DIELC in the tem-
plate input script for mm_pbsa.pl speciﬁed under mmpbsa_template needs
to be set to the same dielectric constant to ensure that the calculated
molecular mechanics electrostatic energies are scaled by the same con-
stant.

Lower boundary of the membrane slab relative to the coordinate origin
in [Å]. If more than one slab region is deﬁned please give the lower
boundary of the slab that is farthest away from the origin, see Figure
35.5. Default = -18 Å.

Thickness of the implicit membrane slab in [Å]. If a membrane slab
with different slab regions is deﬁned, please specify the thickness of the
complete slab including all sub-slabs, see Figure 35.5. Default = 36 Å.

membrane_dielc <no.>

second_slab_thickness <no.>

second_slab_dielc <no.>

third_slab_thickness <no.>

third_slab_dielc <no.>

35.4. Workﬂow for automated MM-PBSA & MM-GBSA calculations (WAMM)

Dielectric constant of the implicit membrane slab. If a multi-slab mem-
brane is constructed, this is the dielectric constant of the central mem-
brane slab closest to the coordinate origin, see Figure 35.5. Default =
2.

Optional: Thickness of a second slab region ﬂanking the central slab on
both sides. This slab can e.g. be used to model the properties in the
region of or close to the lipid head groups. Please not that the thickness
of the central slab deﬁned under membrane_thickness decreases by 2 ×
second_slab_thickness, see Figure 35.5.

Optional: Dielectric constant of the two second implicit membrane slab
regions above and below the central membrane slab (Figure 35.5). This
dielectric constant is usually larger than membrane_dielc to describe the
properties in the region of or close to the lipid head groups. For a dis-
cussion of the complex electrostatic properties of a lipid bilayer see e.g.
[706][707].

Optional: Thickness of a third slab region located between the cen-
tral slab and the second slab on both sides of the central slab (Figure
35.5). Please not that the thickness of the central slab deﬁned under
membrane_thickness decreases by (2 × second_slab_thickness) + (2 ×
third_slab_thickness), see Figure 35.5.

Optional: Dielectric constant of the third implicit membrane slab region
sandwitched between the second slab region and the central slab on both
sides of the central slab (Figure 35.5). This dielectric constant is usually
larger than membrane_dielc to describe the properties of the membrane
region close to the membrane surface. For a discussion of the complex
electrostatic properties of a lipid bilayer see e.g. [706][707].

ion_concentration <no.>

Concentration of ions, i.e. salt, that shall be considered in the Poisson-
Boltzmann calculation. Default = 0.15 M.

upper_exclusion_radius <no.>

Upper exclusion radius in [Å]. See [703] and Figure 35.5.

lower_exclusion_radius <no.>

Lower exclusion radius in [Å]. See [703] and Figure 35.5.

do_focussing 1 | 0

size_large_grid <no.>

size_medium_grid <no.>

In such
Perform a three step APBS focussing calculation.
a calculation three successive calculations are performed starting
from a large grid followed by focussing using smaller grids, see
http://www.poissonboltzmann.org. Default: 0.

Optional: Size of the largest grid in the focussing calculation in [Å].
This is only considered if do_focussing=1. Please choose the size of
the grids such that even the smallest grid (size_small_grid) completely
comprises the membrane slab in the direction orthogonal to the plane of
the membrane slab. Default = 300 Å.

Optional: Size of medium grid in the focussing calculation in [Å]. This
is only considered if do_focussing=1. Please choose the size of the grid
such that even the smallest grid (size_small_grid) completely com-
prises the membrane slab in the direction orthogonal to the plane of the
membrane slab. Default = 200 Å.

791

35. FEW

size_small_grid <no.>

grid_dimensions <no.>

Size of the grid, if do_focussing=0, or size of the smallest grid, if
do_focussing=1, in [Å]. Please choose the size of the grids such that
it completely comprises the membrane slab in the direction orthogonal
to the plane of the membrane slab. Default = 100 Å..

Number of grid points in each dimension, i.e.
x, y, and z direc-
tions, of the grid. Valid values are 97, 129, and 161. Defaults: If
do_focussing=0 then grid_dimensions=161 and if do_focussing=1 then
grid_dimensions=97.

Figure 35.4.: Folder structure and ﬁles created during setup of MM-PB/GBSA calculations.

Figure 35.5.: Parameters for deﬁnition of implicit membrane in MM-PBSA calculations.

792

output_pathfoldercalc<r|a><x>t<Ligandname>x<Ligand(cid:3)name>calc_<r|a>_<x>t<Ligand(cid:3)name>…xqsub_s_<start>_<end>_<offset>_pb<no.>_gb<no.>.sh(cid:159)Script(cid:3)for(cid:3)submission(cid:3)of(cid:3)MM(cid:882)PBSA(cid:3)/(cid:3)MM(cid:882)GBSA(cid:3)jobsxsnapshotsFolder(cid:3)with(cid:3)snapshots(cid:3)extracted(cid:3)from(cid:3)MD(cid:3)trajectoriestopos<start><end><offset>PB<no>GB<no>Input(cid:3)and(cid:3)Folder(cid:3)containing(cid:3)topology(cid:3)files(cid:3)for(cid:3)MM(cid:882)PBSA(cid:3)&(cid:3)MM(cid:882)GBSA…s_<start>_<end>_<offset>PB<no.>_GB<no.>output(cid:3)files(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)of(cid:3)MM(cid:882)PBSA(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)and(cid:3)/(cid:3)orMM(cid:882)GBSA(cid:3)llPB<no.>_GB<no.>s_<start>_<end>_<offset>…calculations.…membrane_dielc second_slab_dielc third_slab_dielc membrane_thickness bottom_membrane_boundary second_slab_thickness thrid_slab_thickness upper_exclusion_radius lower_exclusion_radius 35.4. Workﬂow for automated MM-PBSA & MM-GBSA calculations (WAMM)

MM-PBSA calculation of a protein-protein complex in the membrane

The protein-protein option is an extension of the implicit membrane MM-PBSA functionality in FEW, which
allows the identiﬁcation of important residues in protein-protein interactions for membrane proteins[708]. MM-
PBSA energies can be calculated between two proteins/peptides on a global or per-residue basis from MD trajecto-
ries of the protein-protein complex in an explicit membrane. Currently, only post-processing of existing trajectories
is supported (mmpbsa_calc=1) in a 1-trajectory approach (1_or_3_traj=1). Requirements for system preparation
and input parameter choice are the same as for general MM-PBSA calculations with implicit membrane in FEW
(see above). The input trajectories have to be speciﬁed explicitly with trajectory_files and results are saved in
a new directory “calc_p_1t” within the directory speciﬁed by output_path. Per-residue decomposition of energies
can be requested with the decomposition option (1 or 2 available only). Since the nonpolar part of the solvation
free energy is proportional to the SASA in the model used here, this assumption is not true for residues located
inside the membrane. To account for this, it is recommended to use the option nonpolar_solv=1, which treats all
residues located in the implict membrane as having a SASA of 0 Å2. It is recommended to use the default APBS
input templates provided with FEW with do_focussing=1 and to check if the grid dimensions are large enough to
account for the protein-protein complex.

protein_protein 1 | 0

protein_protein_com <ﬁle>

protein1_res_range <no.-no.>

protein2_res_range <no.-no.>

nonpolar_solv 1 | 0

Postprocessing:

If set to 1, do MM-PBSA calculations of a protein-protein complex in a
membrane system.

Path to pdb ﬁle of protein-protein complex in explicit membrane needed
for protein-protein MMPBSA. This should be the pdb ﬁle which was
created during system setup for MD simulation with LEaP. It is supposed
to contain the proteins, lipids and water.

Starting and ending residue numbers of the ﬁrst protein in the protein-
protein complex.

Starting and ending residue numbers of the second protein in the protein-
protein complex.

to 1, change SASA to 0 Å2 for all residues inside the
If set
membrane. Membrane is deﬁned with "membrane_thickness" and
"bottom_membrane_boundary".

If MM-PBSA or MM-GBSA calculations without decomposition were conducted for several ligands, the bind-
ing free energies and important energetic contributions can be extracted from the <ligand>_statistics.out ﬁles
created by mm_pbsa.pl using the script .../FEW/miscellaneous/extract_WAMMenergies.pl.

Usage:

perl

extract_WAMMenergies.pl <structure ﬁle> <path> pb<no.>_gb<no.> <Start>_<Stop>_<Offset>

structure ﬁle

path

pb<no.>_gb<no.>

<Start>_<Stop>_<Offset>

Text ﬁle containing names of ligands for which energies shall be extracted;
one name per line.

Path to directory containing MM-PBSA or MM-GBSA results, e.g.,
/home/<user>/work_dir/calc_r_1t.

FEW internal number of type of MM-PBSA / MM-GBSA calculation; see
Table 35.4. The script can be used for all types of implicit solvent calculations
available in FEW, except the hybrid model (PB2) and decomposition (dec).

Snapshots taken into account in the MM-PBSA / MM-GBSA calculations;
see ﬂags first_PB_snapshot, last_PB_snapshot, and offset_PB_snapshots
in the “MM-PBSA / MM-GBSA Analysis” section above.

793

35. FEW

A ﬁle called pb<no.>_gb<no.>.txt will be created in the current working directory. In this ﬁle the electrostic (ELE),
van der Waals (VDW), nonpolar solvation (NP_SOLV), and polar solvation (P_SOLV) energy contributions to
binding as well as the total binding free energy (ETOT) are listed for each ligand.

35.5. Linear interaction energy workﬂow (LIEW)

The LIE workﬂow enables energy calculations according to the linear interaction energy approach introduced
by Åquist et al. [709] and was applied in numerous ligand binding afﬁnity studies [710–712]. In this approach the
changes upon complex formation in the electrostatic and the van der Waals interaction energy between a ligand
and its surrounding environment are calculated based on MD simulations of the receptor bound ligand and of the
ligand in solution. The binding free energy is estimated by combining differences in the electrostatic and van der
Waals interaction energies in a linear equation with the coefﬁcients α and β and possibly a constant term γ.

(cid:16)

(cid:17)

(cid:16)

(cid:17)

(cid:52)ELIE = β

bound − Eele
Eele

f ree

+ α

bound − EvdW
EvdW

f ree

+ γ

Commonly β is set to 0.5. However, several alternative strategies for selecting the coefﬁcients and γ exist
[710, 713, 714]. Furthermore it has been proposed to consider the difference in solvent accessible surface area
between the bound and the free state of the ligand in the calculation of the binding free energy [715, 716].

(cid:16)

(cid:17)

(cid:16)

(cid:17)

(cid:52)ELIE = β

bound − Eele
Eele

f ree

+ α

bound − EvdW
EvdW

f ree

+ γ (SASAbound − SASA f ree)

With the LIE workﬂow it is possible to setup the required MD simulations and to calculate the electrostatic and
van der Waals interaction energy contributions as well as the solvent accessible surface area based on snapshots
from the MD simulations by an automated procedure. This enables a fast calculation of the energy components
needed for a LIE analysis, making energetic calculations for multiple ligands feasible. The computed energies can
be used to construct a LIE model employing a (multiple) linear regression analysis.

The MD simulations can be conducted with sander or PMEMD of Amber. Electrostatic and van der Waals

interaction energies of the ligand based on snapshots from the MD simulations are calculated with sander.

MD simulations for LIE analysis can be prepared using the common MD setup functionality of FEW described
in section 35.3. Only MD setups according to the 3-trajectory approach are possible when the LIE procedure is
requested. The receptor part of the 3-trajectory approach will automatically be neglected such that only ﬁles for
the two simulations required for LIE analysis are generated. Thus, internally a 2-trajectory approach is prepared.
The availability of output/trajectory-ﬁles of simulations of the receptor bound ligand and of the ligand free in
solution in the folders created by the MD setup procedure of FEW is a prerequisite for the energetic calculations. As
for all FEW setup procedures, the command ﬁle for the energetic calculations according to the LIE approach needs
to contain the ﬂags specifying the input and output directories and formats (see section 35.3 "Common setup of
molecular dynamics simulations" for a detailed explanation) as well as procedure speciﬁc ﬂags. Example command
ﬁles for LIE calculation setup are provided in $AMBERHOME/AmberTools/src/FEW/examples/command_files/LIE. An
overview of the folder structure created by the LIE workﬂow is shown in Figure 35.6.

Speciﬁcation of input / output directories and formats

lig_struct_path <path>

Path to folder containing the ligand structures. All ligand structures should be
available as single structure mol2 ﬁles, because the format conversion should
have been carried out in the preparatory step.

output_path <path>

Path to the basis output directory. This path needs to be identical to the
<output_path> speciﬁed in the common MD setup step.

794

35.5. Linear interaction energy workﬂow (LIEW)

water_in_rec 0 | 1

Set to 1 if crystal water molecules were present in the receptor structure used
for MD simulation setup.

General parameters for LIE calculations

lie_calc 0 | 1

Request setup of LIE calculations.

charge_method am1 | resp Charge method that shall be considered for LIE analyses. Trajectories of MD
simulations with corresponding atomic charges for the ligand need to be available.
The generation of the ﬁles required for these simulations is described in section
35.3.

no_of_rec_residues <number> Actual number of residues in the receptor structure.

additional_library <ﬁle>

Optional: Absolute path and name of additional library ﬁle. Such a library ﬁle is
only required if the receptor structure contains non-standard residues.

additional_frcmod <ﬁle>

Optional: Absolute path and name of additional parameter ﬁle. Such a parameter
ﬁle is only required if not all parameters that are needed to describe the receptor
are available in the ff12SB force ﬁeld.

lie_executable <executable> Optional: Absolute path and name of

the LIE.pl program for calcula-
tion of interaction energies according to the LIE approach, which is dis-
tributed with FEW.
is assumed that
the default path and name at
the LIE program can be found under
$AMBERHOME/AmberTools/src/FEW/miscellaneous/LIE.pl

If no executable is speciﬁed,

it

lie_batch_template <ﬁle>

lie_batch_path <path>

Snapshot extraction

Absolute path and name of batch ﬁle for LIE analysis. An example ﬁle can be
found under exmaples/input_info/lie.pbs. Please adapt the batch ﬁle according
to the requirements of your queuing system, but do not change anything from the
"Prepare calculation" section onward and ensure that the line for job naming ends
with "-N".

Optional: Path that shall be used instead of the <output_path> for the setup of
batch ﬁle. This information is only required if the LIE analysis shall be run under
a different path than the setup.

snaps_per_trajectory <number> Number of snapshots per trajectory. If more than one trajectory ﬁle is pro-

vided, all trajectory ﬁles need to contain the same number of snapshots.

image_trajectories 1 | 0

trajectory_ﬁles all | <ﬁle>

If set to 1, the structures will be imaged to the origin before coordinates are
extracted. This is strongly recommended. However, please regard that imaging
may consume a large amount of disk space, since new trajectories with imaged
structures are created. Default=1.

Trajectory ﬁles that shall be regarded. For a consistent numbering of the snap-
shots it is strongly recommended to consider all trajectories that have been
generated by specifying all. Subsets of snapshots that shall be considered in
the energy calculation can be selected by the parameters first_lie_snapshot,
last_lie_snapshot, and offset_lie_snapshots. Individual trajectory ﬁles can
be selected by specifying their ﬁle name (without the path). Each ﬁle that shall
be considered must be speciﬁed in a separate line starting with the keyword
trajectory_files. Default = all.

795

35. FEW

LIE Analysis

ﬁrst_lie_snapshot <number>

No. of ﬁrst snapshot that shall be regarded in the energy calculation.

last_lie_snapshot <number>

No. of last snapshot that shall be regarded in the energy calculation.

offset_lie_snapshots <number>

Offset between snapshots that shall be regarded in the energy calcula-
tion. Every <number>th snapshot will be considered.

calc_sasa 0 | 1

Request calculation of solvent accessible surface area. Default = 0.

sander_executable <executable>

parallel_lie_call <call>

delete_lie_trajectories 0 | 1

Optional: Absolute path and name of sander executable that shall be
used for the energy calculation if not the default application under $AM-
BERHOME/bin shall be employed.

The calculations can be conducted using a parallel version of sander. If
you would like to start a parallel job, please specify the call required for
starting a parallel execution of sander on your system here, e.g.: mpirun
-np 2. Prerequisite for parallel execution: Parallel version of sander
available.

As storing the coordinates of the structures in a form speciﬁcally
required for LIE analyzes can consume a large amount of disk
space, it can be advantageous to only temporarily create them.
If
delete_lie_trajectories is set to 1, the trajectories for LIE analyzes
are deleted directly after the energy calculations.

Figure 35.6.: Folder structure and ﬁles created during the setup of LIE calculations. For reasons of clarity
first_lie_snapshot, last_lie_snapshot, and offset_lie_snapshots were replaced by aliases F,
L, and O.

796

output_path folderlie_<charge method><Ligand name>x<Ligand name>…qsubLIEshScriptforsubmissionofLIEjobsqsub_LIE.sh    Script for submission of LIE jobsxcomtopoTopologiesenergycalcins_tots_ligTopologiesSnapshotsOutput from energycalculationenergy_calc.inAutomatically created command file for energy calculationscom_<vdW|ele>_<F>_<L>_<O>.txts_restopoenergy calculationvdW or electrostatic energy per complex snapshotlig_<vdW|ele>_<F>_<L>_<O>.txtvdWorelectrostaticenergypers_comener_totener_ligs_tots_ligvdW or electrostatic energy per ligand snapshotLIE_s<F>_<L>_<O>.datFile containing final resultsener_ress_watener_totgligener_ligener_wat35.6. Thermodynamic integration workﬂow (TIW)

Postprocessing:

If LIE analyzes were conducted for several
the differences in electrostatic and vdW in-
teraction energies can be extracted from the LIE_s<first>_<last>_<offset>.txt ﬁles using the script
$AMBERHOME/AmberTools/src/FEW/miscellaneous/extract_LIEenergies.pl.

ligands,

Usage:

perl extract_LIEenergies.pl <structure file> <path> <name of LIE output file>

structure ﬁle

Text ﬁle containing the names of the ligands that shall be considered (one lig-
and per line) and experimentally measured IC50 or Ki or binding free energies
in tab-separated format.

Example:

#Ligands dG
Lig_5
Lig_17

-0.5394
-1.3409

path

name of LIE output ﬁle

Path
/home/<user>/work_dir/lie_am1.

directory

to

containing

the

LIE

results,

e.g.

of

the ﬁnal

result ﬁle

Name
LIE_<first>_<last>_<offset>.txt,
<offset> are equivalent
<X>_lie_snapshot(s) keywords described above.

i.e.
<first>, <last>, and
to the values selected for the corresponding

the LIE calculations,

where

of

A ﬁle called LIE_results.txt will be created in the current working directory. In this ﬁle, besides the ligand name
and the binding afﬁnity value provided in the <structure file>, the differences in electrostatic (ELE) and van der
Waals (VDW) interaction energies and the difference in solvent accessible surface area between the bound and the
free state are listed. The ﬁle can be used directly to derive a linear model by a (multiple) linear regression analysis.

35.6. Thermodynamic integration workﬂow (TIW)

The TI workﬂow enables a fast setup of transformation simulations between two ligands for the determination
of the difference in free energy of binding according to the thermodynamic integration approach. Transformation
simulations are prepared employing the one step, soft core option provided in AMBER. For a detailed description
of the method see Section 23.1. Prerequisite for conducting the TI calculation setup with FEW is a parallel
installation of the program sander of AMBER.

Transformation simulations can either be started from provided structures or from structures that have been
pre-equilibrated with FEW. Equilibrated structures of complex and ligand can be prepared using the common MD
setup functionality of FEW. See section 35.3 for details on how to prepare the ﬁles for minimization and equilibra-
tion. Alternatively, the TI setup can be requested based on coordinate and topology ﬁles generated from a crystal
structure or from other sources. This option can be valuable in cases where high resolution crystal structures are
available for the receptor bound state of both the initial (V0) and the ﬁnal (V1) ligand and these show only marginal
differences with respect to the receptor structure. In case user provided structures shall be employed directly it
is necessary to run the common MD setup procedure without providing the ﬂag MDequil_template_folder, in
order to prepare the ﬁles required for the TI calculations. Figure 35.7 illustrates the two setup options and the
corresponding workﬂows.

797

35. FEW

Figure 35.7.: TI workﬂow options: TI based on (A) a structure equilibrated using the MD setup functionality of

FEW or (B) a user provided structure, e.g., a crystal structure.

The TI simulations are separated into a TI equilibration and a TI production phase. Input ﬁles for the latter
can only be prepared when the equilibration simulations have been completed.
In the equilibration phase the
transformation simulations are conducted sequentially for all λ values in ascending order (Figure 35.8), i.e., the
ﬁnal coordinate ﬁle of the equilibration at the smallest λ value serves as input ﬁle for the next larger λ value, and
so on. Thus, only one batch-job for the equilibration needs to be submitted per system.

798

Ligand structureReceptor structureStructure separationCharge calculationPreparation of LEAP input filesSetup of MD (3-trajectory approach)ABPreparation of coordinate and topology filesCreation of input files for equilibrationRunning equilibrationSetup of TI calculationsFinal coordinates of equilibrationCoordinate filesprepared for ligandand complex35.6. Thermodynamic integration workﬂow (TIW)

Figure 35.8.: Internal TI workﬂow of FEW consisting of structure preparation, equilibration simulations, and pro-

duction simulations.

Production simulations are started from equilibrated structures, i.e., from coordinate ﬁles obtained in the equi-
libration phase. Prior to the setup of the production simulations it is checked whether the systems are thoroughly
equilibrated employing a reverse cummulative averaging procedure [717]. The production simulations, which are
prepared when the equilibration check is complete, can be conducted in parallel for all λ values. For each λ value
a separate batch script is generated. Production simulations are run either until a convergence measure, calcu-
lated after each production step, falls below a speciﬁed limit or the total runtime deﬁned in the command ﬁle is
reached. Two alternative convergence criteria are available: (I) The difference between the current standard error
in dV/dλ, determined according to [492], and the one calculated in the previous step. (II) The precision of dV/dλ,
i.e., the expected deviation of the true mean from the sample mean determined based on a student’s distribution at
a conﬁdence level of 95%. How often the convergence is checked depends on the simulation time speciﬁed in the
provided template ﬁle for TI production. A convergence analysis is performed after each production run, and if the
termination criterion is not reached, the next round of TI production is started. Since the calculation of the conver-
gence measures requires the determination of the autocorrelation time in dV/dλ, the number of dV/dλ values that
are written to the sander output ﬁle should be 10 times larger than the autocorrelation time. As the autocorrelation
time is typically in the range of 1 ps [492], it is recommended to request writing of at least 20 dV/dλ values in
the template production ﬁle when a recording interval of 1 ps is used. If the number of dV/dλ values is not larger
than 10 times the autocorrelation time, the simulation procedure is terminated after the ﬁrst production step. The
convergence analysis is handled by the batch script and does not require user intervention.

When the transformation simulations have been completed (cf. Figure 35.9 for created folder structure), the TIW
module of FEW can be used to calculate the difference in free energy of binding between the two studied ligands.
The free energy difference (cid:52)G is calculated by numerical integration over the average dV/dλ values obtained from
the simulations at the individual λ’s, employing the trapezoidal rule. The user can choose whether the commonly
applied linear interpolation to λ=0 and λ=1 shall be conducted (eq. E1) or the boundary area of the dV/dλ curve
shall be neglected (eq. E2).

799

1) Structure preparation:Coordinate and topology files of mol2 files of ligands with ligand and complex in state V0charges for states V0 and V1 Re‐ordering of atoms shifting soft core to the end of the fileGeneration of complex and ligand PDB files of states V0 and V1Library files for states V0 and V1Coordinate and topology files for states V0 and V12A) Sequential equilibration with different ‘s:= 0.2 1.4 ns equilibration Final coordinate file = 0.4 1.4 ns equilibration Final coordinate file = 0.6 1.4 ns equilibration Final coordinate file = 0.8 1.4 ns equilibration Final coordinate file 2B) Parallel production simulations with different ‘s:= 0.2 (Start structure: Final structure from = 0.2 equilibration)=0.4(Startstructure:Finalstructurefrom=0.4equilibration) 0.4 (Start structure: Final structure from  0.4 equilibration)= 0.6 (Start structure: Final structure from = 0.6 equilibration)= 0.8 (Start structure: Final structure from = 0.8 equilibration)  35. FEW

(cid:52)G =(cid:82) 1

0 (cid:104)dV (λ )/dλ(cid:105) dλ (E1)
(cid:52)G = ∑(cid:104)dV (λ )/dλ(cid:105) (cid:52)λ (E2)

Finally the difference in free energy of binding (cid:52)(cid:52)G is calculated by subtracting (cid:52)Gligand calculated based on the
transformation of the ligand free in solution from (cid:52)Gcomplex derived from the transformation within the complex (eq.
E3).

(cid:52)(cid:52)G = (cid:52)Gcomplex −(cid:52)Gligand (E3)

The existence of ﬁles created according to the MD setup for the 3-trajectory approach with FEW is a prereq-
uisite for the execution of the TI workﬂow. Example command ﬁles for TI calculation setup are provided in
$AMBERHOME/AmberTools/src/FEW/examples/command_files/TI.

Speciﬁcation of input / output directories and formats

lig_struct_path <path>

Path to folder containing the ligand structures. All ligand structures should now
be available as single structure mol2 ﬁles because the conversion should have been
carried out in the preparatory step.

output_path <path>

Path to the basis output directory. This path needs to be identical to the
<output_path> speciﬁed in the common MD setup step.

TI simulations
Parameters that have to be speciﬁed and need to be identical in all subsequent TI setup runs for one system:

ti_simulation_setup 0 | 1

Request setup of ﬁles for TI simulation.

charge_method am1 | resp

lig_name_v0_struct <name>

lig_name_v1_struct <name>

lig_alias_v0 <alias>

lig_alias_v1 <alias>

softcore_mask_v0 <mask>

softcore_mask_v1 <mask>

800

Charge method that shall be used for the calculations. MD setup ﬁles
or equilibrated structures generated with the corresponding charge method
need to be available. See section 35.3 on how to generate these ﬁles.

Name of ligand in start state (V0). The name needs to be identical to the
name used for the corresponding structure in the MD setup step, i.e. base-
name of mol2 ﬁle.

Name of ligand in end state (V1). The name needs to be identical to the name
used for the corresponding structure in the MD setup step, i.e. basename of
mol2 ﬁle.

Alias that shall be used for the ligand in the start state (V0). The alias serves,
e.g., as ligand residue name and identiﬁer for the TI simulation ﬁles and must
consist of 3 characters.

Alias that shall be used for the ligand in the end state (V1). The alias serves,
e.g., as ligand residue name and identiﬁer for the TI simulation ﬁles and
must consist of 3 characters.

Soft core mask for state V0 to be used for AMBER "scmask" deﬁnition.
Format: <V0_alias>@<atom>,<atom>,... For details about the format see
Section 23.1.

Soft core mask for V1 to be used for AMBER "scmask" deﬁnition.
Format: <V1_alias>@<atom>,<atom>,... For details about the format see
Section 23.1.

use_pmemd 0 | 1

35.6. Thermodynamic integration workﬂow (TIW)

This parameter speciﬁes with which program TI transformation simulations
shall be performed.
If not provided or set to zero, input ﬁles for Sander
are prepared, whereas when set to 1, input ﬁles for PMEMD are generated.
Input ﬁles for PMEMD can be used to run TI calculations with PMEMD
on CPUs or GPUs. Please consider that in the later case the batch template
script needs to be adjusted so that calculations are started on GPUs and the
CUDA version of PMEMD is used.

The following three steps are done by three consecutive calls of FEW according to Figure 35.3.

1. Creation of coordinate and topology ﬁles

prepare_match_list 0 | 1

prepare_inpcrd_prmtop 0 | 1

lig_inpcrd_v0 <ﬁle>

com_inpcrd_v0 <ﬁle>

lig_prmtop_v0 <ﬁle>

Request setup of match list with atom correspondence information for none
soft-core part of states V0 and V1. The list contains the atom names of corre-
sponding atoms in the two states, in tab-separated format. In case the automatic
matching fails, the list can also be created manually.

Request setup of coordinate and topology ﬁles. The steps needed for prepara-
tion of coordinate and topology ﬁles for start and end states are only carried
out if this ﬂag is set to 1.

Coordinate ﬁle of solvated ligand start structure in coordinate or restart (in-
pcrd, restrt) format. Either the end structure of an equilibration simulation
or a crystal / model structure can be provided. Please regard that in the later
case the structure will be directly subjected to an equilibration MD, without
previous minimization, heating and density adjustment. A signiﬁcant longer
equilibration run will be necessary in this case. Attention: The coordinate ﬁle
must have been prepared with the common MD setup functionality of FEW.

Coordinate ﬁle of the solvated complex start structure either in coordinate or
restart format (cf. lig_inpcrd_v0 ﬂag).

Topology ﬁle of the solvated ligand corresponding to the coordinate ﬁle speci-
ﬁed under lig_inpcrd_v0.

com_prmtop_v0 <ﬁle>

Topology ﬁle of the solvated complex corresponding to the coordinate ﬁle
speciﬁed under com_inpcrd_v0.

match_list_ﬁle <ﬁle>

Absolute path and name of a ﬁle containing atom correspondence in-
formation between states V0 and V1. An example match-ﬁle can be
found in examples/input_info/match_list.txt. This information must only
be provided if the automated generation of the atom correspondence list
(prepare_match_list=1) was not successful and the list was created manually.

SSbond_ﬁle <ﬁle>

Absolute path and name of ﬁle containing disulﬁde bridge deﬁnitions for the
receptor. For an example ﬁle see examples/input_info/SSbridges.txt

chain_termini <no.>,<no.>, .... Numbers of terminal residues of chains in receptor structure, e.g., if a chain
ends at residue 234 and a new chain starts with residue 235, the number 234
needs to be speciﬁed as <no.>.

create_sybyl_mol2 0 | 1

Optional: Request generation of mol2 ligand ﬁles for V0 and V1 with sybyl
atom types. As most molecule visualization programs support this format,
the created ﬁles allow an easy comparison of atom names of start and end
structures to check the correctness of the atom matching step.

801

35. FEW

additional_library <ﬁle>

additional_frcmod <ﬁle>

Optional: Absolute path and name of additional library ﬁle containing infor-
mation about non-standard residues or ions.

Optional: Absolute path and name of additional parameter ﬁle. Such a ﬁle is
only required if parameters necessary for the description of the receptor are
missing in the ff12SB force ﬁeld.

2. General parameters for preparation of TI transformation simulations

ti_batch_path <path>

Optional: If the simulations shall be run under a different path than the setup, a new
<output_path> for the batch ﬁle generation can be speciﬁed.

ti_prod_template <ﬁle>

no_shake 0 | 1

Optional: Template ﬁle for TI production simulations. Per default the example ﬁle
under examples/input_info/MD_prod_TI.in will be used as a template. Please adapt
the ﬁle according to your needs but keep the format of the lines containing the ﬂags
"t", "scmask", and "clambda".
If decomposition is requested, please also use the
format shown in the example ﬁle for the speciﬁcation of "RES" and "LRES".

Optional: Request calculation without AMBER shake option. In this case ensure
that shake is also switched off in the ti_prod_template ﬁle. For an example ﬁle
see examples/input_info/MD_prod_noShake_TI.in.
It is recommended to conduct
transformations not involving exchanges of atoms in rings or exchanges of single
hydrogen atoms with shake (no_shake=0) on hydrogens (ntc=2, ntf=2) to be able to
increase the integration step size to 2 fs. Default = 0.

A) Setup of scripts for TI equilibration

ti_equil 0 | 1

Request setup of ﬁles for TI equilibration.

ti_equil_batch_template <ﬁle>

ti_equil_lambda <no.>,<no.>,...

ti_equil_template <ﬁle>

Template batch ﬁle for the submission of the equilibration phase
job to a queuing system. An example ﬁle can be found under
examples/input_info/equi_TI.pbs. Please adapt the ﬁle according to
the needs of your queuing system, but keep everything from the section
entitled "Fix variables" up to the section "Re-queue" and ensure that the
line for job naming ends with "-N".

λ values for which TI equilibration calculations shall be prepared in as-
cending order. Please specify only the decimal digits, e.g. 1 for lambda
0.1, 05 for lambda 0.05. λ values can be in the range 0.01 – 0.99, i.e.,
01 – 99 in the FEW internal nomenclature. For equilibration only equi-
distant λ values can be used, i.e., (cid:52)λ needs to be equal for all successive
λ’s.

Template ﬁle for equilibration part of the equilibration phase. For an
example ﬁle see examples/input_info/equi_TI.in. The equilibration
part is followed by a 1 ns free MD simulation for ﬁnishing equilibration
of the system. For setup of this later part the template ﬁle speciﬁed under
ti_prod_template will be used.

B) Setup scripts for TI production simulations

ti_production 0 | 1

Request setup of scripts for TI production simulations. Please note that this
option requires the presence of the results of the TI equilibration calcula-
tions in the corresponding "equi" folder.

802

ti_prod_lambda <no.>,<no.>,...

total_ti_prod_time <time>

ti_prod_batch_template <ﬁle>

converge_check_script <ﬁle>

converge_check_method 1|2

converge_error_limit <limit>

35.6. Thermodynamic integration workﬂow (TIW)

λ values for which TI production calculations shall be prepared in ascend-
ing order. Please specify only the decimal digits, e.g., 1 for lambda 0.1, 05
for lambda 0.05. λ values can be in the range 0.01 - 0.99, i.e. 01 - 99 in the
FEW internal nomenclature.

Total simulation time per λ value in [ns]. The number of cyclic runs re-
quired will be calculated based on the deﬁnitions in the ti_prod_template.
Please ensure that the MD total simulation time is a multitude of the MD
simulation time speciﬁed in the production template ﬁle. The requested
total simulation time will only be reached, if the error limit for simulation
termination is not reached before.

the submission of

the production phase
Template batch ﬁle for
An example ﬁle can be found under
job to a queuing system.
examples/input_info/prod_TI.pbs. Please adapt the ﬁle according to your
queuing system, but keep everything from the section entitled "Fix vari-
ables" up to the section "Re-queue" and ensure that the line for job naming
ends with "-N".

Optional: Absolute path and name of Perl-script used for convergence
checking after each production step. If the location of the script is not pro-
vided it will be assumed that the script is located under the default location
at .../FEW/miscellaneous/convergenceCheck.pl

Optional: Method that shall be used for convergence analysis. 1: Dif-
ference in standard error of dV/dλ between consecutive production runs;
2: Precision of dV/dλ determined employing student’s distribution. For a
detailed explanation refer to the introduction section of the TI calculation
module (Section 35.6). Default = 1.

Optional: Error limit that shall be used as termination criterion for the TI
production simulations. Default: 0.01 kcal/mol (method 1); 0.2 kcal/mol
(method 2). As long as the convergence measure is larger than this limit
and the total simulation time has not been reached, the simulation will go
on.

3. Calculation of the difference in free energy of binding

ƊƊGbinding can be calculated using a command ﬁle containing the following parameters (in addition to the

section specifying input / output directories and formats).

ti_ddG 0 | 1

Request calculation of the difference in free energy of binding between
start (V0) and end (V1) ligands.

charge_method am1 | resp

Charge method (see above).

lig_name_v0_struct <name>

Name of ligand in the start state (V0). The name needs to be identical to
the name used in the setup of the simulations (see above).

lig_name_v1_struct <name>

Name of ligand in the end state (V1). The name needs to be identical to the
name used in the setup of the simulations (see above).

lig_alias_v0 <alias>

Alias that shall be used for the ligand in the start state (V0). The alias
must be identical with the alias used for the setup of the TI simulations
(see above).

803

35. FEW

lig_alias_v1 <alias>

dVdL_calc_source <no.>-<no.>

ddG_calc_method 0 | 1

Alias that shall be used for the ligand in the end state (V1). The alias must
be identical with the alias used for the setup of the TI simulations (see
above).

Range of ﬁles from the production phase of the TI simulations that shall
be considered in the calculation of the difference in free energy of bind-
ing. If set to "0", all recorded ﬁles will be considered. If only ﬁles in a
certain range shall be regarded, specify the range, e.g., the range "3-5" will
result in considering of the ﬁles xxx_prod03_v1.out, xxx_prod04_v1.out
and xxx_prod05_v1.out from the production run of the TI simulations. In
case all ﬁles from a certain time point onward shall be regarded, provide a
range that ends with zero, e.g. "4-0".

Method that shall be used for the calculation of ∆∆Gbinding. If “1” is spec-
iﬁed, the common procedure with linear interpolation to λ=0 and λ=1 is
used. In case of "2", no linear interpolation is conducted. The later cal-
culation method can only be used, if the production simulations were run
with equi-distant λ values, i.e., (cid:52)λ was of the same size for all successive
λ’s.

Figure 35.9.: Folder structure and ﬁles generated during TI calculation setup with FEW. Numbering according to

steps shown in Figure 35.8.

Script for the identiﬁcation of “optimal” transformations

If several ligands shall be studied by thermodynamic integration the shortest path algorithm of Kruskal [718] can
be used to determine the ”optimal” transformations between the ligands, i.e. those that require overall the smallest
structural changes. In this way, relative binding free energies can be computed between those ligand pairs that
show overall the highest similarity. A script called identify_transformations.pl provided in the miscellaneous
folder of FEW can be used to identify the ”optimal” transformations. This script employs Kruskal’s algorithm to
determine those transformations that lead to the smallest overall score based on a matrix of similarity scores. Such

804

output_pathfolderTI<chargemethod><LigandnameV0><LigandnameV1>xTI_<charge(cid:3)method><Ligand(cid:3)name(cid:3)V0>_<Ligand(cid:3)name(cid:3)V1>…xFolder(cid:3)contains(cid:3)all(cid:3)files(cid:3)used(cid:3)and(cid:3)created(cid:3)during(cid:3)the(cid:3)generation(cid:3)of(cid:3)the(cid:3)coordinate(cid:3)andtopologyfilesforTIinputsetupx1and(cid:3)topology(cid:3)files(cid:3)for(cid:3)TI(cid:3)inputFiles(cid:3)required(cid:3)for(cid:3)running(cid:3)the(cid:3)TI(cid:3)equilibration(cid:3)MDequi2AFiles(cid:3)required(cid:3)for(cid:3)running(cid:3)the(cid:3)TI(cid:3)productionsimulationsprod2Bproduction(cid:3)simulations3TIresultsOutput(cid:3)files(cid:3)from(cid:3)the(cid:3)calculation(cid:3)of(cid:3)the(cid:3)diffiffbidiTI_resultsdifference(cid:3)in(cid:3)free(cid:3)energy(cid:3)of(cid:3)binding35.6. Thermodynamic integration workﬂow (TIW)

matrix of similarity scores can for example be obtained by a pairwise ligand comparison employing the Tanimoto-
Combo score of ROCS [719, 720]. The script uses the Perl module Graph::Kruskal, which needs to be downloaded
from CPAN (http://www.cpan.org/modules/index.html) and installed as part of the local Perl installation before the
script identify_transformations.pl can be used.

Usage:

perl identify_transformations.pl <number of structures> <score matrix file>

number of structures

score matrix ﬁle

Integer number specifying the number of structures that shall be regarded in
the search for “optimal” transformations.

Absolute path and name of ﬁle containing the score matrix based on which the
“optimal” transformations are determined. This matrix ﬁle should be in tab-
separated text format. The similarity matrix needs to comprise N × N score
values, where N is the number of ligands that shall be regarded. It is assumed
that smaller scores correspond to a higher similarity between ligands. The
ﬁrst line and the ﬁrst column should contain the names of the ligands.
Example - section of score matrix ﬁle:

L01
0
217
284
199
...

L02
217
0
285
427
...

L03
284
285
0
118
...

L04
199
427
118
0
...

...
...
...
...
...

L01
L02
L03
L04
...

805

36. SAXS

36.1. Introduction and theory

Small angle X-ray scattering (SAXS) is a solution based technique that is conventionally used to probe the shape
and structure of (bio)molecules. It has long been recognized that the solvent shell around the molecule signiﬁcantly
impacts the shape of the measured SAXS proﬁle. Experimentally, X-ray scattering on biomolecules compare the
scattering intensity from the sample of interest to a "blank" with just solvent present, and report the difference, or
"excess" intensity:

where the (cid:104)(cid:105)t bracket indicates the intensities are averaged over the measurement time and volume. A (q) and B (q)
are Fourier transforms of the scattering amplitudes for the sample and blank, respectively:

I (q) =

(cid:68)|A (q)|2(cid:69)

t

t

−(cid:68)|B (q)|2(cid:69)

(cid:68)|A (q)|2(cid:69)
(cid:90) (cid:10) ˜A (r) ˜A(cid:0)r(cid:48)(cid:1)(cid:11)e−iq.(r−r(cid:48))drdr(cid:48)
(cid:104)(cid:68)|A1 (q)|2(cid:69)−|(cid:104)A1 (q)(cid:105)|2(cid:105)−(cid:104)(cid:68)|B1 (q)|2(cid:69)−|(cid:104)B1 (q)(cid:105)|2(cid:105)

=

with ˜A (r) is the electron density in the system. It has been shown that the total intensity can be approximately
(though usefully) rewritten as:[721, 722]

I (q) = [(cid:104)A1 (q)(cid:105)−(cid:104)B1 (q)(cid:105)]2 +

(36.1)

where A1 (q) and B1 (q) are Fourier transforms for the sample and blank but here only considering regions where
there is excess/deﬁcit electron density relative to the bulk value. In RISM, the second and the third terms vanish,
leading to:

I (q) = [(cid:104)A1 (q)(cid:105)−(cid:104)B1 (q)(cid:105)]2

(36.2)

There are now two SAXS programs in Amber: saxs_rism for calculating SAXS from distribution function
of solvent in grid format (dx ﬁles) from 3D-RISM, another one is saxs_md which takes input as two sets of
coordinates extracted from snapshots of “sample” and “blank” MD simulations (the “sample” MD contains the
biomolecule plus water and ions, while the “blank” MD only has pure water + salt).

36.1.1. saxs_rism

Intensity is calculated based on eq. 36.2, neglecting the time-correlation of solvent density. The total excess

amplitude is calculated by summing up amplitudes from the biomolecule and the solvent (including ions):

A1 (q)− B1 (q) = F (q) = Fsolu (q) + Fgrid (q)

where the solute form factor is Fsolu (q) = ∑ j f j (q)exp
factor and B j is the B-factor) and the contribution from the solvent is Fgrid (q) = ∑Ngrid

16π2

The angle averaging is then performed by using Lebedev quadrature to obtain the total intensity:

(cid:17)

exp(cid:0)−iq.rj

(cid:1) (with f j (q) is the atomic scattering

f j (q)exp(cid:0)−iq.rj

(cid:1).

j

(cid:16)− B jq2
(cid:90)

I (q) =

I (q)dΩ

1
4π

This approach was shown valid up to angles corresponding to q (cid:39) 1.5 Å-1. (For more details, see [722]).

806

36.1.2. saxs_md

36.2. Usage

The intensity is calculated based on eq. 36.1, which can be rewritten as:[721]

I (q) = |a (q)− b (q)|2 +

1
N ∑

i

1 (q)− a (q)

(cid:12)(cid:12)(cid:12)A(i)

(cid:12)(cid:12)(cid:12)2 − N(cid:48) + 1

N(cid:48) (N(cid:48) − 1) ∑

(cid:12)(cid:12)(cid:12)B( j)

j

1 (q)− b (q)

(cid:12)(cid:12)(cid:12)2

where A(i)
respectively, and are computed by:

1 (q) and B( j)

1 (q) are the scattering amplitudes of the each snapshot from the “sample” and “blank”,

a (q) and b (q) are the averaged amplitudes for the total N and N’ snapshots, respectively (with each weight wi)

A1 (q) = ∑

n

fn (q)e−iq.rn

a (q) =

b (q) =

1 (q)

1 (q)

i wiA(i)
∑N
∑N
i wi
∑N(cid:48)
j w jB( j)
∑N(cid:48)
j w j
(cid:90)

1
4π

I (q)dΩ

The angle averaging is then performed by Lebedev quadrature, as in saxs_rism.

I (q) =

36.2. Usage

36.2.1. saxs_rism

The program requires solvent distribution in dx format (as output of 3D-RISM) and a pdb ﬁle of the biomolecule
to compute SAXS signal. If run without input, saxs_rism prints the usage and default settings for all parameters.
--grid_dir Location of the folder where all the 3D-RISM outputs found. All ﬁles in this folder starting with guv
will be considered by the program. Atom or ion names must be present in the ﬁle name in order for
the program to recognize. Currently supporting O, H1 (for water), Li+, Na+, K+, Rb+, Cs+, Mg2+,
Sr2+, F-, Cl-, Br-, I-. For example these ﬁle names are valid: guv.Cl-.dx, guvﬁleRb+, guvO. The
following ﬁle names are NOT valid: abc.O.dx, guvNa.dx, guv.H.dx

--solute

pdb ﬁle of the solute. Currently only supporting the following atoms: H, O, C, N, P, S, Fe

--conc_ion concentration of salt [mol.l-1]. This is the concentration of the cation. Concentration of the anion

will be automatically computed (2x in Mg2+ and Sr2+ cases)

--conc_wat concentration of water [mol.l-1]. Default is 55.34
momentum transfer q cutoff [Å-1]. Default is 0.5
q spacing [Å-1]. Default is 0.01

--qcut

--dq

--cutoff

real space cutoff [Å]. Only considering grid points within cutoff distance to the nearest solute atom.
Default is 20

--off_cutoff using all grid points for calculating SAXS, ignoring cutoff value

--expli

--anom_f

ﬂag for using explicit H atoms in pdb ﬁle to calculate intensity. Default is to merge H atoms into
heavier atoms
f’ for anomalous scattering. Currently only applied to Rb+, Sr2+ or Br- grids. Default is 0

807

36. SAXS

--decomp

ﬂag for decomposing total intensity into site contributions (usually this leads to 2-5x in computational
time)

--exper

provide the experimental data to read q from. This will override dq and qcut

--exclV

ﬂag for merging those contribution of the grid points inside the excluded volume of the solute into
the solute

--phase

turn on this ﬂag will output the phase and error analysis

--tight

ﬂag for using tighter convergence criteria for Lebedev quadrature (also leads to more time)

--bfactor ﬂag for using B factor (Debye–Waller factor) in the PDB ﬁle to compute intensity

--output

output ﬁle

--ncpus

(need to compile with OpenMP to use this ﬂag) specify the number of threads used. Default is to use
all available threads

Example

The following example ﬁrst run 3D-RISM to calculate the distribution function of water around lysozyme

(lys.pdb). The output (guv.O.dx and guv.H1.dx) will then be used to compute SAXS intensity

• Run 3D-RISM to obtain the distribution function around the solute

$AMBERHOME/bin/rism3d.snglpnt --pdb lys.pdb --prmtop prmtop --xvv rism.xvv --guv guv

• Run saxs_rism

$AMBERHOME/bin/saxs_rism --grid_dir . --solute lys.pdb --expli --decomp \

--bfactor --output saxs.out

36.2.2. saxs_md

The program requires two sets of coordinates (both in PDB formats) of the “sample” (biomolecule + solvent)
and “blank” (pure solvent) systems. Each snapshot starts with “MODEL”, following by “ATOM” or “HETATM”
and ends with “ENDMDL” or “END” (for the last snapshot). These pdb ﬁles can be generated directly from the
trajectory by using ptraj/cpptraj as following:

parm prmtop
trajin md.nc
autoimage
trajout rep.pdb pdb

Additionally, you can assign the weight for each snapshot by using “WEIGHT”. This is useful if you want to use
only representative snapshots for SAXS calculation. For example, the following is a valid pdb ﬁle which assign a
weight of 342 for the ﬁrst snapshot and 148 for the second.

0
342
1 HO5’ DG5
2 O5’ DG5

1
1

14.902 29.822
15.380 29.001

29.924
30.064

1.00
1.00

0.00
0.00

72772 H1 WAT 3867
72773 H2 WAT 3867

40.377 65.382
40.942 64.499

83.718
82.466

1.00
1.00

0.00
0.00

H
O

H
H

MODEL
WEIGHT
ATOM
ATOM
...
ATOM
ATOM
ENDMDL

808

36.2. Usage

1
148
3 C5’ DG5
4 H5’ DG5

MODEL
WEIGHT
ATOM
ATOM
....
END

1
1

16.744 29.215
16.808 29.389

29.653
28.579

1.00
1.00

0.00
0.00

C
H

If run without input, saxs_md prints the usage and default settings for all parameters.

--system

pdb ﬁle for the solute system

--solvent pdb ﬁle for the solvent

--qcut

--dq

--cutoff

momentum transfer q cutoff [Å-1]. Default is 1.0

q spacing [Å-1]. Default is 0.01

distance cutoff to the solute, keep only waters and ions within cutoff distance from the nearest solute
atom. Default is 5.0

--tight

ﬂag for using tighter convergence criteria for Lebedev quadrature (leads to more computational time)

--anom_f

f’ for anomalous scattering. Currently only applied to Rb+, Sr2+ or Br-. Default is 0

--expli

ﬂag for using explicit H atoms in pdb ﬁles to calculate SAXS. Default is to merge H atoms into
heavier atoms.

--output

output ﬁle

--ncpus

(need to compile with OpenMP to use this ﬂag) specify the number of threads used. Default is to use
all available threads

Example

The following example use two pdb ﬁles (sample.pdb and solvent.pdb) to compute SAXS.

$AMBERHOME/bin/saxs_md --system sample.pdb --solvent solvent.pdb \

--cutoff 10 --expli --output saxs.out

809

37. MoFT: analysis of volumetric data

MoFT1 is a series of computational programs and libraries for analysis of volumetric data generated by theo-
retical models (MD, MC simulations, 3D-RISM, NLPB) or derived from experimental measurement (e.g X-ray
crystallography, cryo-EM). metatwist is an application that provides a low level access to most of the function-
alities available in MoFT and is supported by metaFFT, a templated interface to FFTW library v32, that supports
discrete Fourier transforms, correlations, convolutions on 1 or 3-dimensional data of ﬂoat, double of complex
datatypes.

Examples of MoFT usage and how to cite. The development of the functionalities available in MoFT has been
driven by applied work which has been reported in the references bellow. Consider including these publications in
your reference list when using MoFT:

1. "Ion counting from explicit-solvent simulations and 3D-RISM" GM Giamba¸su, T Luchko, D Herschlag, DM

York, DA Case Biophysical Journal 106 (4), 883-894 doi:10.1016/j.bpj.2014.01.021

2. "Competitive interaction of monovalent cations with DNA from 3D-RISM" GM Giamba¸su, MK
Gebala, MT Panteva, T Luchko, DA Case, DM York Nucleic Acids Research 43 (17), 8405-8415
doi:10.1093/nar/gkv830

3. "Predicting site-binding modes of ions and water to nucleic acids using molecular solvation theory" GM

Giamba¸su, DA Case, DM York Journal of the American Chemical Society doi:10.1021/jacs.8b11474

37.1. Usage

Most of the functionalities available in MoFT are exposed through the metatwist application, and include:

1. Reading, converting and writing plain or compressed (gz, bz2) *.dx (OpenDX 3), ccp4 4 volumetric data

formats.

2. Dimensionality reduction of volumetric data:

a) radial distribution functions using cylindrical and spherical frames of references (3D -> 1D).
b) projection of 3D-data on x,y or z coordinates (3D -> 1D).
c) worm plots (3D -> 1D), useful to characterize how density changes along curvilinear paths (such as
channels) which are represented as B-splines and whose pivot points are provided by the user. The ab-
scissa is the result of integrating the 3D density within a tube of speciﬁed radius around the curvilinear
path. See [122] for examples of how worm plots can be used to analyze water and ion distribution in
ion channels and G-quadruplexes.

d) twisted, untwisted maps (3D -> 2D), meant to map the density of ions and water in an average plane
of nucleic acid basepairs that are part of helical regions. Twisted maps are simply average densities in
a plane perpendicular to the helical axis. Untwisted maps deconvolute this information with a mobile
frame of reference that moves against the natural twist of the helical motif. See [259, 723] for examples
of untwisted maps usage.

1Origin of name MoFT: most of the included tools and libraries use template meta-programming approaches in C++ and hence when using
meta-programming too often to write software you may get MoFT. Incidentally moft is a also word in Romanian, the main developer’s
native language, see this link for possible translations: https://translate.google.com/#ro/en/moft.

2http://www.fftw.org/
3antiquated format that is still widely used by most molecular graphics programs, see https://en.wikipedia.org/wiki/IBM_OpenDX.
4a common binary format in use by X-ray crystallography and cryo-EM, see http://www.ccp4.ac.uk/html/maplib.html

810

37.1. Usage

3. Convolutions of volumetric data with several kernels, including Gaussian, sinc, box, Laplacian of a Gaussian,
Butterworth ﬁlter for reduction of resolution range in the reciprocal space, crystallographic atomic form
factors and densities to obtain to corresponding electron densities.

4. Transformations, including numerical derivatives (ﬁnite difference Laplacian), logarithm operators to com-

pute potentials of mean force from equilibrium distributions.

5. Water and ion placement using Laplacian mapping.

metatwist has the following command line options:

--help

--dx

--ldx

--odx

--map

Produces help message.

Input density ﬁle(s): *.dx(gz,bz2)|*.ccp4.

Input Laplacian ﬁle (*.dx|*.ccp4) for use with “-- map blobs(per)”.

Output density ﬁle. File type is determined by extension: *.dx or *.ccp4.

Mapping type:
~ cylindrical (1D): cylindrical RDF along z-axis.
~ twist (2D): twisted helical map along z-axis.
~ untwist (2D): untwisted helical map along z-axis.
~ spherical (1D): spherical RDF.
~ projxyz: (1D) project 3D-map on x,y,z axes.
~ excess: excess number of particles.
~ blobs: Laplacian blob analysis.
~ blobsper: Laplacian blob analysis on a periodic 3D-map.
~ rhoel (3D) : Electron density using atomic form factors.
~ rhoelreal (3D): Electron density using atomic densities.
~ cutresol (3D): Cut 3D-map resolution range.

--bin

Bin size for re-sampling (Å) .

--(x|y|z|r)max Extent in the x,y, z or r directions (Å).

--utrate

Untwisting rate for use with “--map twist”. Untwisting rate: 0.18587 rad/Å - BDNA 0.16870
rad/Å - TDNA 0.25590 rad/Å - ARNA (rad/Å).

--com

COM coordinates .

--resolution

Min and max resolution thresholds (in Å) for use with “ -- map cutresol” (default “1.0 10.0”,
Å).

--bulkdens

Bulk density (M, mol/L, molar).

--species

Chemical species: atom, e.g. “N”, or atom & residue, e.g. “O WAT”, useful for water and ions
placement as well as for computing electron densities.

--sigma

Convolution kernel width, sigma (in Å).

--threshold

Laplacian threshold. Sometimes not all the locally concentrated regions might be interesting.
The threshold limits the region of interest to min(L[rho]) to threshold*min(L[rho]).

--convolve

Convolution type: (1) Gaussian, (2) box, (3) sinc, (4) Laplacian of Gaussian.

--nlog

Take the negative natural logarithm of the input density.

--laplacian

Compute Laplacian of the input density using ﬁnite difference.

--average

Average volumetric data when multiple datasets have been loaded. Otherwise, data will be
accumulated.

811

37. MoFT: analysis of volumetric data

Figure 37.1.: (Left) The negative Laplacian (cyan) can be used to map locally concentrated regions of a density
distribution, ρ. (Middle) A bis-crown ether (shown as CPK) binding mode to K+ (violet sphere)
determined using density distributions obtained using RISM and located using Laplacian mapping
in MoFT. (Right) Two level sets of the Laplacian of the K+ distribution, one using a threshold (see
documentation) of 0.1 (solid cyan) and the other using a threshold of 0.01 (semi-transparent cyan).

37.2. Examples

All ﬁles relevant for these examples are available in $AMBERHOME/Ambertools/src/moft/examples/.

Water and ion placement using Laplacian mapping

We will use MoFT to locate and map tightly bound solution particles to a solute molecule of interest using
molecular distribution functions obtained from 3D-RISM. Speciﬁcally, we will try to locate K+ binding mode(s)
to a small molecule ionophore - a crown ether.

Generally, molecular density distributions of ions and water have alternating regions where they are highly con-
centrated and others where they are locally depleted. While these complex topologies are a beneﬁt of models that
include particle-particle correlations (such as explicit solvent MD, RISM) they make determination of boundaries
of “binding modes” a complex task. Our solution is to demarcate these binding modes using the Laplacian of the
solvent distributions. When applied to 3D distributions, the Laplacian measures the difference between the local
particle density and the average of the density in a small neighborhood of that point. Hence, where the Laplacian is
positive the local particle density is locally depleted, while for the regions with negative values of the Laplacian the
particle density is locally concentrated. Experience shows that a pre-conditioning using kernels that smooth out
small local variations in the density can help eliminate false positives. Here we will apply the Laplacian mapping
on the density convolution with a 3D Gaussian which can be carried out in a single step by a convolution with a
Laplacian of a Gaussian kernel.

(1) Generate density distributions. Solvent density distributions can be determined by several means, but here
RISM is used (See 7 for how to run RISM). When running RISM, make sure to specify the “-- guv” keyword to
have the solution components density distributions outputted:

rism3d.snglpnt --prmtop bc5-k.parm7 --xvv KCl-aq-0.2M-pse3.xvv \

--closure pse1,pse2,pse3 --tolerance 1e-03,1e-06 \
--ng 192,192,192 --solvbox 96,96,96 --buffer -1 \
--mdiis_del 0.5 --mdiis_nvec 10 \
--verbose 2 --npropagate 0 --guv g > rism.out

(2) Compute the Laplacian map. First, one has to take the Laplacian of the distribution, using the “convolve”
option:

812

37.2. Examples

metatwist --dx g.K+.1.dx.bz2 --odx lp-K+.dx --species K+ K+ --bulkdens 0.2\

--convolve 4 --sigma 1.0

Here, --dx speciﬁes the input density, --odx the root of the output ﬁle containing the Laplacian density. Option
“--convolve 4” speciﬁes the type of convolution that leads to the Laplacian; here we have chosen to obtain the
Laplacian using a convolution with the Laplacian of a Gaussian, in this case of width 1.0, speciﬁed using “–sigma
1.0”. This step produces a “convolution-lp-K+.dx” ﬁle that can be visualized in your molecular graphics application
and will be used in the next step.

(3) Solvent Placement. Second, using the determined Laplacian, we can proceed to the actual analysis:

metatwist --dx g.K+.1.dx.bz2 --ldx convolution-lp-K+.dx --species K+ K+ \

--bulkdens 0.2 --map blobs --thresh 0.1

Here, --ldx speciﬁes the input Laplacian, “--map blobs” asks for solvent placement analysis to be carried out (you
can think about solvent binding modes as blobs) using a Laplacian threshold of 0.1. While all the regions of space
having a negative Laplacian can be considered as “locally concentrated”, often a tighter (more negative) threshold
can simplify the analysis. Lastly, --bulkdens speciﬁes the concentration of the solution particle; in this case K+
has a bulk concentration of 0.2M. With these settings, a pdb ﬁle named
“g.K+.1-convolution-lp-K+-blobs-centroid.pdb” is produced that contains the coordinates of the centroid of each
solvation binding mode (in this case only one mode has been found), its occupancy and temperature factor.

ATOM

1 K+

K+ C

1

10.926 12.084

4.026

0.10 92.73

K+

Converting particle density distributions to electron densities

It is often necessary to convert particle density distributions to electron densities to directly compare against

experimentally derived data, such as that obtained from X-ray crystallography. To illustrate this functionality, we
will use the aforementioned RISM calculation on the crown ether immersed in a KCl aqueous solution which
produced density distributions for K+, Cl-, water H and water O. In the ﬁrst step, each of the particle densities is
converted to their corresponding electron densities using model atomic factors used in crystallography. In a
second stage, all the electron densities are accumulated into a resulting total electron density. Note the use of “
--species” option to guide the choice of model density based on the ionization or oxidation number of each atom
as well as the “ --map rhoel” option to ask for computation of the electron density map. A similar option “--map
rhoelreal” could be used which instead of atomic factors will use reference atomic densities to compute the
overall electron density.

# (1) convert each particle density to electron densities :
metatwist --dx g.K+.1.dx.bz2 --species K+ --odx rho.K+.1.dx
--map rhoel --bulkdens 0.2
metatwist --dx g.Cl-.1.dx.bz2 --species Cl- --odx rho.Cl-.1.dx --map rhoel --bulkdens 0.2
metatwist --dx g.O.1.dx.bz2
# (2) assembly of all densities into rho.dx :
metatwist --dx rho.Cl-.1.dx

rho.O.1.dx --odx rho.dx --species none

--species O2- --odx rho.O.1.dx

--map rhoel --bulkdens 55.55

rho.K+.1.dx

813

Part VI.

NAB/sff

814

38. NAB and sff

38.1. A little history

The NAB language compiler nab2c (which converts NAB source code to C, for subsequent compilation) was
written in the 1990’s by Tom Macke. The original design idea was to create a “molecular awk”: a scripting
language for manipulation of (macro-)molecules that would be primarily used to create short scripts to carry out
molecular manipulations. The design goals for the language are summarized in Section 38.3 below. It was quickly
realized that manipulations like force ﬁeld minimization would be useful, and the Amber-compatible molecular
mechanics routines described in Chap. 39 were added by David Case as sff, a “simple force ﬁeld”.

Over the years, sff evolved to keep pace with (and in many cases drive) Amber developments involving implicit
force ﬁelds, including generalized Born, Poisson-Boltzmann and RISM approaches. In keeping with its original
motivation, sff concentrated on implicit solvation, leaving explicit solvent and periodic simulations to the main
Amber programs sander and pmemd. The sff routines were parallelized using both openmp and MPI, and second
derivatives of the generalized Born model were added by Russ Brown. Apart from the lack of a GPU implemen-
tation, the routines in sff are the most general and efﬁcient ones in the Amber package. In particular, sff excels at
generalized Born simulations on large systems, beneﬁtting from an advanced nonbonded list builder, and from the
hierarchical charge partition model described in Section 39.5.

From the very beginning, sff was closely associated with the NAB language: effectively the API for sff is
written in NAB, and is documented in Chapter 39, below. NAB is a C-like language, but one where pointers are
not visible at the user level. This means that nab2c needs to know how to generate the proper C code, which will
involve pointers, especially in function calls. This was implemented by requiring that all NAB-visible routines be
registered in an internal database (see symbol.c) that provides instructions on the nature of these arguments and
other details required to convert NAB to C. This, plus the fact that many C constructs (such as typedef) are not
supported, limits the utility of NAB as a general-purpose language. And in terms of re-purposing the code in sff,
having an API only in the NAB language is of little help to those working in other languages, such as python, C,
Common LISP or Fortran. Starting with AmberTools18, we are trying to make the routines in libsff available to a
wider audience.

38.2. A C interface to libsff

Since both NAB and sff are written entirely in C, there already exists an effective (but hidden) C-API: users can
write sample NAB code, and examine the resulting C code to see what is going on “under the hood.” Furthermore
the sff header ﬁle (in $AMBERHOME/AmberTools/src/sff/sff.h) is ready to be included in C programs. In many
cases, accessing the sff molecular mechanics routines from C involves writing code that looks just like NAB code,
except that referencing and de-referencing (via “*” and “&”) needs to be added by the users.

Still, this is far from satisfactory, even taking account of the fact that people using API’s presumably know
how to read code. As a ﬁrst step, we have prepared sample ﬁles in $AMBERHOME/AmberTools/test/nabc, which
illustrate how to use most of the sff functionality directly from a stand-alone C driver. The Makeﬁle in this directory
can guide you through running several sample calculations. Looking at the code, and its comments, along with the
header ﬁle ($AMBERHOME/include/sff.h) should go a long way towards allowing direct integration into C codes,
without any reference to the NAB compiler.

816

38.3. NAB overview

38.3. NAB overview

Nucleic acid builder (nab) is a high-level language that facilitates manipulations of macromolecules and their
fragments. nab uses a C-like syntax for variables, expressions and control structures (if, for, while) and has exten-
sions for operating on molecules (new types and a large number of builtins for providing the necessary operations).
We expect nab to be useful in model building and coordinate manipulation of proteins and nucleic acids, rang-
ing in size from fairly small systems to the largest systems for which an atomic level of description makes good
computational sense. As a programming language, it is not a solution or program in itself, but rather provides
an environment that eases many of the bookkeeping tasks involved in writing programs that manipulate three-
dimensional structural models.

The current implementation incorporates the following main features:

1. Objects such as points, atoms, residues, strands and molecules can be referenced and manipulated as named
objects. The internal manipulations involved in operations like merging several strands into a single molecule
are carried out automatically; in most cases the programmer need not be concerned about the internal data
structures involved.

2. Rigid body transformations of molecules or parts of molecules can be speciﬁed with a fairly high-level
set of routines. This functionality includes rotations and translations about particular axis systems, least-
squares atomic superposition, and manipulations of coordinate frames that can be attached to particular
atomic fragments.

3. Additional coordinate manipulation is achieved by a tight interface to distance geometry methods. This
allows allows relationships that can be deﬁned in terms of internal distance constraints to be realized in
three-dimensional structural models. nab includes subroutines to manipulate distance bounds in a convenient
fashion, in order to carry out tasks such as working with fragments within a molecule or establishing bounds
based on model structures.

4. Force ﬁeld calculations (e.g. molecular dynamics and minimization) can be carried out with an implementa-
tion of the AMBER force ﬁeld. This works in both three and four dimensions, but periodic simulations are
not (yet) supported. However, the generalized Born models implemented in Amber are also implemented
here, which allows many interesting simulations to be carried out without requiring periodic boundary con-
ditions. The force ﬁeld can be used to carry out minimization, molecular dynamics, or normal mode calcu-
lations. Conformational searching and docking can be carried out using a "low-mode" (LMOD) procedure
that performs sampling exploring the potential energy surface along low-frequency vibrational directions.

5. nab also implements a form of regular expressions that we call atom regular expressions, which provide a

uniform and convenient method for working on parts of molecules.

6. Many of the general programming features of the awk language have been incorporated in nab. These
include regular expression pattern matching, hashedarrays (i.e., arrays with strings as indices), the splitting
of strings into ﬁelds, and simpliﬁed string manipulations.

7. There are built-in procedures for linking nab routines to other routines written in C or Fortran, including

access to most library routines normally available in system math libraries.

We will continue to support the NAB language, primarily because there are a non-negligible number of third-party
programs that depend on it. But going forward, other ways of writing driver routines (especially via the C-interface
described above) seem to be more attractive. For that reason, and because nab itself has changed very little in the
past decade, we are removing the description of nab from this manual. You can still access the full documentation
in the Amber 2017 Reference Manual, available at http://ambermd.org/doc12/Amber17.pdf. The next few
sections document features of libsff that continue to be useful via the C API.

38.4. Fiber Diffraction Duplexes in NAB

The primary function in NAB for creating Watson-Crick duplexes based on ﬁbre-diffraction data is fd_helix:

817

38. NAB and sff

molecule fd_helix( string helix_type, string seq, string acid_type );

fd_helix() takes as its arguments three strings - the helix type of the duplex, the sequence of one strand of the
duplex, and the acid type (which is "dna" or "rna"). Available helix types are as follows:

Helix type options for fd_helix()

arna
aprna
lbdna
abdna
sbdna
adna

Right Handed A-RNA (Arnott)
Right Handed A’-RNA (Arnott)

Right Handed B-DNA (Langridge)

Right Handed B-DNA (Arnott)

Left Handed B-DNA (Sasisekharan)

Right Handed A-DNA (Arnott)

The molecule returns contains a Watson-Crick double-stranded helix, with the helix axis along z. For a further

explanation of the fd_helix code, please see the code comments in the source ﬁle fd_helix.nab.

References for the ﬁbre-diffraction data:

1. Structures of synthetic polynucleotides in the A-RNA and A’-RNA conformations. X-ray diffraction anal-
yses of the molecule conformations of (polyadenylic acid) and (polyinosinic acid).(polycytidylic acid).
Arnott, S.; Hukins, D.W.L.; Dover, S.D.; Fuller, W.; Hodgson, A.R. J.Mol. Biol. (1973), 81(2), 107-22.

2. Left-handed DNA helices. Arnott, S; Chandrasekaran, R; Birdsall, D.L.; Leslie, A.G.W.; Ratliff, R.L. Nature

(1980), 283(5749), 743-5.

3. Stereochemistry of nucleic acids and polynucleotides. Lakshimanarayanan, A.V.; Sasisekharan, V. Biochim.

Biophys. Acta 204, 49-53.

4. Fuller, W., Wilkins, M.H.F., Wilson, H.R., Hamilton, L.D. and Arnott, S. (1965). J. Mol. Biol. 12, 60.

5. Arnott, S.; Campbell Smith, P.J.; Chandraseharan, R. in Handbook of Biochemistry and Molecular Biology,

3rd Edition. Nucleic Acids–Volume II, Fasman, G.P., ed. (Cleveland: CRC Press, 1976), pp. 411-422.

38.5. Symmetry Functions

Here we describe a set of NAB routines that provide an interface for rigid-body transformations based on crys-
tallographic, point-group, or other symmetries. These are primarily higher-level ways to creating and manipulating
sets of transformation matrices corresponding to common types of symmetry operations.

38.5.1. Matrix Creation Functions

int MAT_cube( point pts[3], matrix mats[24] )
int MAT_ico( point pts[3], matrix mats[60] )
int MAT_octa( point pts[3], matrix mats[24] )
int MAT_tetra( point pts[3], matrix mats[12] )
int MAT_dihedral( point pts[3], int nfold, matrix mats[1] )
int MAT_cyclic( point pts[2], ﬂoat ang, int cnt, matrix mats[1] )
int MAT_helix( point pts[2], ﬂoat ang, ﬂoat dst, int cnt, matrix mats[1] )
int MAT_orient( point pts[4], ﬂoat angs[3], matrix mats[1] )
int MAT_rotate( point pts[2], ﬂoat ang, matrix mats[1] )
int MAT_translate( point pts[2], ﬂoat dst, matrix mats[1] )

These two groups of functions produce arrays of matrices that can be applied to objects to generate point group
symmetries (ﬁrst group) or useful transformations (second group). The operations are deﬁned with respect to a
center and a set of axes speciﬁed by the points in the array pts[]. Every function requires a center and one axis

818

38.5. Symmetry Functions

which are pts[1] and the vector pts[1]→pts[2]. The other two points (if required) deﬁne two additional directions:
pts[1]→pts[3] and pts[1]→pts[4]. How these directions are used depends on the function.

The point groups generated by the functions MAT_cube(), MAT_ico(), MAT_octa() and MAT_tetra() have three
internal 2-fold axes. While these 2-fold are orthogonal, the 2 directions speciﬁed by the three points in pts[] need
only be independent (not parallel). The 2-fold axes are constructed in this fashion. Axis-1 is along the direction
pts[1]→pts[2]. Axis-3 is along the vector pts[1]→pts[2] × pts[1]→pts[3] and axis-2 is recreated along the vector
axis-3 × axis-1. Each of these four functions creates a ﬁxed number of matrices.

Dihedral symmetry is generated by an N-fold rotation about an axis followed by a 2-fold rotation about a second
axis orthogonal to the ﬁrst axis. MAT_dihedral() produces matrices that generate this symmetry. The N-fold axis
is pts[0]→pts[1] and the second axis is created by the same orthogonalization process described above. Unlike
the previous point group functions the number of matrices created by MAT_dihedral() is not ﬁxed but is equal to
2× n f old.
MAT_cyclic() creates cnt matrices that produce uniform rotations about the axis pts[1]→pts[2]. The rotations are
in multiples of the angle ang beginning with o, and increasing by ang until cnt matrices have been created. cnt is
required to be > 0, but ang can be 0, in which case MAT_cyclic returns cnt copies of the identity matrix.
MAT_helix() creates cnt matrices that produce a uniform helical twist about the axis pts[1]→pts[2]. The rotations
are in multiples of ang and the translations in multiples of dst. cnt must be > 0, but either ang or dst or both may
be zero. If ang is not 0, but dst is, MAT_helix() produces a uniform plane rotation and is equivalent to MAT_cyclic().
An ang of 0 and a nonzero dst produces matrices that generate a uniform translation along the axis. If both ang
and dst are 0, the MAT_helix() creates cnt copies of the identity matrix.

The three functions MAT_orient(), MAT_rotate() and MAT_translate() are not really symmetry operations but are
auxiliary operations that are useful for positioning the objects which are to be operated on by the true symmetry
operators. Two of these functions MAT_rotate() and MAT_translate() produce a single matrix that either rotates or
translates an object along the axis pts[1]→pts[2]. A zero ang or dst is acceptable in which case the function creates
an identity matrix. Except for a different user interface these two functions are equivalent to the nab builtins rot4p()
and tran4p().
MAT_orient() creates a matrix that rotates a object about the three axes pts[1]→pts[2], pts[1]→pts[3] and
pts[1]→pts[4]. The rotations are speciﬁed by the values of the array angs[], with ang[1] the rotation about axis-1
etc. The rotations are applied in the order axis-3, axis-2, axis-1. The axes remained ﬁxed throughout the operation
and zero angle values are acceptable. If all three angles are zero, MAT_orient() creates an identity matrix.

38.5.2. Matrix I/O Functions

int MAT_fprint( ﬁle f, int nmats, matrix mats[1] )
int MAT_sprint( string str, int nmats, matrix mats[1] )
int MAT_fscan( ﬁle f, int smats, matrix mats[1] )
int MAT_sscan( string str, int smats, matrix mats[1] )
string MAT_getsyminfo()

This group of functions is used to read and write nab matrix variables. The two functions MAT_fprint() and
MAT_sprint() write the the matrix to the ﬁle f or the string str. The number of matrices is speciﬁed by the pa-
rameter nmats and the matrices are passed in the array mats[].

The two functions MAT_fscan() and MAT_sscan() read matrices from the ﬁle f or the string str into the array
mats[]. The parameter smats is the size of the matrix array and if the source ﬁle or string contains more than smats
only the ﬁrst smats will be returned. These two functions return the number of matrices read unless there the
number of matrices is greater than smat or the last matrix was incomplete in which case they return -1.

In order to understand the last function in this group, MAT_getsyminfo(), it is necessary to discuss both the
internal structure the nab matrix type and one of its most important uses. The nab matrix type is used to hold
transformation matrices. Although these are atomic objects at the nab level, they are actually 4× 4 matrices where
the ﬁrst three elements of the fourth row are the X Y and Z components of the translation part of the transformation.
The matrix print functions write each matrix as four lines of four numbers separated by a single space. Similarly
the matrix read functions expect each matrix to be represented as four lines of four white space (any number of tabs
and spaces) separated numbers. The print functions use %13.6e for each number in order to produce output with

819

38. NAB and sff

aligned columns, but the scan functions only require that each matrix be contained in four lines of four numbers
each.

Most nab programs use matrix variables as intermediates in creating structures. The structures are then saved
and the matrices disappear when the program exits. Recently nab was used to create a set of routines called
a “symmetry server”. This is a set of nab programs that work together to create matrix streams that are used
to assemble composite objects. In order to make it most general, the symmetry server produces only matrices
leaving it to the user to apply them. Since these programs will be used to create hierarchies of symmetries or
transformations we decided that the external representation (ﬁles or strings) of matrices would consist of two kinds
of information — required lines of row values and optional lines beginning with the character # some of which are
used to contain information that describes how these matrices were created.

MAT_getsyminfo() is used to extract this symmetry information from either a matrix ﬁle or a string that holds the
contents of a matrix ﬁle. Each time the user calls MAT_fscan() or MAT_sscan(), any symmetry information present
in the source ﬁle or string is saved in private buffer. The previous contents of this buffer are overwritten and lost.
MAT_getsyminfo() returns the contents of this buffer. If the buffer is empty, indicating no symmetry information
was present in either the source ﬁle or string, MAT_getsyminfo() returns NULL.

38.6. Symmetry server programs

This section describes a set of nab programs that are used together to create composite objects described by
a hierarchical nest of transformations. There are four programs for creating and operating on transformation
matrices: matgen, matmerge, matmul and matextract, a program, transform, for transforming PDB or point ﬁles,
and two programs, tss_init and tss_next for searching spaces deﬁned by transformation hierarchies. In addition
to these programs, all of this functionality is available directly at the nab level via the MAT_ and tss_ builtins
described above.

38.6.1. matgen

The program matgen creates matrices that correspond to a symmetry or transformation operation. It has one

required argument, the name of a ﬁle containing a description of this operation. The created matrices are written
to stdout. A single matgen may be used by itself or two or more matgen programs may be connected in a pipeline
producing nested symmetries.

matgen -create sydef-1 | matgen symdef-2 | ... | matgen symdef-N

Because a matgen can be in the middle of a pipeline, it automatically looks for an stream of matrices on stdin. This
means the ﬁrst matgen in a pipeline will wait for an EOF (generally Ctl-D) from the terminal unless connected
to an empty ﬁle or equivalent. In order to avoid the nuisance of having to create an empty matrix stream the ﬁrst
matgen in a pipeline should use the -create ﬂag which tells matgen to ignore stdin.

If input matrices are read, each input matrix left multiplies the ﬁrst generated matrix, then the second etc. The

table below shows the effect of a matgen performing a 2-fold rotation on an input stream of three matrices.

Input:
Operation:
Output:

IM1, IM2, IM3
2-fold rotation: R1, R2
IM1 × R1, IM2 × R1, IM3 × R1, IM1 × R2, IM2 × R2, IM3 × R2

38.6.2. Symmetry Deﬁnition Files

Transformations are speciﬁed in text ﬁles containing several lines of keyword/value pairs. These lines deﬁne
the operation, its associated axes and other parameters such as angles, a distance or count. Most keywords have
a default value, although the operation, center and axes are always required. Keyword lines may be in any order.
Blank lines and most lines starting with a sharp (#) are ignored. Lines beginning with #S{, #S+ and #S} are structure
comments that describe how the matrices were created. These lines are required to search the space deﬁned by
the transformation hierarchy and their meaning and use is covered in the section on “Searching Transformation
Spaces”. A complete list of keywords, their acceptable values and defaults is shown below.

820

38.6. Symmetry server programs

Possible Values
cube, cyclic, dihedral, dodeca, helix, ico, octa, tetra.
orient, rotate, translate.
Any string of nonblank characters.
true, false.
absolute, relative.
Any three numbers separated by tabs or spaces.

Any number.

Any integer.

Default Value

None
None
mPid
false
relative
None
None
None
None

0
0
0
0
1

Keyword
symmetry
transform

name
noid

axestype
center

axis, axis1

axis2
axis3

angle,angle1

angle2
angle3

dist
count

axis and axis1 are synonyms as are angle and angle1.
The symmetry and transform keywords specify the operation. One or the other but not both must be speciﬁed.
The name keyword names a particular symmetry operation. The default name is m immediately followed by
the process ID, eg m2286. name is used by the transformation space search routines tss_init and tss_next and is
described later in the section “Searching Transformation Spaces”.

The noid keyword with value true suppresses generation of the identity matrix in symmetry operations. For

example, the keywords below

symmetry cyclic
noid false
center 0 0 0
axis 0 0 1
count 3

produce three matrices which perform rotations of 0o, 120o and 240o about the Z-axis. If noid is true, only the
two non-identity matrices are created. This option is useful in building objects with two or three orthogonal 2-fold
axes and is discussed further in the example “Icosahedron from Rotations”. The default value of noid is false.

The axestype, center and axis* keywords deﬁned the symmetry axes. The center and axis* keywords each
require a point value which is three numbers separated by tabs or spaces. Numbers may integer or real and in ﬁxed
or exponential format. Internally all numbers are converted to nab type ﬂoat which is actually double precision.
No space is permitted between the minus sign of a negative number and the digits.
The interpretation of these points depends on the value of the keyword axestype. If it is absolute then the axes
are deﬁned as the vectors center→axis1, center→axis2 and center→axis3. If it relative, then the axes are vectors
whose directions are O→axis1, O→axis2 and O→axis3 with their origins at center. If the value of center is 0,0,0,
then absolute and relative are equivalent. The default value axestype is relative; center and the axis* do not have
defaults.

The angle keywords specify the rotation about the axes. angle1 is associated with axis1 etc. Note that angle and
angle1 are synonyms. The angle is in degrees, with positive being in the counterclockwise direction as you sight
from the axis point to the center point. Either an integer or real value is acceptable. No space is permitted between
the minus sign of a negative number and its digits. All angle* keywords have a default value of 0.

The dist keyword speciﬁes the translation along an axis. The positive direction is from center to axis. Either
integer or real value is acceptable. No space is permitted between the minus sign of a negative number and its
digits. The default value of dist is 0.

The count keyword is used in three related ways. For the cyclic value of the symmetry it speciﬁes ount matrices,
each representing a rotation of 360/count. It also speciﬁes the same rotations about the non 2-fold axis of dihedral
symmetry. For helix symmetry, it indicates that count matrices should be created, each with a rotation of angle. In
all cases the default value is 1.

This table shows which keywords are used and/or required for each type of operation.

821

38. NAB and sff

symmetry

cube
cyclic
dihedral
dodeca
helix
ico
octa
tetra

name
mPid
mPid
mPid
mPid
mPid
mPid
mPid
mPid
transform name
mPid
mPid
mPid

orient
rotate

translate

noid
false
false
false
false
false
false
false
false
noid

-
-
-

axestype
relative
relative
relative
relative
relative
relative
relative
relative
axestype
relative
relative
relative

center
Required
Required
Required
Required
Required
Required
Required
Required
center
Required
Required
Required

axes
1,2
1
1,2
1,2
1
1,2
1,2
1,2
axes
All
1
1

angles

dist

count

-
-
-
-

-
-
-

1,D=0

-
-
-
-

-
-
-

D=0

-

D=1
D=1

-

D=1

-
-
-

angles
All,D=0
1,D=0

-

dist

count

-
-

D=0

-
-
-

38.6.3. matmerge

The matmerge program combines 2-4 ﬁles of matrices into a single stream of matrices written to stdout. Input

matrices are in ﬁles whose names are given on as arguments on the matmerge command line. For example, the
command line below

matmerge A.mat B.mat C.mat

copies the matrices from A.mat to stdout, followed by those of B.mat and ﬁnally those of C.mat. Thus matmerge
is similar to the Unix cat command. The difference is that while they are called matrix ﬁles, they can contain
special comments that describe how the matrices they contain were created. When matrix ﬁles are merged, these
comments must be collected and grouped so that they are kept together in any further matrix processing.

38.6.4. matmul

The matmul program takes two ﬁles of matrices, and creates a new stream of matrices formed by the pair wise
product of the matrices in the input streams. The new matrices are written to stdout. If the number of matrices in
the two input ﬁles differ, the last matrix of the shorter ﬁle is replicated and applied to all remaining matrices of the
longer ﬁle. For example, if the ﬁle 3.mat has three matrices and the ﬁle 5.mat has ﬁve, then the command “matmul
3.mat 5.mat” would result in the third matrix of 3.mat multiplying the third, forth and ﬁfth matrices of 5.mat.

38.6.5. matextract

The matextract is used to extract matrices from the matrix stream presented on stdin and writes them to stdout.
Matrices are numbered from 1 to N, where N is the number of matrices in the input stream. The matrices are
selected by giving their numbers as the arguments to the matextract command. Each argument is comma or space
separated list of one or more ranges, where a range is either a number or two numbers separated by a dash (-). A
range beginning with - starts with the ﬁrst matrix and a range ending with - ends with the last matrix. The range -
selects all matrices. Here are some examples.

Command
matextract 2
matextract 2,5
matextract 2 5
matextract 2-5
matextract -5
matextract 2-
matextract -
matextract 2-4,7 13 15,19-

Action
Extract matrix number 2.
Extract matrices number 2 and 5.
Extract matrices number 2 and 5.
Extract matrices number 2 up to and including 5.
Extract matrices 1 to 5.
Extract all matrices beginning with number 2.
Extract all matrices.
Extract matrices 2 to 4, 7, 13, 15 and all matrices numbered 19
or higher.

822

38.6. Symmetry server programs

38.6.6. transform

The transform program applies matrices to an object creating a composite object. The matrices are read from
stdin and the new object is written to stdout. transform takes one argument, the name of the ﬁle holding the object
to be transformed. transform is limited to two types of objects, a molecule in PDB format, or a set of points in a
text ﬁle, three space/tab separated numbers/line. The name of object ﬁle is preceded by a ﬂag specifying its type.

Command

transform -pdb X.pdb
transform -point X.pts

Action
Transform a PDB format ﬁle.
Transform a set of points.

823

39. libsff: Molecular mechanics and dynamics

The initial models created by rigid-body transformations or distance geometry are often in need of further
reﬁnement, and molecular mechanics and dynamics can often be useful here. nab has facilities to allow molecular
mechanics and molecular dynamics calculations to be carried out. At present, this uses the AMBER program
LEaP to set up the parameters and topology; the force ﬁeld calculations and manipulations like minimization and
dynamics are done by routines in the nab suite. A version of LEaP is included in the NAB distribution, and is
accessed by the leap() discussed below. A later chapter gives a more detailed description.

39.1. Basic molecular mechanics routines

int readparm( molecule m, string parmﬁle );
int mme_init( molecule mol, string aexp, string aexp2, point xyz_ref[], string ﬁlename );
int mm_options( string opts );
ﬂoat mme( point xyz[], point grad[], int iter );
ﬂoat mme_rattle( point xyz[], point grad[], int iter );
int conjgrad( ﬂoat x[], int n, ﬂoat fret, ﬂoat func(), ﬂoat rmsgrad,

ﬂoat dfpred, int maxiter );

int md( int n, int maxstep, point xyz[], point f[], ﬂoat v[], ﬂoat func );
int getxv( string ﬁlename, int natom, ﬂoat start_time, ﬂoat x[], ﬂoat v[] );
int putxv( string ﬁlename, string title, int natom, ﬂoat start_time,

ﬂoat x[], ﬂoat v[] );

void mm_set_checkpoint( string ﬁlename );

readparm reads an AMBER parameter-topology ﬁle, created by tleap or with other AMBER programs, and sets
up a data structure which we call a "parmstruct". This is part of the molecule, but is not directly accessible (yet)
to nab programs. You would use this command as an alternative to getpdb_prm(). You need to be sure that the
molecule used in the readparm() call has been created by calling getpdb() with a PDB ﬁle that has been created by
tleap itself (i.e., that has exactly the Amber atoms in the correct order). As noted above, the readparm() routine is
primarily intended for cases where getpdb_prm() fails (i.e., when you need to run tleap by hand).

setxyz_from_mol() copies the atomic coordinates of mol to the array xyz. setmol_from_xyz() replaces the atomic
coordinates of mol with the contents of xyz. Both return the number of atoms copied with a 0 indicating an error
occurred.

The getxv() and putxv() routines read and write non-periodic Amber-style restart ﬁles. Velocities are read if

present.

The getxyz() and putxyz() routines are used in conjunction with the mm_set_checkpoint() routine to write check-
point or restart ﬁles. The coordinates are written at higher precision than to an AMBER restart ﬁle, i.e., with
sufﬁciently high precision to restart even a Newton-Raphson minimization where the error in coordinates may be
on the order of10−12 . The checkpoint ﬁles are written at iteration intervals that are speciﬁed by the nchk or nchk2
parameters to the mm_options() routine (see below). The checkpoint ﬁle names are determined by the ﬁlename
string that is passed to mm_set_checkpoint(). If ﬁlename contains one or more %d format speciﬁers, then the ﬁle
name will be a modiﬁcation of ﬁlename wherein the leftmost %d of ﬁlename is replaced by the iteration count. If
ﬁlename contains no %d format speciﬁer, then the ﬁle name will be ﬁlename with the iteration count appended on
the right.

The mme_init() function must be called after mm_options() and before calls to mme(). It sets up parameters
for future force ﬁeld evaluations, and takes as input an nab molecule. The string aexp is an atom expression that
indicates which atoms are to be allowed to move in minimization or dynamics: atoms that do not match aexp will

824

39.1. Basic molecular mechanics routines

have their positions in the gradient vector set to zero. A NULL atom expression will allow all atoms to move. The
second string, aexp2 identiﬁes atoms whose positions are to be restrained to the positions in the array xyz_ref. The
strength of this restraint will be given by the wcons variable set in mm_options(). A NULL value for aexp2 will
cause all atoms to be constrained. The last parameter to mme_init() is a ﬁle name without extension for the output
trajectory ﬁle. This should be NULL if no output ﬁle is desired. NAB writes trajectories in the netCDF format,
which can be read by cpptraj, and either analyzed, or converted to another format. The default netCDF extension
of .nc is automatically added to the ﬁle name.

mm_options() is used to set parameters, and must be called before mme_init(); if you change options through
a call to mm_options() without a subsequent call to mme_init() you may get incorrect calculations with no error
messages. Beware. The opts string contains keyword/value pairs of the form keyword=value separated by white
space or commas. Allowed values are shown in the following table.

keyword

ntpr

e_debug
gb_debug
gb2_debug

nchk

nchk2

nsnb
nscm

cut

wcons

dim
k4d

dt
t

rattle

default

10
0
0
0

10000

10000

25
0

8.0

0.0

3
1.0

0.001
0.0
0

meaning
Frequency of printing of the energy and its components.
If nonzero printout additional components of the energy.
If nonzero printout information about Born ﬁrst derivatives.
If nonzero printout information about Born second derivatives.
Frequency of writing checkpoint ﬁle during ﬁrst derivative
calculation, i.e., in the mme() routine.
Frequency of writing checkpoint ﬁle during second derivative
calculation, i.e., in the mme2() routine.
Frequency at which the non-bonded list is updated.
If > 0, remove translational and rotational center-of-mass
(COM) motion after every nscm steps. For Langevin dynamics
(gamma_ln>0) without HCP (hcp=0), the position of the COM
is reset to zero every nscm steps, but the velocities are not
affected. With HCP (hcp>0) COM translation and rotation are
also removed, with or without Langevin dynamics.
It is strongly recommended that this option be used whenever
HCP is used.
Non-bonded cutoff, in angstroms. This parameter is ignored if
hcp > 0.
Restraint weight for keeping atoms close to their positions in
xyz_ref (see mme_init).
Number of spatial dimensions; supported values are 3 and 4.
Force constant for squeezing out the fourth dimensional
coordinate, if dim=4. If this is nonzero, a penalty function will
be added to the bounds-violation energy, which is equal to 0.5
* k4d * w * w, where w is the value of the fourth dimensional
coordinate.
Time step, ps.
Initial time, ps.
If set to 1, bond lengths will be constrained to their equilibrium
values, for dynamics; if set to 2, bonds to hydrogens will be
constrained; default is not to include such constraints. Note: if
you want to use rattle (effectively "shake") for minimization,
you do not need to set this parameter; rather, pass the
mme_rattle() function to conjgrad().

825

39. libsff: Molecular mechanics and dynamics

keyword
tautp

default
999999.

gamma_ln

0.0

temp0
vlimit

ntpr_md

ntwx
zerov
tempi

genmass

diel

dielc

gb

300.0
20.0

10
0
0
0.0

10.0

C

1.0

0

meaning
Temperature coupling parameter, in ps. The time constant
determines the strength of the weak-coupling ("Berendsen")
temperature bath.[404] Set tautp to a very large value (e.g.
9999999.) in order to turn off coupling and revert to
Newtonian dynamics. This variable only has an effect if
gamma_ln remains at its default value of zero; if gamma_ln is
not zero, Langevin dynamics is assumed, as discussed below.
Collision frequency for Langevin dynamics, inps−1 . Values in
the range 2-5ps−1 often give acceptable temperature control,
while allowing transitions to take place.[414] Values near
50ps−1 correspond to the collision frequency for liquid water,
and may be useful if rough physical time scales for motion are
desired. The so-called BBK integrator is used here.[724]
Target temperature, K.
Maximum absolute value of any component of the velocity
vector.
Printing frequency for dynamics information to stdout.
Frequency for dumping coordinates to traj_ﬁle.
If nonzero, then the initial velocities will be set to zero.
If zerov=0 and tempi>0, then the initial velocities will be
randomly chosen for this temperature. If both zerov and tempi
are zero, the velocities passed into the md() function will be
used as the initial velocities; this combination is useful to
continue an existing trajectory.
The general mass to use for MD if individual masses are not
read from a prmtop ﬁle; value in amu.
Code for the dielectric model. "C" gives a dielectric constant
of 1; "R" makes the dielectric constant equal to distance in
angstroms; "RL" uses the sigmoidal function of Ramstein &
Lavery, PNAS 85, 7231 (1988); "RL94" is the same thing, but
speeded up assuming one is using the Cornell et al force ﬁeld;
"R94" is a distance-dependent dielectric, again with speedups
that assume the Cornell et al. force ﬁeld.
This is the dielectric constant used for non-GB simulations. It
is implemented in routine mme_init() by scaling all of the
charges by sqrt(dielc). This means that you need to set this (if
desired) in mm_options() before calling mme_init().
If set to 0 then GB is off. Setting gb=1 turns on the Hawkins,
Cramer, Truhlar (HCT) form of pairwise generalized Born
model for solvation. See ref [198] for details of the
implementation; this is equivalent to the igb=1 option in
sander and pmemd. Set diel to "C" if you use this option.
Setting gb=2 turns on the Onufriev, Bashford, Case (OBC)
variant of GB,[177, 182] with α=0.8, β =0.0 and γ=2.909. This
is equivalent to the igb=2 option in sander and pmemd. Setting
gb=5 just changes the values of α, β and γ to 1.0, 0.8, and
4.85, respectively, corresponding to the igb=5 option in
sander. Setting gb=7 turns on the GB Neck variant of
GB,[200] corresponding to the igb=7 option in sander and
pmemd. Setting gb=8 turns on the updated GB Neck variant of
GB, corresponding to the igb=8 option in sander and pmemd.

826

keyword
rgbmax

default
999.0

gbsa

0

surften
epsext

kappa

ipb

inp

epsin

epsout

smoothopt

istrng
radiopt

dprob

iprob

npbopt

solvopt

accept

maxitn

0.005
78.5

0.0

0

2

1.0

80.0

1

0.0
1

1.4

2.0

0

1

0.001

100

39.1. Basic molecular mechanics routines

meaning
A maximum value for considering pairs of atoms to contribute
to the calculation of the effective Born radii. The default value
means that there is effectively no cutoff. Calculations will be
sped up by using smaller values, say around 15. Å or so. This
parameter is ignored if hcp > 0.
If set to 1, add a surface-area dependent energy equal to
surfen*SASA, where surften is discussed below, and SASA is
an approximate surface area term. NAB uses the "LCPO"
approximation developed by Weiser, Shenkin, and Still.[170]
Surface tension (see gbsa, above) in kcal/mol/Å2.
Exterior dielectric for generalized Born; interior dielectric is
always 1.
Inverse of the Debye-Hueckel length, if gb is turned on, in
Å−1. This parameter is related to the ionic strength as
κ = [8πβ I/ε]1/2, where I is the ionic strength (same as the salt
concentration for a 1-1 salt). For T =298.15 and ε=78.5,
κ = (0.10806I)1/2, where I is in [M].
Switch to compute electrostatic solvation free energy. If set to
0 then PBSA is off. This is equivalent to the ipb option in pbsa.
Possible values: 0, 1, 2, and 4. See PBSA chapter for more
information.
Option to select different methods to compute non-polar
solvation free energy. This is equivalent to the inp option in
pbsa. Possible values: 0, 1, and 2. See PBSA chapter for more
information.
Sets the dielectric constant of the solute region. The solute
region is deﬁned to be the solvent excluded volume.
Sets the implicit solvent dielectric constant. The solvent region
is deﬁned to be the space not occupied the solute region. Thus,
only two dielectric regions are allowed in the current release.
Instructs PB how to set up dielectric values for ﬁnite-difference
grid edges that are located across the solute/solvent dielectric
boundary.
Sets the ionic strength (in mM) for the PB equation.
Option to set up atomic radii. This is equivalent to the radiopt
option in pbsa. Possible values: 0, and 1. See PBSA chapter
for more information.
Solvent probe radius for molecular surface used to deﬁne the
dielectric boundary between solute and solvent. If set 0.0, it
would be later assigned to the value of sprob.
Mobile ion probe radius for ion accessible surface used to
deﬁne the Stern layer.
Option to select the linear or the full nonlinear PB equation.
= 0 Linear PB equation is solved.
= 1 Nonlinear PB equation is solved.
Option to select iterative solvers. This is equivalent to the
solvopt option in pbsa. Possible values: 1, 2, 3, 4, 5, and 6. See
PBSA chapter for more information.
Sets the iteration convergence criterion (relative to the initial
residue).
Sets the maximum number of iterations for the ﬁnite difference
solvers, default to 100.

827

39. libsff: Molecular mechanics and dynamics

keyword
ﬁllratio

space
nfocus

fscale

bcopt

eneopt

dbfopt
frcopt

cutnb

sprob

npbverb
arcres

maxarcdot

npbgrid

irism

xvvﬁle

guvﬁle

huvﬁle

cuvﬁle

default

2.0

0.5
2

8

5

2

n/a
0

0.0

0.557

0

0.25

1500

1

0

n/a

n/a

n/a

n/a

meaning
The ratio between the longest dimension of the rectangular
ﬁnite-difference grid and that of the solute.
Sets the grid spacing for the ﬁnite difference solver.
Set how many successive FD calculations will be used to
perform an electrostatic focussing calculation on a molecule.
Possible values: 1 and 2.
Set the ratio between the coarse and ﬁne grid spacings in an
electrostatic focussing calculation.
Boundary condition options. This is equivalent to the bcopt
option in pbsa. Possible values: 1, 5, 6, and 10. See PBSA
chapter for more information.
Option to compute total electrostatic energy and forces. This is
equivalent to the eneopt option in pbsa. Possible values: 1, and
2. See PBSA chapter for more information.
This keyword is phased out in this release.
Option to compute and output electrostatic forces to a ﬁle
named force.dat in the working directory. This is equivalent to
the frcopt option in pbsa. Possible values: 0, 1, 2, and 3. See
PBSA chapter for more information.
Atom-based cutoff distance for van der Waals interactions, and
pairwise Coulombic interactions when ENEOPT = 2. When
ENEOPT = 1, this is the cutoff distance used for van der Waals
interactions only.
Solvent probe radius for solvent accessible surface area
(SASA) used to compute the dispersion term.
This turns on verbose mode in PB when set to 1.
gives the resolution (in the unit of Å) of dots used to represent
solvent accessible arcs.
1500 actually means automatically determine number of arc
dots required for solvent accessible surface, might grow too
large to ﬁt machines with less available memory. Please assign
it to 4000~7000 and see if it ﬁts into your computers.
How many step do pbsa wait to re-calculate the geometry in a
simulation, npbgrid = 1 is required to do trajectory evaluation.
npbgrid is recommended to be 100 if “conjgrad” is used.
Use 3D-RISM.
= 0 Off.

= 1 On.

.xvv ﬁle which describes bulk solvent properties. Required for
3D-RISM calculations. Produced by rism1d.
Root name for solute-solvent 3D pair distribution function,
GUV (R). This will produce one ﬁle for each solvent atom type
for each frame requested.
Rootname for solute-solvent 3D total correlation function,
HUV(R). This will produce one ﬁle for each solvent atom type
for each frame requested.
Rootname for solute-solvent 3D total correlation function,
CUV(R). This will produce one ﬁle for each solvent atom type
for each frame requested.

828

39.1. Basic molecular mechanics routines

keyword
quvﬁle

chgdist

uuvﬁle

asympﬁle

exchemﬁle
solveneﬁle
entropyﬁle
potUVﬁle

molReconstruct

volfmt

default

n/a

n/a

n/a

n/a

n/a
n/a
n/a
n/a

1

dx

meaning
Rootname for solvent 3D charge density distribution [e/Å].
This will produce one ﬁle with contributions from each solvent
atom type for each frame requested.
Rootname for solvent 3D charge distribution [e]. This will
produce one ﬁle with contributions from each solvent atom
type for each frame requested.
Rootname for solute-solvent 3D potential energy, U UV(R).
This will produce one ﬁle for each solvent atom type for each
frame requested.
Rootname for solute-solvent 3D long range real-space
asymptotics for C and H. This will produce one ﬁle for C and
H for each frame requested.
Root name for 3D excess chemical potential distribution ﬁles.
Root name for 3D solvation energy distribution ﬁles.
Root name for 3D solvation entropy distribution ﬁles.
Root name for 3D solute-solvent potential energy distribution
ﬁles.
For any thermodynamic distributions requested, also out the
molecular reconstruction (see section 7.1.5).
Output format for volumetric data.

= dx DX format.

= xyzv XYZV format.

closure

KH

Comma separate list of closure approximations.

= HNC Hyper-netted chain equation (HNC).

= KH Kovalenko-Hirata (KH).

= PSEn Partial series expansion of order n where “n” is a

positive integer.

If more than one closure is provided, the 3D-RISM solver will
use the closures in order to obtain a solution for the last closure
in the list when no previous solutions are available. The
solution for the last closure in the list is used for all output.
(Deprecated) Order for PSE-n closure if closure is speciﬁed as
“PSE” or “PSEN” (no integers).
Cut-off distance for solvent-solute potential and force
calculations. solvcut must be explicitly set if buffer< 0. For
minimization it is recommended to not use a cut-off (e.g.
solvcut=9999).
Minimum distance in Å between the solute and the edge of the
solvent box.

< 0 Use ﬁxed box size (ng3 and solvbox).

>= 0 Buffer distance.

closureorder

solvcut

1

buffer

buffer

14

grdspc

0.5

Linear grid spacing in x-, y- and z-dimensions [Å]. May be
speciﬁed as single number if all dimensions have the same
value. E.g., ‘grdspc=0.5’ is equivalent to ‘grdspc=0.5,0.5,0.5’.

829

39. libsff: Molecular mechanics and dynamics

keyword

ng

default

n/a

solvbox

n/a

tolerance

1e-5

meaning
Sets the number of grid points for a ﬁxed size solvation box.
May be speciﬁed as single integer if all dimensions have the
same value. E.g., ‘ng=64’ is equivalent to ‘ng=64,64,64’.
Sets the size in Å of the ﬁxed size solvation box. May be
speciﬁed as single number if all dimensions have the same
value. E.g., ‘solvbox=32.0’ is equivalent to
‘solvbox=32.0,32.0,32.0’.
A list of maximum residual values for solution convergence.
When used in combination with a list of closures it is possible
to deﬁne different tolerances for each of the closures. This can
be useful for difﬁcult to converge calculations (see §7.3.1). For
the sake of efﬁciency, it is best to use as high a tolerance as
possible for all but the last closure. For minimization a
tolerance of 1e-11 or lower is recommended. Three formats of
list are possible.

one tolerance All closures but the last use a tolerance of 1.

The last tolerance in the list is used by the last
closure. In practice this, is the most efﬁcient.

two tolerances All closures but the last use the ﬁrst

tolerance in the list. The last tolerance in the list
is used by the last closure.

n tolerances Tolerances from the list are assigned to the

closure list in order.

ljTolerance

asympKSpaceTolerance

-1

-1

Determines the Lennard-Jones cutoff distance based on the
desired accuracy of the calculation. See §7.2.3 for details on
how this affects numerical accuracy and how this interacts with
tolerance, buffer, and solvbox.
Determines the reciprocal space long range asymptotics cutoff
distance based on the desired accuracy of the calculation. See
§7.2.3 for details on how this affects numerical accuracy.
Possible values are

< 0

0

> 0

asympKSpaceTolerance=tolerance/10,

no cutoff, and

given value determines the maximum error in the
reciprocal-space long range asymptotics
calculations.

treeDCF

1

Use direct sum or the treecode approximation to calculate the
direct correlation function long-range asymptotic correction.

0 Use direct sum.

1 Use treecode approximation.

830

39.1. Basic molecular mechanics routines

keyword
treeTCF

treeCoulomb

treeDCFMAC

treeTCFMAC

treeCoulombMAC

treeDCFOrder

treeTCFOrder

treeCoulombOrder

treeDCFN0

treeTCFN0

treeCoulombN0

mdiis_del
mdiis_nvec

mdiis_restart

default

1

0

0.1

0.1

0.1

2

2

2
500

500

500

0.7
5

10

meaning
Use direct sum or the treecode approximation to calculate the
total correlation function long-range asymptotic correction.

0 Use direct sum.

1 Use treecode approximation.

Use direct sum or the treecode approximation to calculate the
Coulomb potential energy.

0 Use direct sum.

1 Use treecode approximation.

Treecode multipole acceptance criterion for the direct
correlation function long-range asymptotic correction.
Treecode multipole acceptance criterion for the total
correlation function long-range asymptotic correction.
Treecode multipole acceptance criterion for the Coulomb
potential energy.
Treecode Taylor series order for the direct correlation function
long-range asymptotic correction.
Treecode Taylor series order for the total correlation function
long-range asymptotic correction. Note that the Taylor
expansion used does not converge exactly to the TCF
long-range asymptotic correction, so a very high order will not
necessarily increase accuracy.
Treecode Taylor series order for the Coulomb potential energy.
Maximum number of grid points contained within the treecode
leaf clusters for the direct correlation function long-range
asymptotic correction. This sets the depth of the hierarchical
octtree.
Maximum number of grid points contained within the treecode
leaf clusters for the total correlation function long-range
asymptotic correction. This sets the depth of the hierarchical
octtree.
Maximum number of grid points contained within the treecode
leaf clusters for the Coulomb potential energy. This sets the
depth of the hierarchical octtree.
“Step size” in MDIIS.
Number of vectors used by the MDIIS method. Higher values
for this parameter can greatly increase memory requirements
but may also accelerate convergence.
If the current residual is mdiis_restart times larger than the
smallest residual in memory, then the MDIIS procedure is
restarted using the lowest residual solution stored in memory.
Increasing this number can sometimes help convergence.

831

39. libsff: Molecular mechanics and dynamics

keyword

mdiis_method

default

2

meaning
Specify implementation of the MDIIS routine.

= 0 Original reference implementation.

= 1 BLAS optimized.

= 2 BLAS and memory optimized.

maxstep

npropagate

centering

5

1

10000 Maximum number of iterations allowed to converge on a

solution.
Number of previous solutions propagated forward to create an
initial guess for this solute atom conﬁguration.

= 0 Do not use any previous solutions

= 1..5 Values greater than 0 but less than 4 or 5 will use less

system memory but may introduce artifacts to the
solution (e.g., energy drift).

Controls how the solute is centered/re-centered in the solvent
box. (See Subsection 7.5.1.)

= -4 Center-of-geometry with grid-point rounding. Center on

ﬁrst step only.

= -3 Center-of-mass with grid-point rounding. Center on ﬁrst

step only.

= -2 Center-of-geometry. Center on ﬁrst step only.

= -1 Center-of-mass. Center on ﬁrst step only.

= 0 No centering. Dangerous.

= 1 Center-of-mass. Center on every step. Recommended for

molecular dynamics.

= 2 Center-of-geometry. Center on every step. Recommended

for minimization.

= 3 Center-of-mass with grid-point rounding.

= 4 Center-of-geometry with grid-point rounding.

zerofrc

1

Redistribute solvent forces across the solute such that the net
solvation force on the solute is zero.

= 0 Unmodiﬁed forces.

= 1 Zero net force.

832

39.1. Basic molecular mechanics routines

keyword

apply_rism_force

default

1

meaning
Calculate and use solvation forces from 3D-RISM. Not
calculating these forces can save computation time and is
useful for trajectory post-processing.

ntwrism

ntprism

polarDecomp

entropicDecomp

gf

pcpluscorrection

0

0

0

0

0

0

uccoeff

0,0,0,0

= 0 Do not calculate forces.

= 1 Calculate forces.

Indicates that solvent density grid should be written to ﬁle
every ntwrism iterations.

= 0 No ﬁles written.

>= 1 Output every ntwrism time steps.

Indicates that 3D-RISM thermodynamic output should be
written to ﬁle every ntprism iterations.

= 0 No ﬁles written.

>= 1 Output every ntwrism time steps.

Decompose the solvation free energy into polar and non-polar
contributions. This is only useful if ntprism(cid:54)= 0 and adds about
80% to the total calculation time.

= 0 No decomposition.

= 1 Decomposition is performed.

Decomposes solvation free energy into energy and entropy
components. Also performs temperature derivatives of other
calculated quantities. Note that this typically requires 80%
more computation time and requires a .xvv ﬁle version 1.000 or
higher (see §7.1.3 and 7.3).

= 0 No entropic decomposition.

= 1 Entropic decomposition.

Compute the Gaussian ﬂuctuation excess chemical potential
functional (see §7.1.2).
Compute the PC+/3D-RISM excess chemical potential
functional (see §7.2.4).
Compute the UC excess chemical potential functional with the
provided coefﬁcients (see §7.2.4). a and b are the coefﬁcients
for the original UC functional, though using the closure excess
chemical potential functional. a1 and b1 are optional and
provide temperature dependence to the correction (UCT in
[275]).

833

39. libsff: Molecular mechanics and dynamics

keyword
verbose

default

0

meaning
Indicates level of diagnostic detail about the calculation written
to the log ﬁle.

= 0 No output.

= 1 Print the number of iterations required to converge.

= 2 Print details for each iteration and information about what

FCE is doing every progress iterations.

Display progress of the 3D-RISM solution every progress
iterations. 0 indicates this information will not be displayed.
Only used if verbose > 1.
If set to 1, do not allocate dynamic arrays for each call to the
mme() and mme2() functions. The default value of 1 reduces
computation time by avoiding array allocation.
The granularity with which loop iterations are assigned to
OpenMP threads or MPI processes. For MPI, a blocksize as
small as 1 results in better load balancing during parallel
execution. For OpenMP, blocksize should not be smaller than
the number of ﬂoating-point numbers that ﬁt into one cache
line in order to avoid performance degradation through ’false
sharing’. For ScaLAPACK, the optimum blocksize is not know,
although a value of 1 is probably too small.
Use the GB-HCP model:

1

1

8

0

progress

static_arrays

blocksize

hcp

= 0 No GB-HCP.

= 1 1-charge approximation.

= 2 2-charge approximation.

= 4 2-charge based on optimal point charge approximation

(recommended for GB-HCP).

See Section 39.5 for detailed instructions on using the
GB-HCP. It is strongly recommended that the NSCM option
above be used whenever GB-HCP is used.
Adjusts the separation between the charges used to
approximate uncharged components for hcp=4. dhcp is
empirically determined so that the RMS error in force,
compared to GB without further approximation, is minimized.
Our testing on various structures suggests that the optimal
value for dhcp can be found within the range of 0.1 and 0.4.
See Section 39.5 for details.
GB-HCP level 1 threshold distance. The recommended level 1
threshold distance for amino acids is 15A. For structures with
nucleic acids the recommended level 1 threshold distance is
21A.
GB-HCP level 2 threshold distance. The recommended level 2
threshold distance for proteins is 50A. For structures with
nucleic acids the recommended level 2 threshold distance is
90A.

dhcp

0.25

hcp_h1

hcp_h2

15

50

834

39.2. NetCDF read/write routines

keyword
hcp_h3

default

150

meaning
GB-HCP level 3 threshold distance. The recommended level 3
threshold distance for amino acids is 150A. For structures with
nucleic acids the recommended level 1 threshold distance is
169A.

The mme() function takes a coordinate set and returns the energy in the function value and the gradient of
the energy in grad. The input parameter iter is used to control printing (see the ntpr variable) and non-bonded
updates (see nsnb). The mme_rattle() function has the same interface, but constrains the bond lengths and returns
a corrected gradient. If you want to minimize with constrained bond lengths, pass mme_rattle and not mme to the
conjgrad routine.

The conjgrad() function will carry out conjugate gradient minimization of the function func that depends upon n
parameters, whose initial values are in the x array. The function func must be of the form func( x[], g[], iter ), where x
contains the input values, and the function value is returned through the function call, and its gradient with respect
to x through the g array. The iteration number is passed through iter, which func can use for whatever purpose it
wants; a typical use would just be to determine when to print results. The input parameter dfpred is the expected
drop in the function value on the ﬁrst iteration; generally only a rough estimate is needed. The minimization will
proceed until maxiter steps have been performed, or until the root-mean-square of the components of the gradient is
less than rmsgrad. The value of the function at the end of the minimization is returned in the variable fret. conjgrad
can return a variety of exit codes:

Return codes for conjgrad routine

>0 minimization converged; gives number of ﬁnal

iteration
bad line search; probably an error in the relation of
the function to its gradient (perhaps from round-off if
you push too hard on the minimization).
search direction was uphill
exceeded the maximum number of iterations
could not further reduce function value

-1

-2
-3
-4

Finally, the md function will run maxstep steps of molecular dynamics, using func as the force ﬁeld (this would
typically be set to a function like mme.) The number of dynamical variables is given as input parameter n: this
would be 3 times the number of atoms for ordinary cases, but might be different for other force ﬁelds or functions.
The arrays x[], f[] and v[] hold the coordinates, gradient of the potential, and velocities, respectively, and are updated
as the simulation progresses. The method of temperature regulation (if any) is speciﬁed by the variables tautp and
gamma_ln that are set in mm_options().

Note: In versions of NAB up to 4.5.2, there was an additional input variable to md() called minv that reserved
space for the inverse of the masses of the particles; this has now been removed. This change is not backwards
compatible: you must modify existing NAB scripts that call md() to remove this variable.

39.2. NetCDF read/write routines

NAB has several routines for reading/writing Amber NetCDF trajectory and restart ﬁles. All of the routines
except netcdfGetNextFrame() return a 1 on error, 0 on success. The netcdfGetNextFrame() routine returns 0 on
error, 1 on success to make it easier to use in loops. For an example of how to use NetCDF ﬁles in NAB see the
NAB script in ’$AMBERHOME/AmberTools/test/nab/tnetcdf.nab’.

39.2.1. struct AmberNetcdf

An AmberNetcdf struct must be used to interface with the netcdf commands in NAB (except netcdfWriteR-

estart()). It contains many ﬁelds, but the following are the ones commonly needed by users:

835

39. libsff: Molecular mechanics and dynamics

temp0 Temperature of current frame (if temperature is present).

restartTime Simulation time if NetCDF restart.

isNCrestart 0 if trajectory, 1 if restart.

ncframe Number of frames in the ﬁle.

currentFrame Current frame number.

ncatom Number of atoms.

ncatom3 Number of coordinates (ncatom * 3).

velocityVID If not -1, velocity information is present.

TempVID If not -1, temperature information is present.

In order to use it, you must include nab_netcdf.h and declare it as a struct, e.g.:

#include “nab_netcdf.h”
struct AmberNetcdf NC;

39.2.2. netcdfClose

int netcdfClose(struct AmberNetcdf NC)

Close NetCDF ﬁle associated with NC.

39.2.3. netcdfCreate

int netcdfCreate(struct AmberNetcdf NC, string filename, int natom, int isBox)

NC AmberNetcdf struct to set up.
ﬁlename Name of file to create.
natom Number of atoms in file.
isBox 0 = No box coordinates, 1 = Has box coordinates.

Create NetCDF trajectory ﬁle and associate with struct NC. For writing NetCDF restarts, use netcdfWriteRestart().

39.2.4. netcdfDebug

int netcdfDebug(struct AmberNetcdf NC)

Print debug information for NetCDF ﬁle associated with NC.

39.2.5. netcdfGetFrame

int netcdfGetFrame(struct AmberNetcdf NC, int set, float X[], float box[])

NC AmberNetcdf struct, previously set up and opened.
set Frame number to read.
X Array to store coordinates (dimension NC.ncatom3).
box Array of dimension 6 to store box coordinates if present (X Y Z ALPHA BETA

GAMMA); can be NULL.

Get coordinates at frame set (starting from 0).

836

39.2. NetCDF read/write routines

39.2.6. netcdfGetNextFrame

int netcdfGetNextFrame(struct AmberNetcdf NC, float X[], float box[])

NC AmberNetcdf struct, previously set up and opened.

X Array to store coordinates (dimension NC.ncatom3).

box Array of size 6 to store box coordinates if present (X Y Z ALPHA BETA

GAMMA); can be NULL.

Get the coordinates at frame NC.currentFrame and increment NC.currentFrame by one. Unlike the other netcdf
routines, this returns 1 on success and 0 on error to make it easy to use in loops.

39.2.7. netcdfGetVelocity

int netcdfGetVelocity(struct AmberNetcdf NC, int set, float V[])

NC AmberNetcdf struct, previously set up and opened.

set Frame number to read.

V Array to store velocities (dimension NC.ncatom3).

Get velocities at frame set (starting from 0).

39.2.8. netcdfInfo

int netcdfInfo(struct AmberNetcdf NC)

Print information for NC, including ﬁle type, presence of velocity/box/temperature info, and number of atoms,
coordinates, and frames present.

39.2.9. netcdfLoad

int netcdfLoad(struct AmberNetcdf NC, string filename)

NC AmberNetcdf struct to set up.

ﬁlename Name of NetCDF file to load.

Load NetCDF ﬁle ﬁlename and set up the AmberNetcdf structure NC for reading. The ﬁle type is automatically
detected.

39.2.10. netcdfWriteFrame

int netcdfWriteFrame(struct AmberNetcdf NC, int set, float X[], float box[])

NC AmberNetcdf struct, previously set up and opened.

set Frame number to write.

X Array of coordinates to write (dimension NC.ncatom3).

box Array of size 6 of box coordinates to write (X Y Z ALPHA BETA GAMMA); can

be NULL.

Write to NetCDF trajectory at frame set (starting from 0). NOTE: This routine is for writing NetCDF trajectories
only; to write NetCDF restarts use netcdfWriteRestart().

837

39. libsff: Molecular mechanics and dynamics

39.2.11. netcdfWriteNextFrame

int netcdfWriteNextFrame(struct AmberNetcdf NC, float X[], float box[])

NC AmberNetcdf struct, previously set up and opened.
X Array of coordinates to write (dimension NC.ncatom3).
box Array of size 6 of box coordinates to write (X Y Z ALPHA BETA GAMMA); can

be NULL.

Write coordinates to frame NC.currentFrame and increment NC.currentFrame by one. NOTE: This routine is
for writing NetCDF trajectories only; to write NetCDF restarts use netcdfWriteRestart().

39.2.12. netcdfWriteRestart

int netcdfWriteRestart(string filename, int natom, float X[], float V[],

float box[], float time, float temperature)

ﬁlename Name of NetCDF restart file to create.
natom Number of atoms in netcdf restart file.
X Array of coordinates to write (dimension natom*3).
V Array of velocities to write (dimension natom*3); can be NULL.
box Array of size 6 of box coordinates to write (X Y Z ALPHA BETA GAMMA); can

be NULL.

time Restart time in ps.
temperature Restart temperature; if < 0 no temperature will be written.

39.3. Second derivatives and normal modes

Russ Brown has contributed new codes that compute analytically the second derivatives of the Amber

functions, including the generalized Born terms. This capability resides in the three functions described here.

int newton( ﬂoat x[], int n, ﬂoat fret, ﬂoat func1(), ﬂoat func2(), ﬂoat rms,

ﬂoat nradd, int maxiter );

ﬂoat nmode( ﬂoat x[], int n, ﬂoat func(), int eigp, int ntrun, ﬂoat eta, ﬂoat hrmax, int ioseen );

These routines construct and manipulate a Hessian (second derivative matrix), allowing one (for now) to carry
out Newton-Raphson minimization and normal mode calculations. The mme2() routine takes as input a 3*natom
vector of coordinates x[], and returns a gradient vector g[], a Hessian matrix, stored columnwise in a 3*natom x
3*natom vector h[], and the masses of the system, in a vector m[] of length natom. The iteration variable iter is just
used to control printing. At present, these routines only work for gb = 0 or 1.

Users cannot call mme2() directly, but will pass this as an argument to one of the next two routines.
The newton() routine takes a input coordinates x[] and a size parameter n (must be set to 3*natom). It performs
Newton-Raphson optimization until the root-mean-square of the gradient vector is less than rms, or until maxiter
steps have been taken. For now, the input function func1() must be mme() and func2() must be mme2(). The value
nradd will be added to the diagonal of the Hessian before the step equations are solved; this is generally set to zero,
but can be set something else under particular circumstances, which we do not discuss here.[725]

Generally, you only want to try Newton-Raphson minimization (which can be very expensive) after you have
optimized structures with conjgrad() to an rms gradient of 10 -3 or so. In most cases, it should only take a small
number of iterations then to go down to an rms gradient of about 10 -12 or so, which is somewhere near the
precision limit.

Once a good minimum has been found, you can use the nmode() function to compute normal/Langevin modes
and thermochemical parameters. The ﬁrst three arguments are the same as for newton(), the next two integers

838

39.4. Low-MODe (LMOD) optimization methods

give the number of eigenvectors to compute and the type of run, respectively. The last three arguments (only
used for Langevin modes) are the viscosity in centipoise, the value for the hydrodynamic radius, and the type
of hydrodynamic interactions. Several techniques are available for diagonalizing the Hessian depending on the
number of modes required and the amount of memory available.

In all cases the modes are written to an Amber-compatible "vecs" ﬁle for normal modes or "lmodevecs" ﬁle for
Langevin modes. There are currently no nab routines that use this format. The Langevin modes will also generate
an output ﬁle called "lmode" that can be read by the Amber module lmanal.

ntrun

hrmax

ioseen

0: The dsyev routine is used to diagonalize the Hessian
1: The dsyevd routine is used to diagonalize the Hessian
2: The ARPACK package (shift invert technique) is used to obtain a small number of eigenvalues
3: The Langevin modes are computed with the viscosity and hydrodynamic radius provided

Hydrodynamic radius for the atom with largest area exposed to solvent. If a ﬁle named "expﬁle" is
provided then the relative exposed areas are read from this ﬁle. If "expﬁle" is not present all atoms
are assigned a hydrodynamic radius of hrmax or 0.2 for the hydrogen atoms. The "expﬁle" can be
generated with the ms (molecular surface) program.

0: Stokes Law is used for the hydrodynamic interaction
1: Oseen interaction included
2: Rotne-Prager correction included





1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

Here is a typical calling sequence:

molecule m;
float x[4000], fret;

m = getpdb_prm( "mymolecule.pdb", "leaprc.protein.ff14SB", "", 0 );
mm_options( "cut=999., ntpr=50, nsnb=99999, diel=C, gb=1, dielc=1.0" );
mme_init( m, NULL, "::Z", x, NULL);
setxyz_from_mol( m, NULL, x );

// conjugate gradient minimization
conjgrad(x, 3*m.natoms, fret, mme, 0.1, 0.001, 2000 );

// Newton-Raphson minimization\fP
mm_options( "ntpr=1" );
newton( x, 3*m.natoms, fret, mme, mme2, 0.00000001, 0.0, 6 );

// get the normal modes:
nmode( x, 3*m.natoms, mme2, 0, 0, 0.0, 0.0, 0);





39.4. Low-MODe (LMOD) optimization methods

István Kolossváry has contributed new functions, which implement the LMOD methods for minimization, con-
formational searching, and ﬂexible docking.[475–478] The centerpiece of LMOD is a conformational search al-
gorithm based on eigenvector following of low-frequency vibrational modes. It has been applied to a spectrum
of computational chemistry domains including protein loop optimization and ﬂexible active site docking. The
search method is implemented without explicit computation of a Hessian matrix and utilizes the Arnoldi pack-
age (ARPACK, http://www.caam.rice.edu/software/ARPACK/) for computing the low-frequency modes. LMOD
optimization can be thought of as an advanced minimization method. LMOD can not only energy minimize a
molecular structure in the local sense, but can generate a series of very low energy conformations. The LMOD

839

39. libsff: Molecular mechanics and dynamics

capability resides in a single, top-level calling function lmod(), which uses fast local minimization techniques,
collectively termed XMIN that can also be accessed directly through the function xmin().

There are now four “real-life” examples of carrying out LMOD searches: look in $AMBERHOME/AmberTool-

s/examples/nab/lmod_*. Each directory has a README ﬁle that give more information.

39.4.1. LMOD conformational searching

The LMOD conformational search procedure is based on gentle, but very effective structural perturbations
applied to molecular systems in order to explore their conformational space. LMOD perturbations are derived from
low-frequency vibrational modes representing large-amplitude, concerted atomic movements. Unlike essential
dynamics where such low modes are derived from long molecular dynamics simulations, LMOD calculates the
modes directly and utilizes them to improve Monte Carlo sampling.

LMOD has been developed primarily for macromolecules, with its main focus on protein loop optimization.
However, it can be applied to any kind of molecular systems, including complexes and ﬂexible docking where it has
found widespread use. The LMOD procedure starts with an initial molecular model, which is energy minimized.
The minimized structure is then subjected to an ARPACK calculation to ﬁnd a user-speciﬁed number of low-
mode eigenvectors of the Hessian matrix. The Hessian matrix is never computed; ARPACK makes only implicit
reference to it through its product with a series of vectors. Hv, where v is an arbitrary unit vector, is calculated via
a ﬁnite-difference formula as follows,

Hv = [∇(xmin + h)− ∇(xmin)] /h

(39.1)
where xmin is the coordinate vector at the energy minimized conformation and h denotes machine precision. The
computational cost of Eq. 1 requires a single gradient calculation at the energy minimum point and one additional
gradient calculation for each new vector. Note that (cid:53)x is never 0, because minimization is stopped at a ﬁnite
gradient RMS, which is typically set to 0.1-1.0 kcal/mol-Å in most calculations.

The low-mode eigenvectors of the Hessian matrix are stored and can be re-used throughout the LMOD search.
Note that although ARPACK is very fast in relative terms, a single ARPACK calculation may take up to a few hours
on an absolute CPU time scale with a large protein structure. Therefore, it would be impractical to recalculate
the low-mode eigenvectors for each new structure. Visual inspection of the low-frequency vibrational modes of
different, randomly generated conformations of protein molecules showed very similar, collective motions clearly
suggesting that low-modes of one particular conformation were transferable to other conformations for LMOD
use. This important ﬁnding implies that the time limiting factor in LMOD optimization, even for relatively small
molecules, is energy minimization, not the eigenvector calculation. This is the reason for employing XMIN for
local minimization instead of NAB’s standard minimization techniques.

39.4.2. LMOD procedure

Given the energy-minimized structure of an initial protein model, protein- ligand complex, or any other molec-
ular system and its low-mode Hessian eigenvectors, LMOD proceeds as follows. For each of the ﬁrst n low-modes
repeat steps 1-3 until convergence:

1. Perturb the energy-minimized starting structure by moving along the ith (i =1-n) Hessian eigenvector in ei-
ther of the two opposite directions to a certain distance. The 3N-dimensional (N is equal to the number of
atoms) travel distance along the eigenvector is scaled to move the fastest moving atom of the selected mode
in 3-dimensional space to a randomly chosen distance between a user-speciﬁed minimum and maximum
value.
Note: A single LMOD move inherently involves excessive bond stretching and bond angle bending in Carte-
sian space. Therefore the primarily torsional trajectory drawn by the low-modes of vibration on the PES is
severely contaminated by this naive, linear approximation and, therefore, the actual Cartesian LMOD tra-
jectory often misses its target by climbing walls rather than crossing over into neighboring valleys at not
too high altitudes. The current implementation of LMOD employs a so-called ZIG-ZAG algorithm, which
consists of a series of alternating short LMOD moves along the low-mode eigenvector (ZIG) followed by a
few steps of minimization (ZAG), which has been found to relax excessive stretches and bends more than

840

39.4. Low-MODe (LMOD) optimization methods

keyword

default meaning

Parameter list for xmin()

func

N/A

natm

N/A

x[]

N/A

g[]

ene

grms_out

N/A

N/A
N/A

The name of the function that computes the function value and gradient
of the objective function to be minimized. func() must have the
following argument list: float func( float x[], float g[], int
i)where x[] is the vector of the iterate, g[] is the gradient and i is
currently ignored except when func = mme where i is handled
internally.
Number of atoms. NOTE: if func is other than mme, natm is used to
pass the total number of variables of the objective function to be
minimized. However, natm retains its original meaning in case func is a
user-deﬁned energy function for 3-dimensional (molecular) structure
optimization. Make sure that the meaning of natm is compatible with
the setting of mol_struct_opt below.
Coordinate vector. User has to allocate memory in calling program and
ﬁll x[] with initial coordinates using, e.g., the setxyz_from_mol function
(see sample program below). Array size = 3*natm.
Gradient vector. User has to allocate memory in calling program. Array
size = 3*natm.
On output, ene stores the minimized energy.
On output, grms_out stores the gradient RMS achieved by XMIN.

Table 39.2.: Arguments for xmin().

reversing the torsional move. Therefore, it is expected that such a ZIG- ZAG trajectory will eventually be
dominated by concerted torsional movements and will carry the molecule over the energy barrier in a way
that is not too different from ﬁnding a saddle point and crossing over into the next valley like passing through
a mountain pass.
Barrier crossing check: The LMOD algorithm checks barrier crossing by evaluating the following criterion:
IF the current endpoint of the zigzag trajectory is lower than the energy of the starting structure, OR, the
endpoint is at least lower than it was in the previous ZIG-ZAG iteration step AND the molecule has also
moved farther away from the starting structure in terms of all-atom superposition RMS than at the previous
position THEN it is assumed that the LMOD ZIG-ZAG trajectory has crossed an energy barrier.

2. Energy-minimize the perturbed structure at the endpoint of the ZIG- ZAG trajectory.

3. Save the new minimum-energy structure and return to step 1. Note that LMOD saves only low-energy
structures within a user-speciﬁed energy window above the then current global minimum of the ongoing
search.

After exploring the modes of a single structure, LMOD goes on to the next starting structure, which is selected
from the set of previously found low- energy structures. The selection is based on either the Metropolis criterion,
or simply the than lowest energy structure is used. LMOD terminates when the user-deﬁned number of steps has
been completed or when the user-deﬁned number of low-energy conformations has been collected.

Note that for ﬂexible docking calculations LMOD applies explicit translations and rotations of the ligand(s) on

top of the low-mode perturbations.

39.4.3. XMIN

float xmin( float func(), int natm, float x[], float g[],

float ene, float grms_out, struct xmod_opt xo);

At a glance: The xmin() function minimizes the energy of a molecular structure with initial coordinates given
in the x[] array. On output, xmin() returns the minimized energy as the function value and the coordinates in x[]

841

39. libsff: Molecular mechanics and dynamics

keyword

default meaning

Parameter list for xmin_opt

mol_struct_opt

1

1= 3-dimensional molecular structure optimization. Any other value
means general function optimization.

maxiter

1000 Maximum number of iteration steps allowed for XMIN. A value of zero

grms_tol

0.05

means single point energy calculation, no minimization.
Gradient RMS threshold below which XMIN should minimize the input
structure.
Minimization algorithm. See text for description.
Finite difference method used in TNCG for approximating the product
of the Hessian matrix and some vector in the conjugate gradient
iteration (the same approximation is used in LMOD, see Eq. 39.1 in
section 39.4.1). 1= Forward difference. 2=Central difference.
Size of the L-BFGS memory used in either L-BFGS minimization or
L-BFGS preconditioning for TNCG. The value zero turns off
preconditioning. It usually makes little sense to set the value >10.
Amount of debugging printout. 0= No output. 1= Minimization details.
2= Minimization (including conjugate gradient iteration in case of
TNCG) and line search details. If print_level > 2, print minimization
output every print_level steps
Output parameter. The total number of iteration steps completed by
XMIN.
Output parameter. CPU time in seconds used by XMIN.
1= modiﬁed Armijo [726](not recommended, primarily used for
testing).
2= Wolfe (after J. J. More’ and D. J. Thuente).
Maximum number of line search steps per single minimization step.
Maximum (co-ordinate) movement per degree of freedom allowed in
line search, range > 0.
Armijo beta parameter, range (0, 1). Only change it if you know what
you are doing.
Armijo c parameter, range (0, 0.5). Only change it if you know what you
are doing.
Armijo mu parameter, range [0, 2). Only change it if you know what you
are doing.

0.0001 Wolfe ftol parameter, range (0, 0.5). Only change it if you know what

you are doing.
Wolfe gtol parameter, range (ftol_wolfe, 1). Only change it if you know
what you are doing.
Output parameter. The total number of line search steps completed by
XMIN.
Output parameter. A nonzero value indicates an error. In case of an
error XMIN will always print a descriptive error message.

Table 39.3.: Options for xmin_opt.

3
1

3

0

N/A

N/A
2

20
0.5

0.5

0.4

1.0

0.9

N/A

N/A

method
numdiff

m_lbfgs

print_level

iter

xmin_time
ls_method

ls_maxiter

ls_maxatmov

beta_armijo

c_armijo

mu_armijo

ftol_wolfe

gtol_wolfe

ls_iter

error_ﬂag

842

39.4. Low-MODe (LMOD) optimization methods

will be updated to the minimum-energy conformation. The arguments to xmin() are described in Table 39.2; the
parameters in the xmin_opt structure are described in Table 39.3; these should be preceded by “xo.”, since they
are members of an xmod_opt struct with that name; see the sample program below to see how this works.

There are three types of minimizers that can be used, speciﬁed by the method parameter:

method

1: PRCG Polak-Ribiere conjugate gradient method, similar to the conjgrad() function [479].
2: L-BFGS Limited-memory Broyden-Fletcher-Goldfarb-Shanno quasi-Newton algorithm [480].
L-BFGS is 2-3 times faster than PRCG mainly, because it requires signiﬁcantly fewer line
search steps than PRCG.

3: lbfgs-TNCG L-BFGS preconditioned truncated Newton conjugate gradient algorithm [479, 481].
Sophisticated technique that can minimize molecular structures to lower energy and gradient
than PRCG and L-BFGS and requires an order of magnitude fewer minimization steps, but
L-BFGS can sometimes be faster in terms of total CPU time.

4: Debugging option; printing analytical and numerical derivatives for comparison. Almost all fail-
ures with xmin can be attributed to inaccurate analytical derivatives, e.g., when SCF hasn’t
converged with a quantum based Hamiltonian.

NOTE: The xmin routine can be utilized for minimizing arbitrary, user-deﬁned objective functions. The function
must be deﬁned in a user NAB program or in any other user library that is linked in. The name of the function is
passed to xmin() via the func argument.



39.4.4. Sample XMIN program



The following sample program, which is based on the test program txmin.nab, reads a molecular structure from

a PDB ﬁle, minimizes it, and saves the minimized structure in another PDB ﬁle.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

//
//

XMIN reverse communication external minimization package.
Written by Istvan Kolossvary.

#include "xmin_opt.h"

// M A I N

P R O G R A M

to carry out XMIN minimization on a molecule:

struct xmin_opt xo;

molecule mol;
int natm;
float xyz[ dynamic ], grad[ dynamic ];
float energy, grms;
point dummy;

xmin_opt_init( xo ); //

set up defaults (shown here)

= 1000;
= 0.05;
= 3;
= 1;
= 3;
= 2;

// xo.mol_struct_opt = 1;
// xo.maxiter
// xo.grms_tol
// xo.method
// xo.numdiff
// xo.m_lbfgs
//
//
//
//
//
//
//

xo.ls_method
xo.ls_maxiter = 20;
xo.maxatmov
= 0.5;
xo.beta_armijo = 0.5;
xo.c_armijo
= 0.4;
xo.mu_armijo
= 1.0;
xo.ftol_wolfe = 0.0001;

843

39. libsff: Molecular mechanics and dynamics

xo.gtol_wolfe

//
// xo.print_level

= 0.9;
= 0;

non-defaults are here

//

xo.maxiter
xo.grms_tol
xo.method
xo.ls_maxatmov = 0.15;
xo.print_level = 2;

= 10;
= 0.001;
= 3;

mol = getpdb( "gbrna.pdb" );
readparm( mol, "gbrna.prmtop" );
natm = mol.natoms;
allocate xyz[ 3*natm ]; allocate grad[ 3*natm ];
setxyz_from_mol( mol, NULL, xyz );

mm_options( "ntpr=1, gb=1, kappa=0.10395, rgbmax=99., cut=99.0, diel=C ");
mme_init( mol, NULL, "::ZZZ", dummy, NULL );

energy = mme( xyz, grad, 0 );
energy = xmin( mme, natm, xyz, grad, energy, grms, xo );

// E N D M A I N

The corresponding screen output should look similar to this. Note that this is fairly technical, debugging infor-

mation; normally print_level is set to zero.




31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52




Reading parm file (gbrna.prmtop)
title:
PDB 5DNB, Dickerson decamer
old prmtop format => using old algorithm for GB parms

mm_options: ntpr=99
mm_options: gb=1
mm_options: kappa=0.10395
mm_options: rgbmax=99.
mm_options: cut=99.0
mm_options: diel=C

iter

Total

bad

vdW

elect.

cons.

genBorn

frms

ff:

0

-4107.50

906.22

-192.79

-137.96

0.00

-4682.97 1.93e+01

________________________________________________________________

It=

0

E=

-4107.50 ( 19.289)

:-)
info= 1

It=

1

E=

-4423.34 (

5.719)

:-)
info= 1

It=

2

E=

-4499.43 (

2.674)

:-)
info= 1

It=

3

E=

-4531.20 (

1.543)

:-)
info= 1

It=

4

E=

-4547.59 (

1.111)

:-)
info= 1

It=

5

E=

-4556.35 (

1.068)

MIN:
CG:
0.310)
LS: step= 0.94735 it= 1

3 (

It=

MIN:
0.499)
CG:
LS: step= 0.91413 it= 1

4 (

It=

MIN:
CG:
0.498)
LS: step= 0.86829 it= 1

9 (

It=

MIN:
CG:
0.499)
LS: step= 0.95556 it= 1

8 (

It=

MIN:
0.491)
CG:
LS: step= 0.77247 it= 1

9 (

It=

MIN:

844

39.4. Low-MODe (LMOD) optimization methods

0.361)
it= 1

:-)
info= 1

It=

6

E=

-4562.95 (

1.042)

0.273)
it= 1

:-)
info= 1

It=

7

E=

-4568.59 (

0.997)

0.401)
it= 1

:-)
info= 1

It=

8

E=

-4572.93 (

0.786)

0.335)
it= 1

:-)
info= 1

It=

9

E=

-4575.25 (

0.551)

0.475)
it= 1

:-)
info= 1

It=

CG:
LS: step= 0.75150

8 (

MIN:
CG:
LS: step= 0.79565

8 (

It=

MIN:
CG:
LS: step= 0.86051

5 (

It=

MIN:
CG:
LS: step= 0.88096

4 (

It=

MIN:
CG:
LS: step= 0.95860

64 (

It=

MIN:

0.515)
----------------------------------------------------------------

-4579.19 (

It=

10

E=

FIN:

:-)

E=

-4579.19 (

0.515)





The ﬁrst few lines are typical NAB output from mm_init() and mme(). The output below the horizontal line
comes from XMIN. The MIN/CG/LS blocks contain the following pieces of information. The MIN: line shows
the current iteration count, energy and gradient RMS (in parentheses). The CG: line shows the CG iteration count
and the residual in parentheses. The happy face :-) means convergence whereas :-( indicates that CG iteration
encountered negative curvature and had to abort. The latter situation is not a serious problem, minimization can
continue. This is just a safeguard against uphill moves. The LS: line shows line search information. "step" is the
relative step with respect to the initial guess of the line search step. "it" tells the number of line search steps taken
and "info" is an error code. "info" = 1 means that line searching converged with respect to sufﬁcient decrease and
curvature criteria whereas a non- zero value indicates an error condition. Again, an error in line searching doesn’t
mean that minimization necessarily failed, it just cannot proceed any further because of some numerical dead end.
The FIN: line shows the ﬁnal result with a happy face :-) if either the grms_tol criterion has been met or when the
number of iteration steps reached the maxiter value.

39.4.5. LMOD

float lmod( int natm, float x[], float g[], float ene, float conflib[],

float lmod_traj[], int lig_start[], int lig_end[], int lig_cent[],
float tr_min[], float tr_max[], float rot_min[], float rot_max[],
struct xmin_opt, struct xmin_opt, struct lmod_opt);

At a glance: The lmod() function is similar to xmin() in that it optimizes the energy of a molecular structure
with initial coordinates given in the x[] array. However, the optimization goes beyond local minimization, it
is a sophisticated conformational search procedure. On output, lmod() returns the global minimum energy of
the LMOD conformational search as the function value and the coordinates in x[] will be updated to the global
minimum-energy conformation. Moreover, a set of the best low-energy conformations is also returned in the array
conﬂib[]. Coordinates, energy, and gradient are in NAB units. The parameters are given in the table below; items
above the line are passed as parameters; the rest of the parameters are all preceded by “lo.”, because they are
members of an lmod_opt struct with that name; see the sample program below to see how this works.

Also note that xmin()’s xmin_opt struct is passed to lmod() as well. lmod() changes the default values of some
of the “xo.” parameters via the call to lmod_opt_int() relative to a call to xmin_opt_init(), which means that
in a more complex NAB program with multiple calls to xmin() and lmod(); make sure to always initialize and
set user parameters for each and every XMIN and LMOD search via, respectively calling xmin_opt_init() and
lmod_opt_init() just before the calls to xmin() and lmod().

keyword

natm

default meaning

Number of atoms.

845

39. libsff: Molecular mechanics and dynamics

keyword

default meaning

x[]

g[]

ene

conﬂib[]

lmod_traj[]

lig_start[]

N/A

lig_end[]
lig_cent[]

N/A
N/A

tr_min[]

N/A

tr_max[]
rot_min[]
rot_max[]

niter

nmod

minim_grms

kmod

nrotran_dof

10

5

0.1

3

6

Coordinate vector. User has to allocate memory in calling
program and ﬁll x[] with initial coordinates using, e.g., the
setxyz_from_mol function (see sample program below). Array
size = 3*natm.
Gradient vector. User has to allocate memory in calling
program. Array size = 3*natm.
On output, ene stores the global minimum energy.
User allocated storage array where LMOD stores low-energy
conformations. Array size = 3*natm*nconf.
User allocated storage array where LMOD stores snapshots of
the pseudo trajectory drawn by LMOD on the potential energy
surface. Array size = 3*natom * (nconf + 1).
The serial number(s) of the ﬁrst/last atom(s) of the ligand(s).
The number(s) should correspond to the numbering in the NAB
input ﬁles. Note that the ligand(s) can be anywhere in the atom
list, however, a single ligand must have continuous numbering
between the corresponding lig_start and lig_end values. The
arrays should be allocated in the calling program. Array size =
nlig, but in case nlig=0 there is no need for allocating memory.
See above.
Similar array in all respects to lig_start/end, but the serial
number(s) deﬁne the center of rotation. The value zero means
that the center of rotation will be the geometric center of
gravity of the ligand.
The range of random translation/rotation applied to individual
ligand(s). Rotation is carried out about the origin deﬁned by
the corresponding lig_cent value(s). The angle is given in +/-
degrees and the distance in angstroms. The particular angles
and distances are randomly chosen from their respective
ranges. The arrays should be allocated in the calling program.
Array size = nlig, but in case nlig=0 there is no need to
allocate memory.
See tr_min[], above.
See tr_min[], above.
See tr_min[], above.
The number of LMOD iterations. Note that a single LMOD
iteration involves a number of different computations (see
section 39.4.2.). A value of zero results in a single local
minimization; like a call to xmin.
The total number of low-frequency modes computed by
LMOD every time such computation is requested.
The gradient RMS convergence criterion of structure
minimization.
The deﬁnite number of randomly selected low-modes used to
drive LMOD moves at each LMOD iteration step.
The number of rotational and translational degrees of freedom.
This is related to the number of frozen or tethered atoms in the
system: 0 atoms dof=6, 1 atom dof=3, 2 atoms dof=1, >=3
atoms dof=0. Default is 6, no frozen or tethered atoms. See
section 39.4.7, note (5).

846

39.4. Low-MODe (LMOD) optimization methods

default meaning

keyword
nconf

10

energy_window

50.0

eig_recalc

ndim_arnoldi

lmod_restart

5

0

10

n_best_struct

10

mc_option

1

rtemp

lmod_step_size_min

lmod_step_size_max

nof_lmod_steps

lmod_relax_grms

nlig

1.5

2.0

5.0

0

1.0

0

The maximum number of low-energy conformations stored in
conﬂib[]. Note that the calling program is responsible for
allocating memory for conﬂib[].
The energy window for conformation storage; the energy of a
stored structure will be in the interval [global_min, global_min
+ energy_window].
The frequency, measured in LMOD iterations, of the
recalculation of eigenvectors.
The dimension of the ARPACK Arnoldi factorization. The
default, zero, speciﬁes the whole space, that is, three times the
number of atoms. See note below.
The frequency, in LMOD iterations, of updating the conﬂib
storage, that is, discarding structures outside the energy
window, and restarting LMOD with a randomly chosen
structure from the low-energy pool deﬁned by n_best_struct
below. A value >maxiter will prevent LMOD from doing any
restarts.
Number of the lowest-energy structures found so far at a
particular LMOD restart point. The structure to be used for the
restart will be chosen randomly from this pool. n_best_struct =
1 allows the user to explore the neighborhood of the then
current global minimum.
The Monte Carlo method.
1= Metropolis Monte Carlo (see rtemp below).
2= "Total_Quench", which means that the LMOD trajectory
always proceeds towards the lowest lying neighbor of a
particular energy well found after exhaustive search along all
of the randomly selected kmod low-modes.
3= "Quick_Quench", which means that the LMOD trajectory
proceeds towards the ﬁrst neighbor found, which is lower in
energy than the current point on the path, without exploring the
remaining modes.
The value of RT in NAB energy units. This is utilized in the
Metropolis criterion.
The minimum length of a single LMOD ZIG move in Å. See
section 39.4.2.
The maximum length of a single LMOD ZIG move in Å. See
section 39.4.2.
The number of LMOD ZIG-ZAG moves. The default, zero,
means that the number of ZIG-ZAG moves is not pre-deﬁned,
instead LMOD will attempt to cross the barrier in as many
ZIG-ZAG moves as it is necessary. The criterion of crossing an
energy barrier is stated above in section 39.4.2.
nof_lmod_steps > 0 means that multiple barriers may be
crossed and LMOD can carry the molecule to a large distance
on the potential energy surface without severely distorting the
geometry.
The gradient RMS convergence criterion of structure
relaxation, see ZAG move in section 39.4.2.
Number of ligands considered for ﬂexible docking. The
default, zero, means no docking.

847

39. libsff: Molecular mechanics and dynamics

keyword

default meaning

apply_rigdock

2

nof_poses_to_try

10

random_seed

314159

print_level

lmod_time
aux_time
error_ﬂag

0

N/A
N/A
N/A

The frequency, measured in LMOD iterations, of the
application of rigid-body rotational and translational motions
to the ligand(s). At each apply_rigdock-th LMOD iteration
nof_pose_to-try rotations and translations are applied to the
ligand(s).
The number of rigid-body rotational and translational motions
applied to the ligand(s). Such applications occur at each
apply_rigdock-th LMOD iteration. In case nof_pose_to_try >
1, it is always the lowest energy pose that is kept, all other
poses are discarded.
The seed of the random number generator. A value of zero
requests hardware seeding based on the system clock.
Amount of debugging printout. 0= No output. 1= Basic output.
2= Detailed output. 3= Copious debugging output including
ARPACK details.
CPU time in seconds used by LMOD itself.
CPU time in seconds used by auxiliary routines.
A nonzero value indicates an error. In case of an error LMOD
will always print a descriptive error message.

Notes on the ndim_arnoldi parameter: Basically, the ARPACK package used for the eigenvector calculations
solves multiple "small" eigenvalue problems instead of a single "large" problem, which is the diagonalization of
the three times the number of atoms by three times the number of atoms Hessian matrix. This parameter is the user
speciﬁed dimension of the "small" problem. The allowed range is nmod + 1 <= ndim_arnoldi <= 3*natm. The
default means that the "small" problem and the "large" problem are identical. This is the preferred, i.e., fastest,
calculation for small to medium size systems, because ARPACK is guaranteed to converge in a single iteration.
The ARPACK calculation scales with three times the number of atoms times the Arnoldi dimension squared and,
therefore, for larger molecules there is an optimal ndim_arnoldi much less than three times the number of atoms
that converges much faster in multiple iterations (possibly thousands or tens of thousands of iterations). The key
to good performance is to select ndim_arnoldi such that all the ARPACK storage ﬁts in memory. For proteins,
ndim_arnoldi =1000 is generally a good value, but often a very small ∼50-100 Arnoldi dimension provides the
fastest net computational cost with very many iterations.

39.4.6. Sample LMOD program



The following sample program, which is based on the test program tlmod.nab, reads a molecular structure from

a PDB ﬁle, runs a short LMOD search, and saves the low-energy conformations in PDB ﬁles.



1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

//
//

LMOD reverse communication external minimization package.
Written by Istvan Kolossvary.

#include "xmin_opt.h"
#include "lmod_opt.h"

// M A I N P R O G R A M to carry out LMOD simulation on a molecule/complex:

struct xmin_opt xo;
struct lmod_opt lo;

natm;

molecule mol;
int
float energy;
int lig_start[ dynamic ], lig_end[ dynamic ], lig_cent[ dynamic ];

848

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

39.4. Low-MODe (LMOD) optimization methods

float xyz[ dynamic ], grad[ dynamic ], conflib[ dynamic ], lmod_trajectory[ dynamic ];
float tr_min[ dynamic ], tr_max[ dynamic ], rot_min[ dynamic ], rot_max[ dynamic ];
float glob_min_energy;
point dummy;

lmod_opt_init( lo, xo );

//

set up defaults

//

non-default options are here

= 3;
lo.niter
lo.mc_option
= 2;
lo.nof_lmod_steps = 5;
lo.random_seed
lo.print_level

= 99;
= 2;

xo.ls_maxatmov

= 0.15;

mol = getpdb( "trpcage.pdb" );
readparm( mol, "trpcage.top" );
natm = mol.natoms;

allocate xyz[ 3*natm ]; allocate grad[ 3*natm ];
allocate conflib[ lo.nconf * 3*natm ];
allocate lmod_trajectory[ (lo.niter+1) * 3*natm ];
setxyz_from_mol( mol, NULL, xyz );

mm_options( "ntpr=5000, gb=0, cut=999.0, nsnb=9999, diel=R ");
mme_init( mol, NULL, "::ZZZ", dummy, NULL );

mme( xyz, grad, 1 );
glob_min_energy = lmod( natm, xyz, grad, energy,

conflib, lmod_trajectory, lig_start, lig_end, lig_cent,
tr_min, tr_max, rot_min, rot_max, xo, lo );

printf( "\nGlob. min. E

= %12.3lf kcal/mol\n", glob_min_energy );

// E N D

M A I N




The corresponding screen output should look similar to this.

Reading parm file (trpcage.top)
title:

mm_options: ntpr=5000
mm_options: gb=0
mm_options: cut=999.0
mm_options: nsnb=9999
mm_options: diel=R

________________________________________________________________

Low-Mode Simulation

---------------------------------------------------------------------------

1

p= 0.0000
p= 0.0000
p= 1.0000
p= 0.0004
p= 0.0005
p= 0.0121
---------------------------------------------------------------------------

-118.117 ( 0.054)
-89.2057 ( 0.090)
-51.682 ( 0.097)
-120.978 ( 0.091)
-106.292 ( 0.099)
-106.788 ( 0.095)
-111.501 ( 0.097)

1 / 6
1 / 8
3 /12
3 /10
4 / 6
4 / 3

5.440
2.625
5.399
3.410
5.916
4.802
5.238

rmsd=
rmsd=
rmsd=
rmsd=
rmsd=
rmsd=

8.240
8.217
7.248
4.829
3.391
2.553

Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =

E =
E =
E =
E =
E =
E =
E =




849

39. libsff: Molecular mechanics and dynamics

2

E =
1 / 4 E =
1 / 9 E =
4 / 3 E =
4 / 4 E =
5 / 5 E =
5 / 4 E =

p= 1.0000
p= 1.0000
p= 1.0000
p= 0.0001
p= 0.0053
p= 1.0000
---------------------------------------------------------------------------

-120.978 ( 0.091)
-137.867 ( 0.097)
-130.025 ( 0.100)
-123.559 ( 0.089)
-107.253 ( 0.095)
-113.119 ( 0.096)
-134.1 ( 0.091)

3.410
2.842
4.282
3.451
3.437
3.136
3.141

rmsd=
rmsd=
rmsd=
rmsd=
rmsd=
rmsd=

5.581
5.342
1.285
2.680
2.074
2.820

Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =

3

E =
1 / 8 E =
1 / 4 E =
2 / 8 E =
2 / 7 E =
4 / 7 E =
4 /11 E =

4.282
3.347
4.218
3.093
4.871
4.171
3.290
__________________________________________________

-130.025 ( 0.100)
-150.556 ( 0.093)
-123.738 ( 0.079)
-118.254 ( 0.095)
-115.027 ( 0.090)
-128.905 ( 0.099)
-133.85 ( 0.099)

Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =

rmsd=
rmsd=
rmsd=
rmsd=
rmsd=
rmsd=

5.287
1.487
5.296
4.234
2.113
4.464

p= 1.0000
p= 0.0151
p= 0.0004
p= 0.0000
p= 0.4739
p= 1.0000

Full list:

1 E =
2 E =
3 E =
4 E =
5 E =
6 E =
7 E =
8 E =
9 E =
10 E =

Glob. min. E



-150.556 / 1
-137.867 / 1
-134.1 / 1
-133.85 / 1
-130.025 / 1
-128.905 / 1
-123.738 / 1
-123.559 / 1
-120.978 / 1
-118.254 / 1

Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =
Rg =

3.347
2.842
3.141
3.290
4.282
4.171
4.218
3.451
3.410
3.093

=

-150.556 kcal/mol



The ﬁrst few lines come from mm_init() and mme(). The screen output below the horizontal line originates from
LMOD. Each LMOD-iteration is represented by a multi-line block of data numbered in the upper left corner by
the iteration count. Within each block, the ﬁrst line displays the energy and, in parentheses, the gradient RMS as
well as the radius of gyration (assigning unit mass to each atom), of the current structure along the LMOD pseudo
simulation-path. The successive lines within the block provide information about the LMOD ZIG-ZAG moves
(see section 39.4.2). The number of lines is equal to 2 times kmod (2x3 in this example). Each selected mode is
explored in both directions, shown in two separate lines. The leftmost number is the serial number of the mode
(randomly selected from the set of nmod modes) and the number after the slash character gives the number of
ZIG-ZAG moves taken. This is followed by, respectively, the minimized energy and gradient RMS, the radius of
gyration, the RMSD distance from the base structure, and the Boltzmann probability with respect to the energy
of the base structure and rtemp, of the minimized structure at the end of the ZIG-ZAG path. Note that exploring
the same mode along both directions can result in two quite different structures. Also note that the number of
ZIG-ZAG moves required to cross the energy barrier (see section 39.4.2) in different directions can vary quite a
bit, too. Occasionally, an exclamation mark next to the energy (!E = ...) denotes a structure that could not be fully
minimized.

After ﬁnishing all the computation within a block, the corresponding LMOD step is completed by selecting
one of the ZIG-ZAG endpoint structures as the base structure of the next LMOD iteration. The selection is based
on the mc_option and the Boltzmann probability. The LMOD pseudo simulation-path is deﬁned by the series
of these mc_option-selected structures and it is stored in lmod_traj[]. Note that the sample program saves these
structures in a multi- PDB disk ﬁle called lmod_trajectory.pdb. The ﬁnal section of the screen output lists the nconf
lowest energy structures found during the LMOD search. Note that some of the lowest energy structures are not
necessarily included in the lmod_traj[] list, as it depends on the mc_option selection. The list displays the energy,
the number of times a particular conformation was found (increasing numbers are somewhat indicative of a more
complete search), and the radius of gyration. The glob. min. energy is printed from the sample NAB program,
not from LMOD. The sample program in $AMBERHOME/AmberTools/examples/nab/lmod_dock shows how one

850

39.4. Low-MODe (LMOD) optimization methods

could write the top ten low-energy structures in separate, numbered PDB ﬁles.

As a ﬁnal note, it is instructive to be aware of a simple safeguard that LMOD applies . A copy of the conﬂib[]
array is saved periodically in a binary disk ﬁle called conﬂib.dat. Since LMOD searches might run for a long time,
in case of a crash low-energy structures can be recovered from this ﬁle. The format of conﬂib.dat is as follows.
Each conformation is represented by 3 numbers (double energy, double radius of gyration, and int number of times
found), followed by the double (x, y, z) coordinates of the atoms.

39.4.7. Tricks of the trade of running LMOD searches

1. The AMBER atom types HO, HW, and ho all have zero van der Waals parameters in all of the AMBER
(and some other) force ﬁelds. Corresponding Aij and Bij coefﬁcients in the PRMTOP ﬁle are set to zero.
This means there is no repulsive wall to prevent two oppositely charged atoms, one being of type HO,
HW or ho, to fuse as a result of the ever decreasing electrostatic energy as they come closer and closer to
each other. This potential problem is rarely manifest in molecular dynamics simulations, but it presents
a nuisance when running LMOD searches. The problem is local minimization, especially "aggressive"
TNCG minimization (XMIN xo.method=3) that can easily result in atom fusion. Therefore, before running
an LMOD simulation, the PRMTOP ﬁle (let’s call it prmtop.in) must be processed by running the script
"lmodprmtop prmtop.in prmtop.out". This script will replace all the repulsive Aij coefﬁcients set to zero
in prmtop.in with a high value of 1e03 in prmtop.out in order to re-create the van der Waals wall. It is
understood that this procedure is parameter fudging; however, note that the primary goal of using LMOD
is the quick generation of approximate, low-energy structures that can be further reﬁned by high-accuracy
MD.

2. LMOD requires that the potential energy surface is continuous everywhere to a great degree. Therefore,
always use a distance dependent dielectric constant in mm_options when running searches in vacuo, or use
GB solvation (note that GB calculations will be slow), and always apply a large cut-off. It does make sense to
run quick and dirty LMOD searches in vacuo to generate low-energy starting structures for MD runs. Note
that the most likely symptom of discontinuities causing a problem is when your NAB program utilizing
LMOD is grabbing CPU time, but the LMOD search does not seem to progress. This is the result of NaN’s
that often can be seen when print_level is set to > 0.

3. LMOD is NOT INTENDED to be used with explicit water models and periodic boundary conditions. Al-
though explicit-water solvation representation is not recommended, LMOD docking can be readily used with
crystallographic water molecules as ligands.

4. Conformations in the conﬂib and lmod_trajectory ﬁles can have very different orientations. One trick to
keep them in a common orientation is to restrain the position of, e.g., a single benzene ring. This will ensure
that the molecule cannot be translated or rotated as a whole. However, when applying this trick you should
set nrotran_dof = 0.

5. A subset of the atoms of a molecular system can be frozen or tethered/restrained in NAB by two different
methods. Atoms can either be frozen by using the ﬁrst atom expression argument in mme_init() or restrained
by using the second atom expression argument and the reference coordinate array in mme_init() along with
the wcons option in mm_options. LMOD searches, especially docking calculations can be run much faster
if parts of the molecular system can be frozen, because the effective degrees of freedom is determined by
the size of the ﬂexible part of the system. Application of frozen atoms means that a much smaller number
of moving atoms are moving in the ﬁxed, external potential of the frozen atoms. The tethered atom model
is expected to give similar results to the frozen atom model, but note that the number of degrees of freedom
and, therefore, the computational cost of a tethered calculation is comparable to that of a fully unrestrained
system. However, the eigenvector calculations are likely to converge faster with the tethered systems.

851

39. libsff: Molecular mechanics and dynamics

39.5. The Generalized Born with Hierarchical Charge Partitioning

(GB-HCP)

GB-HCP (and its latest version, GB-HCPO[727] ) is a multi-scale, yet fully atomistic, approach to perform
MD simulations based on the generalized Born model, mainly intended for large and very large structures. For
example, it was used to reﬁne a 1.1M atom structure of 30nm chromatin ﬁber[727]. Compared to the reference
GB model without further approximations, GB-HCP can deliver up to 3 orders of magnitude speedup, depending
on structure size. In contrast to cutoff GB that completely ignores the effect of long range electrostatic interactions
beyond a certain distance, which can lead to serious artifacts under many circumstances such as for highly charged
systems, GB-HCP takes into account the long range electrostatic interactions by using N log N Hierarchical Charge
Partitioning (HCP) approximation [728, 729]. Based on this method, structures are partitioned into multiple hier-
archical levels of components using the natural organization of the biomolecular structures - atoms, groups, chains,
and complexes. The charge distribution for each of these components is approximated by 1 (hcp=1) or 2 (hcp=2
and hcp=4) charges. Setting hcp=4 (strongly recommended) uses GB-HCPO, which takes advantage of the Opti-
mal Point Charge Approximation approach for placing the approximate point charges[100]: two point charges are
placed so that the three lowest order multipole moments of the reference charge distribution are optimally repro-
duced. The approximate charges are then used for computing electrostatic interactions with distant components
while the full set of atomic charges are used for nearby components (Figure 40.1). The HCP can be used for
generalized Born (gb=1-8) simulations, for gas phase (dielec=C) and distant dependent dielectric (dielec=R/RL),
with or without Langevin dynamics (gamma_ln>0).

The usage of the new feature (hcp=4) requires that the separation between the two charges used to approximate
the uncharged components is speciﬁed by dhcp. The value of dhcp is empirically adjusted so that the RMS error
in force, compared to the GB without further approximation, is minimized. Our testing on a various set of
structures suggests that dhcp=0.25 is optimal for many systems. However, if further accuracy is desired for
speciﬁc systems, the value for dhcp can be further optimized within the range of 0.1 and 0.4 following the steps
below. To ﬁnd the optimal value for hcp, one time step simulation for the starting conﬁguration of the structure
can be performed using the GB model without approximation (hcp=0), and with e_debug=1setting, that
automatically prints out the forces on each atom into a text ﬁle called reference.frc. Rename reference.frc to
exact.frc. Then, run one step of the starting conﬁguration of the structure using the GB-HCP (hcp=4) by setting
the dhcp parameter within the range of 0.1 and 0.4 in increments of 0.05. The reference.frc ﬁle produced for each
value of dhcp can be compared to the exact.frc to compute the RMS error in force. The following command line
computes the RMS error:

paste exact.frc reference.frc | awk ’{x+=($9-$20)^2+($10-$21)^2+($11-$22)^2}END{print sqrt(x/NR)}’

The optimal value for dhcp is the one that results in minimum RMS error in the force.

39.5.1. Level 1 HCP approximation

The HCP option can now be used with one level of approximation (groups) using NAB molecular dynamics
scripts. No additional manipulation of the input structure ﬁles is required for one level of approximation. For
an example see AmberTools/examples/hcp/2trx.nab. The level 1 approximation is recommended for single do-
main and small (< 10,000 atoms) multi-domain structures. Speedups of 2x-10x can be realized using the level 1
approximation, depending on structure size.

39.5.2. Level 2 and 3 HCP approximation

For larger multi-domain structures higher levels of approximations (chains and complexes) can be used to
achieve up to 3 orders of magnitude speedups, depending on structure size. The following additional steps are
required to include information about these higher level components in the prmtop ﬁle. For an example see Amber-
Tools/examples/hcp/1kx5.nab. A fully working example (including the MD run scripts) of a 3 level partitioning of
a giant structure, one million atom chromatin ﬁber, can be found at http://people.cs.vt.edu/onufriev/software.php.

852

39.5. The Generalized Born with Hierarchical Charge Partitioning (GB-HCP)

Figure 39.1.: The HCP threshold distance. For the level 1 approximation shown here, groups within the threshold
distance are treated exactly using atomic charges, while groups beyond the threshold distance are
approximated by a small number of charges, e.g. 1 charge for hcp=1 shown here.

1. Ensure the pdb ﬁle identiﬁes the higher level structures: Chains (level 2) separated by TER, and Complexes

(level 3) separated by REMARK END-OF-COMPLEX:
...
ATOM ...
TER (end of chain)
ATOM ...
...
ATOM ...
TER (end of chain)
REMARK END-OF-COMPLEX
ATOM ...

2. Execute hcp_getpdb to generate prmtop entries for HCP: hcp_getpdb pdb-ﬁlename hcp-prmtop

3. Concatenate the HCP prmtop entries to the end of the standard prmtop ﬁle generated by LEaP: cat prmtop-

ﬁle hcp-prmtop > new-prmtop

4. Use this new prmtop ﬁle in the NAB molecular dynamics scripts instead of the prmtop ﬁle generated by

LEaP

853

++++++++++++++++++= Point of interest= Threshold distance= Geometric center of groups= Groups treated exactly= Groups treated approximately++Bibliography

[1] D. A. Pearlman; D. A. Case; J. W. Caldwell; W. S. Ross; T. E. Cheatham, III; S. DeBolt; D. Ferguson;
G. Seibel; P. Kollman. AMBER, a package of computer programs for applying molecular mechanics, normal
mode analysis, molecular dynamics and free energy calculations to simulate the structural and energetic
properties of molecules. Comp. Phys. Commun., 1995, 91, 1–41.

[2] D. A. Case; T. Cheatham; T. Darden; H. Gohlke; R. Luo; K. M. Merz, Jr.; A. Onufriev; C. Simmerling;
B. Wang; R. Woods. The Amber biomolecular simulation programs. J. Computat. Chem., 2005, 26, 1668–
1688.

[3] J. W. Ponder; D. A. Case. Force ﬁelds for protein simulations. Adv. Prot. Chem., 2003, 66, 27–85.

[4] T. E. Cheatham; D. A. Case. Twenty-ﬁve years of nucleic acid simulations. Biopolymers, 2013, 99, 969–977.

[5] S. Harvey; J. A. McCammon. Dynamics of Proteins and Nucleic Acids. Cambridge University Press,

Cambridge, 1987.

[6] A. R. Leach. Molecular Modelling. Principles and Applications, Second Edition. Prentice-Hall, Harlow,

England, 2001.

[7] C. J. Cramer. Essentials of Computational Chemistry: Theories and Models. John Wiley & Sons, New

York, 2002.

[8] M. P. Allen; D. J. Tildesley. Computer Simulation of Liquids. Clarendon Press, Oxford, 1987.

[9] D. Frenkel; B. Smit. Understanding Molecular Simulation: From Algorithms to Applications. Second edi-

tion. Academic Press, San Diego, 2002.

[10] M. E. Tuckerman. Statistical Mechanics: Theory and Molecular Simulation. Oxford University Press,

Oxford, 2010.

[11] W. F. van Gunsteren; P. K. Weiner; A. J. Wilkinson, eds. Computer Simulations of Biomolecular Systems,

Vol. 3. ESCOM Science Publishers, Leiden, 1997.

[12] L. R. Pratt; G. Hummer, eds. Simulation and Theory of Electrostatic Interactions in Solution. American

Institute of Physics, Melville, NY, 1999.

[13] O. Becker; A. D. MacKerell; B. Roux; M. Watanabe, eds. Computational Biochemistry and Biophysics.

Marcel Dekker, New York, 2001.

[14] C. Chipot; A. Pohorille, eds. Free energy calculations. Theory and Applications in Chemistry and Biology.

Springer, Berlin, 2007.

[15] M. Griebel; S. Knapek; G. Zumbusch. Numerical Simulation in Molecular Dynamics. Numerical Algo-

rithms, Parallelization, Applications. Springer-Verlag, Berlin, 2010.

[16] J. W. Ponder; C. Wu; P. Ren; V. S. Pande; J. D. Chodera; M. J. Schieders; I. Haque; D. L. Mobley; D. S.
Lambrecht; R. A. DiStasio, Jr.; M. Head-Gordon; G. N. I. Clark; M. E. Johnson; T. Head-Gordon. Current
status of the AMOEBA polarizable force ﬁeld. J. Phys. Chem. B, 2010, 114, 2549–2564.

[17] G. A. Cisneros. Application of gaussian electrostatic model (gem) distributed multipoles in the amoeba

force ﬁeld. J. Chem. Theo. Comput., 2012, 12, 5072–5080.

854

BIBLIOGRAPHY

[18] A. V. Onufriev; S. Izadi. Water models for biomolecular simulations. WIREs Computational Molecular

Science, 2018, 8, e1347.

[19] C. Tian; K. Kasavajhala; K. Belfon; L. Raguette; H. Huang; A. Migues; J. Bickel; Y. Wang; J. Pincay;
Q. Wu; C. Simmerling. ff19SB: Amino-Acid-Speciﬁc Protein Backbone Parameters Trained against Quan-
tum Mechanics Energy Surfaces in Solution. J. Chem. Theory Comput., 2020, 16, 528–552.

[20] S. Izadi; R. Anandakrishnan; A. V. Onufriev. Building Water Models: A Different Approach. J. Phys.

Chem. Lett., 2014, 5, 3863–3871.

[21] J. A. Maier; C. Martinez; K. Kasavajhala; L. Wickstrom; K. E. Hauser; C. Simmerling. ff14SB: Improving
the Accuracy of Protein Side Chain and Backbone Parameters from ff99SB. J. Chem. Theory Comput.,
2015, 11, 3696–3713.

[22] V. Hornak; R. Abel; A. Okur; B. Strockbine; A. Roitberg; C. Simmerling. Comparison of multiple Amber

force ﬁelds and development of improved protein backbone parameters. Proteins, 2006, 65, 712–725.

[23] J. Graf; P. H. Nguyen; G. Stock; H. Schwalbe. Structure and Dynamics of the Homologous Series of Alanine

Peptides: A Joint Molecular Dynamics/NMR Study. J. Am. Chem. Soc., 2007, 129, 1179–1189.

[24] L. Wickstrom; A. Okur; C. Simmerling. Evaluating the performance of the ff99SB force ﬁeld based on

NMR scalar coupling data. Biophys. J., 2009, 97, 853–856.

[25] H. Nguyen; D. R. Roe; C. Simmerling. Improved Generalized Born Solvent Model Parameters for Protein

Simulations. J. Chem. Theory Comput., 2013, 9, 2020–2034.

[26] K. T. Debiec; D. S. Cerutti; L. R. Baker; A. M. Gronenborn; D. A. Case; L. T. Chong. Further along the
Road Less Traveled: AMBER ff15ipq, an Original Protein Force Field Built on a Self-Consistent Physical
Model. J. Chem. Theory Comput., 2016, 12, 3926–3947.

[27] D. S. Cerutti; J. E. Rice; W. C. Swope; D. A. Case. Derivation of ﬁxed partial charges for amino acids
accommodating a speciﬁc water model and implicit polarization. J. Phys. Chem. B, 2103, 117, 2328–2338.

[28] D. S. Cerutti; W. C. Swope; J. E. Rice; D. A. Case. ff14ipq: A Self-Consistent Force Field for Condensed-

Phase Simulations of Proteins. J. Chem. Theory Comput., 2014, 10, 4515–4534.

[29] K. Takemura; A. Kitao. Water Model Tuning for Improved Reproduction of Rotational Diffusion and NMR

Spectral Density. J. Phys. Chem. B, 2012, 116, 6279–6287.

[30] W. D. Cornell; P. Cieplak; C. I. Bayly; I. R. Gould; K. M. Merz, Jr.; D. M. Ferguson; D. C. Spellmeyer;
T. Fox; J. W. Caldwell; P. A. Kollman. A second generation force ﬁeld for the simulation of proteins, nucleic
acids, and organic molecules. J. Am. Chem. Soc., 1995, 117, 5179–5197.

[31] L.-P. Wang; T. J. Martinez; V. S. Pande. Building force ﬁelds: An automatic, systematic and reproducible

approach. J. Phys. Chem. Lett., 2014, 5, 1885–1891.

[32] L. Wang; K. A. McKiernan; J. Gomes; K. A. Beauchamp; T. Head-Gordon; J. E. Rice; W. C. Swope; T. J.
MartÃnez; V. S. Pande. Building a More Predictive Protein Force Field: A Systematic and Reproducible
Route to AMBER-FB15. J. Phys. Chem. B, 2017, 121, 4023–4039.

[33] Y. Duan; C. Wu; S. Chowdhury; M. C. Lee; G. Xiong; W. Zhang; R. Yang; P. Cieplak; R. Luo; T. Lee. A
point-charge force ﬁeld for molecular mechanics simulations of proteins based on condensed-phase quantum
mechanical calculations. J. Comput. Chem., 2003, 24, 1999–2012.

[34] M. C. Lee; Y. Duan. Distinguish protein decoys by using a scoring function based on a new Amber force
ﬁeld, short molecular dynamics simulations, and the generalized Born solvent model. Proteins, 2004, 55,
620–634.

855

BIBLIOGRAPHY

[35] L. Yang; C. Tan; M.-J. Hsieh; J. Wang; Y. Duan; P. Cieplak; J. Caldwell; P. A. Kollman; R. Luo. New-

generation Amber united-atom force ﬁeld. J. Phys. Chem. B, 2006, 110, 13166–13176.

[36] V. N. Uversky; C. J. Oldﬁeld; A. K. Dunker. Intrinsically disordered proteins in human diseases: Introducing

the d2 concept. Annual Review of Biophysics, 2008, 37, 215–246.

[37] S. Piana; A. G. Donchev; P. Robustelli; D. E. Shaw. Water dispersion interactions strongly inﬂuence sim-
ulated structural properties of disordered protein states. The Journal of Physical Chemistry B, 2015, 119,
5113–5123.

[38] V. T. Duong; Z. Chen; M. T. Thapa; R. Luo. Computational studies of intrinsically disordered proteins. The

Journal of Physical Chemistry B, 2018, 122, 10455–10469.

[39] D. Song; W. Wang; W. Ye; D. Ji; R. Luo; H.-F. Chen. ff14idps force ﬁeld improving the conformation

sampling of intrinsically disordered proteins. Chemical Biology & Drug Design, 2017, 89, 5–15.

[40] W. Ye; D. Ji; W. Wang; R. Luo; H.-F. Chen. Test and evaluation of ff99idps force ﬁeld for intrinsically

disordered proteins. Journal of Chemical Information and Modeling, 2015, 55, 1021–1029.

[41] J. Huang; S. Rauscher; G. Nawrocki; T. Ran; M. Feig; B. L. de Groot; H. Grubmuller; A. D. MacKerell Jr.
Charmm36m: an improved force ﬁeld for folded and intrinsically disordered proteins. Nat Meth, 2017, 14,
71–73.

[42] P. S. Shabane; S. Izadi; A. V. Onufriev. General purpose water model can improve atomistic simulations of

intrinsically disordered proteins. Journal of Chemical Theory and Computation, 2019, 15, 2620–2634.

[43] T. E. Cheatham, III; M. A. Young. Molecular dynamics simulation of nucleic acids: Successes, limitations

and promise. Biopolymers, 2001, 56, 232–256.

[44] T. E. Cheatham, III. Simulation and modeling of nucleic acid structure, dynamics and interactions. Curr.

Opin. Struct. Biol., 2004, 14, 360–367.

[45] P. Varnai; D. Djuranovic; R. Lavery; B. Hartmann. alpha/gamma Transitions in the B-DNA backbone. Nucl.

Acids Res., 2002, 30, 5398–5406.

[46] N. Spackova; T. E. Cheatham; F. Ryjacek; F. Lankas; L. vanMeervelt; P. Hobza; J. Sponer. Molecular
Dynamics Simulations and Thermodynamics Analysis of DNA-Drug Complexes. Minor Groove Binding
between 4’,6-Diamidino-2-phenylindole and DNA Duplexes in Solution. J. Am. Chem. Soc., 2003, 125,
1759–1769.

[47] A. Perez; I. Marchan; D. Svozil; J. Sponer; T. E. Cheatham; C. A. Laughton; M. Orozco. Reﬁnement of the
AMBER Force Field for Nucleic Acids: Improving the Description of alpha/gamma Conformers. Biophys.
J., 2007, 92, 3817–3829.

[48] D. Svozil; J. E. Sponer; I. Marchan; A. Perez; T. E. Cheatham; F. Forti; F. J. Luque; M. Orozco; J. Sponer.
Geometrical and electronic structure variability of the sugar-phosphate backbone in nucleic acids. J. Phys.
Chem. B, 2008, 112, 8188–8197.

[49] M. Zgarbova; M. Otyepka; J. Sponer; A. Mladek; P. Banas; T. E. Cheatham; P. Jurecka. Reﬁnement of the
Cornell et al. Nucleic Acids Force Field Based on Reference Quantum Chemical Calculations of Glycosidic
Torsion Proﬁles. J. Chem. Theory Comput., 2011, 7, 2886–2902.

[50] T. Steinbrecher; J. Latzer; D. A. Case. Revised AMBER Parameters for Bioorganic Phosphates. J. Chem.

Theory Comput., 2012, 8, 4405–4412.

[51] I. Yildirim; H. A. Stern; S. D. Kennedy; J. D. Tubbs; D. H. Turner. Reparameterization of RNA chi Torsion
Parameters for the AMBER Force Field and Comparison to NMR Spectra for Cytidine and Uridine . J.
Chem. Theory Comput., 2010, 6, 1520–1531.

856

BIBLIOGRAPHY

[52] A. H. Aytenﬁsu; A. Spasic; A. Grossﬁeld; H. A. Stern; D. H. Mathews. Revised RNA Dihedral Parameters
for the Amber Force Field Improve RNA Molecular Dynamics. J. Chem. Theory Comput., 2017, 13, 900–
915.

[53] D. Tan; S. Piana; R. Dirks; D. Shaw. RNA force ﬁeld with accuracy comparable to state-of- the-art protein

force ﬁelds. Proc. Natl. Acad. Sci. USA, 2018, 115, E1346–E1355.

[54] R. Aduri; B. T. Psciuk; P. Saro; H. Taniga; H. B. Schlegel; J. SantaLucia, Jr. AMBER force ﬁeld parameters
for the naturally occurring modiﬁed nucleosides in RNA. J. Chem. Theory Comput., 2007, 3, 1465–1475.

[55] P. Banáš; D. Hollas; M. Zgarbová; P. Jurecka; M. Orozco; T. E. Cheatham, III; J. Šponer; M. Otyepka.
Performance of molecular mechanics force ﬁelds for RNA simulations: Stability of UUCG and GNRA
hairpins. J. Chem. Theory. Comput., 2010, 6, 3836–3849.

[56] C. Bergonzo; T. E. C. III. Improved force ﬁeld parameters lead to a better description of rna structure. J. of

Chem. Theory Comput., 2015, 11, 3969–3972.

[57] I. Yildirim; H. A. Stern; J. D. Tubbs; S. D. Kennedy; D. H. Turner. Benchmarking AMBER Force Fields for
RNA: Comparisons to NMR Spectra for Single-Stranded r(GACC) Are Improved by Revised chi Torsions.
J. Phys. Chem. B, 2011, 115, 9261–9270.

[58] I. Yildirim; S. D. Kennedy; H. A. Stern; J. M. Hart; R. Kierzek; D. H. Turner. Revision of AMBER Torsional
Parameters for RNA Improves Free Energy Predictions for Tetramer Duplexes with GC and iGiC Base Pairs.
J. Chem. Theory Comput., 2012, 8, 172–181.

[59] M. Krepl; M. Zgarbova; P. Stadlbauer; M. Otyepka; P. Banas; J. Koca; T. E. Cheatham, III; J. Sponer.
Reference simulations of noncanonical nucleic acids with different chi variants of the AMBER force ﬁeld:
Quadruplex DNA, quadruplex RNA, and Z-DNA. J. Chem. Theory Comp., 2012, 8, 2506–2520.

[60] M. Zgarbová; F. J. Luque; J. Šponer; T. E. C. III; M. Otyepka; P. Jureˇcka. Toward improved description of
dna backbone: Revisiting epsilon and zeta torsion force ﬁeld parameters. J. Chem. Theory Comput., 2013,
9, 2339–2354.

[61] M. Zgarbová; J. Sponer; M. Otyepka; T. E. Cheatham, III; R. Galindo-Murillo; P. Jureˇcka. Reﬁnement of
the Sugar-Phosphate Backbone Torsion Beta for AMBER Force Fields Improves the Description of Z- and
B-DNA. J. Chem. Theor. and Comp., 2015, 12, 5723–5736.

[62] R. Galindo-Murillo; J. C. Robertson; M. Zgarbovic; J. Sponer; M. Otyepka; P. Jureska; T. E. Cheatham.
Assessing the Current State of Amber Force Field Modiﬁcations for DNA. J. Chem. Theory Comput., 2016,
12, 4114–4127.

[63] I. Ivani; P. D. Dans; A. Noy; A. Pérez; I. Faustino; A. Hopsital; J. Walther; P. Andrió; R. Goni; A. Balaceanu;
G. Portella; F. Battistini; J. L. GelpÃ; C. González; M. Vendruscolo; C. A. Laughton; S. Harris; D. A. Case;
M. Orozco. Parmbsc1: A reﬁned force ﬁeld for DNA simulations. Nature Meth., 2016, 13, 55–58.

[64] K. N. Kirschner; A. B. Yongye; S. M. Tschampel; J. González-Outeiriño; C. R. Daniels; B. L. Foley; R. J.
Woods. GLYCAM06: A generalizable biomolecular force ﬁeld. Carbohydrates. J. Comput. Chem., 2008,
29, 622–655.

[65] M. L. DeMarco; R. J. Woods. Atomic-resolution conformational analysis of the G(M3) ganglioside in a
lipid bilayer and its implications for ganglioside-protein recognition at membrane surfaces. Glycobiology,
2009, 19, 344–355.

[66] M. L. DeMarco; R. J. Woods; J. H. Prestegard; F. Tian. Presentation of Membrane-Anchored Glycosph-
ingolipids Determined from Molecular Dynamics Simulations and NMR Paramagnetic Relaxation Rate
Enhancement. J. Am. Chem. Soc., 2010, 132, 1334–1338.

857

BIBLIOGRAPHY

[67] R. Kadirvelraj; O. C. Grant; I. J. Goldstein; H. C. Winter; H. Tateno; E. Fadda; R. J. Woods. Structure and
binding analysis of Polyporus squamosus lectin in complex with the Neu5Acα2-6Galβ 1-4GlcNAc human-
type inﬂuenza receptor. Glycobiology, 2011, 21, 973–984.

[68] M. L. DeMarco; R. J. Woods. From agonist to antagonist: Structure and dynamics of innate immune
glycoprotein MD-2 upon recognition of variably acylated bacterial endotoxins. Mol. Immunol., 2011, 49,
124–133.

[69] B. L. Foley; M. B. Tessier; R. J. Woods. Carbohydrate force ﬁelds. WIREs Comput. Mol. Sci., 2012, 2,

652–697.

[70] E. Ficko-Blean; C. P. Stuart; M. D. Suits; M. Cid; M. Tessier; R. J. Woods; A. B. Boraston. Carbohy-
drate Recognition by an Architecturally Complex α-N-Acetylglucosaminidase from Clostridium perfrin-
gens. PLoS ONE, 2012, 7, e33524.

[71] M. B. Tessier; M. L. DeMarco; A. B. Yongye; R. J. Woods. Extension of the GLYCAM06 biomolecular

force ﬁeld to lipids, lipid bilayers and glycolipids. Mol. Simul., 2008, 34, 349–363.

[72] R. J. Woods. Restrained electrostatic potential charges for condensed phase simulations of carbohydrates.

J. Mol. Struct (Theochem), 2000, 527, 149–156.

[73] R. J. Woods. Derivation of net atomic charges from molecular electrstatic potentials. J. Comput. Chem.,

1990, 11, 29–310.

[74] M. Basma; S. Sundara; D. Calgan; T. Venali; R. J. Woods. Solvated ensemble averaging in the calculation

of partial atomic charges. J. Comput. Chem., 2001, 22, 1125–1137.

[75] S. M. Tschampel; M. R. Kennerty; R. J. Woods. TIP5P-consistent treatment of electrostatics for biomolec-

ular simulations. J. Chem. Theory Comput., 2007, 3, 1721–1733.

[76] M. L. DeMarco; R. J. Woods. Bridging computational biology and glycobiology: A game of snakes and

ladders. Glycobiology, 2008, 18, 426–440.

[77] S. E. Feller. Molecular dynamics simulations of lipid bilayers. Curr. Opin. Colloid Interface Sci., 2000, 5,

217–223.

[78] L. Saiz; M. L. Klein. Computer Simulation Studies of Model Biological Membranes. Acc. Chem. Res.,

2002, 35, 482–489.

[79] A. Lomize; I. Pogozheva; M. Lomize; H. Mosberg. The role of hydrophobic interactions in positioning of

peripheral proteins in membranes. BMC Struct. Biol., 2007, 7, 44.

[80] M. L. Lundstrom, K. H.; Chiu. G Protein-Coupled Receptors in Drug Discovery. Taylor & Francis, London,

2005.

[81] M. F. Crowley; M. J. Williamson; R. C. Walker. CHAMBER: Comprehensive support for CHARMM force

ﬁelds within the AMBER software. Int. J. Quant. Chem., 2009, 109, 3767–3772.

[82] Å. Skjevik; B. D. Madej; R. C. Walker; K. Teigen. Lipid11: A modular framework for lipid simulations

using amber. J. Phys. Chem. B, 2012, 116, 11124–11136.

[83] C. J. Dickson; L. Rosso; R. M. Betz; R. C. Walker; I. R. Gould. GAFFlipid: a General Amber Force Field

for the accurate molecular dynamics simulation of phospholipid. Soft Matter, 2012, 8, 9617.

[84] C. J. Dickson; B. D. Madej; A. A. Skjevik; R. M. Betz; K. Teigen; I. R. Gould; R. C. Walker. Lipid14: The

Amber Lipid Force Field. J. Chem. Theory Comput., 2014, 10, 865–879.

[85] Å. Skjevik; B. D. Madej; C. J. Dickson; K. Teigen; R. C. Walker; I. R. Gould. All-atom lipid bilayer

self-assembly with the amber and charmm lipid force ﬁelds. Chem. Commun., 2015, 51, 4402–4405.

858

BIBLIOGRAPHY

[86] Å. Skjevik; B. D. Madej; C. J. Dickson; C. Lin; K. Teigen; R. C. Walker; I. R. Gould. Simulations of lipid
bilayer self-assembly using all-atom lipid force ﬁelds. Phys. Chem. Chem. Phys., 2016, 18, 10573–10584.

[87] B. D. Madej; I. R. Gould; R. C. Walker. A Parameterization of Cholesterol for Mixed Lipid Bilayer Simu-

lation within the Amber Lipid14 Force Field. J Phys Chem B, 2015, 119, 12424–12435.

[88] W. L. Jorgensen; J. Chandrasekhar; J. Madura; M. L. Klein. Comparison of simple potential functions for

simulating liquid water. J. Chem. Phys., 1983, 79, 926–935.

[89] D. J. Price; C. L. Brooks. A modiﬁed TIP3P water potential for simulation with Ewald summation. J. Chem.

Phys., 2004, 121, 10096–10103.

[90] W. L. Jorgensen; J. D. Madura. Temperature and size dependence for Monte Carlo simulations of TIP4P

water. Mol. Phys., 1985, 56, 1381–1392.

[91] H. W. Horn; W. C. Swope; J. W. Pitera; J. D. Madura; T. J. Dick; G. L. Hura; T. Head-Gordon. Development
of an improved four-site water model for biomolecular simulations: TIP4P-Ew. J. Chem. Phys., 2004, 120,
9665–9678.

[92] H. W. Horn; W. C. Swope; J. W. Pitera. Characterization of the TIP4P-Ew water model: Vapor pressure and

boiling point. J. Chem. Phys., 2005, 123, 194504.

[93] M. W. Mahoney; W. L. Jorgensen. A ﬁve-site model for liquid water and the reproduction of the density

anomaly by rigid, nonpolarizable potential functions. J. Chem. Phys., 2000, 112, 8910–8922.

[94] S. Izadi; A. V. Onufriev. Accuracy limit of rigid 3-point water models. J. Chem. Phys., 2016, 145, 074501.

[95] J. W. Caldwell; P. A. Kollman. Structure and properties of neat liquids using nonadditive molecular dynam-

ics: Water, methanol and N-methylacetamide. J. Phys. Chem., 1995, 99, 6208–6219.

[96] H. J. C. Berendsen; J. R. Grigera; T. P. Straatsma. The missing term in effective pair potentials. J. Phys.

Chem., 1987, 91, 6269–6271.

[97] Y. Wu; H. L. Tepper; G. A. Voth. Flexible simple point-charge water model with improved liquid-state

properties. J. Chem. Phys., 2006, 124, 024503.

[98] F. Paesani; W. Zhang; D. A. Case; T. E. Cheatham; G. A. Voth. An accurate and simple quantum model for

liquid water. J. Chem. Phys., 2006, 125, 184507.

[99] P. Cieplak; J. Caldwell; P. Kollman. Molecular mechanical models for organic and biological systems going
beyond the atom centered two body additive approximation: Aqueous solution free energies of methanol
and N-methyl acetamide, nucleic acid base, and amide hydrogen bonding and chloroform/water partition
coefﬁcients of the nucleic acid bases. J. Comput. Chem., 2001, 22, 1048–1057.

[100] R. Anandakrishnan; C. Baker; S. Izadi; A. V. Onufriev. Point charges optimally placed to represent the

multipole expansion of charge distributions. PloS one, 2013, 8, e67715.

[101] S. Niu; M. L. Tan; T. Ichiye. The large quadrupole of water molecules. J. Chem. Phys., 2011, 134, 134501+.

[102] A. Mukhopadhyay; A. T. Fenley; I. S. Tolokh; A. V. Onufriev. Charge hydration asymmetry: the basic

principle and how to use it to test and improve water models. J. Phys. Chem. B, 2012, 116, 9776–9783.

[103] D. Dans; D. Gallego; A. Balaceanu; L. Darre; H. Gomez; M. Orozco. Modeling, simulations, and bioinfor-

matics at the service of rna structure. Chem, 2019, 5, 51 – 73.

[104] P. Kuhrova; V. Mlynsky; M. Zgarbova; M. Krepl; G. Bussi; R. B. Best; M. Otyepka; J. Sponer; P. Banas.
Improving the performance of the Amber RNA force ﬁeld by tuning the hydrogen-bonding interactions.
bioRxiv, 2019.

859

BIBLIOGRAPHY

[105] A. Bochicchio; M. Krepl; F. Yang; G. Varani; J. Sponer; P. Carloni. Molecular basis for the increased
afﬁnity of an RNA recognition motif with re-engineered speciﬁcity: A molecular dynamics and enhanced
sampling simulations study. PLOS Computat. Biol., 2018, 14, 1–27.

[106] N. M. Kumbhar;

signiﬁcance of hypermodiﬁed nucleoside 5-
carboxymethylaminomethyluridine (cmnm5U) from wobble (34th) position of mitochondrial tRNAs:
Molecular modeling and Markov state model studies. J. Molec. Graph. Model., 2019, 86, 66 – 83.

J. S. Gopal.

Structural

[107] F. Leonarski; M. Jasinski; J. Trylska. Thermodynamics of the fourU RNA thermal switch derived from

molecular dynamics simulations and spectroscopic techniques. Biochimie, 2019, 156, 22 – 32.

[108] C. Yang; M. Kulkarni; M. Lim; Y. Pak. Insilico direct folding of thrombin-binding aptamer G-quadruplex

at all-atom level. Nucl. Acids Res., 2017, 45, 12648–12656.

[109] K. Gao; J. Yin; N. M. Henriksen; A. T. Fenley; M. K. Gilson. Binding enthalpy calculations for a neutral
host-guest pair yield widely divergent salt effects across water models. J. of Chem. Theory Comput., 2015,
11, 4555–4564.

[110] O. H. S. Ollila; H. A. Heikkinen; H. IwaÃ¯. Rotational dynamics of proteins from spin relaxation times
and molecular dynamics simulations. The Journal of Physical Chemistry B, 2018, 122, 6559–6569. PMID:
29812937.

[111] M. Javanainen; A. Lamberg; L. Cwiklik; I. Vattulainen; O. H. S. Ollila. Atomistic model for nearly quanti-

tative simulations of langmuir monolayers. Langmuir, 2018, 34, 2565–2572. PMID: 28945973.

[112] D. Pantoja-Uceda; J. L. Neira; L. M. Contreras; C. A. Manton; D. R. Welch; B. Rizzuti. The isolated
C-terminal nuclear localization sequence of the breast cancer metastasis suppressor 1 is disordered. Arch.
Biochem. Biophys., 2019, 664, 95 – 101.

[113] M. Kulkarni; C. Yang; Y. Pak. Reﬁned alkali metal ion parameters for the opc water model. Bulletin of the

Korean Chemical Society, 2018, 39, 931–935.

[114] I. S. Joung; T. E. Cheatham, III. Molecular dynamics simulations of the dynamic and energetic properties
of alkali and halide ions using water-model-speciﬁc ion parameters. J. Phys. Chem. B, 2009, 113, 13279–
13290.

[115] S. Joung; T. E. Cheatham, III. Determination of alkali and halide monovalent ion parameters for use in

explicitly solvated biomolecular simulations. J. Phys. Chem. B, 2008, 112, 9020–9041.

[116] P. Li; B. P. Roberts; D. K. Chakravorty; K. M. Merz, Jr. Rational Design of Particle Mesh Ewald Compatible
Lennard-Jones Parameters for +2 Metal Cations in Explicit Solvent. J. Chem. Theory Comput., 2013, 9,
2733–2748.

[117] P. Li; K. M. Merz, Jr. Taking into Account the Ion-Induced Dipole Interaction in the Nonbonded Model of

Ions. J. Chem. Theory Comput., 2014, 10, 289–297.

[118] P. Li; L. F. Song; K. M. Merz, Jr. Parameterization of Highly Charged Metal Ions Using the 12-6-4 LJ-Type

Nonbonded Model in Explicit Water. J. Phys. Chem. B, 2015, 119, 883–895.

[119] P. Li; L. F. Song; K. M. Merz, Jr. Systematic Parameterization of Monovalent Ions Employing the Non-

bonded Model. J. Chem. Theory Comput., 2015, 11, 1645–1657.

[120] M. T. Panteva; G. M. Giambasu; D. M. York. Comparison of Structural, Thermodynamic, Kinetic and Mass
Transport Properties of Mg2+ Models Commonly Used in Biomolecular Simulations. J. Comput. Chem.,
2015, 36, 970–982.

[121] M. T. Panteva; G. M. Giambasu; D. M. York. Force Field for Mg2+, Mn2+, Zn2+ and Cd2+ Ions That Have

Balanced Interactions with Nucleic Acids. J. Phys. Chem. B, 2015, 119, 15460–15470.

860

BIBLIOGRAPHY

[122] G. M. Giambasu; D. A. Case; D. M. York. Predicting Site-Binding Modes of Ions and Water to Nucleic

Acids Using Molecular Solvation Theory. J. Am. Chem. Soc., 2019, 141, 2435–2445.

[123] N. Homeyer; A. H. C. Horn; H. Lanig; H. Sticht. AMBER force-ﬁeld parameters for phosphorylated amino
acids in different protonation states: phosphoserine, phosphothreonine, phosphotyrosine, and phosphohisti-
dine. J. Mol. Model., 2006, 12, 281–289.

[124] L. Raguette; A. Cuomo; K. Belfon; C. Tian; Q. Wu; C. Simmerling. Updated Amber force ﬁeld parameters

for phosphorylated amino acids for ff14SB and ff19SB. In Prep, 2020.

[125] K. Belfon; L. Raguette; Q. Wu; C. Simmerling. Application of RAGTAG: modiﬁed amino acids for com-

paring MD simulations with FRET/EPR experiments. In Prep, 2020.

[126] K. Belfon; C. Tian; J. Maier; L. Raguette; Q. Wu; C. Simmerling. RAGTAG: Rapid Amber Gpu Torsion

pArameter Generator. . In Prep, 2020.

[127] D. L. Blood; A. M. Rosnik; B. P. Krueger. Molecular dynamics parameters for the gfp chromophore and

some of its analogues. Manuscript in preparation, 2016.

[128] A. M. Wollacott; K. M. Merz, Jr. Development of a parameterized force ﬁeld to reproduce semiempirical

geometries. J. Chem. Theory Comput., 2006, 2, 1070–1077.

[129] S. N. Steinmann; R. Ferreira de Morais; A. W. Götz; P. Fleurat-Lessard; M. Iannuzzi; P. Sautet; C. Michel.

J. Chem. Theory Comput., 2018.

[130] S. N. Steinmann; P. Fleurat-Lessard; A. W. Götz; C. Michel; R. Ferreira de Morais; P. Sautet. Molecular
mechanics models for the image charge, a comment on “including image charge effects in the molecular
dynamics simulations of molecules on metal surfaces”. J. Comput. Chem., 2017, 38, 2127–2129.

[131] T. Graen; M. Hoeﬂing; H. Grubmueller. Amber-dyes: Characterization of charge ﬂuctuations and force ﬁeld
parameterization of ﬂuorescent dyes for molecular dynamics simulations. Journal of Chemical Theory and
Computation, 2014, 10, 5505–5512.

[132] B. Schepers; H. Gohlke. Amber-dyes in amber: Implementation of ﬂuorophore and linker parameters into

ambertools. Journal of Chemical Physics, 2020, 152.

[133] F. Meng; M. M. Bellaiche; J.-Y. Kim; G. H. Zerze; R. B. Best; H. S. Chung. Highly disordered amyloid-β

monomer probes by single-molecule fret and md simulation. Biophysical Journal, 2018, 114, 870–884.

[134] M. R. Machado; E. E. Barrera; F. Klein; M. Sonora; S. Silva; S. Pantano. The SIRAH 2.0 Force Field:

Altius, Fortius, Citius. J. Chem. Theory Comput., 2019, 15, 2719–2733. PMID: 30810317.

[135] P. D. Dans; A. Zeida; M. R. Machado; S. Pantano. A coarse grained model for atomic-detailed dna simula-

tions with explicit electrostatics. J. Chem. Theory Comput., 2010, 6, 1711–1725. PMID: 26615701.

[136] E. E. Barrera; M. R. Machado; S. Pantano. Fat sirah: Coarse-grained phospholipids to explore membrane-

protein dynamics. J. Chem. Theory Comput., 2019, 15, 5674–5688. PMID: 31433946.

[137] P. G. Garay; E. E. Barrera; S. Pantano. Post-translational modiﬁcations at the coarse-grained level with the

sirah force ﬁeld. J. Chem. Inform. Model., 2020, 60, 964–973. PMID: 31840995.

[138] F. Klein; D. Cáceres-Rojas; M. Carrasco; J. C. Tapia; J. Caballero; J. Alzate-Morales; S. Pantano. Parame-

terization of Divalent Cations for Coarse-Grained Simulations. chemrxiv.11881716.v1, 2020.

[139] L. Darré; M. R. Machado; P. D. Dans; F. E. Herrera; S. Pantano. Another coarse grain model for aqueous

solvation: Wat four? J. Chem. Theory Comput., 2010, 6, 3793–3807.

[140] M. R. Machado; S. Pantano. SIRAH tools: mapping, backmapping and visualization of coarse-grained

models. Bioinformatics, 2016, 32, 1568–1570.

861

BIBLIOGRAPHY

[141] A. Zeida; M. R. Machado; P. D. Dans; S. Pantano. Breathing, bubbling, and bending: DNA ﬂexibility from

multimicrosecond simulations. Phys. Rev. E, 2012, 86, 021903.

[142] M. R. Machado; H. C. González; S. Pantano. Md simulations of viruslike particles with supra cg solvation

affordable to desktop computers. J. Chem. Theory Comput., 2017, 13, 5106–5116. PMID: 28876928.

[143] H. C. Gonzalez; L. Darré; S. Pantano. Transferable mixing of atomistic and coarse-grained water models.

J. Phys. Chem. B, 2013, 117, 14438–14448. PMID: 24219057.

[144] M. R. Machado; P. D. Dans; S. Pantano. A hybrid all-atom/coarse grain model for multiscale simulations

of dna. Phys. Chem. Chem. Phys., 2011, 13, 18134–18144.

[145] M. R. Machado; S. Pantano. Exploring LacI–DNA Dynamics by Multiscale Simulations Using the SIRAH

Force Field. J. Chem. Theory Comput., 2015, 11, 5012–5023. PMID: 26574286.

[146] M. R. Machado; A. Zeida; L. Darré; S. Pantano. From quantum to subcellular scales: multi-scale simulation

approaches and the sirah force ﬁeld. Interface Focus, 2019, 9.

[147] S. J. Weiner; P. A. Kollman; D. A. Case; U. C. Singh; C. Ghio; G. Alagona; S. Profeta, Jr.; P. Weiner. A
new force ﬁeld for molecular mechanical simulation of nucleic acids and proteins. J. Am. Chem. Soc., 1984,
106, 765–784.

[148] S. J. Weiner; P. A. Kollman; D. T. Nguyen; D. A. Case. An all-atom force ﬁeld for simulations of proteins

and nucleic acids. J. Comput. Chem., 1986, 7, 230–252.

[149] U. C. Singh; S. J. Weiner; P. A. Kollman. Molecular dynamics simulations of d(C-G-C-G-A).d(T-C-G-C-G)

with and without "hydrated" counterions. Proc. Nat. Acad. Sci., 1985, 82, 755–759.

[150] P. A. Kollman; R. Dixon; W. Cornell; T. Fox; C. Chipot; A. Pohorille. in Computer Simulation of Biomolec-

ular Systems, Vol. 3, A. Wilkinson; P. Weiner; W. F. van Gunsteren, Eds., pp 83–96. Elsevier, 1997.

[151] M. D. Beachy; R. A. Friesner. Accurate ab intio quantum chemical determination of the relative energies of
peptide conformations and assessment of empirical force ﬁelds. J. Am. Chem. Soc., 1997, 119, 5908–5920.

[152] L. Wang; Y. Duan; R. Shortle; B. Imperiali; P. A. Kollman. Study of the stability and unfolding mechanism

of BBA1 by molecular dynamics simulations at different temperatures. Prot. Sci., 1999, 8, 1292–1304.

[153] J. Higo; N. Ito; M. Kuroda; S. Ono; N. Nakajima; H. Nakamura. Energy landscape of a peptide consisting of
α-helix, 310 helix, β -turn, β -hairpin and other disordered conformations. Prot. Sci., 2001, 10, 1160–1171.
[154] T. E. Cheatham, III; P. Cieplak; P. A. Kollman. A modiﬁed version of the Cornell et al. force ﬁeld with

improved sugar pucker phases and helical repeat. J. Biomol. Struct. Dyn., 1999, 16, 845–862.

[155] J. Wang; P. Cieplak; P. A. Kollman. How well does a restrained electrostatic potential (RESP) model perform
in calculating conformational energies of organic and biological molecules? J. Comput. Chem., 2000, 21,
1049–1074.

[156] P. Cieplak; W. D. Cornell; C. Bayly; P. A. Kollman. Application of the multimolecule and multiconfor-
mational RESP methodology to biopolymers: Charge derivation for DNA, RNA and proteins. J. Comput.
Chem., 1995, 16, 1357–1377.

[157] P. Cieplak; F.-Y. Dupradeau; Y. Duan; J. Wang. Polarization effects in molecular mechanical force ﬁelds. J.

Phys.: Condens. Matter, 2009, 21, 333102.

[158] Z.-X. Wang; W. Zhang; C. Wu; H. Lei; P. Cieplak; Y. Duan. Strike a Balance: Optimization of backbone
torsion parameters of AMBER polarizable force ﬁeld for simulations of proteins and peptides. J. Comput.
Chem., 2006, 27, 781–790.

[159] R. W. Dixon; P. A. Kollman. Advancing beyond the atom-centered model in additive and nonadditive

molecular mechanics. J. Comput. Chem., 1997, 18, 1632–1646.

862

BIBLIOGRAPHY

[160] E. Meng; P. Cieplak; J. W. Caldwell; P. A. Kollman. Accurate solvation free energies of acetate and methy-
lammonium ions calculated with a polarizable water model. J. Am. Chem. Soc., 1994, 116, 12061–12062.

[161] J. Åqvist. Ion-water interaction potentials derived from free energy perturbation simulations. J. Phys. Chem.,

1990, 94, 8021–8024.

[162] L. Dang. Mechanism and thermodynamics of ion selectivity in aqueous solutions of 18-crown-6 ether: A

molecular dynamics study. J. Am. Chem. Soc., 1995, 117, 6954–6960.

[163] P. Aufﬁnger; T. E. Cheatham, III; A. C. Vaiana. Spontaneous formation of KCl aggregates in biomolecular

simulations: a force ﬁeld issue? J. Chem. Theory Comput., 2007, 3, 1851–1859.

[164] L. David; R. Luo; M. K. Gilson. Comparison of generalized born and poisson models: Energetics and

dynamics of hiv protease. J. Comput. Chem., 2000, 21, 295–309.

[165] M. Feig. Kinetics from Implicit Solvent Simulations of Biomolecules as a Function of Viscosity. J. Chem.

Theory Comput., 2007, 3, 1734–1748.

[166] R. E. Amaro; X. Cheng; I. Ivanov; D. Xu; A. J. Mccammon. Characterizing Loop Dynamics and Lig-
and Recognition in Human- and Avian-Type Inﬂuenza Neuraminidases via Generalized Born Molecular
Dynamics and End-Point Free Energy Calculations. J. Am. Chem. Soc., 2009, 131, 4702–4709.

[167] B. Zagrovic; V. Pande. Solvent viscosity dependence of the folding rate of a small protein: Distributed

computing study. J. Comput. Chem., 2003, 24, 1432–1436.

[168] R. Anandakrishnan; A. Drozdetski; R. C. Walker; A. V. Onufriev. Speed of Conformational Change: Com-
paring Explicit and Implicit Solvent Molecular Dynamics Simulations. Biophysical Journal, 2015, 108,
1153–1164.

[169] A. V. Onufriev; D. A. Case. Generalized Born implicit solvent models for biomolecules. Annu. Rev. Bio-

phys., 2019, 48, 275–296.

[170] J. Weiser; P. S. Shenkin; W. C. Still. Approximate Atomic Surfaces from Linear Combinations of Pairwise

Overlaps (LCPO). J. Comput. Chem., 1999, 20, 217–230.

[171] W. C. Still; A. Tempczyk; R. C. Hawley; T. Hendrickson. Semianalytical treatment of solvation for molec-

ular mechanics and dynamics. J. Am. Chem. Soc., 1990, 112, 6127–6129.

[172] M. Schaefer; M. Karplus. A comprehensive analytical treatment of continuum electrostatics. J. Phys. Chem.,

1996, 100, 1578–1599.

[173] S. R. Edinger; C. Cortis; P. S. Shenkin; R. A. Friesner. Solvation free energies of peptides: Comparison
of approximate continuum solvation models with accurate solution of the Poisson-Boltzmann equation. J.
Phys. Chem. B, 1997, 101, 1190–1197.

[174] B. Jayaram; D. Sprous; D. L. Beveridge. Solvation free energy of biomacromolecules: Parameters for a
modiﬁed generalized Born model consistent with the AMBER force ﬁeld. J. Phys. Chem. B, 1998, 102,
9571–9576.

[175] C. J. Cramer; D. G. Truhlar. Implicit solvation models: Equilibria, structure, spectra, and dynamics. Chem.

Rev., 1999, 99, 2161–2200.

[176] D. Bashford; D. A. Case. Generalized Born models of macromolecular solvation effects. Annu. Rev. Phys.

Chem., 2000, 51, 129–152.

[177] A. Onufriev; D. Bashford; D. A. Case. Modiﬁcation of the generalized Born model suitable for macro-

molecules. J. Phys. Chem. B, 2000, 104, 3712–3720.

[178] M. S. Lee; F. R. Salsbury, Jr.; C. L. Brooks, III. Novel generalized Born methods. J. Chem. Phys., 2002,

116, 10606–10614.

863

BIBLIOGRAPHY

[179] B. N. Dominy; C. L. Brooks, III. Development of a generalized Born model parameterization for proteins

and nucleic acids. J. Phys. Chem. B, 1999, 103, 3765–3773.

[180] V. Tsui; D. A. Case. Molecular dynamics simulations of nucleic acids using a generalized Born solvation

model. J. Am. Chem. Soc., 2000, 122, 2489–2498.

[181] N. Calimet; M. Schaefer; T. Simonson. Protein molecular dynamics with the generalized Born/ACE solvent

model. Proteins, 2001, 45, 144–158.

[182] A. Onufriev; D. Bashford; D. A. Case. Exploring protein native states and large-scale conformational

changes with a modiﬁed generalized Born model. Proteins, 2004, 55, 383–394.

[183] J. Srinivasan; M. W. Trevathan; P. Beroza; D. A. Case. Application of a pairwise generalized Born model to

proteins and nucleic acids: inclusion of salt effects. Theor. Chem. Acc., 1999, 101, 426–434.

[184] A. Onufriev; D. A. Case; D. Bashford. Effective Born radii in the generalized Born approximation: The

importance of being perfect. J. Comput. Chem., 2002, 23, 1297–1304.

[185] G. D. Hawkins; C. J. Cramer; D. G. Truhlar. Parametrized models of aqueous free energies of solvation
based on pairwise descreening of solute atomic charges from a dielectric medium. J. Phys. Chem., 1996,
100, 19824–19839.

[186] F. M. Richards. Areas, volumes, packing, and protein structure. Ann. Rev. Biophys. Bioeng., 1977, 6,

151–176.

[187] M. Schaefer; C. Froemmel. A precise analytical method for calculating the electrostatic energy of macro-

molecules in aqueous solution. J. Mol. Biol., 1990, 216, 1045–1066.

[188] M. Feig; A. Onufriev; M. Lee; W. Im; D. A. Case; C. L. Brooks, III. Performance comparison of the
generalized Born and Poisson methods in the calculation of the electrostatic solvation energies for protein
structures. J. Comput. Chem., 2004, 25, 265–284.

[189] R. Geney; M. Layten; R. Gomperts; C. Simmerling. Investigation of salt bridge stability in a generalized

Born solvent model. J. Chem. Theory Comput., 2006, 2, 115–127.

[190] A. Okur; L. Wickstrom; C. Simmerling. Evaluation of salt bridge structure and energetics in peptides using

explicit, implicit and hybrid solvation models. J. Chem. Theory Comput., 2008, 4, 488–498.

[191] A. Okur; L. Wickstrom; M. Layten; R. Geney; K. Song; V. Hornak; C. Simmerling. Improved efﬁciency
of replica exchange simulations through use of a hybrid explicit/implicit solvation model. J. Chem. Theory
Comput., 2006, 2, 420–433.

[192] D. R. Roe; A. Okur; L. Wickstrom; V. Hornak; C. Simmerling. Secondary Structure Bias in Generalized
Born Solvent Models: Comparison of Conformational Ensembles and Free Energy of Solvent Polarization
from Explicit and Implicit Solvation. J. Phys. Chem. B, 2007, 111, 1846–1857.

[193] H. Nguyen; J. Maier; H. Huang; V. Perrone; C. Simmerling. Folding simulations for proteins with diverse
topologies are accessible in days with a physics-based force ﬁeld and implicit solvent. J. Am. Chem. Soc.,
2014, 136, 13959–13962. PMID: 25255057.

[194] H. Nguyen; A. Pérez; S. Bermeo; C. Simmerling. Reﬁnement of Generalized Born Implicit Solvation
Parameters for Nucleic Acids and Their Complexes with Proteins. J. Chem. Theory Comput., 2015, 11,
3714–3728.

[195] A. Onufriev. in Modeling Solvent Environments, M. Feig, Ed., (Wiley, USA). pp 127–165. 2010.

[196] G. D. Hawkins; C. J. Cramer; D. G. Truhlar. Pairwise solute descreening of solute charges from a dielectric

medium. Chem. Phys. Lett., 1995, 246, 122–129.

864

BIBLIOGRAPHY

[197] M. Schaefer; H. W. T. Van Vlijmen; M. Karplus. Electrostatic contributions to molecular free energies in

solution. Adv. Protein Chem., 1998, 51, 1–57.

[198] V. Tsui; D. A. Case. Theory and applications of the generalized Born solvation model in macromolecular

simulations. Biopolymers (Nucl. Acid. Sci.), 2001, 56, 275–291.

[199] C. P. Sosa; T. Hewitt; M. S. Lee; D. A. Case. Vectorization of the generalized Born model for molecular

dynamics on shared-memory computers. J. Mol. Struct. (Theochem), 2001, 549, 193–201.

[200] J. Mongan; C. Simmerling; J. A. McCammon; D. A. Case; A. Onufriev. Generalized Born with a simple,

robust molecular volume correction. J. Chem. Theory Comput., 2007, 3, 156–169.

[201] H. Huang; C. Simmerling. Fast Pairwise Approximation of Solvent Accessible Surface Area for Implicit

Solvent Simulations of Proteins on CPUs and GPUs. J. Chem. Theory Comput., 2018, 14, 5797–5814.

[202] D. Sitkoff; K. A. Sharp; B. Honig. Accurate calculation of hydration free energies using macroscopic

solvent models. J. Phys. Chem., 1994, 98, 1978–1988.

[203] G. Sigalov; P. Scheffel; A. Onufriev. Incorporating variable environments into the generalized Born model.

J. Chem. Phys., 2005, 122, 094511.

[204] G. Sigalov; A. Fenley; A. Onufriev. Analytical electrostatics for biomolecules: Beyond the generalized

Born approximation . J. Chem. Phys., 2006, 124, 124902.

[205] B. Aguilar; A. V. Onufriev. Efﬁcient computation of the total solvation energy of small molecules via the r6

generalized born model. J. Chem. Theory Comput., 2012, 8, 2404–2411.

[206] B. Aguilar; R. Shadrach; A. V. Onufriev. Reducing the secondary structure bias in the generalized born

model via r6 effective radii. J. Chem. Theory Comput., 2010, 6, 3613–3630.

[207] N. Forouzesh; S. Izadi; A. V. Onufriev. Grid-Based Surface Generalized Born Model for Calculation of

Electrostatic Binding Free Energies. J. Chem. Inf. Model., 2017, 57, 2505–2513.

[208] S. Izadi; R. C. Harris; M. O. Fenley; A. V. Onufriev. Accuracy comparison of generalized born models in

the calculation of electrostatic binding free energies. J. Chem. Theory Computat., 2018, 14, 1656–1670.

[209] A. Mukhopadhyay; B. H. Aguilar; I. S. Tolokh; A. V. Onufriev. Introducing charge hydration asymmetry

into the generalized born model. J Chem. Theory Comput., 2014, 10, 1788–1794.

[210] Q. Cai; X. Ye; J. Wang; R. Luo. On-the-Fly Numerical Surface Integration for Finite-Difference Poisson-

Boltzmann Methods. J. Chem. Theory Comput., 2011, 7, 3608–3619.

[211] R. Luo; L. David; M. K. Gilson. Accelerated Poisson-Boltzmann calculations for static and dynamic sys-

tems. J. Comput. Chem., 2002, 23, 1244–1253.

[212] J. Wang; R. Luo. Assessment of Linear Finite-Difference Poisson-Boltzmann solvers. J. Comput. Chem.,

2010, 31, 1689–1698.

[213] Q. Cai; M.-J. Hsieh; J. Wang; R. Luo. Performance of Nonlinear Finite-Difference Poisson-Boltzmann

Solvers. J. Chem. Theory Comput., 2010, 6, 203–211.

[214] R. Qi; W. Botello-Smith; R. Luo. Acceleration of Linear Finite-Difference Poisson-Boltzmann Methods on

Graphics Processing Units. J. Chem. Theory Comput., 2017, 13, 3378–3387.

[215] R. Qi; R. Luo. Robustness and Efﬁciency of Poisson-Boltzmann Modeling on Graphics Processing Units.

J. Chem. Inf. Model., 2019, 59, 409–420.

[216] B. Honig; A. Nicholls. Classical electrostatics in biology and chemistry. Science, 1995, 268, 1144–1149.

865

BIBLIOGRAPHY

[217] Q. Lu; R. Luo. A Poisson-Boltzmann dynamics method with nonperiodic boundary condition. J. Chem.

Phys., 2003, 119, 11035–11047.

[218] M. K. Gilson; K. A. Sharp; B. H. Honig. Calculating the electrostatic potential of molecules in solution:

method. J. Comput. Chem., 1988, 9, 327–35.

[219] J. Warwicker; H. C. Watson. Calculation of the electric potential in the active site cleft due to. J. Mol. Biol.,

1982, 157, 671–679.

[220] I. Klapper; R. Hagstrom; R. Fine; K. Sharp; B. Honig. Focussing of electric ﬁelds in the active stie of Cu,

Zn superoxide dismutase. Proteins, 1986, 1, 47–59.

[221] C. H. Tan; Y. H. Tan; R. Luo. Implicit nonpolar solvent models. J. Phys. Chem. B, 2007, 111, 12263–12274.

[222] E. Gallicchio; M. M. Kubo; R. M. Levy. Enthalpy-entropy and cavity decomposition of alkane hydration
free energies: Numerical results and implications for theories of hydrophobic solvation. J. Phys. Chem.,
2000, 104, 6271–6285.

[223] F. Floris; J. Tomasi. Evaluation of the dispersion contribution to the solvation energy. A simple computa-

tional model in the continuum approximation. J. Comput. Chem., 1989, 10, 616–627.

[224] M. E. Davis; J. A. McCammon. Solving the ﬁnite-difference linearized Poisson-Boltzmann equation – a

comparison of relaxation and conjugate gradient methods. J. Comput. Chem., 1989, 10, 386–391.

[225] A. Nicholls; B. Honig. A rapid ﬁnite difference algorithm, utilizing successive over-relaxation to solve the

Poisson-Boltzmann equation. J. Comput. Chem., 1991, 12, 435–445.

[226] D. Bashford. An object-oriented programming suite for electrostatic effects in biological molecules. Lect.

Notes Comput. Sci., 1997, 1343, 233–240.

[227] J. Wang; Q. Cai; Z. Li; H. Zhao; R. Luo. Achieving Energy Conservation in Poisson-Boltzmann Molecular
Dynamics: Accuracy and Precision with Finite-difference Algorithms. Chem. Phys. Lett., 2009, 468, 112.

[228] Z. Li; I. K. The Immbersed Interface Method: numberical sollutions of PDEs involving interfaces and

irregular domains. SIAM Frontiers in Applied Mathematics, Philadelphia, 2006.

[229] B. A. Luty; M. E. Davis; J. A. McCammon. Electrostatic energy calculations by a ﬁnite-difference method:

Rapid calculation of charge-solvent interaction energies. J. Comput. Chem., 1992, 13, 768–771.

[230] Q. Cai; J. Wang; H. Zhao; R. Luo. On removal of charge singularity in Poisson-Boltzmann equation. J.

Chem. Phys., 2009, 130, 145101.

[231] Q. Cai; X. Ye; J. Wang; R. Luo. Dielectric boundary force in numerical Poisson-Boltzmann methods:

Theory and numerical strategies. Chem. Phys. Lett., 2011, 514, 368–373.

[232] M. E. Davis; J. A. McCammon. Dielectric boundary smoothing in ﬁnite difference solutions of the Poisson

equation: An approach to improve accuracy and convergence. J. Comput. Chem., 1991, 12, 909–912.

[233] J. Wang; Q. Cai; Y. Xiang; R. Luo. Reducing Grid Dependence in Finite-Difference Poisson-Boltzmann

Calculations. J. Chem. Theory Comput., 2012, 8, 2741–2751.

[234] C. Wang; P. Nguyen; K. Pham; D. Huynh; T. Le; H. Wang; P. Ren; R. Luo. Calculating protein-ligand

binding afﬁnities with MMPBSA: Method and error analysis. J. Comput. Chem., 2016, 37, 2436–2446.

[235] M. E. Davis; J. A. McCammon. Electrostatics in biomolecular structure and dynamics. Chem. Rev., 1990,

90, 509–521.

[236] C. H. Tan; L. J. Yang; R. Luo. How well does Poisson-Boltzmann implicit solvent agree with explicit

solvent? A quantitative analysis. J. Phys. Chem. B, 2006, 110, 18680–18687.

866

BIBLIOGRAPHY

[237] X. Ye; J. Wang; R. Luo. A Revised Density Function for Molecular Surface Calculation in Continuum

Solvent Models. J. Chem. Theory Comput., 2010, 6, 1157–1169.

[238] Q. Cai; X. Ye; R. Luo. Dielectric Pressure in Continuum Electrostatic Solvation of Biomolecules. Phys.

Chem. Chem. Phys., 2012, 14, 15917–15925.

[239] M. K. Gilson; M. Davis; B. A. Luty; J. A. McCammon. Computation of electrostatic forces on solvated

molecules using the Poisson-Boltzmann equation. J Phys Chem, 1993, 97, 3591–3600.

[240] T. Luchko; S. Gusarov; D. R. Roe; C. Simmerling; D. A. Case; J. Tuszynski; A. Kovalenko. Three-
dimensional molecular theory of solvation coupled with molecular dynamics in Amber. J. Chem. Theory
Comput., 2010, 6, 607–624.

[241] D. Chandler; H. C. Andersen. Optimized cluster expansions for classical ﬂuids. ii. theory of molecular

liquids. J. Chem. Phys., 1972, 57, 1930–1937.

[242] F. Hirata; P. J. Rossky. An extended RISM equation for molecular polar ﬂuids. Chem. Phys. Lett., 1981, pp

329–334.

[243] F. Hirata; B. M. Pettitt; P. J. Rossky. Application of an extended rism equation to dipolar and quadrupolar

ﬂuids. J. Chem. Phys., 1982, 77, 509–520.

[244] F. Hirata; P. J. Rossky; B. M. Pettitt. The interionic potential of mean force in a molecular polar solvent

from an extended rism equation. J. Chem. Phys., 1983, 78, 4133–4144.

[245] D. Chandler; J. McCoy; S. Singer. Density functional theory of nonuniform polyatomic systems. i. general

formulation. J. Chem. Phys., 1986, 85, 5971–5976.

[246] D. Chandler; J. McCoy; S. Singer. Density functional theory of nonuniform polyatomic systems. ii. rational

closures for integral equations. J. Chem. Phys., 1986, 85, 5977–5982.

[247] D. Beglov; B. Roux. Numerical solution of the hypernetted chain equation for a solute of arbitrary geometry

in three dimensions. J. Chem. Phys., 1995, 103, 360–364.

[248] D. Beglov; B. Roux. An integral equation to describe the solvation of polar molecules in liquid water. J.

Phys. Chem. B, 1997, 101, 7821–7826.

[249] A. Kovalenko; F. Hirata. Three-dimensional density proﬁles of water in contact with a solute of arbitrary

shape: a RISM approach. Chem. Phys. Lett., 1998, 290, 237–244.

[250] A. Kovalenko; F. Hirata. Self-consistent description of a metal–water interface by the Kohn–Sham density
functional theory and the three-dimensional reference interaction site model. J. Chem. Phys., 1999, 110,
10095–10112.

[251] A. Kovalenko. In Hirata [924], chapter 4.

[252] A. Kovalenko; F. Hirata. Potentials of mean force of simple ions in ambient aqueous solution. i: Three-

dimensional reference interaction site model approach. J. Chem. Phys., 2000, 112, 10391–10402.

[253] A. Kovalenko; F. Hirata. Potentials of mean force of simple ions in ambient aqueous solution. ii: Solva-
tion structure from the three-dimensional reference interaction site model approach, and comparison with
simulations. J. Chem. Phys., 2000, 112, 10403–10417.

[254] J.-P. Hansen; I. R. McDonald. Theory of simple liquids. Academic Press, London, 1990.

[255] F. Hirata. In Molecular Theory of Solvation [924], chapter 1.

[256] J. S. Perkyns; B. M. Pettitt. A site-site theory for ﬁnite concentration saline solutions. J. Chem. Phys., 1992,

97, 7656–7666.

867

BIBLIOGRAPHY

[257] A. Kovalenko; S. Ten-No; F. Hirata. Solution of three-dimensional reference interaction site model and
hypernetted chain equations for simple point charge water by modiﬁed method of direct inversion in iterative
subspace. J. Comput. Chem, 1999, 20, 928–936.

[258] I. S. Joung; T. Luchko; D. A. Case. Simple electrolyte solutions: Comparison of DRISM and molecular

dynamics results for alkali halide solutions. J Chem Phys, 2013, 138, 044103.

[259] G. M. Giambasu; T. Luchko; D. Herschlag; D. M. York; D. A. Case. Ion counting from explicit-solvent

simulations and 3d-RISM. Biophys J, 2014, 106, 883–894.

[260] J. W. Kaminski; S. Gusarov; T. A. Wesolowski; A. Kovalenko. Modeling solvatochromic shifts using the
orbital-free embedding potential at statistically mechanically averaged solvent density. J. Phys. Chem. A,
2010, 114, 6082–6096.

[261] M. Frigo; S. G. Johnson. FFTW: An adaptive software architecture for the FFT. in Proc. 1998 IEEE Intl.

Conf. Acoustics Speech and Signal Processing, volume 3, pp 1381–1384. IEEE, 1998.

[262] M. Frigo. A fast Fourier transform compiler. in Proc. 1999 ACM SIGPLAN Conf. on Programming Lan-

guage Design and Implementation, volume 34, pp 169–180. ACM, 1999.

[263] S. J. Singer; D. Chandler. Free energy functions in the extended RISM approximation. Mol. Phys., 1985,

55, 621–625.

[264] B. M. Pettitt; P. J. Rossky. Alkali halides in water: Ion-solvent correlations and ion-ion potentials of mean

force at inﬁnite dilution. J. Chem. Phys., 1986, 15, 5836–5844.

[265] S. M. Kast. Free energies from integral equation theories: Enforcing path independence. Phys. Rev. E, 2003,

67, 041203.

[266] G. Schmeer; A. Maurer. Development of thermodynamic properties of electrolyte solutions with the help of

RISM-calculations at the Born-Oppenheimer level. Phys. Chem. Chem. Phys., 2010, 12, 2407–2417.

[267] S. Gusarov; T. Ziegler; A. Kovalenko. Self-consistent combination of the three-dimensional RISM theory
of molecular solvation with analytical gradients and the amsterdam density functional package. J. Phys.
Chem. A, 2006, 110, 6083–6090.

[268] T. Miyata; F. Hirata. Combination of molecular dynamics method and 3D-RISM theory for conformational

sampling of large ﬂexible molecules in solution. J. Comput. Chem., 2007, 29, 871–882.

[269] S. M. Kast; T. Kloss. Closed-form expressions of the chemical potential for integral equation closures with

certain bridge functions. J. Chem. Phys., 2008, 129, 236101.

[270] D. Chandler; Y. Singh; D. M. Richardson. Excess electrons in simple ﬂuids. I. General equilibrium theory

for classical hard sphere solvents. J. Chem. Phys., 1984, 81, 1975–1982.

[271] T. Ichiye; D. Chandler. Hypernetted chain closure reference interaction site method theory of structure and

thermodynamics for alkanes in water. J. Phys. Chem., 1988, 92, 5257–5261.

[272] P. H. Lee; G. M. Maggiora. Solvation thermodynamics of polar molecules in aqueous solution by the

XRISM method. J. Phys. Chem., 1993, 97, 10175–10185.

[273] S. Genheden; T. Luchko; S. Gusarov; A. Kovalenko; U. Ryde. An MM/3D-RISM approach for ligand-

binding afﬁnities. J. Phys. Chem., 2010. Accepted.

[274] H.-A. Yu; B. Roux; M. Karplus. Solvation thermodynamics: An approach from analytic temperature deriva-

tives. J. Chem. Phys., 1990, 92, 5020–5033.

[275] J. Johnson; D. A. Case; T. Yamazaki; S. Gusarov; A. Kovalenko; T. Luchko. Small molecule solvation

energy and entropy from 3D-RISM. J. Phys. Condens. Mat., 2016.

868

BIBLIOGRAPHY

[276] T. Yamazaki; N. Blinov; D. Wishart; A. Kovalenko. Hydration effects on the HET-s prion and amyloid-β 2
ﬁbrillous aggregates, studied with three-dimensional molecular theory of solvation. Biophys. J., 2008, 95,
4540–4548.

[277] T. Yamazaki; A. Kovalenko; V. V. Murashov; G. N. Patey. Ion solvation in a water-urea mixture. J. Phys.

Chem. B, 2010, 114, 613–619.

[278] H. A. Boateng; R. Krasny. Comparison of treecodes for computing electrostatic potentials in charged particle

systems with disjoint targets and sources. J. Computat. Chem., 2013, 34, 2159–2167.

[279] Z.-H. Duan; R. Krasny. An adaptive treecode for computing nonbonded potential energy in classical molec-

ular systems. J. Computat. Chem., 2001, 22, 184–195.

[280] P. Li; H. Johnston; R. Krasny. A Cartesian treecode for screened Coulomb interactions. J. Computat. Phys.,

2009, 228, 3858–3868.

[281] C. Nguyen; T. Yamazaki; A. Kovalenko; D. A. Case; M. K. Gilson; T. Kurtzman; T. Luchko. A molecular
reconstruction approach to site-based 3D-RISM and comparison to GIST hydration thermodynamic maps
in an enzyme active site. PLoS One, 2019, 14, e0219743.

[282] D. S. Palmer; A. I. Frolov; E. L. Ratkova; M. V. Fedorov. Towards a universal method for calculating
hydration free energies: a 3D reference interaction site model with partial molar volume correction. J.
Phys.: Condens. Matter, 2010, 22, 492101.

[283] J.-F. Truchon; B. M. Pettitt; P. Labute. A cavity corrected 3D-RISM functional for accurate solvation free

energies. J. Chem. Theory Comput., 2014, 10, 934–941.

[284] V. Sergiievskyi; G. Jeanmairet; M. Levesque; D. Borgis. Solvation free-energy pressure corrections in the

three dimensional reference interaction site model. J. Chem. Phys., 2015, 143, 184116.

[285] T. Luchko; N. Blinov; G. C. Linon; K. P. Joyce; A. Kovalenko. SAMPL5: 3D-RISM partition coefﬁcient
calculations with partial molar volume corrections and solute conformational sampling. J. Comput. Aided
Mol. Design, 2016, 30, 1115–1127.

[286] I. Omelyan; A. Kovalenko. MTS-MD of biomolecules steered with 3D-RISM-KH mean solvation forces
accelerated with generalized solvation force extrapolation. J. Chem. Theory Comput., 2015, 11, 1875–1895.

[287] M. E. Tuckerman; B. J. Berne; G. J. Martyna. Molecular dynamics algorithm for multiple time scales:

Systems with long range forces. J. Chem. Phys., 1991, 94, 6811–6815.

[288] M. Tuckerman; B. J. Berne; G. J. Martyna. Reversible multiple time scale molecular dynamics. J. Chem.

Phys., 1992, 97, 1990–2001.

[289] H. Grubmuumlller; H. Heller; A. Windemuth; K. Schulten. Generalized Verlet algorithm for efﬁcient

molecular dynamics simulations with long-range interactions. Mol. Simulat., 1991, 6, 121–142.

[290] T. Schlick. Molecular modeling and simulation: an interdisciplinary guide. Springer-Verlag New York,

Inc., Secaucus, NJ, USA, 2002.

[291] I. Omelyan; A. Kovalenko. Multiple time step molecular dynamics in the optimized isokinetic ensemble
steered with the molecular theory of solvation: Accelerating with advanced extrapolation of effective solva-
tion forces. J. Chem. Phys., 2013, 139, 244106.

[292] I. Omelyan; A. Kovalenko. MTS-MD of Biomolecules Steered with 3D-RISM-KH Mean Solvation Forces
Accelerated with Generalized Solvation Force Extrapolation. J. Chem. Theor. and Comp., 2014, 11, 1875–
1895.

[293] A. Warshel. Computer Modeling of Chemical Reactions in Enzymes and Solutions. John Wiley and Sons,

New York, 1991.

869

BIBLIOGRAPHY

[294] S. R. Billeter; S. P. Webb; T. Iordanov; P. K. Agarwal; S. Hammes-Schiffer. Hybrid approach for including
electronic and nuclear quantum effects in molecular dynamics simulations of hydrogen transfer reactions in
enzymes. J. Chem. Phys., 2001, 114, 6925.

[295] H. B. Schlegel; J. L. Sonnenberg. Empirical valence-bond models for reactive potential energy surfaces

using distributed Gaussians. J. Chem. Theory Comput., 2006, 2, 905.

[296] J. L. Sonnenberg; H. B. Schlegel. Empirical valence bond models for reactive potential energy surfaces. II.
Intramolecular proton transfer in pyridone and the Claisen reaction of allyl vinyl ether. Mol. Phys., 2007,
105, 2719.

[297] Y. Saad; M. H. Schultz. GMRES: A generalized minimal residual algorithm for solving nonsymmetric

linear systems. SIAM J. Sci. Stat. Comput., 1986, 7, 856.

[298] P. Pulay. Convergence acceleration of iterative sequencies. The case of SCF iteration. Chem. Phys. Lett.,

1980, 73, 393.

[299] P. Pulay. Improved SCF convergence acceleration. J. Comput. Chem., 1982, 3, 556.

[300] R. P. Feynman; A. R. Hibbs. Quantum Mechanics and Path Integrals. McGraw-Hill, New York, 1965.

[301] R. P. Feynman. Statistcal Mechanics. Benjamin, Reading, MA, 1972.

[302] H. Kleinert. Path Integrals in Quantum Mechanics, Statistics, and Polymer Physics. World Scientiﬁc,

Singapore, 1995.

[303] S. Kumar; D. Bouzida; R. H. Swendsen; P. A. Kollman; J. M. Rosenberg. The weighted histogram analysis
method for free-energy calculations on biomolecules. I. The method. J. Comput. Chem., 1992, 13, 1011–
1021.

[304] S. Kumar; J. M. Rosenberg; D. Bouzida; R. H. Swendsen; P. A. Kollman. Multidimensional free-energy

calculations using the weighted histogram analysis method. J. Comput. Chem., 1995, 16, 1339–1350.

[305] B. Roux. The calculation of the potential of mean force using computer simulations. Comput. Phys. Comm.,

1995, 91, 275–282.

[306] R. C. Walker; M. F. Crowley; D. A. Case. The implementation of a fast and accurate QM/MM potential

method in Amber. J. Comput. Chem., 2008, 29, 1019–1031.

[307] G. M. Seabra; R. C. Walker; M. Elstner; D. A. Case; A. E. Roitberg. Implementation of the SCC-DFTB
Method for Hybrid QM/MM Simulations within the Amber Molecular Dynamics Package. J. Phys. Chem.
A., 2007, 20, 5655–5664.

[308] M. Elstner; D. Porezag; G. Jungnickel; J. Elsner; M. Haugk; T. Frauenheim; S. Suhai; G. Seifert. Self-
consistent charge density functional tight-binding method for simulation of complex material properties.
Phys. Rev. B, 1998, 58, 7260.

[309] T. Kruger; M. Elstner; P. Schiffels; T. Frauenheim. Validation of the density-functional based tight-binding

approximation. J. Chem. Phys., 2005, 122, 114110.

[310] T. J. Giese; D. M. York. Charge-dependent model for many-body polarization, exchange, and dispersion
interactions in hybrid quantum mechanical/molecular mechanical calculations. J. Chem. Phys., 2007, 127,
194101–194111.

[311] J. J. P. Stewart. Optimization of parameters for semiempirical methods I. Method. J. Comput. Chem., 1989,

10, 209–220.

[312] M. J. S. Dewar; E. G. Zoebisch; E. F. Healy; J. J. P. Stewart. AM1: A new general purpose quantum

mechanical molecular model. J. Am. Chem. Soc., 1985, 107, 3902–3909.

870

BIBLIOGRAPHY

[313] G. B. Rocha; R. O. Freire; A. M. Simas; J. J. P. Stewart. RM1: A Reparameterization of AM1 for H, C, N,

O, P, S, F, Cl, Br and I. J. Comp. Chem., 2006, 27, 1101–1111.

[314] M. J. S. Dewar; W. Thiel. Ground states of molecules. 38. The MNDO method, approximations and param-

eters. J. Am. Chem. Soc., 1977, 99, 4899–4907.

[315] M. P. Repasky; J. Chandrasekhar; W. L. Jorgensen. PDDG/PM3 and PDDG/MNDO: Improved semiempir-

ical methods. J. Comput. Chem., 2002, 23, 1601–1622.

[316] J. P. McNamara; A. M. Muslim; H. Abdel-Aal; H. Wang; M. Mohr; I. H. Hillier; R. A. Bryce. Towards a
quantum mechanical force ﬁeld for carbohydrates: A reparameterized semiempirical MO approach. Chem.
Phys. Lett., 2004, 394, 429–436.

[317] M. I. Bernal-Uruchurtu; M. F. Ruiz-López. Basic ideas for the correction of semiempirical methods de-

scribing H-bonded systems. Chem. Phys. Lett., 2000, 330, 118–124.

[318] O. I. Arillo-Flores; M. F. Ruiz-López; M. I. Bernal-Uruchurtu. Can semi-empirical models describe HCl

dissociation in water? Theoret. Chem. Acc., 2007, 118, 425–435.

[319] W. Thiel; A. A. Voityuk. Extension of the MNDO formalism to d orbitals: Integral approximations and

preliminary numerical results. Theoret. Chim. Acta, 1992, 81, 391–404.

[320] W. Thiel; A. A. Voityuk. Extension of the MNDO formalism to d orbitals: Integral approximations and

preliminary numerical results. Theoret. Chim. Acta, 1996, 93, 315.

[321] W. Thiel; A. A. Voityuk. Erratum: Extension of MNDO to d orbitals: Parameters and results for the second-

row elements and for the zinc group. J. Phys. Chem., 1996, 100, 616–626.

[322] P. Imhof; F. Noé; S. Fischer; J. C. Smith. AM1/d Parameters for Magnesium in Metalloenzymes. J. Chem.

Theory Comput., 2006, 2, 1050–1056.

[323] K. Nam; Q. Cui; J. Gao; D. M. York. Speciﬁc Reaction Parametrization of the AM1/d Hamiltonian for

Phosphoryl Transfer Reactions: H, O, and P Atoms. J. Chem. Theory Comput., 2007, 3, 486–504.

[324] J. J. P. Stewart. Optimization of parameters for semiempirical methods V: Modiﬁcation of NDDO approxi-

mations and application to 70 elements. J. Mol. Mod., 2007, 13, 1173–1213.

[325] D. Porezag; T. Frauenheim; T. Kohler; G. Seifert; R. Kaschner. Construction of tight-binding-like potentials

on the basis of density-functional-theory: Applications to carbon. Phys. Rev. B, 1995, 51, 12947.

[326] G. Seifert; D. Porezag; T. Frauenheim. Calculations of molecules, clusters and solids with a simpliﬁed

LCAO-DFT-LDA scheme. Int. J. Quantum Chem., 1996, 58, 185.

[327] M. Gaus; Q. Cui; M. Elstner. DFTB3: Extension of the self-consistent-charge density-functional tight-

binding method (SCC-DFTB). J. Chem. Theory Comput., 2011, 7, 931–948.

[328] M. Elstner; P. Hobza; T. Frauenheim; S. Suhai; E. Kaxiras. Hydrogen bonding and stacking interactions of

nucleic acid base pairs: a density-functional-theory based treatment. J. Chem. Phys., 2001, 114, 5149.

[329] J. A. Kalinowski; B. Lesyng; J. D. Thompson; C. J. Cramer; D. G. Truhlar. Class IV charge model for the

self-consistent charge density-functional tight-binding method. J. Phys. Chem. A, 2004, 108, 2545–2549.

[330] Y. Yang; H. Yu; D. M. York; Q. Cui; M. Elstner. Extension of the self-consistent charge density-functional
tight-binding method: Third-order expansion of the density functional theory total energy and introduction
of a modiﬁed effective Coulomb interaction. J. Phys. Chem. A, 2007, 111, 10861–10873.

[331] M. Korth. Third-generation hydrogen-bonding corrections for semiempirical qm methods and force ﬁelds.

J. Chem. Theory Comput., 2010, 6, 3808.

871

BIBLIOGRAPHY

[332] P. Jurecka; J. Cerný; P. Hobza; D. R. Salahub. Density functional theory augmented with an empirical
dispersion term. Interaction energies and geometries of 80 noncovalent complexes compared with ab initio
quantum mechanics calculations. J. Comp. Chem., 2007, 28, 555–569.

[333] A. Bondi. van der Waals volumes and radii. J. Phys. Chem., 1964, 68, 441–451.

[334] M. Korth; M. Pitonak; J. Rezac; P. Hobza. A transferable h-bonding correction for semiempirical quantum-

chemical methods. J. Chem. Theory Comput., 2010, 6, 344–352.

[335] E. Pellegrini; M. J. Field. A generalized-Born solvation model for macromolecular hybrid-potential calcu-

lations. J. Phys. Chem. A., 2002, 106, 1316–1326.

[336] K. Nam; J. Gao; D. York. An efﬁcient linear-scaling Ewald method for long-range electrostatic interactions

in combined QM/MM calculations. J. Chem. Theory Comput., 2005, 1, 2–13.

[337] Q. T. Wang; R. A. Bryce. Improved hydrogen bonding at the NDDO-type semiempirical quantum mechan-

ical/molecular mechanical interface. J. Chem. Theory Comput., 2009, 5, 2206–2211.

[338] A. W. Götz; M. A. Clark; R. C. Walker. An extensible interface for QM/MM molecular dynamics simula-

tions with AMBER. J. Comput. Chem., 2014, 35, 95–108.

[339] G. te Velde; F. M. Bickelhaupt; E. J. Baerends; C. F. Guerra; S. J. A. van Gisbergen; J. G. Snijders; T. Ziegler.

Chemistry with ADF. J. Comp. Chem., 2001, 22, 931–967.

[340] ADF2011,

SCM, Theoretical Chemistry, Vrije Universiteit, Amsterdam, The Netherlands,

http://www.scm.com, 2012.

[341] M. W. Schmidt; K. K. Baldridge; J. A. Boatz; S. T. Elbert; M. S. Gordon; J. H. Jensen; S. Koseki; N. Mat-
sunaga; K. A. Nguyen; S. Su; T. L. Windus; M. Dupuis; J. A. Montgomery, Jr. General atomic and molecular
electronic structure system. J. Comp. Chem., 1993, 14, 1347–1363.

[342] M. S. Gordon; M. W. Schmidt. in Theory and Applications of Computational Chemistry, the ﬁrst forty years,
C. E. Dykstra; G. Frenking; K. S. Kim; G. E. Scuseria, Eds., chapter 41, pp 1167–1189. Elsevier, Asterdam,
2005.

[343] M. Valiev; E. J. Bylaska; N. Govind; K. Kowalski; T. P. Straatsma; H. J. J. van Dam; D. Wang; J. Niepolcha;
E. Apra; T. L. Windus; W. A. de Jong. Nwchem: a comprehensive and scalable open-source solution for
large scale molecular simulations. Comput. Phys. Commun., 2010, 181, 1477.

[344] M. J. Frisch; G. W. Trucks; H. B. Schlegel; G. E. Scuseria; M. A. Robb; J. R. Cheeseman; G. Scalmani;
V. Barone; B. Mennucci; G. A. Petersson; H. Nakatsuji; M. Caricato; X. Li; H. P. Hratchian; A. F. Iz-
maylov; J. Bloino; G. Zheng; J. L. Sonnenberg; M. Hada; M. Ehara; K. Toyota; R. Fukuda; J. Hasegawa;
M. Ishida; T. Nakajima; Y. Honda; O. Kitao; H. Nakai; T. Vreven; J. A. Montgomery, Jr.; J. E. Peralta;
F. Ogliaro; M. Bearpark; J. J. Heyd; E. Brothers; K. N. Kudin; V. N. Staroverov; R. Kobayashi; J. Normand;
K. Raghavachari; A. Rendell; J. C. Burant; S. S. Iyengar; J. Tomasi; M. Cossi; N. Rega; J. M. Millam;
M. Klene; J. E. Knox; J. B. Cross; V. Bakken; C. Adamo; J. Jaramillo; R. Gomperts; R. E. Stratmann;
O. Yazyev; A. J. Austin; R. Cammi; C. Pomelli; J. W. Ochterski; R. L. Martin; K. Morokuma; V. G. Za-
krzewski; G. A. Voth; P. Salvador; J. J. Dannenberg; S. Dapprich; A. D. Daniels; O. Farkas; J. B. Foresman;
J. V. Ortiz; J. Cioslowski; D. J. Fox. Gaussian 09 Revision A.1. Gaussian Inc. Wallingford CT 2009.

[345] F. Neese. ORCA - an ab initio, Density Functional and Semiempirical program package, Version 2.8.0,

University of Bonn, 2010.

[346] Y. Shao; L. Fusti-Molnar; Y. Jung; J. Kussmann; C. Ochsenfeld; S. T. Brown; A. T. B. Gilbert; L. V.
Slipchenko; S. V. Levchenko; D. P. O’Neill; R. A. DiStasio, Jr.; R. C. Lochan; T. Wang; G. J. O. Beran;
N. A. Besley; J. M. Herbert; C. Y. Lin; T. V. Voorhis; S. H. Chien; A. Sodt; R. P. Steele; V. A. Rassolov;
P. E. Maslen; P. P. Korambath; R. D. Adamson; B. Austin; J. Baker; E. F. C. Byrd; H. Daschel; R. J.
Doerksen; A. Dreuw; B. D. Dunietz; A. D. Dutoi; T. R. Furlani; S. R. Gwaltney; A. Heyden; S. Hirata;

872

BIBLIOGRAPHY

C.-P. Hsu; G. Kedziora; R. Z. Khaliullin; P. Klunzinger; A. M. Lee; M. S. Lee; W. Liang; I. Lotan; N. Nair;
B. Peters; E. I. Proynov; P. A. Pieniazek; Y. M. Rhee; J. Ritchie; E. Rosta; C. D. Sherrill; A. C. Simmonett;
J. E. Subotnik; H. L. Woodcock, III; W. Zhang; A. T. Bell; A. K. Chakraborty; D. M. Chipman; F. J.
Keil; A. Warshel; W. J. Hehre; H. F. Schaefer, III; J. Kong; A. I. Krylov; P. M. W. Gill; M. Head-Gordon.
Advances in methods and algorithms in a modern quantum chemistry program package. Phys. Chem. Chem.
Phys., 2006, 8, 3172–3191.

[347] I. S. Uﬁmtsev; T. J. Martinez. Quantum chemistry on graphical processing units. 3. Analytical energy
gradients, geometry optimization, and ﬁrst principles molecular dynamics. J. Chem. Theory Comput., 2009,
5, 2619–2628.

[348] M. Kállay; Z. Rolik; J. Csontos; I. Ladjánszki; L. Szegedy; B. Lado´czki; G. Samu; K. Petrov; M. Farkas;

P. Nagy; D. Mester; B. Hegely. Mrcc, a quantum chemical program suite. www.mrcc.hu.

[349] Z. Rolik; L. Szegedy; I. Ladjánszki; B. Ladóczki; M. Kállay. An efﬁcient linear-scaling CCSD(T) method

based on local natural orbitals. J. Chem. Phys., 2013, 139, 094105.

[350] J. P. Lewis; P. Jelínek; J. Ortega; A. A. Demkov; D. G. Trabada; B. Haycock; H. Wang; G. Adams; J. K.
Tomfohr; E. Abad; H. Wang; D. A. Drabold. Advances and applications in the FIREBALL ab initio tight-
binding molecular-dynamics formalism. Phys. Status Solidi B, 2011, 248, 1989–2007.

[351] J. Torras; Y. He; C. Cao; K. Muralidharan; E. Deumens; H. Cheng; S. Trickey. PUPIL: A systematic

approach to software integration in multi-scale simulations. Comput. Phys. Comm., 2007, 177, 265–279.

[352] J. Torras; G. Seabra; E. Deumens; S. B. Trickey; A. E. Roitberg. A versatile AMBER-Gaussian QM/MM

interface through PUPIL. J. Comput. Chem., 2008, 29, 1564–1573.

[353] B. Hégely; P. R. Nagy; G. G. Ferenczy; M. Kállay. Exact density functional and wave function embedding

schemes based on orbital localization. J. Chem. Phys., 2016, 145, 064107.

[354] R. E. Bulo; C. Michel; P. Fleurat-Lessard; P. Sautet. Multiscale modeling of chemistry in water: Are we

there yet? J. Chem. Theory Comput., 2013, 9, 5567–5577.

[355] R. E. Bulo; B. Ensing; J. Sikkema; L. Visscher. Toward a practical method for adaptive qm/mm simulations.

J. Chem. Theory Comput., 2009, 9, 2212–2221.

[356] K. Park; A. W. Götz; R. C. Walker; F. Paesani. Application of adaptive qm/mm methods to molecular

dynamics simulations of aqueous systems. J. Chem. Theory Comput., 2012, 8, 2868–2877.

[357] N. Bernstein; C. Várnai; I. Solt; S. A. Winﬁeld; M. C. Payne; I. Simon; M. Fuxreiter; G. Csányi.

Phys. Chem. Chem. Phys., 2011, 14, 646–656.

[358] C. Várnai; N. Bernstein; L. Mones; G. Csányi. Tests of an adaptive qm/mm calculation on free energy

proﬁles of chemical reactions in solution. J. Phys. Chem. B, 2013, 117, 12202–12211.

[359] G. Csányi; T. Albaret; G. Moras; M. C. Payne; A. D. Vita. Multiscale hybrid simulation methods for material

systems. J. Phys. Condens. Matt., 2005, 17, R691.

[360] N. Bernstein; J. R. Kermode; G. Csányi. Hybrid atomistic simulation methods for materials systems.

Rep. Prog. Phys., 2009, 72, 026501.

[361] A. Jones; B. Leimkuhler.

Adaptive stochastic methods for sampling driven molecular systems.

J. Chem. Phys., 2011, 135, 084125.

[362] T. Kerdcharoen; B. M. Rode. A QM/MM simulation method applied to the solution of Li+ in liquid ammo-

nia. Chem. Phys., 1996, 211, 313–323.

[363] S. L. Dixon; K. M. Merz, Jr. Semiempirical molecular orbital calculations with linear system size scaling.

J. Chem. Phys., 1996, 104, 6643–6649.

873

BIBLIOGRAPHY

[364] S. L. Dixon; K. M. Merz, Jr. Fast, accurate semiempirical molecular orbital calculations for macromolecules.

J. Chem. Phys., 1997, 107, 879–893.

[365] A. Marion; H. Gockan; G. Monard. SemiEmpirical Born-Oppenheimer Molecular Dynamics (SEBOMD)

Within the Amber Biomolecular Package. J. Chem. Inf. Model., 2019, 59, 206–214.

[366] G. Monard; M. I. Bernal-Uruchurtu; A. Van Der Vaart; K. M. Merz, Jr.; M. F. Ruiz-López. Simulation of
liquid water using semiempirical Hamiltonians and the divide and conquer approach. J. Phys. Chem. A,
2005, 109, 3425–3432.

[367] A. Marion; G. Monard; M. F. Ruiz-López; F. Ingrosso. Water interactions with hydrophobic groups: assess-

ment and recalibration of semiempirical molecular orbital methods. J. Chem. Phys., 2014, 141, 034106.

[368] M. I. Bernal-Uruchurtu; M. T. C. Martins-costa; C. Millot; M. F. Ruiz-López. Improving Description of
Hydrogen Bonds at the Semiempirical Level : Water - Water Interactions as Test Case. J. Comput. Chem.,
2000, 21, 572–581.

[369] W. Harb; M. I. Bernal-Uruchurtu; M. F. Ruiz-López. An improved semiempirical method for hydrated

systems. Theor. Chem. Acc., 2004, 112, 204–216.

[370] E. Thiriot; G. Monard. Combining a genetic algorithm with a linear scaling semiempirical method for

protein-ligand docking. J. Mol. Struct. Theochem, 2009, 898, 31–41.

[371] O. Ludwig; H. Schinke; W. Brandt. Reparametrisation of Force Constants in MOPAC 6.0/7.0 for Better

Description of the Activation Barrier of Peptide Bond Rotations. J. Molec. Model., 1996, 2, 341–350.

[372] T. Nugent; D. T. Jones. Membrane protein orientation and reﬁnement using a knowledge-based statistical

potential. BMC Bioinformatics, 2013, 14, 276.

[373] B. Ho. pdbremix. https://github.com/boscoh/pdbremix, 2018.

[374] J. M. Martínez; L. Martínez. Packing optimization for automated generation of complex system’s initial

conﬁgurations for molecular dynamics and docking. J. Computat. Chem., 2003, 24, 819–825.

[375] L. Martínez; R. Andrade; E. G. Birgin; J. M. Martínez. PACKMOL: A package for building initial conﬁgu-

rations for molecular dynamics simulations. J. Comput. Chem., 2009, 30, 2157–2164.

[376] S. Schott-Verdugo; H. Gohlke. PACKMOL-Memgen: A simple-to-use generalized workﬂow for membrane-

protein/lipid-bilayer system building. J. Chem. Inf. Model., 2019, 59, 2522–2528.

[377] A. D. MacKerell Jr.; D. Bashford; M. Bellott; R. L. Dunbrack; J. D. Evanseck; M. J. Field; S. Fischer;
J. Gao; H. Guo; S. Ha; D. Joseph-McCarthy; L. Kuchnir; K. Kuczera; F. T. K. Lau; C. Mattos; S. Michnick;
T. Ngo; D. T. Nguyen; B. Prodhom; W. E. Reiher; B. Roux; M. Schlenkrich; J. C. Smith; R. Stote; J. Straub;
M. Watanabe; J. Wiorkiewicz-Kuczera; D. Yin; M. Karplus. All-Atom Empirical Potential for Molecular
Modeling and Dynamics Studies of Proteins. J. Phys. Chem. B, 1998, 102, 3586–3616.

[378] A. D. MacKerell Jr.; N. Banavali; N. Foloppe. Development and current status of the CHARMM force ﬁeld

for nucleic acids. Biopolymers, 2000, 56, 257–265.

[379] A. D. MacKerell, Jr.; M. Feig; C. L. Brooks III. Improved Treatment of the Protein Backbone in Empirical

Force Fields. J. Am. Chem. Soc., 2004, 126, 698–699.

[380] A. D. MacKerell, Jr.; M. Feig; C. L. Brooks III. Extending the treatment of backbone energetics in protein
force ﬁelds: Limitations of gas-phase quantum mechanics in reproducing protein conformational distribu-
tions in molecular dynamics simulations. J. Computat. Chem., 2004, 25, 1400–1415.

[381] C. W. Hopkins; S. Le Grand; R. C. Walker; A. E. Roitberg. Long-Time-Step Molecular Dynamics through

Hydrogen Mass Repartitioning. J. Chem. Theory Comput., 2015, 11, 1864–1874.

874

BIBLIOGRAPHY

[382] C. Bergonzo; N. M. Henriksen; D. R. Roe; J. M. Swails; A. E. Roitberg; T. E. Cheatham III. Multidimen-
sional Replica Exchange Molecular Dynamics Yields a Converged Ensemble of an RNA Tetranucleotide. J.
Chem. Theory Comput., 2013, 10, 492–499.

[383] J. Wang; R. M. Wolf; J. W. Caldwell; P. A. Kollamn; D. A. Case. Development and testing of a general

Amber force ﬁeld. J. Comput. Chem., 2004, 25, 1157–1174.

[384] B. Wang; K. M. Merz, Jr. A fast QM/MM (quantum mechanical/molecular mechanical) approach to calcu-
late nuclear magnetic resonance chemical shifts for macromolecules. J. Chem. Theory Comput., 2006, 2,
209–215.

[385] A. Jakalian; B. L. Bush; D. B. Jack; C. I. Bayly. Fast, efﬁcient generation of high-quality atomic charges.

AM1-BCC model: I. Method. J. Comput. Chem., 2000, 21, 132–146.

[386] A. Jakalian; D. B. Jack; C. I. Bayly. Fast, efﬁcient generation of high-quality atomic charges. AM1-BCC

model: II. Parameterization and Validation. J. Comput. Chem., 2002, 23, 1623–1641.

[387] C. I. Bayly; P. Cieplak; W. D. Cornell; P. A. Kollman. A well-Behaved electrostatic potential based method
using charge restraints for determining atom-centered charges: The RESP model. J. Phys. Chem., 1993, 97,
10269–10280.

[388] J. Wang; P. A. Kollman. Automatic parameterization of force ﬁeld by systematic search and genetic algo-

rithms. J. Comput. Chem., 2001, 22, 1219–1228.

[389] A. P. Graves; D. M. Shivakumar; S. E. Boyce; M. P. Jacobson; D. A. Case; B. K. Shoichet. Rescoring
docking hit lists for model cavity sites: Predictions and experimental testing. J. Mol. Biol., 2008, 377,
914–934.

[390] B. Jojart; T. A. Martinek. Performance of the general amber force ﬁeld in modeling aqueous POPC mem-

brane bilayers. J. Comput. Chem., 2007, 28, 2051–2058.

[391] L. Rosso; I. R. Gould. Structure and dynamics of phospholipid bilayers using recently developed general

all-atom force ﬁelds. J. Comput. Chem., 2008, 29, 24–37.

[392] J. Wang; T. Hou. Application of Molecular Dynamics Simulations in Molecular Property Prediction. 1.

Density and Heat of Vaporization. J. Chem. Theory Comput., 2011, 7, 2151–2165.

[393] P. Li; K. M. Merz, Jr. Metal Ion Modeling Using Classical Mechanics. Chem. Rev., 2017, 117, 1564–1686.

[394] P. Li; K. M. Merz, Jr. MCPB.py: A Python Based Metal Center Parameter Builder. J. Chem. Inf. Model.,

2016, 56, 599–604.

[395] M. B. Peters; Y. Yang; B. Wang; L. Fusti-Molnar; M. N. Weaver; K. M. Merz, Jr. Structural Survey of Zinc-
Containing Proteins and Development of the Zinc AMBER Force Field (ZAFF). J. Chem. Theor. Comput.,
2010, 6, 2935–2947.

[396] P. Eastman; V. S. Pande. OpenMM: A Hardware-Independent Framework for Molecular Simulations. Com-

puting in Science and Engineering, 2010, 12, 34–39.

[397] P. Eastman; M. S. Friedrichs; J. D. Chodera; R. J. Radmer; C. M. Bruns; J. P. Ku; K. A. Beauchamp; T. J.
Lane; L. Wang; D. Shukla; T. Tye; M. Houston; T. Stich; C. Klein; M. R. Shirts; V. S. Pande. OpenMM
4: A Reusable, Extensible, Hardware Independent Library for High Performance Molecular Simulation. J.
Chem. Theory Comput., 2013, 9, 461–469.

[398] Z. Yu; P. Li; K. M. Merz, Jr. Extended Zinc AMBER Force Field (EZAFF). J. Chem. Theory Comput.,

2018, 14, 242–254.

[399] J. M. Seminario. Calculation of Intramolecular Force Fields from Second-Derivative Tensors. Int. J. Quan-

tum Chem., 1996, 30, 1271–1277.

875

BIBLIOGRAPHY

[400] D. S. Cerutti; D. A. Case. Molecular dynamics simulations of macromolecular crystals. Wires Comput. Mol.

Sci., 2018, 8, e1402.

[401] H. Kopitz; A. Zivkovic; J. W. Engels; H. Gohlke. Determinants of the unexpected stability of RNA ﬂuo-

robenzene self pairs. ChemBioChem, 2008, 9, 2619–2622.

[402] T. Morishita. Fluctuation formulas in molecular-dynamics simulations with the weak coupling heat bath. J.

Chem. Phys., 2000, 113, 2976.

[403] A. Mudi; C. Chakravarty. Effect of the Berendsen thermostat on the dynamical properties of water. Mol.

Phys., 2004, 102, 681–685.

[404] H. J. C. Berendsen; J. P. M. Postma; W. F. van Gunsteren; A. DiNola; J. R. Haak. Molecular dynamics with

coupling to an external bath. J. Chem. Phys., 1984, 81, 3684–3690.

[405] S. C. Harvey; R. K. Tan; T. E. Cheatham, III. The ﬂying ice cube: Velocity rescaling in molecular dynamics

leads to violation of energy equipartition. J. Comput. Chem., 1998, 19, 726–740.

[406] T. A. Andrea; W. C. Swope; H. C. Andersen. The role of long ranged forces in determining the structure

and properties of liquid water. J. Chem. Phys., 1983, 79, 4576–4584.

[407] H. C. Andersen. Molecular dynamics simulations at constant pressure and/or temperature. J. Chem. Phys.,

1980, 72, 2384–2393.

[408] B. P. Uberuaga; M. Anghel; A. F. Voter. Synchronization of trajectories in canonical molecular-dynamics

simulations: Observation, explanation, and exploitation. J. Chem. Phys., 2004, 120, 6363–6374.

[409] D. J. Sindhikara; S. Kim; A. F. Voter; A. E. Roitberg. Bad seeds sprout perilous dynamics: Stochastic
thermostat induced trajectory synchronization in biomolecules. J. Chem. Theory Comput., 2009, 5, 1624–
1631.

[410] I. Omelyan; A. Kovalenko. Generalized canonical-isokinetic ensemble: Speeding up multiscale molecular

dynamics and coupling with 3d molecular theory of solvation. Mol. Sim., 2013, 39, 25–48.

[411] B. Leimkuhler; D. T. Margul; M. E. Tuckerman. Stochastic, Resonance-Free Multiple Time-Step Algorithm

for Molecular Dynamics with Very Large Time Steps. Mol. Phys., 2013, 111, 3579–3594.

[412] G. Bussi; D. Donadio; M. Parrinello. Canonical sampling through velocity rescaling. The Journal of

chemical physics, 2007, 126, 014101.

[413] R. W. Pastor; B. R. Brooks; A. Szabo. An analysis of the accuracy of Langevin and molecular dynamics

algorithms. Mol. Phys., 1988, 65, 1409–1419.

[414] R. J. Loncharich; B. R. Brooks; R. W. Pastor. Langevin dynamics of peptides: The frictional dependence of

isomerization rates of N-actylananyl-N’-methylamide. Biopolymers, 1992, 32, 523–535.

[415] Y. M. Rhee; V. S. Pande. Solvent viscosity dependence of the protein folding dynamics. J. Phys. Chem. B,

2008, 112, 6221–6227. PMID: 18229911.

[416] J. A. Izaguirre; D. P. Catarello; J. M. Wozniak; R. D. Skeel. Langevin stabilization of molecular dynamics.

J. Chem. Phys., 2001, 114, 2090–2098.

[417] R. G. FernÃ¡ndez; J. L. F. Abascal; C. Vega. The melting point of ice Ih for common water models calculated
from direct coexistence of the solid-liquid interface. The Journal of Chemical Physics, 2006, 124, 144506.

[418] Y. Zhang; S. E. Feller; B. R. Brooks; R. W. Pastor. Computer simulation of liquid/liquid interfaces. I. Theory

and application to octane/water. J. Chem. Phys., 1995, 103, 10252–10266.

[419] J.-P. Ryckaert; G. Ciccotti; H. J. C. Berendsen. Numerical integration of the cartesian equations of motion

of a system with constraints: Molecular dynamics of n-alkanes. J. Comput. Phys., 1977, 23, 327–341.

876

BIBLIOGRAPHY

[420] S. Miyamoto; P. A. Kollman. SETTLE: An analytical version of the SHAKE and RATTLE algorithm for

rigid water models. J. Comput. Chem., 1992, 13, 952–962.

[421] Z. Zhang; X. Liu; Z. Chen; H. Zheng; K. Yan; J. Liu. A uniﬁed thermostat scheme for efﬁcient conﬁgura-
tional sampling for classical/quantum canonical ensembles via molecular dynamics. J. Chem. Phys., 2017,
147, 034109.

[422] J. Liu; D. Li; X. Liu. A simple and accurate algorithm for path integral molecular dynamics with the

Langevin thermostat. J. Chem. Phys., 2016, 145, 024103.

[423] D. Li; X. Han; Y. Chai; C. Wang; Z. Zhang; Z. Chen; J. Liu; J. Shao. Stationary state distribution and
efﬁciency analysis of the Langevin equation via real or virtual dynamics. J. Chem. Phys., 2017, 147, 184104.

[424] D. Li; Z. Chen; Z. Zhang; J. Liu. Understanding molecular dynamics with stochastic processes via real or

virtual dynamics. Chinese Journal of Chemical Physics, 2017, 30, 735–760.

[425] Z. Zhang; K. Yan; X. Liu; J. Liu. A leap-frog algorithm-based efﬁcient uniﬁed thermostat scheme for

molecular dynamics. Chinese Science Bulletin, 2018, 63, 3467–3483.

[426] B. Leimkuhler; C. Matthews. Rational construction of stochastic numerical methods for molecular sam-

pling. Appl. Math. Res. eXpress, 2013, 2013, 34–56.

[427] N. Gr"ønbech-Jensen; O. Farago. A simple and effective Verlet-type algorithm for simulating Langevin

dynamics. Mol. Phys., 2013, 111, 983–991.

[428] X. Liu; J. Liu. Critical role of quantum dynamical effects in the Raman spectroscopy of liquid water. Mol.

Phys., 2018, 116, 755–779.

[429] H. C. Andersen. RATTLE: A "velocity" version of the shake algorithm for molecular dynamics calculations.

J. Computat. Phys., 1983, 52, 24 – 34.

[430] Z. Zhang; X. Liu; K. Yan; M. Tuckerman; J. Liu. Uniﬁed efﬁcient thermostat scheme for the canonical
ensemble with holonomic or isokinetic constraints via molecular dynamics. J. Phys. Chem. A, 2019, 123,
6056–6079.

[431] X. Wu; S. Subramaniam; D. A. Case; K. Wu; B. R. Brooks. Targeted conformational search with map-
restrained self-guided langevin dynamics: application to ﬂexible ﬁtting into electron microscopic density
maps. J. Struct. Biology, 2013, 183, 429–440.

[432] P. Ren; J. W. Ponder. Consistent treatment of inter- and intramolecular polarization in molecular mechanics

calculations. J. Comput. Chem., 2002, 23, 1497–1506.

[433] P. Ren; J. W. Ponder. Temperature and pressure dependence of the AMOEBA water model. J. Phys. Chem.

B, 2004, 108, 13427–13437.

[434] T. Darden; D. York; L. Pedersen. Particle mesh Ewald–an Nlog(N) method for Ewald sums in large systems.

J. Chem. Phys., 1993, 98, 10089–10092.

[435] U. Essmann; L. Perera; M. L. Berkowitz; T. Darden; H. Lee; L. G. Pedersen. A smooth particle mesh Ewald

method. J. Chem. Phys., 1995, 103, 8577–8593.

[436] M. F. Crowley; T. A. Darden; T. E. Cheatham, III; D. W. Deerﬁeld, II. Adventures in improving the scaling

and accuracy of a parallel molecular dynamics program. J. Supercomput., 1997, 11, 255–278.

[437] C. Sagui; T. A. Darden.

in Simulation and Theory of Electrostatic Interactions in Solution, L. R. Pratt;

G. Hummer, Eds., pp 104–113. American Institute of Physics, Melville, NY, 1999.

[438] A. Toukmaji; C. Sagui; J. Board; T. Darden. Efﬁcient particle-mesh Ewald based approach to ﬁxed and

induced dipolar interactions. J. Chem. Phys., 2000, 113, 10913–10927.

877

BIBLIOGRAPHY

[439] C. Sagui; L. G. Pedersen; T. A. Darden. Towards an accurate representation of electrostatics in classical
force ﬁelds: Efﬁcient implementation of multipolar interactions in biomolecular simulations. J. Chem.
Phys., 2004, 120, 73–87.

[440] X. Wu; B. R. Brooks. Isotropic periodic sum: A method for the calculation of long-range interactions. J.

Chem. Phys., 2005, 122, 044107.

[441] J. B. Klauda; X. Wu; R. W. Pastor; B. R. Brooks. Long-Range Lennard-Jones and Electrostatic Interactions

in Interfaces. J. Phys. Chem. B, 2007, 111, 4393–4400.

[442] K. Takahashi; K. Yasuoka; T. Narumi. Cutoff radius effect of isotropic periodic sum method for transport.

J. Chem. Phys., 2007, 127, 114511.

[443] X. Wu; B. R. Brooks. Using the Isotropic Periodic Sum Method to Calculate Long-Range Interactions of

Heterogeneous Systems. J. Chem. Phys., 2008, 129, 154115.

[444] X. Wu; B. R. Brooks. Isotropic periodic sum of electrostatic interactions for polar systems. J. Chem. Phys.,

2009, 131, 024107.

[445] R. M. Venable; L. E. Chen; R. W. Pastor. Comparison of the Extended Isotropic Periodic Sum and Particle
Mesh Ewald Methods for Simulations of Lipid Bilayers and Monolayers. J. Phys. Chem. B, 2009, 113,
5855–5862.

[446] R. Konecny; N. A. Baker; J. A. McCammon.

iAPBS: a programming interface to the adaptive Poisson–

Boltzmann solver. Comput. Sci. Disc., 2012, 5, 15005–15013.

[447] A. W. Goetz; M. J. Williamson; D. Xu; D. Poole; S. L. Grand; R. C. Walker. Routine microsecond molecular
dynamics simulations with AMBER - Part I: Generalized Born. J. Chem. Theory Comput., 2012, 8, 1542–
1555.

[448] R. Salomon-Ferrer; A. W. Goetz; D. Poole; S. L. Grand; R. C. Walker. Routine microsecond molecular
dynamics simulations with AMBER - Part 2: Explicit Solvent Particle Mesh Ewald . J. Chem. Theory
Comput., 2012, in review.

[449] S. Le Grand; A. W. Goetz; R. C. Walker. SPFP: Speed without compromise–A mixed precision model for

GPU accelerated molecular dynamics simulations. Comput. Phys. Commun., 2013, 184, 374–380.

[450] R. M. Betz; N. A. DeBardeleben; R. C. Walker. An Investigation of the effects of hard and soft errors
on graphics processing unit-accelerated molecular dynamics simulations. Concurrency and Computation:
Practice and Experience, 2014, 26, 2134.

[451] X. Wu; B. R. Brooks. Self-guided Langevin dynamics simulation method. Chem. Phys. Lett., 2003, 381,

512–518.

[452] X. Wu; A. Damjanovic; B. R. Brooks. Efﬁcient and unbiased sampling of biomolecular systems in the

canonical ensemble: a review of self-guided langevin dynamics. Adv. Chem. Phys., 2012, 150, 255–326.

[453] X. Yu; X. Wu; G. A. Bermejo; B. R. Brooks; J. W. Taraska. Accurate high-throughput structure mapping

and prediction with transition metal ion fret. Structure, 2013, 21, 9–19.

[454] X. Wu; B. R. Brooks. Self-guided langevin dynamics via generalized langevin equation. J. Comput. Chem.,

2016, 37, 595–601.

[455] X. Wu; B. R. Brooks. Toward canonical ensemble distribution from self-guided Langevin dynamics simu-

lation. J. Chem. Phys., 2011, 134, 134108.

[456] X. Wu; B. R. Brooks. Force-momentum-based self-guided Langevin dynamics: a rapid sampling method

that approaches the canonical ensemble . J. Chem. Phys., 2011, 135, 204101.

878

BIBLIOGRAPHY

[457] X. Wu; M. Hodoscek; B. R. Brooks. Replica exchanging self-guided Langevin dynamics for efﬁcient and

accurate conformational sampling. J. Chem. Phys., 2012, 137, 044106.

[458] D. Hamelberg; J. Mongan; J. A. McCammon. Accelerated molecular dynamics: A promising and efﬁcient

simulation method for biomolecules. J. Chem. Phys., 2004, 120, 11919–11929.

[459] D. Hamelberg; C. A. F. de Oliveira; J. McCammon. Sampling of slow diffusive conformational transitions

with accelerated molecular dynamics. J. Chem. Phys., 2007, 127, 155102–155109.

[460] B. J. Grant; A. A. Gorfe; J. A. McCammon. Ras conformational switching: Simulating nucleotide-
dependent conformational transitions with accelerated molecular dynamics. PLoS Computat. Biol., 2009, 5,
e1000325.

[461] C. A. F. de Oliveira; B. J. Grant; M. Zhou; J. A. McCammon. Large-scale conformational changes of try-
panosoma cruzi proline racemase predicted by accelerated molecular dynamics simulation. PLoS Computat.
Biol., 2011, 7, e1002178.

[462] L. C. T. Pierce; R. Salomon-Ferrer; C. A. F. de Oliveira; J. A. McCammon; R. C. Walker. Routine access to
milli-second time scales with accelerated molecular dynamics. J. Chem. Theory Comput., 2012, 8, 2997–
3002.

[463] U. Doshi; D. Hamelberg. Reoptimization of the amber forceﬁeld for peptide bond (omega) torsions using

accelerated molecular dynamics. J. Chem. Phys. B, 2009, 113, 16590–16595.

[464] Y. Miao; V. A. Feher; J. A. McCammon. Gaussian Accelerated Molecular Dynamics: Unconstrained En-

hanced Sampling and Free Energy Calculation. J. Chem. Theory Comput., 2015, 11, 3584–3595.

[465] Y. Miao; W. Sinko; L. Pierce; D. Bucher; R. C. Walker; J. A. McCammon.

Improved Reweighting of
Accelerated Molecular Dynamics Simulations for Free Energy Calculation. J. Chem. Theory Comput.,
2014, 10, 2677–2689.

[466] Y. Miao; A. Bhattarai; J. Wang. Ligand Gaussian accelerated molecular dynamics (LiGaMD): Characteri-

zation of ligand binding thermodynamics and kinetics. bioRxiv, 2020.

[467] G. Mills; H. Jönsson. Quantum and thermal effects in H2 dissociative adsorption: Evaluation of free energy

barriers in multidimensional quantum systems. Phys. Rev. Lett., 1994, 72, 1124–1127.

[468] H. Jönsson; G. Mills; K. W. Jacobsen. in Classical and Quantum Dynamics in Condensed Phase Simula-

tions, B. J. Berne; G. Ciccoti; D. F. Coker, Eds., pp 385–404. World Scientiﬁc, Singapore, 1998.

[469] R. Elber; M. Karplus M. A method for determining reaction paths in large molecules: Application to

myoglobin. Chem. Phys. Lett., 1987, 139, 375–380.

[470] G. Henkelman; H. Jönsson.

Improved tangent estimate in the nudged elastic band method for ﬁnding

minimum energy paths and saddle points. J. Chem. Phys., 2000, 113, 9978–9985.

[471] G. Henkelman; B. P. Uberuaga; H. Jönsson. A climbing image nudged elastic band method for ﬁnding

saddle points and minimum energy paths. J. Chem. Phys., 2000, 113, 9901–9904.

[472] J. Chu; B. L. Trout; B. R. Brooks. A super-linear minimization scheme for the nudged elastic band method.

J. Chem. Phys., 2003, 119, 12708–12717.

[473] C. Bergonzo; A. J. Campbell; R. C. Walker; C. Simmerling. A Partial Nudged Elastic Band Implementation

for Use with Large or Explicitly Solvated Systems. Int J Quantum Chem, 2009, 109, 3781–3790.

[474] D. H. Mathews; D. A. Case. Nudged Elastic Band calculation of minimal energy pathways for the confor-

mational change of a GG mismatch. J. Mol. Biol., 2006, 357, 1683–1693.

879

BIBLIOGRAPHY

[475] I. Kolossváry; W. C. Guida. Low mode search. An efﬁcient, automated computational method for confor-
mational analysis: Application to cyclic and acyclic alkanes and cyclic peptides. J. Am. Chem. Soc., 1996,
118, 5011–5019.

[476] I. Kolossváry; W. C. Guida. Low-mode conformatinoal search elucidated: Application to C39H80 and

ﬂexible docking of 9-deazaguanine inhibitors into PNP. J. Comput. Chem., 1999, 20, 1671–1684.

[477] I. Kolossváry; G. M. Keserü. Hessian-free low-mode conformational search for large-scale protein loop

optimization: Application to c-jun N-terminal kinase JNK3. J. Comput. Chem., 2001, 22, 21–30.

[478] G. M. Keserü; I. Kolossváry. Fully ﬂexible low-mode docking: Application to induced ﬁt in HIV integrase.

J. Am. Chem. Soc., 2001, 123, 12708–12709.

[479] W. H. Press; B. P. Flannery; S. A. Teukolsky; W. T. Vetterling. Numerical Recipes: The Art of Scientiﬁc

Computing. Cambridge University Press, New York, 1989.

[480] D. C. Liu; J. Nocedal. On the limited memory method for large scale optimization. Math. Programming B,

1989, 45, 503–528.

[481] J. Nocedal; J. L. Morales. Automatic preconditioning by limited memory quasi-Newton updating. SIAM J.

Opt., 2000, 10, 1079–1096.

[482] P. Kollman. Free energy calculations: Applications to chemical and biochemical phenomena. Chem. Rev.,

1993, 93, 2395–2417.

[483] T. Simonson.

in Computational Biochemistry and Biophysics, O. Becker; A. D. MacKerell; B. Roux;

M. Watanabe, Eds. Marcel Dekker, New York, 2001.

[484] T. Steinbrecher; D. A. Case; A. Labahn. A multistep approach to structure-based drug design: Studying

ligand binding at the human neutrophil elastase. J. Med.. Chem., 2006, 49, 1837–1844.

[485] T. Steinbrecher; A. Hrenn; K. Dormann; I. Merfort; A. Labahn. Bornyl (3,4,5-trihydroxy)-cinnamate - An
optimized human neutrophil elastase inhibitor designed by free energy calculations. Bioorg. Med. Chem.,
2008, 16, 2385–2390.

[486] J. Kaus; L. C. T. Pierce; R. C. Walker; J. A. McCammon. PMEMD TI: Placeholder. J. Chem. Theory

Comput., 2013.

[487] T.-S. Lee; Y. Hu; B. Sherborne; Z. Guo; D. M. York. Toward fast and accurate binding afﬁnity prediction
with pmemdgti: An efﬁcient implementation of GPU-accelerated thermodynamic integration. J. Chem.
Theory Comput., 2017, 13, 3077–3084.

[488] T.-S. Lee; D. S. Cerutti; D. Mermelstein; C. Lin; S. LeGrand; T. J. Giese; A. Roitberg; D. A. Case; R. C.
Walker; D. M. York. Gpu-accelerated molecular dynamics and free energy methods in amber18: Perfor-
mance enhancements and new features. J. Chem. Inf. Model., 2018, 58, 2043–2050.

[489] L. F. Song; T.-S. Lee; C. Zhu; D. M. York; K. M. Merz Jr. Using AMBER18 for Relative Free Energy

Calculations. J. Chem. Inf. Model., 2019, 59, 3128–3135.

[490] G. Hummer; A. Szabo. Calculation of free-energy differences from computer simulations of initial and ﬁnal

states. J. Chem. Phys., 1996, 105, 2004–2010.

[491] T. Steinbrecher; D. L. Mobley; D. A. Case. Non-linear scaling schemes for Lennard-Jones interactions in

free energy calculations. J. Chem. Phys., 2007, 127, 214108.

[492] T. Steinbrecher; I. Joung; D. A. Case. Soft-core potentials in thermodynamic integration: Comparing one-

and two-step transformations. J. Comp. Chem., 2011, 32, 3253–3263.

[493] S. Boresch; M. Karplus. The role of bonded terms in free energy simulations. 1. theoretical analysis. J.

Phys. Chem. A, 1999, 103, 103–118.

880

BIBLIOGRAPHY

[494] S. Boresch; M. Karplus. The role of bonded terms in free energy simulations. 2. calculation of their inﬂuence

on free energy differences of solvation. J. Phys. Chem. A, 1999, 103, 119–136.

[495] S. Boresch. The role of bonded energy terms in free energy simulations - insights from analytical results.

Mol. Simul., 2002, 28, 13–37.

[496] A. Mitsutake; Y. Sugita; Y. Okamoto. Generalized-ensemble algorithms for molecular simulations of

biopolymers. Biopolymers, 2001, 60, 96–123.

[497] H. Nymeyer; S. Gnanakaran; A. García. Atomic simulations of protein folding using the replica exchange

algorithm. Meth. Enzymol., 2004, 383, 119–149.

[498] X. Cheng; G. Cui; V. Hornak; C. Simmerling. Modiﬁed replica exchange simulation methods for local

structure reﬁnement. J. Phys. Chem. B, 2005, 109, 8220–8230.

[499] Y. Meng; D. Sabri Dashti; A. E. Roitberg. Computing Alchemical Free Energy Differences with Hamilto-
nian Replica Exchange Molecular Dynamics (H-REMD) Simulations. J. Chem. Theory Comput., 2011, 7,
2721–2727.

[500] S. G. Itoh; A. Damjanovic; B. R. Brooks. pH replica-exchange method based on discrete protonation states.

Proteins, 2011, 79, 3420–3436.

[501] J. M. Swails; A. E. Roitberg. Enhancing Conformation and Protonation State Sampling of Hen Egg White
Lysozyme Using pH Replica Exchange Molecular Dynamics. J. Chem. Theory Comput., 2012, 8, 4393–
4404.

[502] V. W. D. Cruzeiro; M. S. Amaral; A. E. Roitberg. Redox Potential Replica Exchange Molecular Dynamics at
constant pH in AMBER: Implementation, Validation and Application. J. Chem. Phys., 2018, 149, 072338.

[503] V. W. D. Cruzeiro; A. E. Roitberg. Multidimensional Replica Exchange Simulations for Efﬁcient Constant

pH and Redox Potential Molecular Dynamics. J. Chem. Theory Comput., 2019.

[504] A. Patriksson; D. van der Spoel. A temperature predictor for parallel tempering simulations. Phys. Chem.

Chem. Phys., 2008, 10, 2073–2077.

[505] A. Okur; D. R. Roe; G. Cui; V. Hornak; C. Simmerling.

Improving convergence of replica-exchange
simulations through coupling to a high-temperature structure reservoir. J. Chem. Theory comput., 2007, 3,
557–568.

[506] A. E. Roitberg; A. Okur; C. Simmerling. Coupling of replica exchange simulations to a non-Boltzmann

structure reservoir. J. Phys. Chem. B, 2007, 111, 2415–2418.

[507] D. Sabri Dashti; A. E. Roitberg. Calculating the pKa Shift of Titratable Group at Position 66 of Staphylococ-
cal Nuclease Mutant with the Replica Exchange Free Energy Perturbation method (REFEP). In preparation,
2012.

[508] D. Sabri Dashti; A. E. Roitberg. Optimization of Umbrella Sampling Replica Exchange Molecular Dynam-

ics by Replica Positioning. J. Chem. Theory Comput., 2013, 9, 4692–4699.

[509] M. Fajer; D. Hamelberg; J. A. McCammon. Replica-Exchange Accelerated Molecular Dynamics (REX-

AMD) Applied to Thermodynamic Integration. J. Chem. Theory Comput., 2008, 4, 1565–1569.

[510] M. Arrar; C. A. F. de Oliveira; M. Fajer; W. Sinko; J. A. McCammon. w-REXAMD: A Hamiltonian
Replica Exchange Approach to Improve Free Energy Calculations for Systems with Kinetically Trapped
Conformations. J. Chem. Theory Comput., 2013, 9, 18–23.

[511] M. R. Shirts; J. D. Chodera. Statistically optimal analysis of samples from multiple equilibrium states. J.

Chem. Phys., 2008, 129, 124105–124105–10.

881

BIBLIOGRAPHY

[512] A. Pohorille; C. Jarzynski; C. Chipot. Good practices in Free-Energy calculations. J. Phys. Chem. B, 2010,

114, 10235–10253.

[513] J. M. Swails. Free Energy Simulations of Complex Biological Systems at Constant pH. PhD thesis, Univer-

sity of Florida, 2013.

[514] V. Babin; C. Roland; C. Sagui. Adaptively biased molecular dynamics for free energy calculations. J. Chem.

Phys., 2008, 128, 134101.

[515] T. Huber; A. E. Torda; W. F. van Gunsteren. Local elevation: a method for improving the searching proper-

ties of molecular dynamics simulation. J. Comput. Aided. Mol. Des., 1994, 8, 695–708.

[516] F. Wang; D. P. Landau. Efﬁcient, multiple-range random walk algorithm to calculate the density of states.

Phys. Rev. Lett., 2001, 86, 2050–2053.

[517] A. Laio; M. Parrinello. Escaping free-energy minima. Proc. Natl. Acad. Sci., 2002, 99, 12562–12566.

[518] M. Iannuzzi; A. Laio; M. Parrinello. Efﬁcient exploration of reactive potential energy surfaces using car-

parrinello molecular dynamics. Phys. Rev. Lett., 2003, 90, 238302–1.

[519] T. Lelièvre; M. Rousset; G. Stoltz. Computation of free energy proﬁles with parallel adaptive dynamics. J.

Chem. Phys., 2007, 126, 134111.

[520] P. Raiteri; A. Laio; F. L. Gervasio; C. Micheletti; M. Parrinello. Efﬁcient reconstruction of complex free

energy landscapes by multiple walkers metadynamics. J. Phys. Chem., 2006, 110, 3533–3539.

[521] Y. Sugita; A. Kitao; Y. Okamoto. Multidimensional replica-exchange method for free-energy calculations.

J. Chem. Phys., 2000, 113, 6042–6051.

[522] G. Bussi; F. L. Gervasio; A. Laio; M. Parrinello. Free-energy landscape for β hairpin folding from combined

parallel tempering and metadynamics. J. Am. Chem. Soc., 2006, 128, 13435–13441.

[523] S. Piana; A. Laio. A bias-exchange approach to protein folding. J. Phys. Chem. B, 2007, 111, 4553–4559.

[524] V. Babin; C. Roland; T. A. Darden; C. Sagui. The free energy landscape of small peptides as obtained from

metadynamics with umbrella sampling corrections. J. Chem. Phys., 2006, 125, 2049096.

[525] V. Babin; V. Karpusenka; M. Moradi; C. Roland; C. Sagui. Adaptively biased molecular dynamics: an
umbrella sampling method with a time dependent potential. Inter. J. Quantum Chem., 2009, 109, 3666–
3678.

[526] V. Babin; C. Sagui. Conformational free energies of methyl-alpha-l-iduronic and methyl-beta-d-glucuronic

acids in water. J. Chem. Phys., 2010, 132, 104108.

[527] M. Moradi; V. Babin; C. Roland; T. Darden; C. Sagui. Conformations and free energy landscapes of

polyproline peptides. Proc. Natl. Aca. Sci. USA, 2009, 106, 20746.

[528] M. Moradi; V. Babin; C. Roland; C. Sagui. A classical molecular dynamics investigation of the free energy

and structure of short polyproline conformers. J. Chem. Phys., 2010, 133, 125104.

[529] M. Moradi; V. Babin; C. Sagui; C. Roland.

in Proline: Biosynthesis, Regulation and Health Beneﬁts, B.

Nedjimi, Ed., pp 67–110. Nova Publishers, 2013.

[530] M. Moradi; V. Babin; C. Sagui; C. Roland. A statistical analysis of the PPII propensity of amino acid guests

in proline-rich peptides. Biophysical J., 2011, 100, 1083 – 1093.

[531] M. Moradi; V. Babin; C. Sagui; C. Roland. PPII propensity of multiple-guest amino acids in a proline-rich

environment. J. Phys. Chem. B., 2011, 115, 8645–8656.

882

BIBLIOGRAPHY

[532] V. Babin; C. Roland; C. Sagui. The alpha-sheet: A missing-in-action secondary structure? Proteins –

Structure Function and Bioinformatics, 2011, 79, 937–946.

[533] M. Moradi; V. Babin; C. Roland; C. Sagui. Are long-range structural correlations behind the aggregation

phenomena of polyglutamine diseases? PLoS Comput. Biol., 2012, 8, e1002501.

[534] M. Moradi; V. Babin; C. Roland; C. Sagui. Reaction path ensemble of the B-Z-DNA transition: a compre-

hensive atomistic study. Nucleic Acids Research, 2013, 41, 33–43.

[535] F. Pan; V. H. Man; C. Roland; C. Sagui. Structure and Dynamics of DNA and RNA Double Helices of CAG

and GAC Trinucleotide Repeats. Biophys. J., 2017, 113, 19–36.

[536] F. Pan; Y. Zhang; V. H. Man; C. Roland; C. Sagui. E-motif formed by extrahelical cytosine bases in DNA

homoduplexes of trinucleotide and hexanucleotide repeats. Nucl. Acids Res., 2018, 46, 942–955.

[537] F. Pan; V. H. Man; C. Roland; C. Sagui. Structure and Dynamics of DNA and RNA Double Helices Obtained

From the CCG and GGC Trinucleotide Repeats. J. Phys. Chem. B, 2018, 122, 4491–4512.

[538] P. Xu; F. Pan; C. Roland; C. Sagui; K. Weninger. Dynamics of strand slippage in DNA hairpins formed by
CAG repeats: roles of sequence parity and trinucleotide interrupts. Nucl. Acids Res., 2020, 48, 2232–2245.

[539] M. Moradi; J.-G. Lee; V. Babin; C. Roland; C. Sagui. Free energy and structure of polyproline peptides: an

ab initio and classical molecular dynamics investigation. Int. J. Quantum Chem., 2010, 110, 2865–2879.

[540] M. Moradi; C. Sagui; C. Roland. Calculating relative transition rates with driven nonequilibrium simula-

tions. Chem. Phys. Lett., 2011, 518, 109.

[541] M. Moradi; C. Sagui; C. Roland.

Investigating rare events with nonequilibrium work measurements: I.

Nonequilibrium transition paths. J. Chem. Phys., 2014, 140, 034114.

[542] M. Moradi; C. Sagui; C. Roland. Investigating rare events with nonequilibrium work measurements: II.

Transition and reaction rates. J. Chem. Phys., 2014, 140, 034115.

[543] M. Moradi; E. Tajkorshid. Driven Metadynamics: Reconstructing equilibrium free energies from driven

adaptive-bias simulations. J. Phys. Chem. Lett., 2013, 4, 1882.

[544] A. C. Pan; D. Sezer; B. Roux. Finding transition pathways using the string method with swarms of trajec-

tories. J. Phys. Chem. B, 2008, 112, 3432–3440.

[545] A. Barducci and G. Bussi and M. Parrinello. Well-tempered metadynamics: a smoothly converging and

tunable free energy method. Phys. Rev. Lett., 2008, 100, 020603.

[546] K. Minoukadeh and Ch. Chipot and T. Lelievre. Potential of Mean Force Calculations: A multiple-walker

adaptive biasing force technique. J. Chem. Theor. and Comput., 2010, 6, 1008.

[547] E. A. Coutsias; C. Seok; K. A. Dill. Using quaternions to calculate RMSD. J. Comput. Chem., 2004, 25,

1849–1857.

[548] D. K. Coutsias EA, Seok C. Using quaternions to calculate rmsd. J Comput Chem, 2004 Nov 30, 25,

1849–57.

[549] G. Fiorin; M. L. Klein; J. Hénin. Using collective variables to drive molecular dynamics simulations.

Molecular Physics, 2013, 111, 3345–3362.

[550] M. Moradi; E. Tajkhorshid. Mechanistic picture for conformational transition of a membrane transporter at

atomic resolution. Proc. Natl. Acad. Sci. U.S.A., 2013, 110, 18916–18921.

[551] M. Moradi; E. Tajkhorshid. Computational Recipe for Efﬁcient Description of Large-Scale Conformational

Changes in Biomolecular Systems. J Chem Theory Comput, 2014, 10, 2866–2880.

883

BIBLIOGRAPHY

[552] S. Park; F. Khalili-Araghi; E. Tajkhorshid; K. Schulten. Free energy calculation from steered molecular

dynamics simulations using Jarzynski’s equality. J. Chem. Phys., 2003, 119, 3559–3566.

[553] M. Matsumoto; T. Nishimura. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-

random number generator. ACM Trans. Model. Comput. Simul., 1998, 8, 3–30.

[554] L. Maragliano; A. Fischer; E. Vanden-Eijnden; G. Ciccotti. String method in collective variables: Minimum

free energy paths and isocommittor surfaces. J. Chem. Phys., 2006, 125, 024106.

[555] M. O. Jensen; S. Park; E. d; K. Schulten. Energetics of glycerol conduction through aquaglyceroporin GlpF.

Proc. Natl. Acad. Sci. USA, 2002, 99, 6731–6736.

[556] A. Crespo; M. A. Marti; D. A. Estrin; A. E. Roitberg. Multiple-steering QM-MM calculation of the free

energy proﬁle in chorismate mutase. J. Am. Chem. Soc., 2005, 127, 6940–6941.

[557] C. Jarzynski. Nonequilibrium equality for free energy differences. Phys. Rev. Lett., 1997, 78, 2690–2693.

[558] G. Hummer; A. Szabo. Free energy reconstruction from nonequilibrium single-molecule pulling experi-

ments. Proc. Natl. Acad. Sci. USA, 2001, 98, 3658.

[559] G. Hummer; A. Szabo. Kinetics from nonequilibrium single-molecule pulling experiments. Biophys. J.,

2003, 85, 5–15.

[560] T. Schilling; F. Schmid. Computing absolute free energies of disordered structures by molecular simulation.

J. Chem. Phys., 2009, 131, 231102.

[561] F. Schmid; T. Schilling. A method to compute absolute free energies or enthalpies of ﬂuids. Physics

Procedia, 2010, 4, 131–143.

[562] J. T. Berryman; T. Schilling. Free Energies by Thermodynamic Integration Relative to an Exact Solution,
Used to Find the Handedness-Switching Salt Concentration for DNA. J. Chem. Theory Comput., 2013, 9,
679–686.

[563] J. T. Berryman; T. Schilling. Absolute Free Energies for Biomolecules in Implicit or Explicit Solvent.

Physics Procedia, 2014, 57, 7–15.

[564] D. Frenkel; A. J. C. Ladd. New Monte Carlo method to compute the free energy of arbitrary solids. Appli-

cation to the fcc and hcp phases of hard spheres. J. Chem. Phys., 1984, 81, 3188–3193.

[565] C. Vega; E. G. Noya. Revisiting the Frenkel-Ladd method to compute the free energy of solids: the Einstein

molecule approach. J. Chem. Phys., 2007, 127, 154113.

[566] R. Assaraf; M. Caffarel; A. C. Kollias. Chaotic versus nonchaotic stochastic dynamics in monte carlo
simulations: A route for accurate energy differences in n-body systems. Phys. Rev. Lett., 2011, 106, 150601.

[567] J. Mongan; D. A. Case; J. A. McCammon. Constant pH molecular dynamics in generalized Born implicit

solvent. J. Comput. Chem., 2004, 25, 2038–2048.

[568] J. M. Swails; D. M. York; A. E. Roitberg. Constant pH replica exchange molecular dynamics in explicit
solvent using discrete protonation states: implementation, testing, and validation. J. Chem. Theory Comput.,
2014, 10, 1341–1352.

[569] J. Khandogin; C. L. Brooks, III. Constant pH molecular dynamics with proton tautomerism. Biophys. J.,

2005, 89, 141–157.

[570] Y. Huang; R. C. Harris; J. Shen. Generalized Born based continuous constant pH molecular dynamics in

Amber: implementation, benchmarking, and analysis. J. Chem. Inform. Model., 2018, 58, 1372–1383.

[571] R. C. Harris; J. Shen. GPU-Accelerated Implementation of Continuous Constant pH Molecular Dynamics

in Amber: pKa Predictions with Single-pH Simulations. J. Chem. Inform. Model., 2019, 59, 4821–4832.

884

BIBLIOGRAPHY

[572] J. A. Wallace; J. K. Shen. Continuous constant pH molecular dynamics in explicit solvent with pH-based

replica exchange. J. Chem. Theory Comput., 2011, 7, 2617–2629.

[573] J. A. Wallace; J. K. Shen. Charge-leveling and proper treatment of long-range electrostatics in all-atom

molecular dynamics at constant pH. J. Chem. Phys., 2012, 137, 184105.

[574] W. Chen; J. A. Wallace; Z. Yue; J. K. Shen. Introducing titratable water to all-atom molecular dynamics at

constant pH. Biophys. J., 2013, 105, L15–L17.

[575] Y. Huang; W. Chen; J. A. Wallace; J. Shen. All-Atom continuous constant pH molecular dynamics with

particle mesh Ewald and titratable water. J. Chem. Theory Comput., 2016, 12, 5411–5421.

[576] J. Khandogin; C. L. Brooks, III. Toward the accurate ﬁrst-principles prediction of ionization equilibria in

proteins. Biochemistry, 2006, 45, 9363–9373.

[577] B. M. Duggan; G. B. Legge; H. J. Dyson; P. E. Wright. SANE (Structure Assisted NOE Evaluation): An

automated model-based approach for NOE assignment. J. Biomol. NMR, 2001, 19, 321–329.

[578] A. Kalk; H. J. C. Berendsen. Proton magnetic relaxation and spin diffusion in proteins. J. Magn. Reson.,

1976, 24, 343–366.

[579] E. T. Olejniczak; M. A. Weiss. Are methyl groups relaxation sinks in small proteins? J. Magn. Reson.,

1990, 86, 148–155.

[580] K. J. Cross; P. E. Wright. Calibration of ring-current models for the heme ring. J. Magn. Reson., 1985, 64,

220–231.

[581] K. Ösapay; D. A. Case. A new analysis of proton chemical shifts in proteins. J. Am. Chem. Soc., 1991, 113,

9436–9444.

[582] D. A. Case. Calibration of ring-current effects in proteins and nucleic acids. J. Biomol. NMR, 1995, 6,

341–346.

[583] L. Banci; I. Bertini; G. Gori-Savellini; A. Romagnoli; P. Turano; M. A. Cremonini; C. Luchinat; H. B.
Gray. Pseudocontact shifts as constraints for energy minimization and molecular dynamics calculations on
solution structures of paramagnetic metalloproteins. Proteins, 1997, 29, 68.

[584] C. R. Sanders, II; B. J. Hare; K. P. Howard; J. H. Prestegard. Magnetically-oriented phospholipid micelles

as a tool for the study of membrane-associated molecules. Prog. NMR Spectr., 1994, 26, 421–444.

[585] V. Tsui; L. Zhu; T. H. Huang; P. E. Wright; D. A. Case. Assessment of zinc ﬁnger orientations by residual

dipolar coupling constants. J. Biomol. NMR, 2000, 16, 9–21.

[586] D. A. Case. Calculations of NMR dipolar coupling strengths in model peptides. J. Biomol. NMR, 1999, 15,

95–102.

[587] G. P. Gippert; P. F. Yip; P. E. Wright; D. A. Case. Computational methods for determining protein structures

from NMR data. Biochem. Pharm., 1990, 40, 15–22.

[588] D. A. Case; P. E. Wright. in NMR in Proteins, G. M. Clore; A. Gronenborn, Eds., pp 53–91. MacMillan,

New York, 1993.

[589] D. A. Case; H. J. Dyson; P. E. Wright. Use of chemical shifts and coupling constants in nuclear magnetic

resonance structural studies on peptides and proteins. Meth. Enzymol., 1994, 239, 392–416.

[590] R. Brüschweiler; D. A. Case. Characterization of biomolecular structure and dynamics by NMR cross-

relaxation. Prog. NMR Spectr., 1994, 26, 27–58.

[591] D. A. Case. The use of chemical shifts and their anisotropies in biomolecular structure determination. Curr.

Opin. Struct. Biol., 1998, 8, 624–630.

885

BIBLIOGRAPHY

[592] A. E. Torda; R. M. Scheek; W. F. VanGunsteren. Time-dependent distance restraints in molecular dynamics

simulations. Chem. Phys. Lett., 1989, 157, 289–294.

[593] D. A. Pearlman; P. A. Kollman. Are time-averaged restraints necessary for nuclear magnetic resonance

reﬁnement? A model study for DNA. J. Mol. Biol., 1991, 220, 457–479.

[594] A. E. Torda; R. M. Brunne; T. Huber; H. Kessler; W. F. van Gunsteren. Structure reﬁnement using time-

averaged J-coupling constant restraints. J. Biomol. NMR, 1993, 3, 55–66.

[595] D. A. Pearlman. How well to time-averaged J-coupling restraints work? J. Biomol. NMR, 1994, 4, 279–299.

[596] D. A. Pearlman. How is an NMR structure best deﬁned? An analysis of molecular dynamics distance-based

approaches. J. Biomol. NMR, 1994, 4, 1–16.

[597] X. Wu; J. L. Milne; M. J. Borgnia; A. V. Rostapshov; S. Subramaniam; B. R. Brooks. A core-weighted ﬁtting
method for docking atomic structures into low-resolution maps: application to cryo-electron microscopy. J
Struct Biol, 2003, 141, 63–76.

[598] J. L. Milne; X. Wu; M. J. Borgnia; J. S. Lengyel; B. R. Brooks; D. Shi; R. N. Perham; S. Subramaniam.
Molecular structure of a 9-MDa icosahedral pyruvate dehydrogenase subcomplex containing the E2 and E3
enzymes using cryoelectron microscopy. J Biol Chem, 2006, 281, 4364–70.

[599] X. Wu; B. R. Brooks. Modeling of Macromolecular assemblies with map objects. Proc. 2007 Int. Conf.

Bioinform. Comput. Biol., 2007, II, 411–417.

[600] C. M. Khursigara; X. Wu; P. Zhang; J. Lefman; S. Subramaniam. Role of HAMP domains in chemotaxis

signaling by bacterial chemoreceptors. PNAS, 2008, 105, 16555–60.

[601] J. S. Lengyel; K. M. Stott; X. Wu; A. Brooks, B. R.and Balbo; P. Schuck; R. N. Perham; S. Subramaniam;
J. L. Milne. Extended polypeptide linkers establish the spatial architecture of a pyruvate dehydrogenase
multienzyme complex. Structure, 2008, 16, 93–103.

[602] C. M. Khursigara; X. Wu; ; S. Subramaniam. Chemoreceptors in Caulobacter crescentus: trimers of receptor

dimers in a partially ordered hexagonally packed array. J Bacteriol, 2008, 190, 6805–10.

[603] J. Elegheert; A. Desfosses; A. V. Shkumatov; X. Wu; N. Bracke; K. Verstraete; K. Van Craenenbroeck;
B. R. Brooks; D. I. Svergun; B. Vergauwen; I. Gutsche; S. N. Savvides. Extracellular complexes of the
hematopoietic human and mouse CSF-1 receptor are driven by common assembly principles . Structure,
2011, 19, 1762–72.

[604] C. M. Khursigara; G. Lan; S. Neumann; X. Wu; S. Ravindran; M. J. Borgnia; V. Sourjik; J. Milne; Y. Tu;
S. Subramaniam. Lateral density of receptor arrays in the membrane plane inﬂuences sensitivity of the E.
coli chemotaxis response. Embo J, 2011, 30, 1719–29.

[605] X. Wu; B. R. Brooks. in Microscopy: advances in scientiﬁc research and education, A. Mendez-Vilas, Ed.,

pp 39–47. Formatex Research Center, Spain, 2014.

[606] X. Wu; B. R. Brooks. in Modern electron microscopy in physical and life science, M. Janecek, Ed., chap-

ter 12, pp 243–262. InTech, 2016.

[607] A. Bartesaghi; A. Merk; S. Banerjee; D. Matthies; X. Wu; J. L. S. Milne; S. Subramaniam. 2.2 a resolution
cryo-em structure of beta-galactosidase in complex with a cell-permeant inhibitor. Science, 2015, 348,
1147–1151.

[608] S. Kalinin; T. Peulen; S. Sindbert; P. J. Rothwell; S. Berger; T. Restle; R. S. Goody; H. Gohlke; C. A. Seidel.
A toolkit and benchmark study for fret-restrained high-precision structural modeling. Nature Methods, 2012,
9, 1218–1225.

886

BIBLIOGRAPHY

[609] M. Dimura; T. O. Peulen; C. A. Hanke; A. Prakash; H. Gohlke; C. A. Seidel. Quantitative fret studies and
integrative modeling unravel the structure and dynamics of biomolecular systems. Curr. Opin. Struct. Biol.,
2016, 40, 163–185.

[610] M. Dimura; T. O. Peulen; H. Sanabria; D. Rodnin; K. Hemmen; C. A. Seidel; H. Gohlke. Automated and

optimally fret-assisted structural modeling. 2019.

[611] R. T. McGibbon; K. A. Beauchamp; M. P. Harrigan; C. Klein; J. M. Swails; C. X. Hernandez; C. R.
Schwantes; L.-P. Wang; T. J. Lane; V. S. Pande. Mdtraj: A modern open library for the analysis of molecular
dynamics trajectories. Biophys. J., 2015, 109, 1528–1532.

[612] P. A. Janowski; D. S. Cerutti; J. M. Holton; D. A. Case. Peptide crystal simulations reveal hidden dynamics.

J. Am. Chem. Soc., 2013, 135, 7938–7948.

[613] N. Moriarty; P. Janowski; J. Swails; H. Nguyen; J. Richardson; D. Case; P. Adams. Improved chemistry
restraints for crystallographic reﬁnement by integrating the Amber force ﬁeld into Phenix. Acta Cryst. D,
2020, 76, 51–62.

[614] P. Afonine; A. Urzhumtsev. On a fast calculation of structure factors at a subatomic resolution. Acta Cryst.,

2004, A60, 19–32.

[615] J. Jiang; A. Brünger. Protein hydration observed by X-ray diffraction: solvation properties of penicillopepsin

and neuraminidase crystal structures. J. Mol. Biol., 1994, 243, 100–115.

[616] A. Fokine; A. Urzhumtsev. Flat bulk-solvent model: obtaining optimal parameters. Acta Cryst., 2002, D58,

1387–1392.

[617] R. Grosse-Kunstleve; N. Sauter; N. Moriarty; P. Adams. The Computational Crystallography Toolbox:

crystallographic algorithms in a reusable software framework. J. Appl. Crystallogr., 2002, 35, 126–136.

[618] Y. Xue; N. Skrynnikov. Ensemble MD simulations restrained via crystallographic data: Ð°ccurate structure

leads to accurate dynamics. Prot. Sci., 2014, 23, 488–507.

[619] A. Raval; S. Piana; M. Eastwood; R. Dror; D. Shaw. Reﬁnement of protein structure homology models via

long, all-atom molecular dynamics simulations. Proteins, 2012, 80, 2071–2079.

[620] V. Lunin; T. Skovoroda. R-free likelihood-based estimates of errors for phases calculated from atomic

models. Acta Cryst., 1995, A51, 880–887.

[621] R. Read; A. McCoy. A log-likelihood-gain intensity target for crystallographic phasing that accounts for

experimental error. Acta Cryst. D, 2016, 72, 375–387.

[622] P. Afonine; R. Grosse-Kunstleve; P. Adams; A. Urzhumtsev. Bulk-solvent and overall scaling revisited:

faster calculations, improved results. Acta Cryst., 2013, D69, 625–634.

[623] S. Meisburger; N. Ando. Correlated Motions from Crystallography beyond Diffraction. Acc. Chem. Res.,

2017, 50, 580–583.

[624] S. Meisburger; D. Case; N. Ando. Correlated motions in a protein crystal. Nature Commun., 2020, 11,

1271.

[625] A. Roitberg; R. Elber. Modeling side chains in peptides and proteins: Application of the locally enhanced
sampling and the simulated annealing methods to ﬁnd minimum energy conformations. J. Chem. Phys.,
1991, 95, 9277.

[626] A. Ulitsky; R. Elber. The thermal equilibrium aspects of the time-dependent Hartree and the locally en-
hanced sampling approximations: Formal properties, a correction, and computational examples for rare gas
clusters. J. Chem. Phys., 1993, 98, 3380.

887

BIBLIOGRAPHY

[627] C. Simmerling; T. Fox; P. A. Kollman. Use of Locally Enhanced Sampling in Free Energy Calculations:
Testing and Application of the alpha to beta Anomerization of Glucose. J. Am. Chem. Soc., 1998, 120,
5771–5782.

[628] C. Simmerling; J. L. Miller; P. A. Kollman. Combined locally enhanced sampling and particle mesh Ewald
as a strategy to locate the experimental structure of a nonhelical nucleic acid. J. Am. Chem. Soc., 1998, 120,
7149–7155.

[629] A. Miranker; M. Karplus. Functionality maps of binding sites: A multiple copy simultaneous search method.

Proteins: Str. Funct. Gen., 1991, 11, 29–34.

[630] X. Cheng; V. Hornak; C. Simmerling. Improved conformational sampling through an efﬁcient combination

of mean-ﬁeld simulation approaches. J. Phys. Chem. B, 2004, 108.

[631] J. E. Straub; M. Karplus. Enery partitioning in the classical time-dependent Hartree approximation. J.

Chem. Phys., 1991, 94, 6737.

[632] P. Y. Ren; J. W. Ponder. Polarizable atomic multipole water model for molecular mechanics simulation. J.

Phys. Chem. B, 2003, 107, 5933–5947.

[633] P. Y. Ren; J. W. Ponder. Tinker polarizable atomic multipole force ﬁeld for proteins. to be published., 2006.

[634] O. N. Starovoytov; H. Torabifard; G. A. Cisneros. Development of amoeba force ﬁeld for 1,3-

dimethylimidazolium based ionic liquids. J. Phys. Chem. B, 2014, 118, 7156–7166.

[635] H. Torabifard; O. N. Starovoytov; P. Ren; G. A. Cisneros. Development of an amoeba water model using

gem distributed multipoles. Theo. Chem. Acc., 2015, 134, 1–10.

[636] H. Torabifard; L. Reed; M. T. Berry; J. E. Hein; E. Menke; G. A. Cisneros. Computational and experimental
characterization of a pyrrolidinium-based ionic liquid for electrolyte applications. J. Chem. Phys., 2017,
147, 161731.

[637] Y.-J. Tu; M. J. Allen; G. A. Cisneros. Simulations of the water exchange dynamics of lanthanide ions in
1-ethyl-3-methylimidazolium ethyl sulfate ([emim][etso4]) and water. Phys. Chem. Chem. Phys., 2016, 18,
30323–30333.

[638] Y.-J. Tu; Z. Lin; M. J. Allen; G. A. Cisneros. Molecular dynamics investigation of water-exchange reactions
on lanthanide ions in water/1-ethyl-3-methylimidazolium triﬂuoromethylsufate ([emim][otf]). J. Chem.
Phys., 2018, 148, 024503.

[639] G. A. Cisneros; J.-P. Piquemal; T. A. Darden. Generalization of the gaussian electrostatic model: extension
to arbitrary angular momentum, distributed multipoles and computational speedup with reciprocal space
methods. J. Chem. Phys., 2006, 125, 184101.

[640] J.-P. Piquemal; G. A. Cisneros; P. Reinhardt; N. Gresh; T. A. Darden. Towards a force ﬁeld based on density

ﬁtting. J. Chem. Phys., 2006, 124, 104101.

[641] J.-P. Piquemal; G. Cisneros.

in Many-body effects and electrostatics in multi-scale computations of

Biomolecules, Q. Cui; P. Ren; M. Meuwly, Eds., pp 269–300. Pan Stanford Publishing, 2015.

[642] R. E. Duke; O. N. Starovoytov; J.-. Piquemal; G. A. Cisneros. Gem*: A molecular electronic density-based

force ﬁeld for molecular dynamics simulations. J. Chem. Theo. Comput., 2014, 10, 1361–1365.

[643] D. R. Roe; T. E. Cheatham, III. PTRAJ and CPPTRAJ: Software for Processing and Analysis of Molecular

Dynamics Trajectory Data. J. Chem. Theory Comput., 2013, 9, 3084–3095.

[644] D. R. Roe; T. E. Cheatham III. Parallelization of CPPTRAJ enables large scale analysis of molecular

dynamics trajectory data. J. Computat. Chem., 2018, 39, 2110–2117.

888

BIBLIOGRAPHY

[645] S. Chatterjee; P. G. Debenedetti; F. H. Stillinger; R. M. Lynden-Bell. A Computational Investigation of
Thermodynamics, Structure, Dynamics and Solvation Behavior in Modiﬁed Water Models. J. Chem. Phys.,
2008, 128, 124511.

[646] T. Lazaridis. Inhomogeneous Fluid Approach to Solvation Thermodynamics. 1 Theory. J. Phys. Chem. B,

1998, 102, 3531–3541.

[647] C. N. Nguyen; T. Kurtzman Young; M. K. Gilson. Grid Inhomogeneous Solvation Theory: Hydration Struc-

ture and Thermodynamics of the Miniature Receptor cucurbit[7]uril. J. Chem. Phys., 2012, 137, 044101.

[648] W. Humphrey; A. Dalke; K. Schulten. VMD Visual Molecular Dynamics. J. Molec. Graph., 1996, 14,

33–38.

[649] D. J. Sindhikara; N. Yoshida; F. Hirata. Placevent: An Algorithm for Prediction of Explicit Solvent Atom
Distribution-Application to HIV-1 Protease and F-ATP Synthase. J. Comput. Chem., 2012, 33, 1536–1543.

[650] J. J. Chou; D. A. Case; A. Bax. Insights into the mobility of methyl-bearing side chains in proteins. J. Am.

Chem. Soc., 2003, 125, 8959–8966.

[651] C. Perez; F. Lohr; H. Ruterjans; J. M. Schmidt. Self-Consistent Karplus Parameterization of (3)J couplings

depending on the polypeptide side-chain torsion chi(1). J. Am. Chem. Soc., 2001, 123, 7081–7093.

[652] P. H. Hunenberger; A. E. Mark; W. F. van Gunsteren. Fluctuation and Cross-correlation Analysis of Protein

Motions Observed in Nanosecond Molecular Dynamics Simulations. J. Mol. Biol., 1995, 252, 492–503.

[653] J. J. Prompers; R. Brüschweiler. Dynamic and structural analysis of isotropically distributed molecular

ensembles. Proteins, 2002, 46, 177–189.

[654] J. J. Prompers; R. Brüschweiler. General framework for studying the dynamics of folded and nonfolded
proteins by NMR relaxation spectroscopy and MD simulation. J. Am. Chem. Soc., 2002, 124, 4522–4534.

[655] M. L. Connolly. Analytical molecular surface calculation. J. Appl. Cryst., 1983, 16, 548–558.

[656] M. A. E. Hassan; C. R. Calladine. Two distinct modes of protein-induced bending in dna. J. Mol. Biol.,

1998, 282, 331–343.

[657] X. Lu; W. Olson.

3dna: a software package for the analysis, rebuilding and visualization of three-

dimensional nucleic acid structures. NUCLEIC ACIDS RESEARCH, 2003, 31, 5108–5121.

[658] M. S. Babcock; E. P. D. Pednault; W. K. Olson. Nucleic Acid Structure Analysis. J. Mol. Biol., 1994, 237,

125–156.

[659] W. K. Olson; M. Bansal; S. K. Burley; R. E. Dickerson; M. Gerstein; S. C. Harvey; U. Heinemann; X.-J.
Lu; S. Neidle; Z. Shakked; H. Sklenar; M. Suzuki; C.-S. Tung; E. Westhof; C. Wolberger; H. M. Berman.
A standard reference frame for the description of nucleic acid base-pair geometry. J. Mol. Biol., 2001, 313,
229–237.

[660] C. Altona; M. Sundaralingam. Conformational analysis of the sugar ring in nucleosides and nucleotides. a

new description using the concept of pseudorotation. J Am Chem Soc, 1972, 94, 8205–8212.

[661] S. Harvey; M. Prabhakaran. Ribose puckering - structure, dynamics, energetics, and the pseudorotation

cycle. J Am Chem Soc, 1986, 108, 6128–6136.

[662] D. Cremer; J. Pople. A general deﬁnition of ring puckering coordinates. J Am Chem Soc, 1975, 97, 1354–

1358.

[663] W. Kabsch; C. Sander. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded

and geometrical features. Biopolymers, 1983, 22, 2577–2637.

889

BIBLIOGRAPHY

[664] G. Cui; J. M. Swails; E. S. Manas. SPAM: A Simple Approach for Proﬁling Bound Water Molecules. J.

Chem. Theory Comput., 2013, 9, 5539–5549.

[665] M. Ester; H. Kriegel; J. Sander; X. Xu. A Density-Based Algorithm for Discovering Clusters in Large
Spatial Databases with Noise. Proc. Second Int. Conf. Knowledge Disc. Data Mining (KDD-96), 1996, pp
226–231.

[666] A. Rodriguez; A. Laio. Clustering by fast search and ﬁnd of density peaks. Science, 2014, 344, 1492–1496.

[667] A. Bakan; L. M. Meireles; I. Bahar. ProDy: Protein Dynamics Inferred from Theory and Experiments.

Bioinformatics, 2011, 27, 1575–1577.

[668] D. A. McQuarrie. Statistical Thermodynamics. Harper and Row, New York, 1973.

[669] C.-E. Chang; W. Chen; M. K. Gilson. Evaluating the Accuracy of the Quasiharmonic Approximation. J.

Chem. Theory Computat, 2005, 1, 1017–1028. PMID: 26641917.

[670] D. R. Roe; C. Bergonzo; T. E. C. III. Evaluation of enhanced sampling provided by accelerated molecular

dynamics with hamiltonian replica exchange methods. J. Phys. Chem. B, 2014, 118, 3543–3552.

[671] R. Galindo-Murillo; D. R. Roe; T. E. Cheatham, III. Convergence and reproducibility in molecular dynamics
simulations of the DNA duplex d(GCACGAACGAACGAACGC). Biochim. Biophys. Acta, 2015, 1850,
1041–1058.

[672] V. Wong; D. A. Case. Evaluating rotational diffusion from protein md simulations. J. Phys. Chem. B, 2008,

112, 6013–6024.

[673] B. Schneider; S. Neidle; H. M. Berman. Conformations of the sugar-phosphate backbone in helical dna

crystal structures. Biopolymers, 1997, 42, 113–124.

[674] B. Schneider; Z. Moravek; H. M. Berman. Rna conformational classes. Nucleic Acids Res., 2004, 32,

1666–1677.

[675] C. Torrence; G. P. Compo. A practical guide to wavelet analysis. Bull. Am. Meteorol. Soc., 1998, 79, 61–78.

[676] N. C. Benson; V. Dagget. Wavelet analysis of protein motion. Int. J. Wavelets Multi., 2012, 10.

[677] Z. Heidari; D. R. Roe; R. Galindo-Murillo; J. B. Ghasemi; T. E. Cheatham, III. Using Wavelet Analysis
To Assist in Identiﬁcation of Signiﬁcant Events in Molecular Dynamics Simulations. J. Chem. Inf. Model.,
2016, 56, 1282–1291.

[678] H. Nguyen; D. R. Roe; J. M. Swails; D. A. Case. PYTRAJ: Interactive data analysis for molecular dynamics

simulations. Manuscript in preparation, 2016.

[679] H. Nguyen; D. A. Case; A. S. Rose. Nglview–interactive molecular graphics for jupyter notebooks. Bioin-

formatics, 2017, 34, 1241–1242.

[680] B. R. Miller; T. D. McGee; J. M. Swails; N. Homeyer; H. Gohlke; A. E. Roitberg. MMPBSA.py: An
Efﬁcient Program for End-State Free Energy Calculations. J. Chem. Theory Comput., 2012, 8, 3314–3321.

[681] J. Srinivasan; T. E. Cheatham, III; P. Cieplak; P. Kollman; D. A. Case. Continuum solvent studies of the

stability of DNA, RNA, and phosphoramidate–DNA helices. J. Am. Chem. Soc., 1998, 120, 9401–9409.

[682] P. A. Kollman; I. Massova; C. Reyes; B. Kuhn; S. Huo; L. Chong; M. Lee; T. Lee; Y. Duan; W. Wang;
O. Donini; P. Cieplak; J. Srinivasan; D. A. Case; T. E. Cheatham, III. Calculating structures and free
energies of complex molecules: Combining molecular mechanics and continuum models. Accts. Chem.
Res., 2000, 33, 889–897.

[683] N. Homeyer; H. Gohlke. Free energy calculations by the molecular mechanics poisson-boltzmann surface

area method. Mol. Informatics, 2012, DOI: 10.1002/minf.201100135.

890

BIBLIOGRAPHY

[684] E. Wang; H. Sun; J. Wang; Z. Wang; H. Liu; J. Zhang; T. Hou. End-Point Binding Free Energy Calculation
with MM/PBSA and MM/GBSA: Strategies and Applications in Drug Design. Chem. Rev., 2019, 119,
9478–9508.

[685] W. Wang; P. Kollman. Free energy calculations on dimer stability of the HIV protease using molecular

dynamics and a continuum solvent model. J. Mol. Biol., 2000, 303, 567.

[686] C. Reyes; P. Kollman. Structure and thermodynamics of RNA-protein binding: Using molecular dynamics
and free energy analyses to calculate the free energies of binding and conformational change. J. Mol. Biol.,
2000, 297, 1145–1158.

[687] M. R. Lee; Y. Duan; P. A. Kollman. Use of MM-PB/SA in estimating the free energies of proteins: Appli-

cation to native, intermediates, and unfolded vilin headpiece. Proteins, 2000, 39, 309–316.

[688] J. Wang; P. Morin; W. Wang; P. A. Kollman. Use of MM-PBSA in reproducing the binding free energies to
HIV-1 RT of TIBO derivatives and predicting the binding mode to HIV-1 RT of efavirenz by docking and
MM-PBSA. J. Am. Chem. Soc., 2001, 123, 5221–5230.

[689] L. Marinelli; S. Cosconati; T. Steinbrecher; V. Limongelli; A. Bertamino; E. Novellino; D. A. Case. Ho-
mology Modeling of NR2B Modulatory Domain of NMDA Receptor and Analysis of Ifenprodil Binding.
ChemMedChem, 2007, 2,, 1498–1510.

[690] N. Homeyer; H. Gohlke. FEW - A workﬂow tool for free energy calculations of ligand binding. J. Comput.

Chem., 2013, 34, 965–973.

[691] S. Jo; T. Kim; W. Im. Automated builder and database of protein/membrane complexes for molecular

dynamics simulations. PLoS One, 2007, 2, e880.

[692] S. Jo; T. Kim; V. G. Iyer; I. W. CHARMM-GUI: a web-based graphical user interface for CHARMM. J.

Comput. Chem., 2008, 29, 1859–1865.

[693] S. Jo; J. B. Lim; J. B. Klauda; W. Im. CHARMM-GUI Membrane Builder for mixed bilayers and its

application to yeast membranes. Biophys. J., 2009, 97, 50–58.

[694] E. L. Wu; X. Cheng; S. Jo; H. Rui; K. C. Song; E. M. Davila-Contreras; Y. Qi; J. Lee; V. Monje-Galvan;
R. M. Venable; J. B. Klauda; I. W. CHARMM-GUI Membrane Builder toward realistic biological membrane
simulations. J. Comput. Chem., 2014, 35, 1997–2004.

[695] J. Domanski; P. Stansfeld; M. S. P. Sansom; O. Beckstein. Lipidbook: A Public Repository for Force Field

Parameters Used in Membrane Simulations. J. Membrane Biol., 2010, 236, 255–258.

[696] S. Izadi; B. Aguilar; A. V. Onufriev. Protein-ligand electrostatic binding free energies from explicit and

implicit solvation. J. Chem. Theory Comput., 2015, 11, 4450–4459.

[697] A. Metz. Goethe University (Frankfurt am Main), 2006.

[698] N. A. Baker; D. Sept; J. Simpson; M. J. Holst; M. J. A. Electrostatics of nanosystems: application to

microtubules and the ribosome. Proc. Natl. Acad. Sci. U. S. A., 2001, 98, 10037–10041.

[699] M. Holst; F. Saied. Multigrid solution of the Poisson-Boltzmann equation. J. Comput. Chem., 1993, 14,

105–113.

[700] M. Holst; F. Saied. Numerical solution of the nonlinear Poisson-Boltzmann equation: Developing more

robust and efﬁcient methods. J. Comput. Chem., 1995, 16, 337–364.

[701] M. Holst. Adaptive numerical treatment of elliptic systems on manifolds. Adv. Comput. Math., 2001, 15,

139–191.

[702] R. Bank; M. Holst. A New Paradigm for Parallel Adaptive Meshing Algorithms. SIAM Review, 2003, 45,

291–323.

891

BIBLIOGRAPHY

[703] K. M. Callenberg; O. P. Choudhary; G. L. de Forest; D. W. Gohara; N. A. Baker; M. Grabe. APBSmem: A

graphical interface for electrostatic calculations at the membrane. PLoS One, 2010, 5, e12722.

[704] M. Grabe; H. Lecar; Y. N. Jan; J. L. Y. A quantitative assessment of models for voltage-dependent gating

of ion channels. Proc. Natl. Acad. Sci. U. S. A., 2004, 101, 17640–17645.

[705] N. Homeyer; H. Gohlke. Extension of the free energy workﬂow FEW towards implicit solvent/implicit

membrane MM-PBSA calculations. BBA - Gen. Subjects, 2015, 1850, 972–982.

[706] H. Nymeyer; H. X. Zhou. A method to determine dielectric constants in nonhomogeneous systems: appli-

cation to biological membranes. Biophys. J., 2008, 94, 1185–1193.

[707] H. A. Stern; S. E. Feller. Calculation of the dielectric permittivity proﬁle for a nonuniform system: applica-

tion to a lipid bilayer simulation. J. Chem. Phys., 2003, 118, 3401–3412.

[708] L. Waeschenbach; C. G. W. Gertzen; V. Keitel; H. Gohlke. Dimerization energetics of the G-protein coupled

bile acid receptor TGR5 from all-atom simulations. J. Comput. Chem., 2019, 41.

[709] J. Åqvist; C. Medina; J. E. Samuelsson. A new method for predicting binding afﬁnity in computer-aided

drug design. Protein Eng., 1994, 7, 385–391.

[710] J. Åqvist; V. B. Luzhkov; B. O. Brandsdal. Ligand binding afﬁnities from MD simulations. Acc. Chem.

Res., 2002, 35, 358–365.

[711] M. M. van Lipzig; A. M. ter Laak; A. Jongejan; N. P. Vermeulen; M. Wamelink; D. Geerke; J. H. Meerman.
Prediction of ligand binding afﬁnity and orientation of xenoestrogens to the estrogen receptor by molecular
dynamics simulations and the linear interaction energy method. J. Med. Chem., 2004, 47, 1018–1030.

[712] H. G. Wallnoefer; K. R. Liedl; T. Fox. A challenging system: free energy prediction for factor Xa. J.

Comput. Chem., 2011, 32, 1743–1752.

[713] B. O. Brandsdal; F. Österberg; M. Almlöf; I. Feierberg; V. B. Luzhkov; Åqvist, J. Free energy calculations

and ligand binding. Adv. Protein Chem., 2003, 66, 123–158.

[714] W. Wang; J. Wang; P. A. Kollman. What determines the van der Waals coefﬁcient beta in the LIE (lin-
ear interaction energy) method to estimate binding free energies using molecular dynamics simulations?
Proteins: Struct., Funct., Genet., 1999, 34, 395–402.

[715] D. K. Jones-Hertzog; W. L. Jorgensen. Binding afﬁnities for sulfonamide inhibitors with human thrombin

using Monte Carlo simulations with a linear response method. J. Med. Chem., 1997, 40, 1539–1549.

[716] M. L. Lamb; J. Tirado-Rives; W. L. Jorgensen. Estimation of the binding afﬁnities of FKBP12 inhibitors

using a linear response method. Bioorg. Med. Chem., 1999, 7, 851–860.

[717] W. Yang; R. Bitetti-Putzer; K. M. Free energy simulations: Use of reverse cumulative averaging to determine

the equilibrated region and the time required for convergence. J. Chem. Phys., 2004, 120, 2618–2628.

[718] J. B. Kruskal. On the shortest spanning subtree of a graph and the traveling salesman problem. Proc. Amer.

Math. Soc., 1956, 7, 48–50.

[719] ROCS, OpenEye Scientiﬁc Software, Santa Fe, http://www.eyesopen.com.

[720] P. C. D. Hawkins; A. G. Skillman; A. Nicholls. Comparison of shape-matching and docking as virtual

screening tools. J. Med. Chem., 2007, 50, 74–82.

[721] S. Park; J. P. Bardhan; B. Roux; L. Makowski. Simulated X-ray scattering of protein solutions using

explicit-solvent models. J. Chem. Phys., 2009, 130, 134114.

[722] H. T. Nguyen; S. A. Pabit; S. P. Meisburger; L. Pollack; D. A. Case. Accurate small and wide angle X-ray

scattering proﬁles from atomic models of proteins and nucleic acids. J. Chem. Phys., 2014, 141, 22D508.

892

BIBLIOGRAPHY

[723] G. M. Giambasu; M. K. Gebala; M. T. Panteva; T. Luchko; D. A. Case; D. M. York. Competitive Interaction

of Monovalent Cations with DNA from 3D-RISM. Nucleic Acids Res., 2015, 43, 8405–8415.

[724] C. Brooks; A. Brünger; M. Karplus. Active site dynamics in protein molecules: A stochastic boundary

molecular-dynamics approach. Biopolymers, 1985, 24, 843–865.

[725] D. T. Nguyen; D. A. Case. On ﬁnding stationary states on large-molecule potential energy surfaces. J. Phys.

Chem., 1985, 89, 4020–4026.

[726] Z. J. Shi; J. Shen. New inexact line search method for unconstrained optimization. J. Optim. Theory Appl.,

2005, 127, 425–446.

[727] S. Izadi; R. Anandakrishnan; A. V. Onufriev. Implicit solvent model for Million-Atom atomistic simulations:

Insights into the organization of 30-nm chromatin ﬁber. J. Chem. Theory Comput., 2016, 12, 5946–5959.

[728] R. Anandakrishnan; A. V. Onufriev. An N log N approximation based on the natural organization of
biomolecules for speeding up the computation of long range interactions. J. Comput. Chem., 2010, 31,
691–706.

[729] R. Anandakrishnan; M. Daga; A. V. Onufriev. An n log n Generalized Born Approximation. J. Chem.

Theory Comput., 2011, 7, 544–559.

[730] J. I. Mendieta-Moreno; R. C. Walker; J. P. Lewis; P. Gómez-Puertas; J. Mendieta; J. Ortega. FIREBAL-
L/AMBER: An efﬁcient local-orbital DFT QM/MM method for biomolecular systems. J. Chem. Theory
Comput., 2014, 10, 2185–2193.

[731] B. E. Hingerty; S. Figueroa; T. L. Hayden; S. Broyde. Prediction of DNA Structure from Sequence: A

Build-up Technique. Biopolymers, 1989, 28, 1195–1222.

[732] D. A. Erie; K. J. Breslauer; W. K. Olson. A Monte Carlo Method for Generating Structures of Short Single-

Stranded DNA Sequences. Biopolymers, 1993, 33, 75–105.

[733] D. A. Pearlman; S.-H. Kim. Conformational Studies of Nucleic Acids I. A Rapid and Direct Method for

Generating Coordinates from the Pseudorotation Angle. J. Biomol. Struct. Dyn., 1985, 3, 85–98.

[734] D. A. Pearlman; S.-H. Kim. Conformational Studies of Nucleic Acids II. The Conformational Energetics of

Commonly Occurring Nucleosides. J. Biomol. Struct. Dyn., 1985, 3, 99–125.

[735] D. A. Pearlman; S.-H. Kim. Conformational Studies of Nucleic Acids: III. Empirical Multiple Correlation

Functions for Nucleic Acid Torsion Angles. J. Biomol. Struct. Dyn., 1986, 4, 49–67.

[736] D. A. Pearlman; S.-H. Kim. Conformational Studies of Nucleic Acids: IV. The Conformational Energetics

of Oligonucleotides: d(ApApApA) and ApApApA. J. Biomol. Struct. Dyn., 1986, 4, 69–98.

[737] D. A. Pearlman; S.-H. Kim. Conformational Studies of Nueleic Acids. V. Sequence Speciﬁcities of in the

Conformational Energetics of Oligonucleotides: The Homo-Tetramers. Biopolymers, 1988, 27, 59–77.

[738] T. Schlick. A Modular Strategy for Generating Starting Conformations and Data Structures of Polynu-

cleotide Helices for Potential Energy Calculations. J. Comput. Chem., 1988, 9, 861–889.

[739] J. Gabarro-Arpa; J. A. H. Cognet; M. Le Bret. Object Command Language: a formalism to build molecule
models and to analyze structural parameters in macromolecules, with applications to nucleic acids. J. Mol.
Graph., 1992, 10, 166–173.

[740] R. Lavery. in Unusual DNA Structures, R. D. Wells; S. C. Harvey, Eds. Springer-Verlag, New York, 1988.

[741] L. Shen; I. Tinoco. The Structure of an RNA Pseudoknot that Causes Efﬁcient Frameshift in Mouse Mam-

mary Tumor Virus. J. Mol. Biol., 1995, 247, 963–978.

893

BIBLIOGRAPHY

[742] J. M. Hubbard; J. E. Hearst. Predicting the Three-Dimensional Folding of Transfer RNA with a Computer

Modeling Protocol. Biochemsitry, 1991, 30, 5458–5465.

[743] S.-H. Chou; L. Zhu; B. R. Reid. The Unusual Structure of the Human Centromere (GGA)2 Motif. J. Mol.

Biol., 1994, 244, 259–268.

[744] M. Levitt. Detailed Molecular Model for Transfer Ribonucleic Acid. Nature, 1969, 224, 759–763.

[745] J. M. Hubbard; J. E. Hearst. Computer Modeling 16S Ribosomal RNA. J. Mol. Biol., 1991, 221, 889–907.

[746] F. Major; M. Turcotte; D. Gautheret; G. Lapalme; E. Fillon; R. Cedergren. The Combination of Symbolic

and Numerical Computation for Three-Dimensional Modeling of RNA. Science, 1991, 253, 1255–1260.

[747] T. Schlick; W. K. Olson. Supercoiled DNA Energetics and Dynamics by Computer Simulation. J. Mol.

Biol., 1992, 223, 1089–1119.

[748] R. E. Dickerson. Deﬁnitions and Nomenclature of Nucleic Acid Structure Parameters. J. Biomol. Struct.

Dyn., 1989, 6, 627–634.

[749] S. R. Holbrook; J. L. Sussman; R. W. Warrant; S.-H. Kim. Crystal Structure of Yeast Phenylalanine Transfer

RNA II. Structural Features and and Functional Implications. J. Mol. Biol., 1978, 123, 631–660.

[750] B. N. Conner; C. Yoon; J. Dickerson; R. E. Dickerson. Helix Geometry and Hydration in an A-DNA

Tetramer: C-C-G-G. J. Mol. Biol., 1984, 174, 663–695.

[751] M. Le Bret; J. Gabarro-Arpa; J. C. Gilbert; C. Lemarechal. MORCAD an object-oriented molecular mod-

eling package. J. Chim. Phys., 1991, 88, 2489–2496.

[752] V. B. Zhurkin; Y. P. Lysov; V. I. Ivanov. Different Families of Double Stranded Conformations of DNA as

Revealed by Computer Calculations. Biopolymers, 1978, 17, 277–312.

[753] A. T. Brünger. X-PLOR: A System for Cystallography and NMR, Version 3.1. Yale University, New Haven,

CT, 1992.

[754] J. R. Wyatt; J. D. Puglisi; I. Tinoco Jr. RNA Pseudoknots. Stability and Loop Size Requirements. J. Mol.

Biol., 1990, 214, 455–470.

[755] J. D. Puglisi; J. R. Wyatt; I. Tinoco Jr. Conformation of an RNA Pseudoknot. J. Mol. Biol., 1990, 214,

437–453.

[756] G. Kuila; J. A. Fee; J. R. Schoonover; W. H. Woodruff. Resonance Raman Spectra of the [2Fe-2S] Clusters
of the Rieske Protein from Thermus and Phthalate Dioxygenase from Pseudomonas. J. Am. Chem. Soc.,
1987, 109, 1559–1561.

[757] B. Lewin. in Genes IV, pp 409–425. Cell Press, Cambridge, Mass., 1990.

[758] W. H. Press; S. A. Teukolsky; W. T. Vettering; B. P. Flannery.

Cambridge, New York, 1992.

in Numerical Recipes in C, pp 113–117.

[759] V. B. Zhurkin; G. Raghunathan; N. B. Ulynaov; R. D. Camerini-Otero; R. L. Jernigan. A Parallel DNA
Triplex as a Model for the Intermediate in Homologous Recombination. J. Mol. Biol., 1994, 239, 181–200.

[760] W. Saenger. in Principles of Nucleic Acid Structure, p 120. Springer-Verlag, New York, 1984.

[761] M. Turcotte; G. Lapalme; F. Major. Exploring the conformations of nucleic acids. J. Funct. Program., 1995,

5, 443–460.

[762] C.-S. Tung; E. S. Carter, II. Nucleic acid modeling tool (NAMOT): an interactive graphic tool for modeling

nucleic acid structures. CABIOS, 1994, 10, 427–433.

894

BIBLIOGRAPHY

[763] E. S. Carter, II; C.-S. Tung. NAMOT2–a redesigned nucleic acid modeling tool: construction of non-

canonical DNA structures. CABIOS, 1996, 12, 25–30.

[764] R. Lavery; K. Zakrzewska; H. Skelnar. JUMNA (junction minimisation of nucleic acids). Comp. Phys.

Commun., 1995, 91, 135–158.

[765] G. M. Crippen; T. F. Havel. Distance Geometry and Molecular Conformation. Research Studies Press,

Taunton, England, 1988.

[766] D. C. Spellmeyer; A. K. Wong; M. J. Bower; J. M. Blaney. Conformational analysis using distance geometry

methods. J. Mol. Graph. Model., 1997, 15, 18–36.

[767] M. E. Hodsdon; J. W. Ponder; D. P. Cistola. The NMR solution structure of intestinal fatty acid-binding
protein complexed with palmitate: Application of a novel distance geometry algorithm. J. Mol. Biol., 1996,
264, 585–602.

[768] T. Macke; S.-M. Chen; W. J. Chazin.

in Structure and Function, Volume 1: Nucleic Acids, R. H. Sarma;

M. H. Sarma, Eds., pp 213–227. Adenine Press, Albany, 1992.

[769] B. C. M. Potts; J. Smith; M. Akke; T. J. Macke; K. Okazaki; H. Hidaka; D. A. Case; W. J. Chazin. The
structure of calcyclin reveals a novel homodimeric fold S100 Ca2+-binding proteins. Nature Struct. Biol.,
1995, 2, 790–796.

[770] J. J. Love; X. Li; D. A. Case; K. Giese; R. Grosschedl; P. E. Wright. DNA recognition and bending by the
architectural transcription factor LEF-1: NMR structure of the HMG domain complexed with DNA. Nature,
1995, 376, 791–795.

[771] R. J. Gurbiel; P. E. Doan; G. T. Gassner; T. J. Macke; D. A. Case; T. Ohnishi; J. A. Fee; D. P. Ballou; B. M.
Hoffman. Active site structure of Rieske-type proteins: Electron nuclear double resonance studies of iso-
topically labeled phthalate dioxygenase from Pseudomonas cepacia and Rieske protein from Rhodobacter
capsulatus and molecular modeling studies of a Rieske center. Biochemistry, 1996, 35, 7834–7845.

[772] T. J. Macke. NAB, a Language for Molecular Manipulation. Ph.D. thesis, The Scripps Research Institute,

1996.

[773] D. Gautheret; F. Major; R. Cedergren. Modeling the three-dimensional structure of RNA using discrete

nucleotide conformational sets. J. Mol. Biol., 1993, 229, 1049–1064.

[774] R. Tan; S. Harvey. Molecular Mechanics Model of Supercoiled DNA. J. Mol. Biol., 1989, 205, 573–591.

[775] T. F. Havel. An evaluation of computational strategies for use in the determination of protein structure from

distance constraints obtained by nuclear magnetic resonance. Prog. Biophys. Mol. Biol., 1991, 56, 43–78.

[776] J. Kuszewski; M. Nilges; A. T. Brünger. Sampling and efﬁciency of metric matrix distance geometry: A

novel partial metrization algorithm. J. Biomolec. NMR, 1992, 2, 33–56.

[777] B. L. deGroot; D. M. F. van Aalten; R. M. Scheek; A. Amadei; G. Vriend; H. J. C. Berendsen. Prediction

of protein conformational freedom from distance constraints. Proteins, 1997, 29, 240–251.

[778] T. F. Havel; I. D. Kuntz; G. M. Crippen. The theory and practice of distance geometry. Bull. Math. Biol.,

1983, 45, 665–720.

[779] D. K. Agraﬁotis. Stochastic Proximity Embedding. J. Comput. Chem., 2003, 24, 1215–1221.

[780] W. F. van Gunsteren; P. K. Weiner; A. J. Wilkinson, eds. Computer Simulations of Biomolecular Systems,

Vol. 2. ESCOM Science Publishers, Leiden, 1993.

[781] J. Åqvist; A. Warshel. Computer simulation of the initial proton-transfer step in human carbonic anhydrase-

I. J. Mol. Biol., 1992, 224, 7–14.

895

BIBLIOGRAPHY

[782] H. J. C. Berendsen; J. P. M. Postma; W. F. van Gunsteren; A. DiNola; J. R. Haak. Molecular dynamics with

coupling to an external bath. J. Chem. Phys., 1984, 81, 3684–3690.

[783] D. S. Wishart; D. A. Case. Use of chemical shifts in macromolecular structure determination. Meth.

Enzymol., 2001, 338, 3–34.

[784] L. T. Chong; Y. Duan; L. Wang; I. Massova; P. A. Kollman. Molecular dynamics and free-energy calcula-
tions applied to afﬁnity maturation in antibody 48G7. Proc. Natl. Acad. Sci. USA, 1999, 96, 14330–14335.

[785] R. Elber; M. Karplus. Enhanced sampling in molecular dynamics. Use of the time-dependent Hartree
approximation for a simulation of carbon monoxide diffusion through myoglobin. J. Am. Chem. Soc., 1990,
112, 9161–9175.

[786] C. Simmerling; M. R. Lee; A. R. Ortiz; A. Kolinski; J. Skolnick; P. A. Kollman. Combining MONSSTER
and LES/PME to Predict Protein Structure from Amino Acid Sequence: Application to the Small Protein
CMTI-1. J. Am. Chem. Soc., 2000, 122, 8392–8402.

[787] C. Simmerling; R. Elber. Hydrophobic "collapse" in a cyclic hexapeptide: Computer simulations of

CHDLFC and CAAAAC in water. J. Am. Chem. Soc., 1994, 116, 2534–2547.

[788] W. S. Ross; C. C. Hardin. Ion-induced stabilization of the G-DNA quadruplex: Free energy perturbation

studies. J. Am. Chem. Soc., 1994, 116, 6070–6080.

[789] A. Vedani; D. W. Huhta. A new force ﬁeld for modeling metalloproteins. J. Am. Chem. Soc., 1990, 112,

4759–4767.

[790] D. L. Veenstra; D. M. Ferguson; P. A. Kollman. How transferable are hydrogen parameters in molecular

mechanics calculations? J. Comput. Chem., 1992, 13, 971–978.

[791] F. H. Allen; O. Kennard; D. G. Watson; L. Brammer; A. G. Orpen; R. Taylor. J. Chem. Soc. Perkin Trans.

II, 1987, pp S1–S19.

[792] M. D. Harmony; R. W. Laurie; R. L. Kuczkowski; R. H. Schwendemann; D. A. Ramsay; F. J. Lovas; W. J.

Lafferty; A. G. Maki. J. Phys. Chem. Ref. Data, 1979, 8, 619.

[793] A. J. Hopﬁnger; R. A. Pearlstein. Molecular mechanics force-ﬁeld parameterization procedures. J. Comput.

Chem., 1985, 5, 486–499.

[794] J. F. Cannon. AMBER force-ﬁeld parameters for guanosine triphosphate and its imido and methylene

analogs. J. Comput. Chem., 1993, 14, 995–1005.

[795] W. D. Cornell; P. Cieplak; C. I. Bayly; P. A. Kollman. Application of RESP charges to calculate confor-
mational energies, hydrogen bond energies and free energies of solvation. J. Am. Chem. Soc., 1993, 115,
9620–9631.

[796] A. E. Howard; P. Cieplak; P. A. Kollman. A molecular mechanical model that reproduces the relative

energies for chair and twist-boat conformations of 1,3-dioxanes. J. Comp. Chem., 1995, 16, 243–261.

[797] A. St.-Amant; W. D. Cornell; P. A. Kollman; T. A. Halgren. Calculation of molecular geometries, rela-
tive conformational energies, dipole moments, and molecular electrostatic potential ﬁtted charges of small
organic molecules of biochemical interest by density functional theory. J. Comput. Chem., 1995, 16, 1483–
1506.

[798] T. A. Halgren. Merck Molecular Force Field (MMFF94). Part I-V. J. Comput. Chem., 1996, 17, 490–641.

[799] D. L. Beveridge; F. M. DiCapua. Free energy simulation via molecular simulations: Applications to chemi-

cal and biomolecular systems. Annu. Rev. Biophys. Biophys. Chem., 1989, 18, 431–492.

896

BIBLIOGRAPHY

[800] C. Chipot; P. A. Kollman; D. A. Pearlman. Alternative approaches to potential of mean force calculations:
free energy perturbation versus thermodynamics integration. Case study of some representative nonpolar
interactions. J. Comput. Chem, 1996, 17, 1112–1131.

[801] D. A. Pearlman; P. A. Kollman. The overlooked bond-stretching contribution in free energy perturbation

calculations. J. Chem. Phys., 1991, 94, 4532–4545.

[802] D. A. Pearlman. Determining the contributions of constraints in free energy calculations: Development,

characterization, and recommendations. J. Chem. Phys., 1993, 98, 8946–8957.

[803] D. A. Pearlman. Free energy derivatives: A new method for probing the convergence problem in free energy

calculations. J. Comput. Chem., 1994, 15, 105–123.

[804] D. A. Pearlman. A comparison of alternative approaches to free energy calculations. J. Phys. Chem., 1994,

98, 1487–1493.

[805] D. A. Pearlman; B. G. Rao. in Encyclopedia of Computational Chemistry, P. von R. Schleyer; N. L. Allinger;
T. Clark; J. Gasteiger; P. A. Kollman; I. H. F. Schaefer, Eds., pp 1036–1061. John Wiley, Chichester, 1998.

[806] R. J. Radmer; P. A. Kollman. Free energy calculation methods: A theoretical and empirical comparison
of numerical errors and a new method for qualitative estimates of free energy changes. J. Comput. Chem.,
1997, 18, 902–919.

[807] D. A. Pearlman; P. A. Kollman. A new method for carrying out free energy perturbation calculations:

dynamically modiﬁed windows. J. Chem. PHys., 1989, 90, 2460–2470.

[808] H.-A. Yu; M. Karplus. A thermodynamic analysis of solvation. J. Chem. Phys., 1988, 89, 2366–2379.

[809] G. Hummer. Fast-growth thermodynamic integration: Error and efﬁciency analysis. J. Chem. Phys., 2001,

114, 7330–7337.

[810] S. H. Fleischman; C. L. Brooks, III. Thermodynamic calculations on biological systems: Solution properties

of alcohols and alkanes. J. Chem. Phys., 1988, 87, 221–234.

[811] J. J. Vincent; K. M. Merz, Jr. A highly portable parallel implementation of AMBER4 using the message

passing interface standard. J. Comput. Chem., 1995, 16, 1420–1427.

[812] R. Radmer; P. Kollman. The application of three approximate free energy calculations methods to structure
based ligand design: Trypsin and its complex with inhibitors. J. Comput.-Aided Mol. Design, 1998, 12,
215–228.

[813] S. R. Niketic; K. Rasmussen. The Consistent Force Field: A Documentation. Springer-Verlag, New York,

1977.

[814] C. Cerjan; W. H. Miller. On ﬁnding transition states. J. Chem. Phys., 1981, 75, 2800.

[815] D. T. Nguyen; D. A. Case. On ﬁnding stationary states on large-molecule potential energy surfaces. J. Phys.

Chem., 1985, 89, 4020–4026.

[816] G. Lamm; A. Szabo. Langevin modes of macromolecules. J. Chem. Phys., 1986, 85, 7334–7348.

[817] J. Kottalam; D. A. Case. Langevin modes of macromolecules: application to crambin and DNA hexamers.

Biopolymers, 1990, 29, 1409–1421.

[818] S. Huo; I. Massova; P. A. Kollman. Computational Alanine Scanning of the 1:1 Human Growth Hormone-

Receptor Complex. J. Comput. Chem., 2002, 23, 15–27.

[819] T. Darden; D. Pearlman; L. G. Pedersen. Ionic charging free energies: Spherical versus periodic boundary

conditions. J. Chem. Phys., 1998, 109, 10921–10935.

897

BIBLIOGRAPHY

[820] R. M. Levy; M. Karplus; J. Kushick; D. Perahia. Evaluation of the conﬁgurational entropy for proteins:

Application to molecular dynamics simulations of an α-helix. Macromolecules, 1984, 17, 1370–1374.

[821] S. Arnott; P. J. Campbell-Smith; R. Chandrasekaran. in Handbook of Biochemistry and Molecular Biology,

3rd ed. Nucleic, G. P. Fasman, Ed., pp 411–422. CRC Press, Cleveland, 1976.

[822] T. E. Cheatham, III; B. R. Brooks; P. A. Kollman.
Sections 7.5, 7.8, 7.9, 7.10. Wiley, New York, 1999.

in Current Protocols in Nucleic Acid Chemistry, pp

[823] J. P. Valleau; G. M. Torrie. in Modern Theoretical Chemistry, Vol. 5: Statistical Mechanics, Part A,, B. J.

Berne, Ed. Plenum Press, New York, 1977.

[824] J. Kottalam; D. A. Case. Dynamics of ligand escape from the heme pocket of myoglobin. J. Am. Chem.

Soc., 1988, 110, 7690–7697.

[825] W. H. Press; B. P. Flannery; S. A. Teukolsky; W. T. Vetterling. in Numerical Recipes: The Art of Scientiﬁc

Computing. Cambridge University Press, New York, 1989.

[826] P. Beroza; D. A. Case. Calculations of proton-binding thermodynamics in proteins. Meth. Enzymol., 1998,

295, 170–189.

[827] J. D. Madura; M. E. Davis; M. K. Gilson; R. C. Wade; B. A. Luty; J. A. McCammon. Biological applications
of electrostatic calculations and brownian dynamics simulations. Rev. Computat. Chem., 1994, 5, 229–267.

[828] M. K. Gilson. Theory of electrostatic interactions in macromolecules. Curr. Opin. Struct. Biol., 1995, 5,

216–23.

[829] M. Scarsi; J. Apostolakis; A. Caﬂisch. Continuum electrostatic energies of macromolecules in aqueous

solutions. J. Phys. Chem. A, 1997, 101, 8098–8106.

[830] T. Simonson. Electrostatics and dynamics of proteins. Rep. Prog. Phys., 2003, 66, 737–787.

[831] D. Bashford; M. Karplus. p‘K sub a‘’s of ionizable groups in proteins: Atomic detail from a continuum

electrostatic model. Biochemistry, 1990, 29, 10219–10225.

[832] A. Ghosh; C. S. Rapp; R. A. Friesner. Generalized Born model based on a surface integral formulation. J.

Phys. Chem. B, 1998, 102, 10983–10990.

[833] J. D. Jackson. Classical Electrodynamics. Wiley and Sons, New York, 1975.

[834] M. Feig; J. Karanicolas; C. L. Brooks, III. MMTSB Tool Set: Enhanced sampling and multiscale modeling

methods for application in structural biology. J. Mol. Graphics Mod., 2004, 22, 377–395.

[835] C. Simmerling; B. Strockbine; A. E. Roitberg. All-atom structure prediction and folding simulations of a

stable protein. J. Am. Chem. Soc., 2002, 124, 11258–11259.

[836] A. E. García; K. Y. Sanbonmatsu. α-helical stabilization by side chain shielding of backbone hydrogen

bonds. Proc. Natl. Acad. Sci. USA, 2002, 99, 2782–2787.

[837] K. N. Kirschner; R. J. Woods. Solvent interactions determine carbohydrate conformation. Proc. Natl. Acad.

Sci. USA, 2001, 98, 10541–10545.

[838] K. N. Kirschner; R. J. Woods. Quantum mechanical study of the nonbonded forces in water-methanol

complexes. J. Phys. Chem. A, 2001, 105, 4150–4155.

[839] K. A. Sharp; B. Honig. Electrostatic interactions in macromolecules: Theory and experiment. Annu. Rev.

Biophys. Biophys. Chem., 1990, 19, 301–332.

[840] J. Gao. Absolute free energy of solvation from Monte Carlo simulations using combined quantum and

molecular mechanical potentials. J. Phys. Chem., 1992, 96, 537–540.

898

BIBLIOGRAPHY

[841] A. Warshel; M. Levitt. Theoretical studies of enzymic reactions: Dielectric, electrostatic and steric stabi-

lization of the carbonium ion in the reaction of lysozyme. J. Mol. Biol., 1976, 103, 227–249.

[842] M. J. Field; P. A. Bash; M. Karplus. A combined quantum mechanical and molecular mechanical potential

for molecular dynamics simulations. J. Comput. Chem., 1990, 11, 700–733.

[843] R. V. Stanton; D. S. Hartsough; K. M. Merz, Jr. An examination of a density functional/molecular mechan-

ical coupled potential. J. Comput. Chem., 1994, 16, 113–128.

[844] R. V. Stanton; L. R. Little; K. M. Merz, Jr. An examination of a Hartree-Fock/molecular mechanical coupled

potential. J. Phys. Chem., 1995, 99, 17344–17348.

[845] R. V. Stanton; D. S. Hartsough; K. M. Merz, Jr. Calculations of solvation free energies using a density

functional/molecular dynamics coupled potential. J. Phys. Chem., 1993, 97, 11868–11870.

[846] W. Yang; T.-S. Lee. A density-matrix divide-and-conquer approach for electronic structure calculations of

large molecules. J. Chem. Phys., 1995, 103, 5674–5678.

[847] J. Nocedal; S. J. Wright. Numerical Optimization. Springer-Verlag, New York, 1999.

[848] S. G. Nash. A survey of truncated-Newton methods. J. of Computational and Applied Mathematics, 2000,

124, 45–59.

[849] E. J. Sorin; V. S. Pande. Exploring the helix-coil transition via all-atom equilibrium ensemble simulations.

Biophys. J., 2005, 88, 2472–2493.

[850] R. C. Rizzo; T. Aynechi; D. A. Case; I. D. Kuntz. Estimation of absolute free energies of hydration using
continuum methods: Accuracy of partial charge models and optimization of nonpolar contributions. J.
Chem. Theory Comput., 2006, 2, 128–139.

[851] L. S. Schulman. Techniques and Applications of Path Integration. Wiley & Sons, New York, 1996.

[852] A. Messiah. Quantum Mechanics. Wiley & Sons, New York, 1958.

[853] D. Chandler; P. G. Wolynes. Exploiting the isomorphism between quantum theory and classical statistical

mechanics of polyatomic ﬂuids. J. Chem. Phys., 1981, 74, 4078–4095.

[854] D. M. Ceperley. Path integrals in the theory of condensed helium. Rev. Mod. Phys., 1995, 67, 279–355.

[855] J. Cao; B. J. Berne. On energy estimators in path integral Monte Carlo simulations: Dependence of accuracy

on algorithm. J. Chem. Phys., 1989, 91, 6359–6366.

[856] J. W. Storer; D. J. Giesen; C. J. Cramer; D. G. Truhlar. Class IV charge models: A new semiempirical

approach in quantum chemistry. J. Comput.-Aided Mol. Design, 1995, 9, 87–110.

[857] J. Li; C. J. Cramer; D. G. Truhlar. New class IV charge model for extracting accurate partial charges from

Wave Functions. J. Phys. Chem. A., 1998, 102, 1820–1831.

[858] A. van der Vaart; K. M. Merz, Jr. Divide and conquer interaction energy decomposition. J. Phys. Chem. A,

1999, 103, 3321–3329.

[859] A. V. Mitin. The dynamic level shift method for improving the convergence of the SCF procedure. J.

Comput. Chem., 1988, 9, 107–110.

[860] M. D. Ermolaeva; A. van der Vaart; K. M. Merz, Jr. Implementation and testing of a frozen density matrix

- divide and conquer algorithm. J. Phys. Chem., 1999, 103, 1868–1875.

[861] B. Wang; E. N. Brothers; A. van der Vaart; K. M. Merz Jr. Fast semiempirical calculations for nuclear
magnetic resonance chemical shifts: A divide-and-conquer approach. J. Chem. Phys., 2004, 120, 11392–
11400.

899

BIBLIOGRAPHY

[862] B. Wang; K. Raha; K. M. Merz Jr. Pose scoring by NMR. J. Am. Chem. Soc., 2004, 126, 11430–11431.

[863] K. Raha; A. van der Vaart; K. E. Riley; M. B. Peters; L. M. Westerhoff; H. Kim; K. M. Merz Jr. Pairwise
decomposition of residue interaction energies using semiempirical quantum mechanical methods in studies
of protein-ligand interaction. J. Am. Chem. Soc., 2005, 127, 6583–6594.

[864] A. Luzhkov; A. Warshel. Microscopic models for quantum-mechanical calculations of chemical processes
in solutions - Ld/Ampac and Scaas/Ampac calculations of solvation energies. J. Comp. Chem., 1992, 13,
199–213.

[865] U. C. Singh; P. A. Kollman. A combined Ab initio quantum-mechanical and molecular mechanical method
for carrying out simulations on complex molecular systems - Applications to the Ch3Cl + Cl- exchange-
reaction and gas-phase protonation of polyethers. J. Comp. Chem., 1986, 7, 718–730.

[866] I. B. Bersuker; M. K. Leong; J. E. Boggs; R. S. Pearlman. A method of combined quantum mechanical
(QM) molecular mechanics (MM) treatment of large polyatomic systems with charge transfer between the
QM and MM fragments. Int. J. Quant. Chem., 1997, 63, 1051–1063.

[867] F. Maseras; K. Morokuma.

Imomm - a new integrated ab-initio plus molecular geometry optimization

scheme of equilibrium structures and transition-states. J. Comp. Chem., 1995, 16, 1170–1179.

[868] Y. K. Zhang; T. S. Lee; W. T. Yang. A pseudobond approach to combining quantum mechanical and

molecular mechanical methods. J. Chem. Phys., 1999, 110, 46–54.

[869] J. L. Gao; P. Amara; C. Alhambra; M. J. Field. A generalized hybrid orbital (GHO) method for the treatment

of boundary atoms in combined QM/MM calculations. J Phys Chem A, 1998, 102, 4714–4721.

[870] D. M. Philipp; R. A. Friesner. Mixed ab initio QM/MM modeling using frozen orbitals and tests with alanine

dipeptide and tetrapeptide. J. Comp. Chem., 1999, 20, 1468–1494.

[871] M. J. Field; M. Albe; C. Bret; F. Proust-De Martin; A. Thomas. The Dynamo library for molecular simu-
lations using hybrid quantum mechanical and molecular mechanical potentials. J. Comp. Chem., 2000, 21,
1088–1100.

[872] R. M. Levy; E. Gallicchio. Computer simulations with explicit solvent: recent progress in the thermody-
namic decomposition of free energies and in modeling electrostatic effects. Annu. Rev. Phys. Chem., 1999,
49, 531–567.

[873] J. Wang; W. Wang; P. A. Kollman; D. A. Case. Automatic atom type and bond type perception in molecular

mechanical. J. Mol. Graphics Model., 2006, 25, 247–260.

[874] V. Hornak; A. Okur; R. Rizzo; C. Simmerling. HIV-1 protease ﬂaps spontaneously open and reclose in

molecular dynamics simulations. Proc. Nat. Acad. Sci. USA, 2006, 103, 915–920.

[875] V. Hornak; A. Okur; R. Rizzo; C. Simmerling. HIV-1 protease ﬂaps spontaneously close when an inhibitor

binds to the open state. J. Am. Chem. Soc., 2006, 128, 2812–2813.

[876] J. Kästner; W. Thiel. Bridiging the gap between thermodynamic integration and umbrella sampling provides

a novel analysis method: "Umbrella integration". J. Chem. Phys., 2005, 123, 144104.

[877] C. Simmerling; R. Elber. Hydrophobic "collapse" in a cyclic hexapeptide: Computer simulations of

CHDLFC and CAAAAC in water. J. Am. Chem. Soc., 1994, 116, 2534–2547.

[878] Y. Deng; B. Roux. Calculation of standard binding free energies: Aromatic molecules in the T4 lysozyme

L99A mutant. J. Chem. Theor. Comput., 2006, 2, 1255–1273.

[879] A. K. Rappe; C. J. Casewit; K. S. Colwell; W. A. Goddard III; W. M. Skiff. UFF, a Full Periodic Table
Force Field for Molecular Mechanics and Molecular Dynamics Simulations. J. Am. Chem. Soc., 1992, 114,
10024–10035.

900

BIBLIOGRAPHY

[880] G. A. Voth; D. Chandler; W. H. Miller. Rigorous Formulation of Quantum Transition State Theory and Its

Dynamical Corrections. J. Chem. Phys., 1989, 91, 7749–7760.

[881] G. J. Martyna; M. L. Klein; M. Tuckerman. Nosé-Hoover chains: The canonical ensemble via continuous

dynamics. J. Chem. Phys., 1992, 97, 2635.

[882] G. J. Martyna; A. Hughes; M. E. Tuckerman. Molecular dynamics algorithms for path integrals at constant

pressure. J. Chem. Phys., 1999, 110, 3275.

[883] B. J. Berne; D. Thirumalai. On the simulation of quantum systems: path integral methods. Annu. Rev. Phys.

Chem., 1986, 37, 401.

[884] G. A. Voth. Path-integral centroid methods in quantum statistcal mechanics and dynamics. Adv. Chem.

Phys., 1996, 93, 135.

[885] I. R. Craig; D. E. Manolopoulos. Quantum statistics and classical mechnanics: Real time correlation func-

tions from ring polymer molecular dynamics. J. Chem. Phys., 2004, 121, 3368.

[886] T. F. Miller; D. E. Manolopoulos. Quantum diffusion in liquid water from ring polymer molecular dynamics.

J. Chem. Phys., 2005, 123, 154504.

[887] J. Cao; G. A. Voth. The formulation of quantum statistical mechanics based on the Feynman path centroid

density. IV. Algorithms for centroid molecular dynamics. J. Chem. Phys., 1994, 101, 6168.

[888] J. Vaníˇcek; W. H. Miller; J. F. Castillo; F. J. Aoiz. Quantum-instanton evalution of the kinetic isotope effects.

J. Chem. Phys., 2005, 123, 054108.

[889] J. Vaníˇcek; W. H. Miller. Efﬁcient estimators for quantum instanton evaluation of the kinetic isotope effects:

application to the intramolecular hydrogen transfer in pentadiene. J. Chem. Phys., 2007, 127, 114309.

[890] W. H. Miller; Y. Zhao; M. Ceotto; S. Yang. Quantum instanton approximation for thermal rate constants of

chemical. J. Chem. Phys., 2003, 119, 1329–1342.

[891] W. H. Miller. Semiclassical limit of quantum mechanical transition state theory for nonseparable systems.

J. Chem. Phys., 1975, 62, 1899.

[892] T. Yamamoto; W. H. Miller. On the efﬁcient path integral evaluation of thermal rate constants with the

quantum instanton approximation. J. Chem. Phys., 2004, 120, 3086–3099.

[893] T. Yamamoto; W. H. Miller. Path integral evaluation of the quantum instanton rate constant for proton

transfer in a polar solvent. J. Chem. Phys., 2005, 122, 044106.

[894] W. H. Miller; S. D. Schwartz; J. W. Tromp. Quantum mechanical rate constants for bimolecular reactions.

J. Chem. Phys., 1983, 79, 4889–4898.

[895] A. T. Brünger; P. D. Adams; G. M. Clore; W. L. Delano; P. Gros; R. W. Grosse-Kunstleve; J.-S. Jiang;
J. Kuszewski; M. Nilges; N. S. Pannu; R. J. Read; L. M. Rice; T. Simonson; G. L. Warren. Crystallography
and NMR system (CNS): A new software system for macromolecular structure determination. Acta Cryst.
D, 1998, 54, 905–921.

[896] N. Yu; H. P. Yennawar; K. M. Merz, Jr. Reﬁnement of protein crystal structures using energy restraints

derived from linear-scaling quantum mechanics . Acta Cryst. D, 2005, 61, 322–332.

[897] N. Yu; X. Li; G. Cui; S. Hayik; K. M. Merz, Jr. Critical assessment of quantum mechanics based energy

restraints in protein crystal structure reﬁnement. Prot. Sci., 2006, 15, 2773–2784.

[898] S. Fulle; H. Gohlke. Analyzing the ﬂexibility of RNA structures by constraint counting. Biophys. J., 2008,

DOI:10.1529/biophysj.107.113415.

901

BIBLIOGRAPHY

[899] H. Gohlke; L. A. Kuhn; D. A. Case. Change in protein ﬂexibility upon complex formation: Analysis of

Ras-Raf using molecular dynamics and a molecular framework approach. Proteins, 2004, 56, 322–327.

[900] A. Ahmed; H. Gohlke. Multiscale modeling of macromolecular conformational changes combining con-

cepts from rigidity and elastic network theory. Proteins, 2006, 63, 1038–1051.

[901] E. F. Pettersen; T. D. Goddard; C. C. Huang; G. S. Couch; D. M. Greenblatt; E. C. Meng; T. E. Ferrin.
UCSF Chimera - A visualization system for exploratory research and analysis. J. Comput. Chem., 2004, 25,
1605–1612.

[902] H. Sasaki; N. Ochi; A. Del; M. Fukuda. Site-speciﬁc glycosylation of human recombinant erythropoietin:
Analysis of glycopeptides or peptides at each glycosylation site by fast atom bombardment mass spectrom-
etry. Biochemistry, 1988, 27, 8618–8626.

[903] S. Dube; J. W. Fisher; J. S. Powell. Glycosylation at speciﬁc sites of erythropoietin is essential for biosyn-

thesis, secretion, and biological function. J. Biol. Chem., 1988, 263, 17516–17521.

[904] R. J. Darling; U. Kuchibhotla; W. Glaesner; R. Micanovic; D. R. Witcher; J. M. Beals. Glycosylation of
erythropoietin effects receptor binding kinetics: Role of electrostatic interactions. Biochemistry, 2002, 41,
14524–14531.

[905] J. C. Cheetham; D. M. Smith; K. H. Aoki; J. L. Stevenson; T. J. Hoeffel; R. S. Syed; J. Egrie; T. S. Harvey.
NMR structure of human erythropoietin and a comparison with its receptor bound conformation. Nat. Struct.
Biol., 1998, 5, 861–866.

[906] K. L. Dormann; R. Brueckner. Variable Synthesis of the Optically Active Thiotetronic Acid Antibiotics

Thiolactomycin, Thiotetromycin, and 834-B1. Angew. Chem. Int. Ed., 2007, 46, 1160–1163.

[907] E. Darve; A. Pohorille. Calculating free energies using average force. J. Chem. Phys., 2001, 115, 9169–

9183.

[908] J. Shao; S. W. Tanner; N. Thompson; T. E. Cheatham, III. Clustering molecular dynamics trajectories:
1. Characterizing the performance of different clustering algorithms. J. Chem. Theory Comput., 2007, 3,
2312–2334.

[909] B. R. Brooks; R. E. Bruccoleri; D. J. Olafson; D. J. States; S. Swaminathan; M. Karplus. CHARMM:
A Program for Macromolecular Energy, Minimization, and Dynamics Calculations. J. Computat. Chem.,
1983, 4, 187–217.

[910] B. R. Brooks; C. L. Brooks; A. D. Mackerell; L. Nilsson; R. J. Petrella; B. Roux; Y. Won; G. Archontis;
C. Bartels; S. Boresch; A. Caﬂisch; L. Caves; Q. Cui; A. R. Dinner; M. Feig; S. Fischer; J. Gao; M. Ho-
doscek; W. Im; K. Kuczera; T. Lazaridis; J. Ma; V. Ovchinnikov; E. Paci; R. W. Pastor; C. B. Post; J. Z.
Pu; M. Schaefer; B. Tidor; R. M. Venable; H. L. Woodcock; X. Wu; W. Yang; D. M. York; M. Karplus.
CHARMM: the biomolecular simulation program. J. Comput. Chem., 2009, 30, 1545–1614.

[911] B. J. Berne; G. D. Harp. Adv. Chem. Phys., 1970, 17, 63.

[912] R. Kubo; M. Toda; N. Hashitsume. Statistical Physics II: Nonequilibrium Statistical Mechanics, 2nd ed.

Springer-Verlag, Heidelberg, 1991.

[913] W. H. Miller. Adv. Chem. Phys., 1974, 25, 69.

[914] W. H. Miller. Including quantum effects in the dynamics of complex (i.e., large) molecular systems. J.

Chem. Phys., 2006, 125, 132305.

[915] H. Wang; X. Sun; W. H. Miller. Semiclassical approximations for the calculation of thermal rate constants

for chemical reactions in complex molecular systems. J. Chem. Phys., 1998, 108, 9726.

902

BIBLIOGRAPHY

[916] X. Sun; H. Wang; W. H. Miller. Semiclassical theory of electronically nonadiabatic dynamics: Results of a

linearized approximation to the initial value representation. J. Chem. Phys., 1998, 109, 7064.

[917] J. Liu; W. H. Miller. A simple model for the treatment of imaginary frequencies in chemical reaction rates

and molecular liquids. J. Chem. Phys., 2009, 131, 074113.

[918] J. Liu; W. H. Miller; F. Paesani; W. Zhang; D. A. Case. Quantum dynamical effects in liquid water: A
semiclassical study on the diffusion and the infrared absorption spectrum. J. Chem. Phys., 2009, 131,
164509.

[919] J. Liu. Recent advances in the linearized semiclassical initial value representation/classical wigner model

for the thermal correlation function. International Journal of Quantum Chemistry, 2015, 115, 657–670.

[920] J. Liu; W. H. Miller. Real time correlation function in a single phase space integral beyond the linearized

semiclassical initial value representation. J. Chem. Phys., 2007, 126, 234110.

[921] J. Liu; W. H. Miller. Test of the consistency of various linearized semiclassical initial value time correlation
functions in application to inelastic neutron scattering from liquid para-hydrogen. J. Chem. Phys., 2008,
128, 144511.

[922] Q. Shi; E. Giva. J. Chem. Phys. A, 2003, 107, 9059.

[923] M.-J. Hsieh; R. Luo. Balancing simulation accuracy and efﬁciency with the Amber united atom force ﬁeld.

J. Phys. Chem. B, 2010, 114, 2886–2893.

[924] F. Hirata, Ed. Molecular Theory of Solvation. Kluwer Academic Publishers, 2003.

[925] D. W. Li; R. Brüschweiler. NMR-based protein potentials. Angew. Chem. Int. Ed., 2010, 49, 6778–6780.

[926] K. Lindorff-Larsen; S. Piana; K. Palmo; P. Maragakis; J. Klepeis; R. O. Dror; D. E. Shaw.

Improved

side-chain torsion potentials for the Amber ff99SB protein force ﬁeld. Proteins, 2010, 78, 1950–1958.

[927] D. S. Cerutti; R. E. Duke; T. A. Darden; T. P. Lybrand. Staggered Mesh Ewald: An Extension of the Smooth
Particle-Mesh Ewald Method Adding Great Versatility. J. Chem. Theory Computat., 2009, 5, 2322–2338.

[928] D. S. Cerutti; D. A. Case. Multi-Level Ewald: A Hybrid Multigrid/Fast Fourier Transform Approach to the

Electrostatic Particle-Mesh Problem. J. Chem. Theory Comput., 2010, 6, 443–458.

[929] D. S. Cerutti; P. L. Freddolino; R. E. Duke, Jr.; D. A. Case. Simulations of a Protein Crystal with a High
Resolution X-ray Structure: Evaluation of Force Fields and Water Models . J. Phys. Chem. B, 2010, pp
12811–12824.

[930] M.-J. Hsieh; R. Luo. Exploring a coarse-grained distributive strategy for ﬁnite-difference poisson-boltzmann

calculations. J. Molec. Model., 2011.

[931] T. Gaillard; D. A. Case. Evaluation of DNA Force Fields in Implicit Solvation. J. Chem. Theory Comput.,

2011, 7, 3181–3198.

[932] Y. Meng; A. E. Roitberg. Constant pH replica exchange molecular dynamics in biomolecules using a

discrete protonation model. J. Chem. Theory Comput., 2010, 6, 1401–1412.

[933] D. Sabri Dashti; Y. Meng; A. E. Roitberg. pH-Replica Exchange Molecular Dynamics in Proteins Using a

Discrete Protonation Method. J. Phys. Chem. B, 2012, 116, 8805–8811.

[934] D. L. Mobley; C. I. Bayly; M. D. Cooper; M. R. Shirts; K. A. Dill. Small Molecule Hydration Free Energies
in Explicit Solvent: An Extensive Test of Fixed-Charge Atomistic Simulations. J. Chem. Theory Comput.,
2009, 5, 350–358.

[935] X. Wu; B. R. Brooks. A virtual mixture approach to the study of multistate equilibrium: application to

constant ph simulation in explicit water. PLOS Computational Biology, 2015, 11, e1004480.

903

BIBLIOGRAPHY

[936] P. G. Karamertzanis; P. Raiteri; A. Galindo. The use of anisotropic potentials in modeling water and free

energies of hydration. J. Chem. Theory Comput., 2010, 6, 3153–3161.

[937] J. Wang; P. Cieplak; J. Li; T. Hou; R. Luo; Y. Duan. Development of Polarizable Models for Molecular
Mechanical Calculations I: Parameterization of Atomic Polarizability. J. Phys. Chem. B, 2011, 115, 3091–
3099.

[938] J. Wang; P. Cieplak; J. Li; J. Wang; Q. Cai; M. Hsieh; H. Lei; R. Luo; Y. Duan. Development of Polarizable
Models for Molecular Mechanical Calculations II: Induced Dipole Models Signiﬁcantly Improve Accuracy
of Intermolecular Interaction Energies. J. Phys. Chem. B, 2011, 115, 3100–3111.

[939] J. Wang; P. Cieplak; J. Li; Q. Cai; M. Hsieh; R. Luo; Y. Duan. Development of Polarizable Models for
Molecular Mechanical Calculations. 4. van der Waals Parametrization. J. Phys. Chem. B, 2012, 116, 7088–
7101.

[940] J. Wang; P. Cieplak; Q. Cai; M. Hsieh; J. Wang; Y. Duan; R. Luo. Development of Polarizable Models
for Molecular Mechanical Calculations. 3. Polarizable Water Models Conforming to Thole Polarization
Screening Schemes. J. Phys. Chem. B, 2012, 116, 7999–8008.

[941] B. T. Thole. Molecular polarizabilities calculated with a modiﬁed dipole interaction. Chem. Phys., 1981,

59, 341–350.

[942] R. Bosque; J. Sales. Polarizabilities of solvents from the chemical composition. J. Chem. Inf. Comput. Sci.,

2002, 42, 1154–1163.

[943] Z. X. Wang; C. Wu; H. X. Lei; Y. Duan. Accurate ab initio study on the hydrogen-bond pairs in protein

secondary structures. J. Chem. Theory Comput., 2007, 3, 1527–1537.

[944] J. Wang; T. Hou. Application of Molecular Dynamics Simulations in Molecular Property Prediction. II.

Diffusion coefﬁcient. J. Comput. Chem., 2011, 32, 3509–3519.

[945] C. F. Fu; S. X. Tian. A Comparative Study for Molecular Dynamics Simulations of Liquid Benzene. J.

Chem. Theory Comput., 2011, 7, 2240–2252.

[946] S. Tsuzuki; T. Uchimaru; K. Tanabe; S. Kuwajima. Reﬁnement of Nonbonding Interaction Potential Pa-
rameters for Methane on the Basis of the Pair Potential Obtained by Mp3/6-311g(3d,3p)-Level Ab-Initio
Molecular-Orbital Calculations - the Anisotropy of H/H Interaction. J. Phys. Chem., 1994, 98, 1830–1833.

[947] G. A. Kaminski; R. A. Friesner; J. Tirado-Rives; W. L. Jorgensen. Evaluation and Reparametrization of
the OPLS-AA Force Field for Proteins via Comparison with Accurate Quantum Chemical Calculations on
Peptides. J. Phys. Chem. B, 2001, 105, 6474–6487.

[948] I. J. Chen; D. Yin; A. D. MacKerell. Combined Ab initio/Empirical Approach for Optimization of Lennard-

Jones Parameters for Polar-Neutral Compounds. J. Comput. Chem., 2002, 23, 199–213.

[949] F.-Y. Dupradeau; A. Pigache; T. Zaffran; C. Savineau; R. Lelong; N. Grivel; D. Lelong; W. Rosanskia;
P. Cieplak. The R. E. D. tools: advances in RESP and ESP charge derivation and force ﬁeld library building.
PhysChemChemPhys, 2010, 12, 7821–7839.

[950] D. E. Warschawski; P. F. Devaux. Order parameters of unsaturated phospholipids in membranes and the
effect of cholesterol: a 1H-13C solid-state NMR study at natural abundance. Eur. Biophys. J., 2005, 34,
987–996.

[951] S. A. Showalter; R. Brüschweiler. Validation of molecular dynamics simulations of biomolecules using
NMR spin relaxation as benchmarks: Application to the Amber99SB force ﬁeld. J. Chem. Theory Comput.,
2007, 3, 961–975.

[952] R. B. Best; N.-V. Buchete; G. Hummer. Are Current Molecular Dynamics Force Fields too Helical? Bio-

phys. J., 2008, 95, L07–L09; 4494.

904

BIBLIOGRAPHY

[953] R. B. Best; G. Hummer. Optimized Molecular Dynamics Force Fields Applied to the Helix-Coil Transition

of Polypeptides. J. Phys. Chem. B, 2009, 113, 9904–9015.

[954] R. B. Best; J. Mittal. Free-energy landscape of the GB1 hairpin in all-atom explicit solvent simulations with

different force ﬁelds: Similarities and differences. Proteins, 2011, 79, 1318–1328.

[955] K. K. Patapati; N. M. Glykos. Three force ﬁelds views of the 3-10 helix. Biophys. J., 2011, 101, 1766–1771.

[956] R. Salomon-Ferrer; D. A. Case; R. C. Walker. An overview of the Amber biomolecular simulation package.

WIREs Comput. Mol. Sci., 2013, 3, 198–210.

[957] PDB Current Holdings Breakdown. 2013.

[958] A. Ganguly; B. P. Weissman; T. J. Giese; N.-A. Li; S. Hoshika; S. Rao; A. A. Benner; J. A. Piccirilli;
D. M. York. Conﬂuence of theory and experiment reveals the catalytic mechanism of the Varkud satellite
ribozyme. Nat. Chem., 2020, 12, 192–201.

[959] C. N. Nguyen; T. Kurtzman Young; M. K. Gilson. Grid Inhomogeneous solvation theory: Hydration struc-
ture and thermodynamics of the miniature receptor cucurbit[7]uril. J. Chem. Phys., 2012, 137, 044101–
044118.

[960] D. P. Fernandez; A. R. H. Goodwin; E. W. Lemmon; J. M. H. Levelt Sengers; R. C. Williams. A formulation
for the static permittivity of water and steam at temperatures from 238 k to 873 k at pressures up to 1200
mpa, including derivatives and debye huckel coefﬁcients. J. Phys. Chem. Ref. Data, 1997, 26, 1125–1166.

[961] R. Mills. Self-diffusion in normal and heavy water in the range 1-45. deg. J. Phys. Chem., 1973, 77,

685–688.

[962] W. Wagner; A. Pruss. The iapws formulation 1995 for the thermodynamic properties of ordinary water

substance for general and scientiﬁc use. J. Phys. Chem. Ref. Data, 2002, 31, 387–535.

[963] L. B. Skinner; C. Huang; D. Schlesinger; L. G. M. Pettersson; A. Nilsson; C. J. Benmore. Benchmark
oxygen-oxygen pair-distribution function of ambient water from x-ray diffraction measurements with a
wide q-range. J. Chem. Phys., 2013, 138, 074506+.

[964] G. S. Kell. Precise representation of volume properties of water at one atmosphere. J. Chem. Eng. Data,

1967, 12, 66–69.

[965] C. Vega; J. L. F. Abascal. Simulating water with rigid non-polarizable models: a general perspective. Phys

Chem Chem Phys, 2011, 13, 19663–19688.

[966] J. Z. Ruscio; D. Kumar; M. Shukla; M. G. Prisant; T. M. Murali; A. V. Onufriev. Atomic level computational
identiﬁcation of ligand migration pathways between solvent and binding site in myoglobin. Proc. Nat. Acad.
Sci. USA, 2008, 105, 9204–9209.

[967] D. S. Cerutti; K. T. Debiec; D. A. Case; L. T. Chong. Links between the charge model and bonded parameter

force constants in biomolecular force ﬁelds. J. Chem. Phys., 2017, 147, 161730.

[968] J.-P. Ryckaert; G. Ciccotti; H. J. Berendsen. Numerical integration of the cartesian equations of motion of a

system with constraints: molecular dynamics of n-alkanes. J. of Computat. Phys., 1977, 23, 327 – 341.

[969] S. Myamoto; P. A. Kollman. Settle: An analytical version of the SHAKE and RATTLE algorithm for rigid

water models. J. Computat. Chem., 1992, 13, 952–962.

[970] H. C. Andersen. Molecular dynamics simulations at constant pressure and/or temperature. J. Chem. Phys.,

1980, 72, 2384–2393.

[971] M. Havrila; M. Otyepka; P. Stadlbauer; J. Sponer; J. L. Mergny; P. Banas; P. Kuhrova. Structural dynamics

of propeller loop: towards folding of RNA G-quadruplex. Nucl. Acids Res., 2018, 46, 8754–8771.

905

BIBLIOGRAPHY

[972] T. J. Giese; D. M. York. A GPU-Accelerated Parameter Interpolation Thermodynamic Integration Free

Energy Method. J. Chem. Theory Comput., 2018, 14, 1564–1582.

[973] E. W. Weisstein. Euler angles From MathWorld—A Wolfram Web Resource.

[974] D. C. Rapaport. The Art of Molecular Dynamics Simulation. Cambridge University Press, 2010.

906

Index

1D-RISM, 105, 106, 116
3D-RISM, 105, 107, 119, 125

A
abfqmmm, 190, 382
accept, 86, 826
acdoctor, 298
activeref, 616
adbcor, 118
add, 224
add_12_6_4, 260
add\_pdb, 259
addAtomicNumber, 258
addAtomTypes, 224
addDihedral, 258
addExclusions, 259
addIons, 225
addIons2, 225
addIonsRand, 225
addLJType, 259
addPath, 225
addPDB, 259
addPdbAtomMap, 225
addPdbResMap, 226
adjust_q, 382
adjust_q, 164
aexp, 550
alias, 226
alpb, 73, 378
alpha, 446
am1bcc, 294
amb2chm_par.py, 282
amb2chm_psf_crd.py, 281
amb2gro_top_gro.py, 282
AMBER-DYES in AMBER, 58
amoeba_verbose, 586
anchor_postion, 489
anchor_strength, 489
angle, 645
antechamber, 287
apply_rism_force, 832
apply_rism_force, 131
arad, 73
arange, 550
arcres, 85, 827

arnoldi_dimension, 438
asymp, 122
asympcorr, 128
asympﬁle, 828
asympKSpaceTolerance, 110, 113, 123, 130, 829
atmask, 570
atnam, 546
atom\_selection\_mask, 575
atomicﬂuct, 647
atommap, 648
atomn, 372
atomtype, 294
auxbasis, 176
average, 649
awt, 550

B
bar_intervall, 454
bar_l_incr, 454
bar_l_max, 454
bar_l_min, 454
baroscalingdir, 348
barostat, 348
basis, 170, 172–174, 176, 177, 179, 181
bcopt, 87, 827
beckegrid, 170
beeman_integrator, 586
bellymask, 344
blocksize, 833
bond, 226
bondByDistance, 227
bondtype, 295
bridge function, 106
bspline_order_for_gridtype, 587
buffer, 113, 123, 129, 130, 762, 828, 829
buffer_iqmatoms, 382
buffercharge, 191, 381
buffermask, 191, 382
bulk\_solvent\_model, 575

C
calc, 177
calc_wbk, 186
car_to_ﬁles.py, 329
CartHess2FC.py, 326

907

INDEX

cavity_offset, 760
cavity_surften, 760
cbasis, 174
ccut, 556
CEMD, 529
center, 651
center_type, 192
centering, 125, 131, 831
centermask, 192, 382
cestats, 533
chamber, 261
change, 268
changeLJ14Pair, 268
changeLJPair, 268
changeLJSingleType, 268
changeProtState, 268
changeRadii, 269
changeRedoxState, 268
charge, 195
charge density, 127
charge distribution, 127
charge_analysis, 180
charge_out, 197
check, 227, 651
checkValidity, 269
chelpg, 172
chgdist, 122, 828
chkvir, 372
chngmask, 366
clambda, 442, 498
closest, 652
closure, 115, 116, 122, 128, 762, 828
closureorder, 122, 762, 828
cluster, 715
clusterdihedral, 653
cobsl, 556
column_fft, 364
combine, 227
comp, 348
conﬂib_ﬁlename, 438
conﬂib_size, 438
conjgrad, 823
convkey, 174
convthre, 179
copy, 228
core, 170
core_iqmatoms, 382
corecharge, 191, 381
coremask, 190, 382
corembed, 178
corembedatoms, 178
corr, 722
correlation, 176

908

coul_CD_split_expon, 587
coul_gaussian_extent_tol, 587
CpHMD, 509
cphstats, 520
create, 617
createAtom, 228
createResidue, 228
createUnit, 228
crgmask, 447
csurften, 349
csv_format, 761
cter, 552
cut, 360, 378, 824
cut_bond_list_ﬁle, 193
cutcap, 358
cutfd, 88
cutnb, 88, 827
cuv, 122, 127
cuvﬁle, 827
cv_ﬁle, 488
cv_i, 483
cv_max, 490
cv_min, 490
cv_ni, 483
cv_nr, 483
cv_r, 483
cv_type, 483
cwt, 556

D
damp, 380
dataﬁle, 617
dataset, 555
datasetc, 556
dbfopt, 827
dbuff1, 195
dbuff2, 195
dcut, 555
debug, 177, 621
debug_printlevel, 758
dec_verbose, 761
decompopt, 89
deﬁneSolvent, 269
deleteBond, 228, 269
deleteDihedral, 269
deletePDB, 269
density, 117
density_predict, 382
desc, 229, 476
dft, 177
dftb_3rd_order, 163
dftb_3rd_order, 151, 383
dftb_chg, 151, 382

dftb_disper, 151, 382
dftb_maxiter, 151, 382
dftb_slko_path, 151
dftb_telec, 151, 380
dftb_telec_step, 380
dftb_chg, 163
dftb_maxiter, 163
dftb_telec, 163
dftd, 179
dftgrid, 179
diag_routine, 382
diag_routine, 152, 163
diel, 825
dielc, 360, 378, 761, 825
dieps, 118
dihedral, 657
dij, 555
dim, 824
dipmass, 366
dipole, 171–173, 175, 176, 180
dipole_scf_iter_max, 586
dipole_scf_tol, 586
diptau, 366
diptol, 366
direct correlation function, 105
distance, 658
do_dipole, 177
dobsl, 555
do_debugf, 372
do_vdw_longrange, 586
do_vdw_taper, 586
dpmax, 197
dprob, 85, 826
dr, 116
driven_cutoff, 491
driven_weight, 491
drms, 344, 437, 761
drmsd, 659
dsum_tol, 363
dt, 345
dtfb_disper, 163
dumpfrc, 372
dvbips, 365
dvdl_norest, 446
dwt, 555
DX, 139
dx0, 344
dynamicgrid, 179
dynlmb, 446

E
e_debug, 824
ee_damped_cut, 586

eedmeth, 364
ee_dsum_cut, 586
eedtbdns, 364
effreq, 361
efphase, 361
efx, 361
efy, 361
efz, 361
embed, 178
embedatoms, 178
emem, 760
EMIL, 497
emil_do_calc, 497
emil_logﬁle, 498, 500
emil_model_inﬁle, 498
emil_model_outﬁle, 498
emil_paramﬁle, 498
emil_sc, 497
emilParameters, 498
emix, 550
endframe, 758
ene_avg_sampling, 401
eneopt, 87, 827
energy, 269
energy_window, 438
entropicDecomp, 116, 124, 133, 832
entropy, 127, 758
--entropy, 122
entropyﬁle, 828
epsext, 826
epsilonTrap, 498
epsilonWell, 498
epsin, 84, 826
epsmem, 84
epsout, 84, 826
equilibration, 493
E-REMD, 472
errconv, 154, 380
es_cutoff, 400
espgen, 296
espgen.py, 327
ew_type, 363, 378
ew_coeff, 363
exactdensity, 171
excess chemical potential, 108
exch_type, 476
exchange, 176
exchange_freq, 492
exchange_log_ﬁle, 492
exchange_log_freq, 492
exch_cutoff, 587
exchem, 127
--exchem, 122

INDEX

909

INDEX

exchemﬁle, 828
exch_factor, 587
exch_gaussian_extent_tol, 587
exdi, 760
executable, 173, 179
explored_low_modes, 438
ext_buffermask_subset, 192
ext_coremask_subset, 192
ext_qmmask_subset, 192
extdiel, 71, 377
extra_precision, 118

F
fcap, 358
FCE, 125
fcecrd, 132
fceenormsw, 132
fceifreq, 133
fcenbase, 131
fcenbasis, 131
fcentfrcor, 133
fcesort, 131
fcestride, 131
fcetrans, 132
fceweigh, 132
fcons, 570
fd_helix, 817
ffp_auto_setup, 587
fft_grids_per_ang, 401
ﬁllratio, 86, 760, 827
ﬁnalgrid, 175
ﬁnddgref.py, 517
ﬁt_type, 170
ﬁx_atom_list, 192
ﬁxcom, 419
ﬁxremdcouts.py, 478
fock_predict, 382
fockp_d1, 380
fockp_d2, 380
fockp_d3, 380
fockp_d4, 380
frameon, 366
frcopt, 87, 827
freezemol, 555
frequency_eigenvector_recalc, 438
frequency_ligand_rotrans, 438
fscale, 87, 827
fswitch, 360
full_traj, 759
fullscf, 197
fxyz, 549

910

G
gamma_ln, 191
gamma_ln_qm, 192
gamma_ten, 349
gamma_ln, 347, 825
gammamap, 359
Gaussian ﬂuctuation, 108, 124, 832
gaussian_recip_tol, 587
gb, 825
gb2_debug, 824
gb_debug, 824
gbsa, 72, 378, 826
gem_verbose, 587
genmass, 825
genremdinputs.py, 457
getxv, 823
gfCorrection, 128
gigj, 555
gist, 664
gms_version, 172
go, 270
gpu, 407
gpuids, 179
grdspc, 123, 129, 762, 828
gremd_acyc, 457
grid, 175
gridips, 365
grids, 571
grms_tol, 153
grnam1, 549
gromber, 271
group, 476
groupSelectedAtoms, 229
gti_add_sc, 450
gti_bat_sc, 450
gti_chg_keep, 451
gti_cpu_output, 451
gti_cut, 451
gti_ele_sc, 449
gti_lam_sch, 448
gti_output, 451
gti_vdw_sc, 449
guess, 176
guv, 122, 127
guvﬁle, 827

H
hamiltonian, 195
harm, 488
harm_mode, 488
hbond, 671
hcp, 833
help, 621

hist, 727
history, 272
HMassRepartition, 271
HNC, 106, 108
hot_spot, 193, 382
huv, 122, 127
huvﬁle, 827
hybridgb, 465
hypernetted-chain approximation, 106

I
ialtd, 547
iamoeba_, 361, 585
iat, 545
iatr, 552
ibelly, 343
icfe, 442, 497
iconstr, 549
icsa, 556
id, 555
id2o, 551
idecomp, 343, 443, 762
idftd3, 181
idistr, 347
iemap, 359
ievb, 142, 361
iﬁt, 570
ifmbar, 454
ifntyp, 549
ifqnt, 361, 378, 759
ifsc, 446, 497
ifvari, 547, 548
ig, 346
igb, 69, 270, 274, 361, 378, 759
igr1, 549
ihp, 550
image, 493, 674
imin, 83, 340
impose, 230
imult, 547
indi, 760
indmeth, 366
ineb, 435
infe, 483
initial_selection_type, 191
inp, 84, 760, 826
intdiel, 71, 377
integration, 170
interpolate, 272
interval, 758
intramolecular pair correlation matrix, 106
invwt1, 550
ionstepvelocities, 342

ioutfm, 343
ipb, 83, 378, 826
IPMach.py, 323
ipnlty, 359
ipol, 361
ipolyn, 197
iprob, 85, 826
iprot, 552, 553
ips, 365
iqmatoms, 161, 380
ir6, 549
iresid, 547
irest, 341
irism, 127, 361, 827
irstdip, 367
irstyp, 547
iscale, 359
ischeme, 354
isgend, 419
isgld, 419
isgsta, 419
istrng, 84, 760, 826
itgtmd, 431
ithermostat, 354
itrmax, 153, 163, 381
ivcap, 358
iwrap, 342
iwrtcharges, 181
iwrteigen, 181
ixpk, 549

J
jbasis, 174
jcoupling, 675
jfastw, 349, 378

K
k4d, 824
kappa, 380, 826
keep_ﬁles, 758
KH, 106, 108
klambda, 443, 497
kmaxqx, 162, 381
kmaxqy, 382
kmaxqz, 382
Kovalenko-Hirata, 106
ksave, 117
ksqmaxq, 162
ksqmaxsq, 382

L
lambda, 197, 498
lambda-scheduling, 448

INDEX

911

INDEX

lbfgs_memory_depth, 437
lie, 676
ligand_mask, 758
ligcent_list, 440
ligstart_list, 439
linit, 760
link_atomic_no, 381
list, 232
listParms, 272
lj1264, 361, 378
ljTolerance, 113, 123, 129, 130, 829
lmod, 844
lmod_job_title, 438
lmod_minimize_grms, 438
lmod_relax_grms, 438
lmod_restart_frequency, 438
lmod_step_size_max, 438
lmod_step_size_min, 438
lmod_trajectory_ﬁlename, 438
lmod_verbosity, 439
lnk_dis, 379
lnk_method, 381
lnk_atomic_no, 164
lnk_dis, 164
lnk_method, 164
loadAmberParams, 232
loadAmberPrep, 232
loadCoordinates, 272
loadMol2, 232
loadOff, 232
loadPdb, 233
loadPdbUsingSeq, 233
loadRestrt, 273
logdvdl, 446
logFile, 233
longrange, 196
long-range asymptotics, 127

M
mapﬁle, 570
mapﬁt, 571
mask, 679
match, 299
match_atomname, 300
MAT_cube, etc, 817
matextract, 821
MAT_fprint, etc, 818
matgen, 819
matmerge, 821
matrix_vector_product_method, 437
max_bonds_per_atom, 193
max_scf_iterations, 181
maxarcdot, 827

912

maxcore, 175
maxcyc, 153, 344, 437, 761
maxit, 172, 179
maxiter, 175, 366
maxitn, 86, 826
maxsph, 90
maxstep, 118, 124, 130, 831
mbar_lambda, 454
mbar_states, 454
mcbarint, 348
mcboxshift, 362
mcint, 362
MCPB.py, 318
mcrescyc, 362
mctrdz, 86, 760
mcwat, 362
mcwatmaxdiff, 362
md, 823
MDIIS, 107, 115
mdiis_del, 115, 117, 124, 130, 830
mdiis_method, 130, 831
mdiis_nvec, 115, 117, 124, 130, 830
mdiis_restart, 115, 118, 124, 130, 830
mdinfo_ﬂush_interval, 400
MDL, 135
mdout_ﬂush_interval, 400
mean solvation force, 108
measureGeom, 233
mem, 173, 177
membraneopt, 85, 91
memopt, 760
metalpdb2mol2.py, 329
method, 172–174, 176, 179, 195
midpoint, 362
min_heavy_mass, 193, 380
minimize, 273
mipso, 365
mipsx, 365
mlimit, 363
mltpro, 553
mme, 823
mme_init, 823
mme_rattle, 823
mm_options, 823
mm_set_checkpoint, 823
mode, 490
model, 117
modif, 196
modiﬁed direct inversion of the iterative subspace, 107
mol2rtf.py, 329
molﬁt, 571
molReconstruct, 828
molReconstruction, 133

molsurf, 681, 760
mom_cons_region, 192
mom_cons_type, 192
monitor_ﬁle, 490
monitor_freq, 490
monte_carlo_method, 439
move, 570
mprob, 86
msoffset, 760
mt19937_ﬁle, 492
mt19937_seed, 492
mthick, 86, 91, 760
mtmdforce, 432
mtmdform, 432
mtmdmask, 433
mtmdmult, 432
mtmdninc, 432
mtmdrmsd, 432
mtmdstep1, 432
mtmdvari, 432
MTS, 125
Multidimensional REMD, 474
multipmemd, 374
multisander, 374
mutant_only, 761
mwords, 172
mxsub, 359

N
n_max_recursive, 193
n_partition, 186
NAB, 119, 121
namr, 552
nastruct, 683
natr, 552
nbﬂag, 364
nbtell, 364
nbuffer, 86
NCCL, 407
nchain, 191
nchk, 824
nchk2, 824
ncore, 195
ncyc, 344
ndiis_attempts, 381
ndiis_matrices, 381
ndiis_attempts, 154
ndiis_matrices, 154
ndip, 555, 556
nearest_qm_solvent, 185
nearest_qm_solvent_center_id, 185
nearest_qm_solvent_fq, 185
nearest_qm_solvent_resname, 185

neglgdel, 372
netcdf, 758
netCharge, 274
netfrc, 364
newton, 837
nfe_abmd, 490
nfe_bbmd, 491
nfe_pmd, 489
nfe_smd, 488
nfe_stsm, 492
nfft3, 363
nfft_for_gridtype, 587
nfocus, 87, 827
ng, 123, 762, 829
ng3, 129
ngpus, 179
nharm, 488
ninc, 547
ninterface, 349
nkija, 347
nkout, 117
nleb, 172
nme, 553
nmendframe, 761
nminterval, 761
nmo_corembed, 178
nmo_embed, 178
nmode, 837
nmode_igb, 761
nmode_istrng, 761
nmpmc, 553
nmropt, 341
nmstartframe, 761
noasympcorr, 122
noeskp, 359
noexitonerror, 622
no_intermolecular_bonds, 400
noprogress, 622
noshakemask, 350, 445
npath, 488
npbgrid, 87, 827
npbopt, 86, 826
npbverb, 89, 827
npeak, 550
nprintlog, 177
npropagate, 112, 124, 130, 831
nprot, 552, 553
nr, 116
nrad, 172
nranatm, 372
nrespa, 345
nring, 552
nrout, 117

INDEX

913

INDEX

nscm, 344, 824
nsnb, 361, 824
nsnba, 88
nsp, 118
nstep1, 547
nstlim, 344
ntave, 342
ntb, 360, 378
ntc, 349, 378
nter, 552
ntf, 360, 378
ntmin, 344, 437
ntp, 348
ntpr, 153, 171–173, 175–177, 180, 342, 824
ntprism, 832
ntpr_md, 825
ntr, 343
ntt, 191, 345
ntwc, 197
ntwe, 343
ntwf, 342
ntwidrst, 193
ntwpdb, 193
ntwprt, 343
ntwr, 342
ntwrism, 133, 832
ntwsf, 575
ntwv, 342
ntwx, 342, 825
ntx, 83, 341
ntxo, 342
num_mpi_prcs, 176
num_threads, 171–173, 175, 176
number_free_rotrans_modes, 439
number_ligand_rotrans, 439
number_ligands, 439
number_lmod_iterations, 439
number_lmod_moves, 439
num_datasets, 555
numwatkeep, 465
nvec, 112
nxpk, 549

O
obs, 552, 553
offset, 72, 90
omega, 551
OpenMM, 274
OptC4.py, 325
optkon, 553
optphi, 553
order, 363
Ornstein-Zernike, 105

914

oscale, 551
outCIF, 275
outlist, 117
outlvlset, 88
outmlvlset, 88
outparm, 275
output_ﬁle, 488
output_freq, 488
outtraj, 689
outxyz, 549
oxidation_number_list_ﬁle, 192

P
packmol-memgen, 208
pair-distribution function, 105
parameter_ﬁle, 163
parameterﬂe, 153
parm, 276, 630
parmbox, 631
parmcal, 298
parmchk2, 290
ParmEd, 257
parminfo, 631
parmout, 276
parmresinfo, 633
parmstrip, 632
parmwrite, 632
path, 488
path_mode, 488
PBRadii, 236
pbtemp, 84
PC+/3D-RISM, 124, 128, 832
pdb, 122
pdb_ﬁle, 193
pdb\_inﬁle, 574
pdb_outﬁle, 574
pdb\_read\_coordinates, 574
PdbSearcher.py, 325
pencut, 359
peptcorr, 197
peptide_corr, 381
peptide_corr, 153, 163
peptk, 198
phiform, 88, 94
phiout, 94
pH-REMD, 470
pme_auto_setup, 587
polarDecomp, 114, 124, 133, 832
polardecomp, 112, 762
poreradius, 86
poretype, 86, 761
--potUV, 122
potUVﬁle, 828

potUVroot, 127
prbrad, 760
precision, 179, 622
prepgen, 296
pres0, 348
print_eigenvalues, 153, 381
print_qm_coords, 186
print_res, 762
printAngles, 276
printbondorders, 381
printBonds, 276
printcharges, 153, 163, 381
printDetails, 276
printDihedrals, 276
printdipole, 163, 381
printFlags, 277
printInfo, 277
printLJMatrix, 277
printLJTypes, 277
printPointers, 277
prmtop, 122
probe, 760
proﬁle_mpi, 367
progress, 117, 133, 833
ProScrs.py, 328
pseduo_diag_criteria, 380
PSE-n, 106, 108
pseudo_diag, 381
pseudo_diag, 152, 163
pseudo_diag_criteria, 152, 163
pucker, 692
putxv, 823

Q
qm_center_atom_id, 186
qm_ewald, 381
qm_pme, 381
qm_residues, 759
qm_theory, 383, 759
qmcharge, 151, 163, 191, 381, 759
qmcut, 161, 379, 760
qm_ewald, 161
qmgb, 162, 380
qmmask, 161, 190, 382
qmmm_int, 382
qmmm_switch, 382
qmmm_int, 154, 162
qmmmrij_incore, 381
qmmm_switch, 162
qm_pme, 162
qmqm_erep_incore, 381
qmqmdx, 151, 163, 381
qmshake, 163, 381

qm_theory, 150, 162, 163
quit, 277
quv, 122
quvﬁle, 828
qxd, 153, 163

R
r0, 548
r_buffer_in, 191
r_core_in, 191
r_core_out, 191
r_qm_in, 191
r_switch_hi, 380
r_switch_lo, 380
RA, 186
radgyr, 693
radial, 693
radiopt, 84, 760, 826
raips, 365
ramdboost, 362
ramdboostfreq, 362
ramdboostrate, 362
ramdint, 362
ramdligmask, 362
ramdmaxdist, 362
ramdprotmask, 362
random_seed, 439
ranseed, 372
rattle, 824
rbornstat, 72
rdt, 72, 378
read_idrst_ﬁle, 193
readdata, 622
readinput, 623
readparm, 823
receptor_mask, 759
reference, 636
reﬁn, 432
reﬂection\_inﬁle, 575
reg_ewald_auto_setup, 587
release, 493
remove, 234
repeats, 493
report_centers, 493
residuegen, 298
resolution, 490, 570
resolution_high, 575
respgen, 296
restart_pool_size, 439
restraint, 546
restraintmask, 344
restraint_wt, 344
rgbmax, 71, 377, 826

INDEX

915

INDEX

rhow_effect, 89
RISM, 105, 125
rism1d, 105, 114–116
rism3d.snglpnt, 122
rism_verbose, 762
RISMnRESPA, 125
rismnrespa, 131
rjcoef, 548
rms2d, 738
rmsavgcorr, 739
rmsd, 695
rmsfrc, 372
rotmin_list, 440
rst, 122
Rst7, 395
rstwt, 545
rsum_tol, 363
r_switch_hi, 162
r_switch_lo, 162
RT, 186
rtemperature, 439
rTrap, 498
runavg, 698
rWell, 498

S
s11, 555
saltcon, 71, 270, 274, 378, 760
sander, 125
sander_apbs, 760
saopt, 85
sasopt, 85
saveAmberParm, 234
saveMol2, 234
saveOff, 234
savePdb, 235
sc_bond_mask1, 450, 451
scaldip, 367
scale, 277, 760
scale_update_frequency, 575
scalec, 88
scalm, 359
scalpha, 498
scbeta, 498
scee, 278
scf_conv, 170, 172, 173, 176
scf_iter, 170
scfconv, 152, 163, 174, 380
scmask, 447
scmask1, 447
scmask2, 447
scnb, 278
screen, 197

916

search_path, 759
secstruct, 698
select, 624
selection_constant, 491
selection_epsilon, 491
selection_freq, 490
selection_type, 191
selftest, 117
sequence, 235
set, 235
set container, 236
set default, 235
setAngle, 278
setBond, 278
setBox, 237
setMolecules, 278
setOverwrite, 278
sf\_outﬁle, 575
sgff, 419
sgft, 419
shcut, 552
shrang, 552
sigmatol, 181
sinrtau, 347
skin_permit, 364
skinnb, 364
skmax, 435
skmin, 435
smear, 118
smoothing, 493
smoothopt, 84, 826
Smoothstep, 448
snapshots_basename, 490
snapshots_freq, 490
solvateBox, 237
solvateCap, 238
solvateOct, 237
solvateShell, 238
solvation, 105, 108
solvation free energy, 108
solvbox, 113, 123, 129, 130, 762, 829
solvcut, 123, 129, 762, 828
solvene, 127
--solvene, 122
solveneﬁle, 828
solvent_atom_number, 192
solvent\_mask\_expand, 575
solvent\_mask\_probe\_radius, 575
solvopt, 86, 826
sor_coefﬁcient, 586
source, 278
space, 86, 827
spin, 151, 163, 381

sprob, 89, 827
startframe, 759
static_arrays, 833
str, 552
strip, 279, 702
strip_mask, 759
summary, 279
surf, 703
surfoff, 760
surften, 72, 89, 760, 826

T
t, 344, 824
taumet, 551
taup, 348
taurot, 551
tausw, 359
tautp, 347, 825
temp0, 346, 825
temp0les, 346
temperature, 118
tempi, 346, 825
tempsg, 419
tgtﬁtmask, 431, 435
tgtmdfrc, 431
tgtrmsd, 431
tgtrmsmask, 431, 435
theory, 116
therm_par, 354
thermo, 763
thermodynamics, 108
threall, 179
ti_vdw_mask, 451
tight_p_conv, 382
tight_p_conv, 152, 163
timask1, 443
timask2, 443
tiMerge, 279
timescale, 490
tishake, 443, 445, 446
tmode, 435
tol, 349
tolerance, 113, 115, 118, 123, 129, 130, 763, 829
tolpro, 553
total correlation function, 105
total_low_modes, 439
trajin, 636
trajout, 638
transform, 230, 239, 822
translate, 239
treeCoulomb, 123, 128, 830
treeCoulombMAC, 124, 129, 830
treeCoulombN0, 124, 129, 830

treeCoulombOrder, 124, 129, 830
treeDCF, 123, 128, 829
treeDCFMAC, 124, 128, 830
treeDCFN0, 124, 129, 830
treeDCFOrder, 124, 129, 830
treeTCF, 123, 128, 830
treeTCFMAC, 124, 129, 830
treeTCFN0, 124, 129, 830
treeTCFOrder, 124, 129, 830
treﬂf, 419
T-REMD, 461
triopt, 85
trmin_list, 440
tsgavg, 419

U
uccoeff, 128
Universal Correction, 124, 832
unstrip, 705
use_dftb, 171
use_sander, 759
use_template, 171–173, 175–177, 180
use_axis_opt, 401
use_rmin, 89
use_sav, 89
uuv, 122
uuvﬁle, 828

V
vdw_cutoff, 400
vdwmeth, 364, 378
verbose, 125, 133, 363, 759, 833
verbosity, 152, 163, 177, 186, 239, 381
vfac, 435
vlimit, 347, 825
volfmt, 122, 133, 828
vprob, 89
vrand, 347
vshift, 154, 380
vsolv, 163, 382
vv, 435

W
wcons, 824
write_idrst_ﬁle, 193
write_thermo, 133
writeFrcmod, 280
writeOFF, 280
writepdb, 163
wt, 552, 553
wt_temperature, 491
wt_umbrella_ﬁle, 491

INDEX

917

INDEX

X
xc, 170
xmax, 90
xmin, 90, 840
xmin_method, 437
xmin_verbosity, 437
xray\_weight, 575
XVV, 136
xvv, 122, 127
xvvﬁle, 827

Y
ymax, 90
ymin, 90

Z
zcap, 358
zerochg, 372
zerodip, 372
zerofrc, 131, 831
zerov, 825
zerovdw, 372
zlmﬁt, 170
zMatrix, 240
zmax, 90
zmin, 90

918

